<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {inlineMath: [['$$$','$$$']], displayMath: [['$$$$$$','$$$$$$']]}
        });
    </script>

    <script type="text/javascript" async="" src="/home/lxc/modules/codeforces2html/codeforces2html/MathJax/MathJax.js?config=TeX-AMS_HTML-full">
    </script>

	<link rel="stylesheet" href="/home/lxc/modules/codeforces2html/codeforces2html/css.css"/>
    <link rel="stylesheet" href="/home/lxc/modules/codeforces2html/codeforces2html/github.css" /> 

	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/highlight.min.js"></script>
    
    <script>hljs.initHighlightingOnLoad();</script>

<style type="text/css">
* { font-family: Verdana; }
.new-page { page-break-after: always; }
</style>
</head>

<body>


    <h1> Codeforces Round #625 (Div. 2, based on Technocup 2020 Final Round)
    1321A
    Контест для роботов </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Контест для роботов</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Поликарп готовит первый контест по программированию для роботов.       В этом контесте $$$n$$$ задач, и большое количество самых разных       роботов попробует их решить. Каждый робот, решивший задачу       $$$i$$$, получает $$$p_i$$$ баллов, и итоговый результат робота в       соревновании считается как сумма $$$p_i$$$ по всем задачам       $$$i$$$, которые он решил. Для каждой задачи $$$p_i$$$ — целое       число не меньше $$$1$$$.</p>     <p>Две компании, специализирующиеся на робототехнике, «Robo-Coder       Inc.» и «BionicSolver Industries», также собираются отправить по       одному роботу на соревнование. Поликарп знает все сильные и слабые       стороны роботов, производимых этими компаниями, поэтому для каждой       задачи он может точно предсказать, какие из этих двух роботов       решат ее, а какие — не решат. Зная эту информацию, он может       оценить результаты соревнования или повлиять на них. </p>     <p>По какой-то причине (которая совершенно точно никак не связана с       подкупом) Поликарп хочет, чтобы робот «Robo-Coder Inc.» выступил       лучше, чем робот «BionicSolver Industries». Поликарп хочет       выставить баллы за задачи $$$p_i$$$ таким образом, что робот       «Robo-Coder Inc.» получит <span class="tex-font-style-bf">строго       больше</span> баллов, чем робот «BionicSolver Industries». Однако       если значения $$$p_i$$$ будут большими, то наблюдатели могут       что-то заподозрить, поэтому Поликарп хочет минимизировать максимум       $$$p_i$$$ по всем задачам. Можете ли вы помочь Поликарпу       определить минимально возможное верхнее ограничение на количество       баллов за каждую задачу?</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке задано одно целое число $$$n$$$ ($$$1 \le n \le       100$$$) — количество задач в контесте.</p>     <p>Во второй строке заданы $$$n$$$ целых чисел $$$r_1$$$, $$$r_2$$$,       ..., $$$r_n$$$ ($$$0 \le r_i \le 1$$$). $$$r_i = 1$$$ означает,       что робот «Robo-Coder Inc.» решит $$$i$$$-ю задачу, $$$r_i = 0$$$       означает, что он не решит $$$i$$$-ю задачу.</p>     <p>В третьей строке заданы $$$n$$$ целых чисел $$$b_1$$$, $$$b_2$$$,       ..., $$$b_n$$$ ($$$0 \le b_i \le 1$$$). $$$b_i = 1$$$ означает,       что робот «BionicSolver Industries» решит $$$i$$$-ю задачу, $$$b_i       = 0$$$ означает, что он не решит $$$i$$$-ю задачу.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Если роботу «Robo-Coder Inc.» ни при какой разбалловке не удастся       набрать больше баллов, чем наберет робот «BionicSolver       Industries», выведите одно число $$$-1$$$.</p>     <p>Иначе выведите минимально возможное значение $$$\max \limits_{i =       1}^{n} p_i$$$, при котором можно расставить такие значения       $$$p_i$$$, что робот «Robo-Coder Inc.» наберет <span class="tex-font-style-bf">строго больше</span> баллов, чем робот       «BionicSolver Industries».</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
1 1 1 0 0
0 1 1 1 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
0 0 0
0 0 0
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
-1
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
1 1 1 1
1 1 1 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
-1
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
9
1 0 0 0 0 0 0 0 1
0 1 1 0 1 1 1 1 0
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
4
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере одна из возможных разбалловок — следующая: $$$p       = [3, 1, 3, 1, 1]$$$. Тогда «Robo-Coder» получит $$$7$$$ баллов,       «BionicSolver» — $$$6$$$ баллов.</p>     <p>Во втором примере оба робота получат $$$0$$$ баллов, поэтому       разбалловка ни на что не влияет.</p>     <p>В третьем примере оба робота решают все задачи, поэтому       разбалловка также ни на что не влияет.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1321/problem/A' title='Codeforces Round 625 (Div. 2, based on Technocup 2020 Final Round)'>1321A - Contest for Robots</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Score distribution for problems having $$$r_i = b_i$$$ is       irrelevant (we can make $$$p_i = 1$$$ for all of them). Let's       consider the remaining problems.</p>     <p>Suppose we have $$$x$$$ problems solved by the first robot (and       not solved by the second one), and $$$y$$$ problems solved by the       second robot (and not solved by the first one). If $$$x = 0$$$,       then the score of the first robot won't exceed the score of the       second robot by any means, so the answer is $$$-1$$$.</p>     <p>Otherwise, we can set the score for problems solved by the first       robot to some number $$$p$$$, and the score for all remaining       problems to $$$1$$$. Then, the condition $$$xp &gt; y$$$ must       hold, or $$$p &gt; \frac{y}{x}$$$, so $$$p = \lceil \frac{y +       1}{x} \rceil$$$ is the answer. Note that the constraints allow us       to iterate on $$$p$$$ instead of implementing a formula for it.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #625 (Div. 2, based on Technocup 2020 Final Round)
    1321C
    Удаление соседних </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Удаление соседних</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам задана строка $$$s$$$, состоящая из строчных букв латинского       алфавита. Пусть длина $$$s$$$ равна $$$|s|$$$.</p>     <p>За один ход вы можете выбрать любой индекс $$$i$$$ и <span class="tex-font-style-bf">удалить</span> $$$i$$$-й символ $$$s$$$       ($$$s_i$$$), если <span class="tex-font-style-bf">хотя бы       один</span> из его соседних символов является <span class="tex-font-style-it">предыдущей</span> буквой в латинском       алфавите для $$$s_i$$$. Например, для буквы <span class="tex-font-style-tt">b</span> <span class="tex-font-style-it">предыдущей</span> буквой является <span class="tex-font-style-tt">a</span>, для буквы <span class="tex-font-style-tt">s</span> <span class="tex-font-style-it">предыдущей</span> букой является <span class="tex-font-style-tt">r</span>, для буквы <span class="tex-font-style-tt">a</span> <span class="tex-font-style-it">предыдущей</span> буквы не существует.       Заметьте, что после каждого удаления длина строки уменьшается на       единицу. Таким образом, индекс $$$i$$$ должен удовлетворять       условию $$$1 \le i \le |s|$$$ в течение каждого хода.</p>     <p>Соседними символами для символа $$$s_i$$$ являются символы       $$$s_{i-1}$$$ и $$$s_{i+1}$$$. Первый и последний символы $$$s$$$       имеют только один соседний символ (за исключением случая $$$|s| = 1$$$).</p>     <p>Рассмотрим следующий пример. Пусть $$$s=$$$ <span class="tex-font-style-tt">bacabcab</span>.</p>          <ol> <li> В течение первого хода вы можете удалить первый символ         $$$s_1=$$$ <span class="tex-font-style-tt">b</span>, так как         $$$s_2=$$$ <span class="tex-font-style-tt">a</span>. Тогда         строка станет равна $$$s=$$$ <span class="tex-font-style-tt">acabcab</span>. </li>       <li> В течение второго хода вы можете удалить пятый символ         $$$s_5=$$$ <span class="tex-font-style-tt">c</span>, так как         $$$s_4=$$$ <span class="tex-font-style-tt">b</span>. Тогда         строка станет равна $$$s=$$$ <span class="tex-font-style-tt">acabab</span>. </li>       <li> В течение третьего хода вы можете удалить шестой символ         $$$s_6=$$$ <span class="tex-font-style-tt">b</span>, так как         $$$s_5=$$$ <span class="tex-font-style-tt">a</span>. Тогда         строка станет равна $$$s=$$$ <span class="tex-font-style-tt">acaba</span>. </li>       <li> В течение четвертого хода единственным символом, который вы         можете удалить, является $$$s_4=$$$ <span class="tex-font-style-tt">b</span>, так как $$$s_3=$$$ <span class="tex-font-style-tt">a</span> (или $$$s_5=$$$ <span class="tex-font-style-tt">a</span>). Строка станет равна         $$$s=$$$ <span class="tex-font-style-tt">acaa</span>, и вы         больше не сможете ничего с ней сделать. </li></ol>          <p>Ваша задача — найти <span class="tex-font-style-bf">максимальное</span> количество символов,       которые вы можете удалить, если вы выберете последовательность       ходов оптимально.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка входных данных содержит одно целое число $$$|s|$$$       ($$$1 \le |s| \le 100$$$) — длину $$$s$$$.</p>     <p>Вторая строка входных данных содержит строку $$$s$$$, состоящую       из $$$|s|$$$ строчных букв латинского алфавита.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одно целое число — максимально возможное количество       символов, которые вы можете удалить, если вы выберете       последовательность ходов оптимально.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
8
bacabcab
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
4
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
bcda
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
abbbbb
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
5
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Первый тестовый пример разобран в условии задачи. Заметьте, что       последовательность ходов, представленная в условии, не является       единственной, но можно показать, что максимально возможный ответ       на этот тест равен $$$4$$$.</p>     <p>Во втором тестовом примере вы можете удалить все символы $$$s$$$,       кроме одного. Единственный возможный ответ описан ниже.</p>          <ol> <li> В течение первого хода следует удалить третий символ         $$$s_3=$$$ <span class="tex-font-style-tt">d</span>, $$$s$$$         станет равна <span class="tex-font-style-tt">bca</span>. </li>       <li> В течение второго хода следует удалить второй символ         $$$s_2=$$$ <span class="tex-font-style-tt">c</span>, $$$s$$$         станет равна <span class="tex-font-style-tt">ba</span>. </li>       <li> Наконец, в течение третьего хода следует удалить первый         символ $$$s_1=$$$ <span class="tex-font-style-tt">b</span>,         $$$s$$$ станет равна <span class="tex-font-style-tt">a</span>. </li></ol></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1321/problem/C' title='Codeforces Round 625 (Div. 2, based on Technocup 2020 Final Round)'>1321C - Remove Adjacent</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>The optimal answer can be obtained by the following algorithm:       choose the <span class="tex-font-style-it">maximum</span> possible       (alphabetically) letter we can remove and remove it. We can do it       naively and it will lead to $$$O(n^2)$$$ time complexity.</p>     <p>Why is it always true? Suppose we remove the <span class="tex-font-style-it">maximum</span> letter $$$i$$$ that can       be used to remove some other letter $$$j$$$ (it is obvious that       $$$s_i + 1 = s_j$$$ in such case).</p>     <p>If there are no other letters between $$$s_i$$$ and $$$s_j$$$       then $$$s_i$$$ is not the <span class="tex-font-style-it">maximum</span> letter, so we got       contradiction with our algorithm.</p>     <p>Now suppose that we can remove all letters between $$$s_i$$$ and       $$$s_j$$$. Then we first choose $$$s_j$$$ and only after that       $$$s_i$$$ by our algorithm.</p>     <p>Consider the last case — there is at least one letter $$$s_k$$$       between $$$s_i$$$ and $$$s_j$$$. Because we cannot remove       $$$s_k$$$ then there are only two cases: $$$s_k &gt; s_j + 1$$$ or       $$$s_k + 1 &lt; s_i$$$. Then we cannot use $$$s_i$$$ to remove       $$$s_j$$$ at all.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #626 (Div. 1, по задачам Открытой олимпиады школьников по программированию)
    1322A
    Интересные конкурсы </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Интересные конкурсы</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Напомним, что скобочная последовательность называется правильной,       если путем вставки в неё символов «+» и «1» можно получить из неё       корректное математическое выражение. Например, последовательности         «<span class="tex-font-style-tt">(())()</span>», «<span class="tex-font-style-tt">()</span>» и «<span class="tex-font-style-tt">(()(()))</span>» — правильные, в то       время как «<span class="tex-font-style-tt">)(</span>», «<span class="tex-font-style-tt">(()</span>» и «<span class="tex-font-style-tt">(()))(</span>» — нет.</p>     <p>Учительница дала классу, в котором учится Дмитрий, очень странное       задание — она попросила каждого из учеников придумать       последовательность произвольной длины, состоящую только из       открывающих и закрывающих скобок. После этого все ученики по       очереди называли придуманные ими последовательности. Когда очередь       дошла до Димы, он внезапно понял, что у всех его одноклассников       получились правильные скобочные последовательности, а получилась       ли у него правильная скобочная последовательность, он не знал.</p>     <p>Дима подозревает, что он просто прослушал слово «правильная» в       постановке задания, поэтому хочет срочно исправить ситуацию — для       этого он решил немного изменить свою последовательность. А именно,       он решил <span class="tex-font-style-bf">произвольное число       раз</span> (возможно, нулевое) выполнить операцию <span class="tex-font-style-it">перемешивания</span>.</p>     <p>Для выполнения одной операции перемешивания Дима выбирает       произвольный подотрезок (подстроку) последовательности и       произвольным образом переставляет все символы на нём. Такая       операция занимает ровно $$$l$$$ наносекунд, где $$$l$$$ — длина       подотрезка, который Дима выбрал для перемешивания. Легко заметить,       что при этом число открывающих скобок не меняется, равно как и       число закрывающих. Например, для «<span class="tex-font-style-tt">))((</span>» он может выбрать подотрезок         «<span class="tex-font-style-tt">)(</span>» и перемешать символы       в нём, получив «<span class="tex-font-style-tt">)()(</span>» (эта       операция потребует $$$2$$$ наносекунды).</p>     <p>Уже совсем скоро подойдёт очередь Димы называть свою       последовательность, поэтому он обратился за помощью к вам.       Помогите ему определить минимальное время, за которое он может       сделать свою последовательность правильной, или определите, что       сделать это невозможно.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке содержится одно целое число $$$n$$$ ($$$1 \le n       \le 10^6$$$) — длина последовательности Димы.</p>     <p>Вторая строка содержит строку длины $$$n$$$, состоящую только из       символов «<span class="tex-font-style-tt">(</span>» и «<span class="tex-font-style-tt">)</span>».</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите единственное число — минимальное количество наносекунд,       необходимое, чтобы сделать последовательность правильной, или         «<span class="tex-font-style-tt">-1</span>», если сделать       последовательность правильной с помощью операций перемешивания невозможно.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
8
))((())(
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
6
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
(()
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
-1
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере можно сначала перемешать подотрезок с первого по       четвёртый символ, заменив его на «<span class="tex-font-style-tt">()()</span>» — получится       последовательность «<span class="tex-font-style-tt">()()())(</span>», а затем перемешать       подотрезок с седьмого по восьмой символ, заменив его на «<span class="tex-font-style-tt">()</span>». В итоге получится правильная       скобочная последовательность «<span class="tex-font-style-tt">()()()()</span>», такие действия займут       суммарно $$$4 + 2 = 6$$$ наносекунд.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1322/problem/A' title='Codeforces Round 626 (Div. 1, based on Moscow Open Olympiad in Informatics)'>1322A - Unusual Competitions</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Obviously, if the number of opening brackets is not equal to the       number of closing ones, then since the described operation does       not change their number, it will be impossible to get the correct       sequence. Otherwise, if their numbers are equal, you can take the       entire string and rearrange its $$$n$$$ characters so that the       string becomes a right bracketed sequence, for example, <span class="tex-font-style-tt">&quot;(((($$$\dots$$$))))&quot;</span>.</p>     <p>Let $$$p_i$$$ be a prefix balance on the first $$$i$$$       characters, that is, the difference between the number of opening       and closing brackets.</p>     <p>Consider an index $$$i$$$ such that $$$bal_{i-1} \leq 0$$$,       $$$bal_{i} &lt; 0$$$, or $$$bal_{i-1} &lt; 0$$$, $$$bal_i \leq       0$$$. Then, if the $$$s_i$$$ character does not participate in any       shuffle oeration, the resulting string will have a $$$i$$$th or       $$$i-1$$$th prefix balance negative, making the resulting sequence       incorrect. This means that at least characters with such indexes       $$$i$$$ must participate in at least one operation. It will be       shown below how to use only them in shuffles to make a right       bracketed sequence.</p>     <p>Let's represent this bracketed sequence as a polyline. It will       start at the point with coordinates $$$(0,0)$$$, end at the point       with coordinates $$$(2n, 0)$$$, $$$i$$$ - th vector of this       polyline will be equal to $$$(+1, +1)$$$, if $$$s_i = $$$ <span class="tex-font-style-tt">(</span> and $$$(+1, -1)$$$ otherwise.       Then the above-described indexes $$$i$$$, which must participate       in at least one operation — are exactly all the segments below the       line $$$x=0$$$. To make the sequence correct, we will turn all       consecutive segments of such brackets backwards. It's not hard to       see that the sequence will become correct.</p>     <p>An example of this conversion is shown below:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/58c6c250698d751f0f527141da5810d008c6023d.png" style="max-width: 100.0%;max-height: 100.0%;" />     </center> Given sequence was <span class="tex-font-style-tt">())(()))()((</span>               <center> <img class="tex-graphics" src="https://espresso.codeforces.com/0ae5d62cbc394e9ba6c8e5603bd7056628813d3a.png" style="max-width: 100.0%;max-height: 100.0%;" />     </center> After reshuffling 2 segments of total length 8, we can get     a right bracketed sequence:<span class="tex-font-style-tt">()()((()())</span></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #626 (Div. 1, по задачам Открытой олимпиады школьников по программированию)
    1322B
    Подарок </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Подарок</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>3 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>          <p>На восьмое марта Катерине подарили массив чисел. Со временем ей       стало скучно просто смотреть на него, и она решила посчитать       некоторые его бесполезные характеристики. Со всеми, что она       придумывала, ей это удавалось. Придумав очередную — <span class="tex-font-style-tt">xor</span> попарных сумм чисел в       массиве, она поняла, что не может придумать, как посчитать её для       большого массива, и попросила вас помочь. А вы сможете? Более       формально, вам нужно посчитать</p>     <p>$$$$$$ (a_1 + a_2) \oplus (a_1 + a_3) \oplus \ldots \oplus (a_1 +       a_n) \\ \oplus (a_2 + a_3) \oplus \ldots \oplus (a_2 + a_n) \\       \ldots \\ \oplus (a_{n-1} + a_n) \\ $$$$$$</p>     <p>Запись $$$x \oplus y$$$ обозначает битовый XOR чисел (т.е.       $$$x$$$ <span class="tex-font-style-tt">^</span> $$$y$$$ для       многих современных языков программирования). Об этой операции вы       можете прочитать по ссылке в Wikipedia: <a href="https://tiny.cc/34xykz">https://tiny.cc/34xykz</a>.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит целое число $$$n$$$ ($$$2 \leq n \leq       400\,000$$$) — количество чисел в массиве.</p>     <p>Вторая строка содержит целые числа $$$a_1, a_2, \ldots, a_n$$$       ($$$1 \leq a_i \leq 10^7$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одно число — xor попарных сумм чисел в данном массиве.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
1 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
1 2 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере есть всего одна сумма: $$$1 + 2 = 3$$$.</p>     <p>Во втором примере есть три суммы: $$$1 + 2 = 3$$$, $$$1 + 3 =       4$$$, $$$2 + 3 = 5$$$. В двоичной системе счисления это $$$011_2       \oplus 100_2 \oplus 101_2 = 010_2$$$, то есть 2.</p>     <p>$$$\oplus$$$ означает операцию побитового xor. Чтобы определить       $$$x \oplus y$$$ рассмотрим двоичную запись чисел $$$x$$$ и       $$$y$$$. Скажем, что $$$i$$$-й бит результата равен 1, если ровно       один из $$$i$$$-х битов $$$x$$$ и $$$y$$$ равен 1. В противном       случае $$$i$$$-й бит результата равен 0. Например, $$$0101_2 \,       \oplus \, 0011_2 = 0110_2$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1322/problem/B' title='Codeforces Round 626 (Div. 1, based on Moscow Open Olympiad in Informatics)'>1322B - Present</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's calculate each bit in the answer separately. Suppose we       want to know the value of $$$k$$$-th (in 0-indexation) bit in the       answer. Then we can notice that we are only interested in bits       from $$$0$$$-th to $$$k$$$-th, which means that we can take all       numbers modulo $$$2^{k+1}$$$. After that, the sum of the two       numbers can't exceed $$$2^{k+2} - 2$$$. $$$k$$$-th bit is 1 if and       only if sum belongs to $$$[2^k; 2^{k+1})$$$ or $$$[2^{k+1} + 2^k;       2^{k+2} - 2]$$$.</p>     <p>So, we have to count the number of pairs of numbers that give a       sum that belongs to these segments. Let's sort all numbers (taken       by modulo) and make a pass with two pointers or do binary searches       for each number.</p>     <p>Total complexity: $$$O(n \log n \log C)$$$</p>     <p>Bonus: can you do it in $$$O(n \log C)$$$?</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #626 (Div. 1, по задачам Открытой олимпиады школьников по программированию)
    1322C
    Лапша быстрого приготовления </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Лапша быстрого приготовления</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Ву проголодался после интенсивной тренировки и отправился в       ближайший магазин, чтобы приобрести его любимую лапшу быстрого       приготовления. После того, как Ву расплатился, кассир задал ему       интересную задачу.</p>     <p>Дан двудольный граф, в вершинах <span class="tex-font-style-bf">правой</span> доли которого записаны       положительные целые числа. Для подмножества вершин $$$S$$$ <span class="tex-font-style-bf">левой</span> доли определим $$$N(S)$$$       как множество вершин правой доли, смежной хотя бы с одной из       вершин $$$S$$$, а $$$f(S)$$$ — как сумму чисел, записанных в       вершинах $$$N(S)$$$. Требуется найти наибольший общий делитель       чисел $$$f(S)$$$ для всех возможных непустых подмножеств $$$S$$$       (полагайте, что НОД пустого множества равен $$$0$$$).</p>     <p>Ву слишком устал во время тренировки, чтобы справиться с такой       задачей. Помогите ему!</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано целое число $$$t$$$ ($$$1 \leq t \leq       500\,000$$$) — количество тестовых случаев, для которых требуется       решить задачу. Затем следует описание тестовых случаев.</p>     <p>В первой строке каждого описания записаны два целых числа $$$n$$$       и $$$m$$$ ($$$1~\leq~n,~m~\leq~500\,000$$$) — количество вершин в       каждой из долей графа и количество рёбер, соответственно. </p>     <p>Во второй строке записано $$$n$$$ целых чисел $$$c_i$$$ ($$$1       \leq c_i \leq 10^{12}$$$), $$$i$$$-е из которых задаёт число,       записанное в $$$i$$$-й вершине правой доли графа.</p>     <p>В следующих $$$m$$$ строках записаны пары целых чисел $$$u_i$$$ и       $$$v_i$$$ ($$$1 \leq u_i, v_i \leq n$$$), обозначающие ребро между       $$$u_i$$$-й вершиной левой доли графа и $$$v_i$$$-й вершиной       правой доли графа. Гарантируется, что в графе нет кратных рёбер.</p>     <p>Тестовые случаи разделены пустой строкой. Сумма значений $$$n$$$       по всем тестовым случаям не превосходит $$$500\,000$$$, сумма       значений $$$m$$$ по всем тестовым случаям также не превосходит $$$500\,000$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого тестового случая выведите единственное число —       искомый наибольший общий делитель.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
2 4
1 1
1 1
1 2
2 1
2 2

3 4
1 1 1
1 1
1 2
2 2
2 3

4 7
36 31 96 29
1 2
1 3
1 4
2 2
2 4
3 1
4 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
1
12
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Наибольшим общим делителем множества чисел называется наибольшее       целое число $$$g$$$ такое, что все элементы множества без остатка       делятся на $$$g$$$.</p>     <p>В первом примере все вершины левой доли соединены ребром со всеми       вершинами правой доли, поэтому значение $$$f(S)$$$ для любого       непустого подмножества будет равно $$$2$$$, соответственно       наибольший общий делитель этих значений будет также равен $$$2$$$.</p>     <p>Во втором примере подмножество $$$\{1\}$$$ вершин левой доли       соединено ребром с вершинами $$$\{1, 2\}$$$ правой доли, сумма       значений в которых равна $$$2$$$, а подмножество $$$\{1, 2\}$$$       вершин левой доли соединено рёбрами с вершинами $$$\{1, 2, 3\}$$$       правой доли, сумма значений в которых равна $$$3$$$. Таким       образом, $$$f(\{1\}) = 2$$$, $$$f(\{1, 2\}) = 3$$$, что значит,       что наибольший общий делитель всех чисел $$$f(S)$$$ равен $$$1$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1322/problem/C' title='Codeforces Round 626 (Div. 1, based on Moscow Open Olympiad in Informatics)'>1322C - Instant Noodles</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's split vertices of right half of graph in groups in such a       way that group consists of vertices with same neighboring set.       Then answer equals to $$$gcd$$$ of sums of numbers in all groups       except the group with empty neighboring set. Let's prove it.</p>     <p>If there are some vertices with same list of neighbors then they       will both in some $$$N(S)$$$ or none of them will be in it. It       means that we can replace such vertices with one vertex with value       equals to sum of values in these vertices. After that numbers in       all vertices are divisible by answer and thus sum of every subset       is divisible by it. Let's divide all the numbers by answer and       prove that after it answer will be 1.</p>     <p>Consider some integer $$$k$$$ and we'll find some set of vertices       $$$S$$$ such that $$$f(S)$$$ is not divisible by $$$k$$$. If sum       of all numbers is not divisible by $$$k$$$ we can take all the       left half and its sum is not divisible by $$$k$$$. Otherwise       consider a vertex with minimum degree such that its value is not       divisible by $$$k$$$ (such vertex exists because gcd of numbers in       right half is 1 now). Let's take subset of vertices in left part       which are not connected to $$$v$$$. Which vertices are not       neighboring to this set? It is $$$v$$$ and all the vertices that       their neighboring set it a subset of neighboring set of $$$v$$$       (and their sum is divisible by $$$k$$$). But value of $$$v$$$ is       not divisible by $$$k$$$ so sum in complement of its neighboring       set is not divisible by $$$k$$$ too.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #626 (Div. 1, по задачам Открытой олимпиады школьников по программированию)
    1322D
    Реалити-шоу </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Реалити-шоу</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Одно известное реалити-шоу набирает участников для третьего       сезона! Собеседование прошли $$$n$$$ кандидатов, пронумерованных       от $$$1$$$ до $$$n$$$. $$$i$$$-й кандидат обладает агрессивностью       $$$l_i$$$, и для того, чтобы взять этого кандидата, организаторам       шоу придется потратить $$$s_i$$$ рублей.</p>     <p>Ведущая реалити-шоу листает досье всех кандидатов от $$$i=1$$$ до       $$$i=n$$$ в порядке возрастания номеров, и для каждого из них она       принимает решение, стоит ли взять этого кандидата в шоу. Если       агрессивность кандидата $$$i$$$ строго выше, чем агрессивность       какого-либо из уже <span class="tex-font-style-bf">взятых</span>       кандидатов, то кандидата $$$i$$$ она точно брать откажется. В       противном случае ведущая может на свой выбор как взять кандидата в       шоу, так и не взять. Ведущая хочет выбрать участников таким       образом, чтобы максимизировать <span class="tex-font-style-it">прибыль</span>.</p>     <p>Рассматриваемое реалити-шоу получает доход следующим образом. Для       каждого значения агрессивности $$$v$$$ указана доходность       $$$c_v$$$, которая может быть как положительной, так и       отрицательной. Участники, попавшие в проект, поочередно выходят на       сцену в порядке возрастания номеров. Как только участник с номером       $$$i$$$ выходит на сцену, происходит следующее:</p>          <ul> <li> Шоу зарабатывает $$$c_{l_i}$$$ рублей, где $$$l_i$$$ —         изначальная агрессивность участника $$$i$$$. </li>       <li> Если оказывается, что на сцене находятся два участника с         одинаковым значением агрессивности, то они немедленно начинают         драку. В результате драке происходит следующее:                  <ul> <li> проигравшего участника увозит скорая помощь, и он             выбывает из проекта, </li>           <li> агрессивность выигравшего участника возрастает на один, а             шоу зарабатывает $$$c_t$$$ рублей, где $$$t$$$ — новое             значение агрессивности. </li></ul>                  </li>       <li> Драки на сцене продолжаются до тех пор, пока на сцене не         останутся участники с различными значениями агрессивности. </li></ul>          <p>Ведущая шоу хочет выбрать команду таким образом, чтобы       максимизировать прибыль, которая определяется как суммарный доход       от происходящего на сцене, минус суммарные затраты на приглашение       участников (которые определяются как сумма $$$s_i$$$ для выбранных       участников). Помогите ведущей сделать шоу максимально прибыльным!</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке вводится два целых числа $$$n$$$ и $$$m$$$ ($$$1       \le n, m \le 2000$$$) — количество кандидатов и максимальное       начальное значение агрессивности кандидатов.</p>     <p>Во второй строке вводится $$$n$$$ целых чисел $$$l_i$$$ ($$$1 \le       l_i \le m$$$) — агрессивность каждого из кандидатов.</p>     <p>В третьей строке вводится $$$n$$$ целых чисел $$$s_i$$$ ($$$0 \le       s_i \le 5000$$$) — количество рублей, которое придется заплатить       для найма каждого из кандидатов.</p>     <p>В четвертой строке вводится $$$n + m$$$ целых чисел $$$c_i$$$       ($$$|c_i| \le 5000$$$) — уровень доходности для каждого из       значений агрессивности.</p>     <p>Гарантируется, что при данных ограничениях значение агрессивности       участников не может превысить $$$n + m$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одно целое число — максимальную прибыль шоу.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5 4
4 3 1 2 1
1 2 1 2 1
1 2 3 4 5 6 7 8 9
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
6
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
2 2
1 2
0 0
2 1 -100 -100
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5 4
4 3 2 1 1
0 2 6 7 4
12 12 12 6 -3 -5 3 10 -4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
62
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере выгоднее всего взять кандидатов с номерами $$$1,       2, 3, 5$$$. В таком случае шоу заплатит им за участие $$$1 + 2 + 1       + 1 = 5$$$ рублей. На сцене же будет происходить следующее:</p>          <ul> <li> на сцене появится участник со значением агрессивности         $$$4$$$, шоу заработает $$$4$$$ рубля; </li>       <li> на сцене появится участник со значением агрессивности         $$$3$$$, шоу заработает $$$3$$$ рубля; </li>       <li> на сцене появится участник со значением агрессивности         $$$1$$$, шоу заработает $$$1$$$ рубль; </li>       <li> на сцене появится еще один участник со значением         агрессивности $$$1$$$, шоу заработает еще $$$1$$$ рубль,         начнется драка. Один из участников проиграет и покинет проект, а         второй повысит свое значение агрессивности до $$$2$$$. Шоу         заработает на этом еще $$$2$$$ рубля. </li></ul>          <p>Таким образом, доход шоу составит $$$4 + 3 + 1 + 1 + 2=11$$$       рублей, а суммарная прибыль будет равна $$$11 - 5 = 6$$$ рублям.</p>     <p>Во втором примере мы не можем пригласить обоих кандидатов, так       как значение агрессивности второго кандидата больше, поэтому нам       выгоднее взять кандидата с номером $$$1$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1322/problem/D' title='Codeforces Round 626 (Div. 1, based on Moscow Open Olympiad in Informatics)'>1322D - Reality Show</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>First of all, we will notice that the order of entering doesn't       affect the answer. </p>     <p>Let's reverse the sequence. We will add people in the       non-decreasing order. Let's use dynamic programming:       $$$dp[i][k][cnt]$$$ is the answer if we processed first $$$i$$$       candidates with the maximum value less or equal $$$k$$$ and total       number of people who will reach $$$l_j = k$$$ is $$$cnt \leq n$$$. </p>     <p>How we should change values of $$$dp$$$ when we go from $$$k$$$       to $$$k + 1$$$? $$$dp[i][k + 1][cnt / 2] \leq dp[i][k][cnt] + (cnt       / 2) \cdot c_{k + 1}$$$</p>     <p>But how $$$dp$$$ changes when we take $$$i$$$-th element? $$$dp[i       + 1][a_i][cnt] \leq dp[i][a_i][cnt - 1] + s_i$$$ </p>     <p>After adding $$$i$$$-th element we also should change $$$dp[i +       1][&gt;a_i ]$$$. But every next lay will change less: $$$n + \left       \lceil \frac{n}{2} \right \rceil + \left \lceil \frac{n}{4} \right       \rceil + \left \lceil \frac{n}{8} \right \rceil + \ldots = O(n + m)$$$.</p>     <p>It clear, that we can remove first parameter of $$$dp$$$ and       finally get the asymptotics $$$O(n(n + m))$$$.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #626 (Div. 1, по задачам Открытой олимпиады школьников по программированию)
    1322E
    Медианный горный хребет </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. Медианный горный хребет</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Берляндия — огромная страна с разнообразной географией. Одной из       самых знаменитых природных достопримечательностей Берляндии       является «Медианный горный хребет». Этот горный хребет       представляет из себя $$$n$$$ подряд идущих горных вершин,       расположенных на одной прямой, пронумерованных в порядке       следования от $$$1$$$ до $$$n$$$. Высота $$$i$$$-й горной вершины       равна $$$a_i$$$.</p>     <p>«Медианный горный хребет» знаменит тем, что с ним ежедневно       происходит так называемое <span class="tex-font-style-it">выравнивание горных вершин</span>. В       момент выравнивания одновременно для каждой вершины от $$$2$$$ до       $$$n - 1$$$ её высота становится равна медианной высоте среди неё       и двух соседних гор. А именно, если до выравнивания высоты были       равны $$$b_i$$$, то новые высоты $$$a_i$$$ устроены следующим       образом: $$$a_1 = b_1$$$, $$$a_n = b_n$$$, а для всех $$$i$$$ от       $$$2$$$ до $$$n - 1$$$ $$$a_i = \texttt{median}(b_{i-1}, b_i,       b_{i+1})$$$. Медианой трёх чисел называется второе по счёту число,       если отсортировать эти три числа по возрастанию. Например,       $$$\texttt{median}(5,1,2) = 2$$$, а $$$\texttt{median}(4,2,4) = 4$$$.</p>     <p>Недавно Берляндские учёные доказали, что какими бы ни были высоты       гор, процесс выравнивания рано или поздно стабилизируется, то есть       в какой-то момент высоты гор перестанут изменяться после       выравнивания. Правительство Берляндии хочет понять через сколько       лет это произойдёт, то есть, найти величину $$$c$$$ — сколько       произойдет выравниваний, при которых у хотя бы одной горы       изменится её высота. Также правительству Берляндии необходимо       определить высоты гор после $$$c$$$ выравниваний, то есть узнать,       какими высоты гор останутся навсегда. Помогите ученым решить эту       важную задачу!</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит число $$$n$$$ ($$$1 \le n \le       500\,000$$$) — количество гор.</p>     <p>Вторая строка содержит целые числа $$$a_1, a_2, a_3, \ldots,       a_n$$$ ($$$1 \le a_i \le 10^9$$$) — текущие высоты гор.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>В первой строке выведите $$$c$$$ — число выравниваний вершин, при       которых высота хотя бы одной горы изменится. </p>     <p>Во второй строке выведите $$$n$$$ чисел — итоговые высоты гор       после $$$c$$$ выравниваний.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
1 2 1 2 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
1 1 1 1 1 
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
1 3 2 5 4 6
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
1 2 3 4 5 6 
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
1 1 2 2 1 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
1 1 2 2 1 1 
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере высоты на позициях $$$1$$$ и $$$5$$$ не       меняются. Так как медиана чисел $$$1$$$, $$$2$$$, $$$1$$$ это       $$$1$$$, то на позициях 2 и 4 после первого выравнивания       оказываются числа 1, и так как медиана чисел $$$2$$$, $$$1$$$,       $$$2$$$ это $$$2$$$, то на позиции 3 после первого выравнивания       оказывается число 2. Итого после первого выравнивания горных       вершин горы имеют высоты $$$1$$$, $$$1$$$, $$$2$$$, $$$1$$$,       $$$1$$$. После второго выравнивания высоты становятся $$$1$$$,       $$$1$$$, $$$1$$$, $$$1$$$, $$$1$$$ и дальше они меняться не будут,       соответственно всего было $$$2$$$ меняющих высоты выравнивания.</p>     <p>В третем примере после выравнивания ни у одной горы её высота не       изменится и число выравниваний, при которых высоты изменятся,       равно $$$0$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1322/problem/E' title='Codeforces Round 626 (Div. 1, based on Moscow Open Olympiad in Informatics)'>1322E - Median Mountain Range</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's assume that $$$1 \le a_i \le 2$$$. We can notice that if       for some $$$i$$$ $$$a_i = a_{i + 1}$$$, than on $$$i$$$-th and       $$$(i+1)$$$-th positions numbers will stay the same forever. So       the only changes will happen to segments of consecutive       alternating $$$1$$$ and $$$2$$$. Now let's look what will happen       to such segments after first alignment of mountain peaks. The       beginning and end of segment will stay the same, and all       intermediate number will change ($$$1$$$ will change to $$$2$$$       and $$$2$$$ will change to $$$1$$$). So the second number will be       equal to first and pre last number will be equal to last. That       means that lengths of all segments of consecutive alternating       $$$1$$$ and $$$2$$$ will decrease by $$$2$$$. So the number of       alignments equals to length of longest segment divided by $$$2$$$,       and for each segment its first half will be equal to beginning of       segment, and its second half will be equal to the end of segment.</p>     <p>Now let's fix some number $$$x$$$ and create array $$$b$$$, where       $$$b_i = 1$$$ if $$$a_i &lt; x$$$ and $$$b_i = 2$$$ if $$$a_i \ge       x$$$. It can be observed, that if we will make alignment with       initial mountain heights and replace them with $$$1$$$ and $$$2$$$       the same way, we will get array $$$b$$$ after first alignment. So       if we will get array $$$b$$$ after stabilization, we will know       that on positions where $$$b_i = 1$$$ mountains will have height       less than $$$x$$$, and on positions where $$$b_i = 2$$$ the       mountain heights after stabilization will be grater or equal than       $$$x$$$. So to get the number of alignments we will need to find       the longest segment of consecutive alternating $$$1$$$ and $$$2$$$       for all possible $$$x$$$.</p>     <p>Now we need to get the final heights. Let's assume that we know       all positions where final heights will be grater than $$$x$$$.       Let's create array $$$b$$$ the same way as described above. Using       this array we can get positions where the mountain heights will be       grater or equal than $$$x$$$ after stabilization. As we know       positions where the heights will be grater than $$$x$$$, we can       get positions where heights will be equal to $$$x$$$. So if we       will decrease $$$x$$$ from maximum value to $$$1$$$, we can get       the final heights of all mountains.</p>     <p>To perform it quick enough, we can consider only those $$$x$$$,       that equal to some of existing initial heights. Then we can       decrease $$$x$$$ and in some set store all segments of consecutive       alternating $$$1$$$ and $$$2$$$ in array $$$b$$$ for such $$$x$$$.       When the $$$x$$$ is decreased, on some positions $$$1$$$ can       change to $$$2$$$. The changes can happen only to the segments       that have such positions. (The segments can be splited by this       position, or this position can be merged with neighbouring       segment(s)) So in total there will be $$$O(n)$$$ changes to       segments, and we can perform all of them in $$$O(n \log n)$$$       time. Also we can store in set all positions, for which we do not       know the final heights, we for each new segment we can find       positions where $$$1$$$ will be in the end (it will be some       segment of consecutive positions) and search free positions among       them in the set. In total it will take $$$O(n \log n)$$$ time.</p>     <p>There also exists solution in $$$O(n)$$$ time.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #626 (Div. 1, по задачам Открытой олимпиады школьников по программированию)
    1322F
    Разработка тарифов </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Разработка тарифов</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>6 секунд</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Мэр города М. решил в 2020 году запустить несколько новых веток       метро. Поскольку бюджет города сильно ограничен, он принял решение       не копать новые туннели, а воспользоваться уже существующей       подземной сетью.</p>     <p>Туннельная система города М. состоит из $$$n$$$ станций метро.       Станции соединены между собой двунаправленными туннелями, которых       всего $$$n - 1$$$. Между любыми станциями $$$v$$$ и $$$u$$$ есть       ровно один простой путь. Каждая ветка метро, которую хочет создать       мэр, является простым путём от станции $$$a_i$$$ до станции       $$$b_i$$$. Ветки могут пересекаться, то есть иметь общие станции       или туннели. Однако, ещё не решено, в какую из двух сторон будут       следовать поезда на каждой из веток. А именно, на пути между       станциями $$$a_i$$$ и $$$b_i$$$ поезда будут следовать либо от       станции $$$a_i$$$ к станции $$$b_i$$$, либо от станции $$$b_i$$$ к       станции $$$a_i$$$, но только в одну из сторон.</p>     <p>В городе $$$M$$$ действует особая система тарифов. Каждой станции       присваивается целое положительное число $$$c_i$$$ — тарифная зона       станции, а стоимость переезда от станции $$$v$$$ до станции       $$$u$$$ определяется как $$$c_u - c_v$$$ бурлей. Разумеется, такой       переезд разрешен, только если есть ветка метро, по которой поезда       идут из $$$v$$$ в $$$u$$$. Мэр города не хочет, чтобы между       какими-то двумя станциями на одной ветке стоимость проезда была       отрицательной, поэтому было принято решение выбрать направления       движения поездов по веткам и изменить тарифные зоны всех станций       города таким образом, чтобы на каждой ветке тарифные зоны станций       строго возрастали, если рассмотреть её в сторону движения поездов.</p>     <p>Мэр сначала хочет присвоить каждой станции тарифную зону, а потом       выбрать направления всех веток метро, чтобы вдоль каждой ветки       тарифные зоны строго возрастали. В связи со скорым наступлением       дня города, из всех возможных вариантов назначения тарифных зон       мэр хочет выбрать то, где максимальное $$$c_i$$$ будет как можно       меньше. Помогите мэру составить новое распределение, или скажите,       что это невозможно. Обратите внимание, от вас требуется только       назначить тарифные зоны оптимальным образом, а направления для       веток выводить не требуется. Таким образом, ваше решение считается       верным, если существует способ выбрать направление следования       поездов на каждой ветке так, чтобы вдоль всех веток тарифные зоны       строго возрастали.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит целые числа $$$n$$$, $$$m$$$ ($$$2 \le n,       \le 500\,000,\ 1 \le m \le 500\,000$$$) — количество станций в       городе и количество веток метро.</p>     <p>Каждая из следующих $$$n-1$$$ строк описывает очередной туннель       метро. Каждый туннель задаётся целыми числами $$$v_i$$$, $$$u_i$$$       ($$$1 \le v_i,\ u_i \le n$$$, $$$v_i \ne u_i$$$). Гарантируется,       что между любыми двумя станциями есть ровно один простой путь.</p>     <p>Каждая из следующих $$$m$$$ строк описывает очередную ветку       метро. Каждая ветка задаётся целыми числами $$$a_i$$$, $$$b_i$$$       ($$$1 \le a_i,\ b_i \le n$$$, $$$a_i \neq b_i$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>В первой строке выведите целое число $$$k$$$ — максимальный номер       тарифной зоны.</p>     <p>В следующей строке выведите числа $$$c_1, c_2, \ldots, c_n$$$       ($$$1 \le c_i \le k$$$)  — тарифные зоны станций. </p>     <p>Если существует несколько ответов, выведите любой из них. Если же       не существует ни одного способа назначить тарифные зоны, выведите         «<span class="tex-font-style-tt">-1</span>».</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3 1
1 2
2 3
1 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
1 2 3
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
4 3
1 2
1 3
1 4
2 3
2 4
3 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
-1
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
7 5
3 4
4 2
2 5
5 1
2 6
4 7
1 3
6 7
3 7
2 1
3 6
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
-1
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере ветка $$$1 \rightarrow 3$$$ проходит по станциям       в порядке 1, 2, 3. При таком порядке посещения станций их тарифные       зоны возрастают. Поскольку на этой ветке 3 станции, то нам       потребуется как минимум 3 тарифные зоны. Таким образом, ответ 1,       2, 3 оптимален.</p>     <p>Во втором примере ни одно распределение тарифных зон не       согласуется с ветками метро.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1322/problem/F' title='Codeforces Round 626 (Div. 1, based on Moscow Open Olympiad in Informatics)'>1322F - Assigning Fares</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's assume $$$c_v$$$ is the color of vertex v. So, we need to       find a coloring of tree, where $$$c_v$$$ strictly increases along       every path.</p>     <p>First of all, if coloring exists, we can renumerate colors so       that they will be in range [1, $$$n$$$]. Secondly, we can always       revert our coloring, make $$$c_v \rightarrow k + 1 - c_v$$$. Also,       let's do binary search to find $$$k$$$. So, now we want to check       if it is possible to paint tree using $$$k$$$ colors.</p>     <p>Every path can be on of two directions. If we determine direction       for path #0, then we also automatically determine direction for       every path which has common edge with path #0. So, we can get a       components of paths — if we choose one path direction, we choose       every other paths direction. We can notice, that if a single       component is not bipartite, answer is -1. So, for every path, we       know it's component and it's orientation inside the component. It       can be calculated using subtree sum — for vertexes $$$a$$$ and       $$$b$$$ we make +1 for $$$a$$$, +1 for $$$b$$$, and -2 for       $$$lca(a,\,b)$$$. Let's make our tree rooted and then count dp on       subtrees. $$$dp_v$$$ — minimal color of $$$v$$$, if all it's       subtree is colored in a correct way and edge $$$v \rightarrow       parent_v$$$ goes from lower to higher color. How to calculate dp?</p>     <p>If we fix $$$parent_v \rightarrow v$$$ edge direction, for some       edges $$$v \rightarrow to$$$ we know the orientation. It happens       when they were in same component as $$$parent_v \rightarrow v$$$.       For other components, we can or use $$$dp_{to}$$$ or $$$k + 1 -       dp_{to}$$$ — depending on which direction of component we use. If       we will try both variants and combine all the constraints, we will       get two different segments $$$[l, r]$$$ and $$$[k + 1 - r, k + 1 -       l]$$$, and $$$dp_v$$$ must be in one of them. It can be solved       with scanline in $$$O(n \log n)$$$ time.</p>     <p>Now we can notice that $$$r = k + 1 - dp_{to}$$$. Let's think of       segments as about two left constraints: $$$l_1$$$ and $$$l_2$$$.       We have two sets $$$L$$$ and $$$R$$$. We either put $$$l_1       \rightarrow L,\ l_2 \rightarrow R$$$ or $$$l_2 \rightarrow L,\ l_1       \rightarrow R$$$.</p>     <p>So, we want these conditions to be done: $$$$$$\begin{cases}       \max(L) \le \min(k - R) \\ \max(L) \rightarrow \min \end{cases}       \rightarrow \begin{cases} \max(L) + \max(R) \le k \\ \max(L)       \rightarrow \min \end{cases}$$$$$$</p>     <p>If we fix what is more — $$$\max(R)$$$ or $$$\max(L)$$$, we get       fixed distribuition between $$$L$$$ and $$$R$$$ — max of $$$l_1$$$       and $$$l_2$$$ goes to max of two sets. Then we just need to check       conditions and use best of variants. Solution will have complexity       $$$O(n \log n)$$$.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #626 (Div. 2, по задачам Открытой олимпиады школьников по программированию)
    1323A
    Задача о подмножестве чётной суммы </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Задача о подмножестве чётной суммы</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Дан массив $$$a$$$, состоящий из $$$n$$$ положительных целых       чисел. Найдите <span class="tex-font-style-bf">непустое</span>       подмножество его элементов с <span class="tex-font-style-bf">чётной</span> (т.е. делящейся на       $$$2$$$) суммой или определите, что такого подмножества нет.</p>     <p>И заданный массив и искомое подмножетсво могут содержать равные       значения элементов.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке задано целое число $$$t$$$ ($$$1 \leq t \leq       100$$$) — количество наборов входных данных, для которых требуется       решить задачу. Затем следуют описания $$$t$$$ наборов входных данных.</p>     <p>Описание каждого набора входных данных состоит из двух строк. В       первой строке задано одно целое число $$$n$$$ ($$$1 \leq n \leq       100$$$) — количество элементов в массиве $$$a$$$. Во второй строке       заданы $$$n$$$ целых чисел $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \leq       a_i \leq 100$$$) — элементы массива $$$a$$$. Массив $$$a$$$ может       содержать одинаковые (равные) значения элементов.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите $$$-1$$$, если не       существует требуемого подмножества элементов. Иначе выведите целое       число $$$k$$$ — количество элементов в подмножестве. Затем       выведите $$$k$$$ различных чисел ($$$1 \leq p_i \leq n$$$) —       индексы элементов найденного подмножества. Если есть несколько       подходящих подмножеств, выведите любое из них.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
3
1 4 3
1
15
2
3 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
2
-1
2
1 2
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В примере описан тест, состоящий их трёх наборов входных данных.</p>     <p>В первом наборе входных данных можно выбрать подмножество,       состоящее из второго элемента массива. Сумма в этом подмножестве       равна $$$4$$$, то есть чётна.</p>     <p>Во втором наборе входных данных существует только одно непустое       подмножество элементов массива, состоящее из первого элемента. В       этом подмножестве сумма нечётна, таким образом ответа не существует.</p>     <p>В третьем наборе входных данных подмножество, состоящее из всех       элементов массива, имеет чётную сумму.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1323/problem/A' title='Codeforces Round 626 (Div. 2, based on Moscow Open Olympiad in Informatics)'>1323A - Even Subset Sum Problem</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>If there is an even element in array there is an answer       consisting of only it. Otherwise if there is at least two odd       elements in array there is an answer consisting of this two       elements. Otherwise array is only one odd element and there is no answer.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #626 (Div. 2, по задачам Открытой олимпиады школьников по программированию)
    1323B
    Посчитай подпрямоугольники </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Посчитай подпрямоугольники</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Дан массив $$$a$$$ длины $$$n$$$ и массив $$$b$$$ длины $$$m$$$,       оба состоящие из чисел $$$0$$$ и $$$1$$$. Рассмотрим матрицу       $$$c$$$ размера $$$n \times m$$$, построенную по следующему       правилу: $$$c_{i, j} = a_i \cdot b_j$$$ (то есть $$$a_i$$$,       умноженное на $$$b_j$$$). Несложно заметить, что $$$c$$$ также       состоит только из нулей и единиц.</p>     <p>Сколько подпрямоугольников размера $$$k$$$, состоящих только из       единиц, есть в $$$c$$$?</p>     <p>       <span class="tex-font-style-it">Подпрямоугольник</span> — это       пересечение непрерывного подотрезка строк и непрерывного       подотрезка столбцов матрицы. Рассмотрим четыре числа $$$x_1, x_2,       y_1, y_2$$$ ($$$1 \le x_1 \le x_2 \le n$$$, $$$1 \le y_1 \le y_2       \le m$$$), тогда подпрямоугольник $$$c[x_1 \dots x_2][y_1 \dots       y_2]$$$ — это пересечение строк $$$x_1, x_1+1, x_1+2, \dots,       x_2$$$ и столбцов $$$y_1, y_1+1, y_1+2, \dots, y_2$$$.</p>     <p>Размер (площадь) подпрямоугольника — это количество элементов       матрицы в нём.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке содержатся три целых числа $$$n$$$, $$$m$$$ и       $$$k$$$ ($$$1 \leq n, m \leq 40\,000, 1 \leq k \leq n \cdot       m$$$) — длина массива $$$a$$$, длина массива $$$b$$$ и требуемый       размер подпрямоугольников.</p>     <p>Во второй строке содержатся $$$n$$$ целых чисел $$$a_1, a_2,       \ldots, a_n$$$ ($$$0 \leq a_i \leq 1$$$) — элементы массива $$$a$$$.</p>     <p>В третьей строке содержатся $$$m$$$ целых чисел $$$b_1, b_2,       \ldots, b_m$$$ ($$$0 \leq b_i \leq 1$$$) — элементы массива $$$b$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одно целое число — количество подпрямоугольников в       $$$c$$$ размера $$$k$$$, состоящих только из единиц.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3 3 2
1 0 1
1 1 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
4
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
3 5 4
1 1 1
1 1 1 1 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
14
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере матрица $$$c$$$ такова:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/f968f525b71461d7167dddb750e21f919b72a4b6.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>В ней есть $$$4$$$ подпрямоугольника размера $$$2$$$, состоящих       только из единиц:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/1bac6e469667a71d19e75eca27ff5616fc4f1849.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>Во втором примере матрица $$$c$$$ такова:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/3109dd0bc266b26bdd9a8a0f1f6c5f6f8cd64093.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1323/problem/B' title='Codeforces Round 626 (Div. 2, based on Moscow Open Olympiad in Informatics)'>1323B - Count Subrectangles</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Rectangle $$$[x1; x2][y1; y2]$$$ consists of only ones iff       subsegment $$$[x1; x2]$$$ consists of only ones in $$$a$$$ and       subsegment $$$[y1; y2]$$$ consists of only ones in $$$b$$$. Let's       iterate over divisors of $$$k$$$. Let the current divisor be       $$$p$$$ (i.e. $$$k = p \cdot q$$$), so we are interested in number       of subsegments consisting of ones of length $$$p$$$ in $$$a$$$ and       number of subsegments consisting of ones of length $$$q$$$ in $$$b$$$.</p>     <p>It's possible to precalculate number of segments consisting of       ones in $$$a$$$ and $$$b$$$ of each length. Let's find all maximal       subsegments consisting of ones in $$$a$$$ and $$$b$$$. Consider       subsegment of length $$$l$$$. It adds $$$l - s + 1$$$ for amount       of subsegments of length $$$s$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using ll = long long;
using ld = long double;
using ull = unsigned long long;

using namespace std;

vector&lt;ll&gt; gao(vector&lt;int&gt; a) {
    int n = a.size();
    vector&lt;ll&gt; res(n + 1);
    int i = 0;
    while (i &lt; n) {
        if (a[i] == 0) {
            i++;
            continue;
        }

        int j = i;
        while (j &lt; n &amp;&amp; a[j] == 1) {
            j++;
        }
        for (int len = 1; len &lt;= j - i; len++) {
            res[len] += j - i - len + 1;
        }
        i = j;
    }

    return res;
}

int main() {
    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    int n, m;
    ll k;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    vector&lt;int&gt; a(n);
    vector&lt;int&gt; b(m);
    for (int&amp; x : a) {
        cin &gt;&gt; x;
    }
    for (int&amp; x : b) {
        cin &gt;&gt; x;
    }

    ll ans = 0;

    auto ga = gao(a);
    auto gb = gao(b);
    for (int i = 1; i &lt; ga.size(); i++) {
        if (k % i == 0 &amp;&amp; k / i &lt;= m) {
            ans += ga[i] * gb[k / i];
        }
    }

    cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
    return 0;
}

</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using ll = long long;
using ld = long double;
using ull = unsigned long long;

using namespace std;

vector&lt;ll&gt; gao(vector&lt;int&gt; a) {
    int n = a.size();
    vector&lt;ll&gt; res(n + 1);
    int i = 0;
    while (i &lt; n) {
        if (a[i] == 0) {
            i++;
            continue;
        }

        int j = i;
        while (j &lt; n &amp;&amp; a[j] == 1) {
            j++;
        }
        for (int len = 1; len &lt;= j - i; len++) {
            res[len] += j - i - len + 1;
        }
        i = j;
    }

    return res;
}

int main() {
    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    int n, m;
    ll k;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    vector&lt;int&gt; a(n);
    vector&lt;int&gt; b(m);
    for (int&amp; x : a) {
        cin &gt;&gt; x;
    }
    for (int&amp; x : b) {
        cin &gt;&gt; x;
    }

    ll ans = 0;

    auto ga = gao(a);
    auto gb = gao(b);
    for (int i = 1; i &lt; ga.size(); i++) {
        if (k % i == 0 &amp;&amp; k / i &lt;= m) {
            ans += ga[i] * gb[k / i];
        }
    }

    cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
    return 0;
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #627 (Div. 3)
    1324A
    Очередная задача про тетрис </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Очередная задача про тетрис</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам задано поле Тетриса, состоящее из $$$n$$$ столбцов. Начальная       высота $$$i$$$-го столбца поля равна $$$a_i$$$ блоков. Сверху на       столбцы вы можете ставить <span class="tex-font-style-bf">только</span> фигуры размера $$$2 \times       1$$$ (то есть высоты $$$2$$$ блока и ширины $$$1$$$ блок).       Заметьте, что вы <span class="tex-font-style-bf">не можете</span>       поворачивать эти фигуры.</p>     <p>Ваша задача — определить, возможно ли очистить заданное поле,       используя только описанные фигуры.</p>     <p>Более формально, задачу можно описать следующим образом:</p>     <p>Пока <span class="tex-font-style-bf">хотя бы одно из $$$a_i$$$         больше $$$0$$$</span>, происходит следующий процесс:</p>          <ol> <li> Вы ставите одну фигуру $$$2 \times 1$$$ (выбираете         какое-то $$$i$$$ от $$$1$$$ до $$$n$$$ и заменяете $$$a_i$$$ на         $$$a_i + 2$$$); </li>       <li> затем, пока все $$$a_i$$$ больше нуля, каждое $$$a_i$$$         заменяется на $$$a_i - 1$$$. </li></ol>          <p>Ваша задача — определить, возможно ли очистить заданное поле       (т.е. завершить описанный процесс), выбирая места для новых фигур       правильным образом.</p>     <p>Вам необходимо ответить на $$$t$$$ независимых наборов тестовых данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка входных данных содержит одно целое число $$$t$$$       ($$$1 \le t \le 100$$$) — количество наборов тестовых данных.</p>     <p>Следующие $$$2t$$$ строк описывают наборы тестовых данных. Первая       строка набора тестовых данных содержит одно целое число $$$n$$$       ($$$1 \le n \le 100$$$) — количество столбцов на поле тетриса.       Вторая строка входных данных содержит $$$n$$$ целых чисел $$$a_1,       a_2, \dots, a_n$$$ ($$$1 \le a_i \le 100$$$), где $$$a_i$$$ равно       начальной высоте $$$i$$$-го столбца поля тетриса.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите ответ — «<span class="tex-font-style-tt">YES</span>» (без кавычек), если вы       можете очистить поле тетриса полностью, и «<span class="tex-font-style-tt">NO</span>» в противном случае.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
3
1 1 3
4
1 1 2 1
2
11 11
1
100
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
YES
NO
YES
YES
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Первый набор тестовых данных из примера показан ниже:</p>     <p>       <img class="tex-graphics" src="https://espresso.codeforces.com/c3b3d19786c16dfd52f9729d83217c7154a5852f.png" style="max-width: 100.0%;max-height: 100.0%;"/></p>     <p>Серые линии означают границы поля Тетриса. Заметьте, что поле не       имеет верхней границы.</p>     <p>Одним из корректных ответов является сначала поставить фигуру в       первый столбец. Затем, после второго шага процесса, поле станет       равно $$$[2, 0, 2]$$$. Затем надо поставить фигуру во второй       столбец и после второго шага процесса поле станет равно $$$[0, 0, 0]$$$.</p>     <p>И второй набор тестовых данных из примера показан ниже:</p>     <p>       <img class="tex-graphics" src="https://espresso.codeforces.com/9e670fa3eabfebd5ecdfa6085157f1f4ccfe494e.png" style="max-width: 100.0%;max-height: 100.0%;"/></p>     <p>Можно показать, что вы не можете сделать ничего, чтобы закончить процесс.</p>     <p>В третьем наборе тестовых данных из примера можно сначала       поставить фигуру во второй столбец и после второго шага процесса       поле станет равно $$$[0, 2]$$$. Затем можно поставить фигуру в       первый столбец и после второго шага процесса поле станет равно       $$$[0, 0]$$$.</p>     <p>В четвертом наборе тестовых данных из примера можно поставить       фигуру в первый столбец, тогда после первого шага процесса поле       станет равно $$$[102]$$$, и затем после второго шага процесса поле       станет равно $$$[0]$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1324/problem/A' title='Codeforces Round 627 (Div. 3)'>1324A - Yet Another Tetris Problem</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>The answer is &quot;<span class="tex-font-style-tt">YES</span>&quot; only if all $$$a_i$$$       have the same parity (i.e. all $$$a_i$$$ are odd or all $$$a_i$$$       are even). That's because placing the block doesn't change the       parity of the element and the $$$-1$$$ operation changes the       parity of all elements in the array. </p></div></div></div>

           
            <pre><code>for i in range(int(input())):
	n = int(input())
	cnto = sum(list(map(lambda x: int(x) % 2, input().split())))
	print(&#39;YES&#39; if cnto == 0 or cnto == n else &#39;NO&#39;)
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #627 (Div. 3)
    1324B
    Еще одна задача про палиндромы </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Еще одна задача про палиндромы</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам задан массив $$$a$$$, состоящий из $$$n$$$ целых чисел.</p>     <p>Ваша задача — определить, содержит ли $$$a$$$ какую-то <span class="tex-font-style-bf">подпоследовательность</span> длины хотя       бы $$$3$$$, которая является палиндромом.</p>     <p>Напомним, что массив $$$b$$$ называется <span class="tex-font-style-bf">подпоследовательностью</span> массива       $$$a$$$, если $$$b$$$ может быть получен удалением некоторого       (возможно, нулевого) количества элементов из $$$a$$$ (не       обязательно подряд идущих) без изменения порядка оставшихся       элементов. Например, $$$[2]$$$, $$$[1, 2, 1, 3]$$$ и $$$[2, 3]$$$       являются подпоследовательностями $$$[1, 2, 1, 3]$$$, а $$$[1, 1,       2]$$$ и $$$[4]$$$ — нет.</p>     <p>Также напомним, что палиндром — это массив, который читается       одинаково как слева направо, так и справа налево. Другими словами,       массив $$$a$$$ длины $$$n$$$ является палиндромом, если $$$a_i =       a_{n - i - 1}$$$ для всех $$$i$$$ от $$$1$$$ до $$$n$$$. Например,       массивы $$$[1234]$$$, $$$[1, 2, 1]$$$, $$$[1, 3, 2, 2, 3, 1]$$$ и       $$$[10, 100, 10]$$$ являются палиндромами, а массивы $$$[1, 2]$$$       и $$$[1, 2, 3, 1]$$$ — нет.</p>     <p>Вам необходимо ответить на $$$t$$$ независимых наборов тестовых данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка входных данных содержит одно целое число $$$t$$$       ($$$1 \le t \le 100$$$) — количество наборов тестовых данных.</p>     <p>Следующие $$$2t$$$ строк описывают наборы тестовых данных. Первая       строка набора тестовых данных содержит одно целое число $$$n$$$       ($$$3 \le n \le 5000$$$) — длину $$$a$$$. Вторая строка набора       тестовых данных содержит $$$n$$$ целых чисел $$$a_1, a_2, \dots,       a_n$$$ ($$$1 \le a_i \le n$$$), где $$$a_i$$$ является $$$i$$$-м       элементом $$$a$$$.</p>     <p>Гарантируется, что сумма $$$n$$$ по всем наборам тестовых данных       не превосходит $$$5000$$$ ($$$\sum n \le 5000$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите ответ — «<span class="tex-font-style-tt">YES</span>» (без кавычек), если $$$a$$$       содержит какую-то <span class="tex-font-style-bf">подпоследовательность</span> длины хотя       бы $$$3$$$, которая является палиндромом, и «<span class="tex-font-style-tt">NO</span>» в противном случае.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
3
1 2 1
5
1 2 2 3 2
3
1 1 2
4
1 2 2 1
10
1 1 2 2 3 3 4 4 5 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
YES
YES
NO
YES
NO
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе тестовых данных из примера массив $$$a$$$       содержит подпоследовательность $$$[1, 2, 1]$$$, которая является палиндромом.</p>     <p>Во втором наборе тестовых данных из примера массив $$$a$$$       содержит две подпоследовательности длины $$$3$$$, которые являются       палиндромами: $$$[2, 3, 2]$$$ и $$$[2, 2, 2]$$$.</p>     <p>В третьем наборе тестовых данных из примера в массиве $$$a$$$ нет       подпоследовательностей длины хотя бы $$$3$$$, которые являются палиндромами.</p>     <p>В четвертом наборе тестовых данных из примера массив $$$a$$$       содержит одну последовательность длины $$$4$$$, которая является       палиндромом: $$$[1, 2, 2, 1]$$$ (и содержит две       подпоследовательности длины $$$3$$$, которые являются       палиндромами: обе равны $$$[1, 2, 1]$$$).</p>     <p>В пятом наборе тестовых данных из примера в массиве $$$a$$$ нет       подпоследовательностей длины хотя бы $$$3$$$, которые являются палиндромами.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1324/problem/B' title='Codeforces Round 627 (Div. 3)'>1324B - Yet Another Palindrome Problem</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>The first observation is that we can always try to find the       palindrome of length $$$3$$$ (otherwise, we can remove some       characters from the middle until its length becomes $$$3$$$).</p>     <p>The second observation is that the palindrome of length $$$3$$$       is two equal characters and some other (maybe, the same) character       between them. Now there are two ways: find the pair of equal       non-adjacent characters in $$$O(n^2)$$$ or do it in $$$O(n)$$$       (for each character we only need to consider its left and right occurrences).</p></div></div></div>

           
            <pre><code>for i in range(int(input())):
	n = int(input())
	s = list(map(int, input().split()))
	ok = False
	for i in range(n):
		for j in range(i + 2, n):
			if s[i] == s[j]: ok = True
	print(&#39;YES&#39; if ok else &#39;NO&#39;)
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #627 (Div. 3)
    1324C
    Прыгающая лягушка </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Прыгающая лягушка</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Слева от строки $$$s = s_1 s_2 \ldots s_n$$$, состоящей из       $$$n$$$ символов, находится лягушка (точнее, изначально лягушка       находится в клетке $$$0$$$). Каждый символ строки $$$s$$$ — это       или '<span class="tex-font-style-tt">L</span>', или '<span class="tex-font-style-tt">R</span>'. Это значит, что если лягушка       находится в $$$i$$$-й клетке и $$$i$$$-й символ — это '<span class="tex-font-style-tt">L</span>', то она может прыгать только       влево. Если лягушка стоит в $$$i$$$-й клетке и $$$i$$$-й символ —       это '<span class="tex-font-style-tt">R</span>', то она может       прыгать только вправо. <span class="tex-font-style-bf">Из клетки         $$$0$$$ лягушка может прыгать только вправо</span>.</p>     <p>       <span class="tex-font-style-bf">Заметим, что лягушка может прыгать         в одну и ту же клетку дважды и может совершить столько прыжков,         сколько ей потребуется</span>.</p>     <p>Лягушка хочет достичь $$$n+1$$$-й клетки. Лягушка выбирает       некоторое <span class="tex-font-style-bf">целое       положительное</span> значение $$$d$$$ <span class="tex-font-style-bf">перед самым первым прыжком</span> (и       потом не может изменить его) и прыгает не более, чем на $$$d$$$       клеток за раз. То есть, если $$$i$$$-й символ — '<span class="tex-font-style-tt">L</span>', то лягушка может прыгнуть в       любую клетку из отрезка $$$[max(0, i - d); i - 1]$$$, а если       $$$i$$$-й символ — '<span class="tex-font-style-tt">R</span>', то       лягушка может прыгнуть в любую клетку из отрезка $$$[i + 1; min(n       + 1; i + d)]$$$.</p>     <p>Лягушка не хочет прыгать слишком далеко, поэтому ваша задача —       найти минимальное возможное значение $$$d$$$, при котором лягушка       сможет достичь клетки $$$n+1$$$ из клетки $$$0$$$, если будет       прыгать не более, чем на $$$d$$$ клеток за раз. <span class="tex-font-style-bf">Гарантируется, что всегда возможно         достичь $$$n+1$$$ из $$$0$$$</span>.</p>     <p>Вам нужно ответить на $$$t$$$ независимых наборов входных данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка теста содержит одно целое число $$$t$$$ ($$$1 \le t       \le 10^4$$$) — количество наборов входных данных.</p>     <p>Следующие $$$t$$$ строк описывают наборы входных данных.       $$$i$$$-й описан строкой $$$s$$$ состоящей из не менее, чем       $$$1$$$, и не более, чем $$$2 \cdot 10^5$$$ символов '<span class="tex-font-style-tt">L</span>' и '<span class="tex-font-style-tt">R</span>'.</p>     <p>Гарантируется, что сумма длин строк по всем наборам входных       данных не превосходит $$$2 \cdot 10^5$$$ ($$$\sum |s| \le 2 \cdot 10^5$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите ответ — минимальное       возможное значение $$$d$$$, при котором лягушка может достичь       клетки $$$n+1$$$ из клетки $$$0$$$, если будет совершать прыжки       длиной не более, чем $$$d$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
LRLRRLL
L
LLR
RRRR
LLLLLL
R
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
2
3
1
7
1
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Картинка, описывающая первый набор тестовых данных из примера и       один из возможных ответов:</p>     <p>       <img class="tex-graphics" src="https://espresso.codeforces.com/de84e2ea205b39d12a73b422b7f6b0229de451ba.png" style="max-width: 100.0%;max-height: 100.0%;"/></p>     <p>Во втором наборе тестовых данных из примера лягушка может       прыгнуть только напрямую из $$$0$$$ в $$$n+1$$$.</p>     <p>В третьем наборе тестовых данных лягушка может выбрать $$$d=3$$$,       прыгнуть в клетку $$$3$$$ из клетки $$$0$$$ и затем прыгнуть в       клетку $$$4$$$ из клетки $$$3$$$.</p>     <p>В четвертом наборе тестовых данных из примера лягушка может       выбрать $$$d=1$$$ и прыгнуть $$$5$$$ раз вправо.</p>     <p>В пятом наборе тестовых данных из примера лягушка может прыгнуть       только напрямую из $$$0$$$ в $$$n+1$$$.</p>     <p>В шестом наборе тестовых данных из примера лягушка может выбрать       $$$d=1$$$ и прыгнуть $$$2$$$ раза вправо.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1324/problem/C' title='Codeforces Round 627 (Div. 3)'>1324C - Frog Jumps</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>The only observation we need is that we don't need to jump left       at all. This only decreases our position so we have less freedom       after the jump to the left. Then, to minimize $$$d$$$, we only       need to jump between the closest '<span class="tex-font-style-tt">R</span>' cells. So, if we build the       array $$$b = [0, r_1, r_2, \dots, r_k, n + 1]$$$, where $$$r_i$$$       is the position of the $$$i$$$-th '<span class="tex-font-style-tt">R</span>' cell from left to right       ($$$1$$$-indexed), then the answer is $$$\max\limits_{i=0}^{k}       b_{i + 1} - b_i$$$.</p>     <p>Time complexity: $$$O(n)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
	
	int t;
	cin &gt;&gt; t;
	while (t--) {
		string s;
		cin &gt;&gt; s;
		vector&lt;int&gt; pos;
		pos.push_back(0);
		for (int i = 0; i &lt; int(s.size()); ++i) {
			if (s[i] == &#39;R&#39;) pos.push_back(i + 1);
		}
		pos.push_back(s.size() + 1);
		int ans = 0;
		for (int i = 0; i &lt; int(pos.size()) - 1; ++i) {
			ans = max(ans, pos[i + 1] - pos[i]);
		}
		cout &lt;&lt; ans &lt;&lt; endl;
	}
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #627 (Div. 3)
    1324D
    Пара тем </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Пара тем</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>На следующей лекции в университете нужно обсудить две темы.       $$$i$$$-я тема интересна на $$$a_i$$$ единиц для преподавателя и       на $$$b_i$$$ единиц для студентов.</p>     <p>Пара тем $$$i$$$ и $$$j$$$ ($$$i &lt; j$$$) называется <span class="tex-font-style-bf">хорошей</span>, если $$$a_i + a_j &gt;       b_i + b_j$$$ (т.е. эта пара тем более интересна преподавателю).</p>     <p>Ваша задача — найти количество <span class="tex-font-style-bf">хороших</span> пар тем.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка теста содержит одно целое число $$$n$$$ ($$$2 \le n       \le 2 \cdot 10^5$$$) — количество тем.</p>     <p>Вторая строка теста содержит $$$n$$$ целых чисел $$$a_1, a_2,       \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$), где $$$a_i$$$ — уровень       интереса к $$$i$$$-й теме у преподавателя.</p>     <p>Третья строка теста содержит $$$n$$$ целых чисел $$$b_1, b_2,       \dots, b_n$$$ ($$$1 \le b_i \le 10^9$$$), где $$$b_i$$$ — уровень       интереса к $$$i$$$-й теме у студентов.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одно целое число — количество <span class="tex-font-style-bf">хороших</span> пар тем.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
4 8 2 6 2
4 5 4 1 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
7
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
1 3 2 4
1 3 2 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1324/problem/D' title='Codeforces Round 627 (Div. 3)'>1324D - Pair of Topics</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's rewrite the inequality from $$$a_i + a_j &gt; b_i + b_j$$$       to $$$(a_i - b_i) + (a_j - b_j) &gt; 0$$$. This looks much       simpler. Let's build the array $$$c$$$ where $$$c_i = a_i - b_i$$$       and sort this array. Now our problem is to find the number of       pairs $$$i &lt; j$$$ such that $$$c_i + c_j &gt; 0$$$.</p>     <p>Let's iterate over all elements of $$$c$$$ from left to right.       For simplicity, we consider only &quot;greater&quot; summands.       Because our sum ($$$c_i + c_j$$$) must be greater than $$$0$$$,       then at least one of these summands will be positive. So, if       $$$c_i \le 0$$$, just skip it. Now $$$c_i &gt; 0$$$ and we need to       calculate the number of such $$$j$$$ that $$$c_i + c_j &gt; 0$$$       and $$$j &lt; i$$$. It means that each $$$c_j \ge -c_i + 1$$$ (for       some $$$j &lt; i$$$) will be okay. Such leftmost position $$$j$$$       can be found with <span class="tex-font-style-tt">std::lower_bound</span> or binary       search. Then add the value $$$i-j$$$ to the answer and consider       the next element.</p>     <p>Time complexity: $$$O(n \log n)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
	
	int n;
	cin &gt;&gt; n;
	vector&lt;int&gt; a(n), b(n);
	for (auto &amp;it : a) cin &gt;&gt; it;
	for (auto &amp;it : b) cin &gt;&gt; it;
	vector&lt;int&gt; c(n);
	for (int i = 0; i &lt; n; ++i) {
		c[i] = a[i] - b[i];
	}
	sort(c.begin(), c.end());
	
	long long ans = 0;
	for (int i = 0; i &lt; n; ++i) {
		if (c[i] &lt;= 0) continue;
		int pos = lower_bound(c.begin(), c.end(), -c[i] + 1) - c.begin();
		ans += i - pos;
	}
	
	cout &lt;&lt; ans &lt;&lt; endl;
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #627 (Div. 3)
    1324E
    Режим сна </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. Режим сна</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У Вовы довольно странный режим сна. В сутках $$$h$$$ часов. Вова       будет спать ровно $$$n$$$ раз. В $$$i$$$-й раз он будет спать       ровно после $$$a_i$$$ часов после пробуждения. Предположим, что       Вова просыпается ровно в начале этой истории (изначальное время       равно $$$0$$$). Каждый раз Вова спит ровно сутки (другими словами,       $$$h$$$ часов).</p>     <p>Вова думает, что $$$i$$$-й раз, когда он спит, — <span class="tex-font-style-bf">хороший</span>, если он идет спать между       $$$l$$$ и $$$r$$$ часами включительно.</p>     <p>Вова может контролировать себя и перед $$$i$$$-м разом он может       выбрать одно из двух: пойти спать после $$$a_i$$$ часов или после       $$$a_i - 1$$$ часов.</p>     <p>Ваша задача — назвать максимальное число <span class="tex-font-style-bf">хороших</span> раз, которые Вова может       получить, если будет действовать оптимально.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка теста содержит четыре целых числа $$$n, h, l$$$ и       $$$r$$$ ($$$1 \le n \le 2000, 3 \le h \le 2000, 0 \le l \le r &lt;       h$$$) — количество раз, которое Вова будет спать, количество часов       в сутках и отрезок <span class="tex-font-style-bf">хорошего</span>       времени для сна.</p>     <p>Вторая строка теста содержит $$$n$$$ целых чисел $$$a_1, a_2,       \dots, a_n$$$ ($$$1 \le a_i &lt; h$$$), где $$$a_i$$$ — количество       часов, после которого Вова пойдет спать в $$$i$$$-й раз.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одно целое число — максимальное количество <span class="tex-font-style-bf">хороших</span> раз, которое Вова может       получить, если будет действовать оптимально.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
7 24 21 23
16 17 14 20 20 11 22
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Максимальное количество <span class="tex-font-style-bf">хороших</span> раз в тестовом примере       равно $$$3$$$.</p>     <p>История начинается с $$$t=0$$$. Затем Вова идет спать после       $$$a_1 - 1$$$ часов, теперь время равно $$$15$$$. Это время не       является хорошим. Затем Вова идет спать после $$$a_2 - 1$$$ часов,       теперь время равно $$$15 + 16 = 7$$$. Это время также не является       хорошим. Затем Вова идет спать после $$$a_3$$$ часов, теперь время       равно $$$7 + 14 = 21$$$. Это время является <span class="tex-font-style-bf">хорошим</span>. Затем Вова идет спать       после $$$a_4 - 1$$$ часов, теперь время равно $$$21 + 19 = 16$$$.       Это время не является хорошим. Затем Вова идет спать после       $$$a_5$$$ часов, теперь время равно $$$16 + 20 = 12$$$. Это время       не является хорошим. Затем Вова идет спать после $$$a_6$$$ часов,       Теперь время равно $$$12 + 11 = 23$$$. Это время является <span class="tex-font-style-bf">хорошим</span>. Затем Вова идет спать       после $$$a_7$$$ часов, теперь время равно $$$23 + 22 = 21$$$. Это       время также является <span class="tex-font-style-bf">хорошим</span>.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1324/problem/E' title='Codeforces Round 627 (Div. 3)'>1324E - Sleeping Schedule</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>This is a very standard dynamic programming problem. Let       $$$dp_{i, j}$$$ be the maximum number of <span class="tex-font-style-bf">good</span> sleeping times if Vova had a       sleep $$$i$$$ times already and the number of times he goes to       sleep earlier by one hour is exactly $$$j$$$. Then the value       $$$\max\limits_{j=0}^{n} dp_{n, j}$$$ will be the answer.       Initially, all $$$dp_{i, j} = -\infty$$$ and $$$dp_{0, 0} = 0$$$.</p>     <p>What about transitions? Let the current state of the dynamic       programming be $$$dp_{i, j}$$$ and $$$s = \sum\limits_{k=0}^{i}       a_k$$$. Then we can don't go to sleep earlier and make the first       transition: $$$dp_{i + 1, j} = max(dp_{i + 1, j}, dp_{i, j} + |(s       - j) \% h \in [l; r]|)$$$. The sign $$$\%$$$ is modulo operation       and the notation $$$|f|$$$ is the boolean result of the expression       $$$f$$$ ($$$1$$$ if $$$f$$$ is true and $$$0$$$ otherwise). And       the second transition if we go to sleep earlier: $$$dp_{i + 1, j +       1} = max(dp_{i + 1, j + 1}, dp_{i, j} + |(s - j - 1) \% h \in [l; r]|)$$$.</p>     <p>Don't forget to don't make transitions from unreachable states.</p>     <p>Time complexity: $$$O(n^2)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

bool in(int x, int l, int r) {
	return l &lt;= x &amp;&amp; x &lt;= r;
}

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
	
	int n, h, l, r;
	cin &gt;&gt; n &gt;&gt; h &gt;&gt; l &gt;&gt; r;
	vector&lt;int&gt; a(n);
	for (auto &amp;it : a) cin &gt;&gt; it;
	vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(n + 1, INT_MIN));
	dp[0][0] = 0;
	int sum = 0;
	for (int i = 0; i &lt; n; ++i) {
		sum += a[i];
		for (int j = 0; j &lt;= n; ++j) {
			dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] + in((sum - j) % h, l, r));
			if (j &lt; n) dp[i + 1][j + 1] = max(dp[i + 1][j + 1], dp[i][j] + in((sum - j - 1) % h, l, r));
		}
	}
	
	cout &lt;&lt; *max_element(dp[n].begin(), dp[n].end()) &lt;&lt; endl;
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #627 (Div. 3)
    1324F
    Максимально белое поддерево  </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Максимально белое поддерево </div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам задано дерево, состоящее из $$$n$$$ вершин. Деревом       называется связный неориентированный граф с $$$n-1$$$ ребром.       Каждая вершина $$$v$$$ этого дерева имеет свой цвет ($$$a_v =       1$$$, если вершина $$$v$$$ белая, и $$$0$$$, если вершина $$$v$$$ черная).</p>     <p>Вам нужно решить следующую задачу для каждой вершины $$$v$$$:       какую максимальную разницу между количеством белых вершин и       количеством черных вершин вы можете получить, если выберете       некоторое поддерево заданного дерева, которое <span class="tex-font-style-bf">содержит</span> вершину $$$v$$$?       Поддеревом дерева называется связный подграф заданного дерева.       Более формально, если вы выберете поддерево, которое содержит       $$$cnt_w$$$ белых вершин и $$$cnt_b$$$ черных вершин, вам нужно       максимизировать $$$cnt_w - cnt_b$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка теста содержит одно целое число $$$n$$$ ($$$2 \le n       \le 2 \cdot 10^5$$$) — количество вершин в дереве.</p>     <p>Вторая строка теста содержит $$$n$$$ целых чисел $$$a_1, a_2,       \dots, a_n$$$ ($$$0 \le a_i \le 1$$$), где $$$a_i$$$ — это цвет       $$$i$$$-й вершины.</p>     <p>Каждая из последующих $$$n-1$$$ строк описывает ребро в дереве.       Ребро $$$i$$$ задается двумя целыми числами $$$u_i$$$ и $$$v_i$$$       — номерами вершин, которые оно соединяет $$$(1 \le u_i, v_i \le n,       u_i \ne v_i$$$).</p>     <p>Гарантируется, что заданные ребра образуют дерево.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$n$$$ целых чисел $$$res_1, res_2, \dots, res_n$$$,       где $$$res_i$$$ — максимальная возможная разница между количеством       белых и количеством черных вершин в некотором поддереве, которое       содержит вершину $$$i$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
9
0 1 1 1 0 0 0 0 1
1 2
1 3
3 4
3 5
2 6
4 7
6 8
5 9
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2 2 2 2 2 1 1 0 2 
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
0 0 1 0
1 2
1 3
1 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0 -1 1 -1 
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Первый тестовый пример представлен ниже:</p>     <p>       <img class="tex-graphics" src="https://espresso.codeforces.com/c9bf2c6663342bfd7b533a049ca2ba27b9f4b4df.png" style="max-width: 100.0%;max-height: 100.0%;"/></p>     <p>Черные вершины выделены жирным.</p>     <p>Во втором тестовом примере лучшими поддеревьями для вершин $$$2,       3$$$ и $$$4$$$ являются вершины $$$2, 3$$$ и $$$4$$$       соответственно. И лучшим поддеревом для вершины $$$1$$$ является       поддерево, состоящее из вершин $$$1$$$ и $$$3$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1324/problem/F' title='Codeforces Round 627 (Div. 3)'>1324F - Maximum White Subtree</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>This problem is about the &quot;rerooting&quot; technique.       Firstly, let's calculate the answer for some fixed root. How can       we do this? Let $$$dp_v$$$ be the maximum possible difference       between the number of white and black vertices in some subtree of       $$$v$$$ (yes, the subtree of the rooted tree, i.e. $$$v$$$ and all       its direct and indirect children) that <span class="tex-font-style-bf">contains</span> the vertex $$$v$$$. We       can calculate this dynamic programming by simple dfs, for the       vertex $$$v$$$ it will look like this: $$$dp_v = a_v +       \sum\limits_{to \in children(v)} max(0, dp_{to})$$$.</p>     <p>Okay, we can store the answer for the root somewhere. What's       next? Let's try to change the root from the vertex $$$v$$$ to some       adjacent to it vertex $$$to$$$. Which states of dynamic       programming will change? Only $$$dp_v$$$ and $$$dp_{to}$$$.       Firstly, we need to &quot;remove&quot; the child $$$to$$$ from the       subtree of the vertex $$$v$$$: $$$dp_v = dp_v - max(0,       dp_{to})$$$. Then we need to &quot;attach&quot; the vertex $$$v$$$       and make it a child of the vertex $$$to$$$: $$$dp_{to} = dp_{to} +       max(0, dp_v)$$$. Then we need to run this process recursively from       $$$to$$$ (store the answer, reroot the tree and so on) and when it       ends we need to &quot;rollback&quot; our changes. Now $$$v$$$ is       the root again and we can try the next child of $$$v$$$ as the root.</p>     <p>Time complexity: $$$O(n)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

vector&lt;int&gt; a;
vector&lt;int&gt; dp;
vector&lt;int&gt; ans;
vector&lt;vector&lt;int&gt;&gt; g;

void dfs(int v, int p = -1) {
	dp[v] = a[v];
	for (auto to : g[v]) {
		if (to == p) continue;
		dfs(to, v);
		dp[v] += max(dp[to], 0);
	}
}

void dfs2(int v, int p = -1) {
	ans[v] = dp[v];
	for (auto to : g[v]) {
		if (to == p) continue;
		dp[v] -= max(0, dp[to]);
		dp[to] += max(0, dp[v]);
		dfs2(to, v);
		dp[to] -= max(0, dp[v]);
		dp[v] += max(0, dp[to]);
	}
}

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
	
	int n;
	cin &gt;&gt; n;
	a = dp = ans = vector&lt;int&gt;(n);
	g = vector&lt;vector&lt;int&gt;&gt;(n);
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; a[i];
		if (a[i] == 0) a[i] = -1;
	}
	for (int i = 0; i &lt; n - 1; ++i) {
		int x, y;
		cin &gt;&gt; x &gt;&gt; y;
		--x, --y;
		g[x].push_back(y);
		g[y].push_back(x);
	}
	
	dfs(0);
	dfs2(0);
	for (auto it : ans) cout &lt;&lt; it &lt;&lt; &#34; &#34;;
	cout &lt;&lt; endl;
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #628 (Div. 2)
    1325A
    ЕхАб И нОд </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. ЕхАб И нОд</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам дано целое положительное число $$$x$$$. Найдите <span class="tex-font-style-bf">любые</span> такие два $$$2$$$ целые       положительные числа $$$a$$$ и $$$b$$$, для которых $$$НОД(a,b)+НОК(a,b)=x$$$.</p>     <p>Напомним, что $$$НОД(a,b)$$$  — это наибольшее целое число, на       которое делятся и $$$a$$$ и $$$b$$$. Аналогично, $$$НОК(a,b)$$$ -       это наименьшее целое число, которое делится и на $$$a$$$ и на $$$b$$$.</p>     <p>Гарантируется, что решение всегда существует. Если существует       несколько таких пар $$$(a, b)$$$, вы можете вывести любую из них.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит одно целое число $$$t$$$ $$$(1 \le t \le       100)$$$  — количество наборов тестовых данных.</p>     <p>Каждый набор тестовых данных состоит из одной строки, содержащей       одно целое число, $$$x$$$ $$$(2 \le x \le 10^9)$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных, выведите пару целых       положительных чисел $$$a$$$ и $$$b$$$ ($$$1 \le a, b \le 10^9)$$$       таких, что $$$НОД(a,b)+НОК(a,b)=x$$$. Гарантируется, что решение       всегда существует. Если существует несколько таких пар $$$(a,       b)$$$, вы можете вывести любую из них.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
2
14
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1 1
6 4
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе тестовых данных примера, $$$НОД(1,1)+НОК(1,1)=1+1=2$$$.</p>     <p>Во втором наборе тестовых данных примера, $$$НОД(6,4)+НОК(6,4)=2+12=14$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #628 (Div. 2)
    1325B
    КопияКопияКопияКопияКопия </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. КопияКопияКопияКопияКопия</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У Ехаба есть массив $$$a$$$ длины $$$n$$$. У него достаточно       свободного времени, чтобы создать новый массив, состоящий из       $$$n$$$ копий старого массива, записанных последовательно. Чему       равна длина самой длинной возрастающей подпоследовательности       нового массива?</p>     <p>Последовательность $$$a$$$ является подпоследовательностью       массива $$$b$$$, если $$$a$$$ можно получить из $$$b$$$, удалив       несколько (возможно, ноль или все) элементов. Самая длинная       возрастающая подпоследовательность массива это самая длинная       подпоследовательность, все элементы которой упорядочены в строго       возрастающем порядке.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит целое число $$$t$$$   — количество наборов       входных данных. Далее следуют описания наборов входных данных.</p>     <p>Первая строка описания каждого набора входных данных содержит       одно целое число $$$n$$$ ($$$1 \le n \le 10^5$$$)   — количество       элементов в массиве $$$a$$$.</p>     <p>Вторая строка содержит $$$n$$$ целых чисел, разделенных пробелом       $$$a_1$$$, $$$a_2$$$, $$$\ldots$$$, $$$a_{n}$$$ ($$$1 \le a_i \le       10^9$$$)   — элементы массив $$$a$$$.</p>     <p>       <span class="tex-font-style-bf">Сумма $$$n$$$ по всем наборам         входных данных не превышает $$$10^5$$$.</span></p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных, выведите длину самой длинной       возрастающей подпоследовательности $$$a$$$, если вы объедините ее       с собой $$$n$$$ раз.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
3
3 2 1
6
3 1 4 1 5 9
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
5
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных примера, новый массив равен       $$$[3,2,\textbf{1},3,\textbf{2},1,\textbf{3},2,1]$$$. Самая       длинная возрастающая подпоследовательность в нем выделена жирным.</p>     <p>Во втором наборе входных данных примера, самая длинная       возрастающая подпоследовательность равна $$$[1,3,4,5,9]$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #628 (Div. 2)
    1325C
    Ехаб и неПутевые MEXы </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Ехаб и неПутевые MEXы</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам дано дерево, состоящее из $$$n$$$ вершин. Вы хотите написать       какие-то числа на ребрах дерева, чтобы выполнялись следующие условия:</p>          <ul> <li> Каждое написанное число является целым числом от $$$0$$$         до $$$n-2$$$ включительно. </li>       <li> Все написанные числа различны. </li>       <li> Наибольшее значение среди $$$MEX(u,v)$$$ среди всех пар         вершин $$$(u,v)$$$ минимально возможно. </li></ul>          <p>Здесь $$$MEX(u,v)$$$ обозначает наименьшее неотрицательное целое       число, которое не записано ни на одном ребре уникального простого       пути между вершинами $$$u$$$ и $$$v$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано целое число $$$n$$$ ($$$2 \le n \le       10^5$$$)   — количество узлов в дереве.</p>     <p>Каждая из следующих $$$n-1$$$ строк содержит два разделенных       пробелом целых числа $$$u$$$ и $$$v$$$ ($$$1 \le u,v \le n$$$),       которые означают, что между узлами $$$u$$$ и $$$v$$$ есть ребро.       Гарантируется, что данный граф является деревом.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$n-1$$$ целых чисел. $$$i$$$-е из них должно быть       равно числу, записанным на $$$i$$$-м ребре (в порядке ввода).</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
1 2
1 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
1
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
1 2
1 3
2 4
2 5
5 6
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
3
2
4
1</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Дерево с второго примера:</p>     <p>       <img class="tex-graphics" src="https://espresso.codeforces.com/f6df68c6c5c1b08e10c2945c8cd69295d2273c9d.png" style="max-width: 100.0%;max-height: 100.0%;"/></p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #628 (Div. 2)
    1325D
    Ехаб, XORминатор </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Ехаб, XORминатор</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Для данных 2 чисел $$$u$$$ и $$$v$$$, найдите самые короткий       массив такой, что <a href="https://ru.wikipedia.org/wiki/Битовая_операция#Исключающее_ИЛИ">побитовое         исключающее ИЛИ</a> его элементов равно $$$u$$$, а сумма его       элементов равна $$$v$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Единственная строка содержит 2 целых числа $$$u$$$ и $$$v$$$       $$$(0 \le u,v \le 10^{18})$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Если нет массива, удовлетворяющего условию, выведите "-1       ". В противном случае:</p>     <p>Первая строка должна содержать одно целое число, $$$n$$$, равное       длине нужного массива. Следующая строка должна содержать $$$n$$$         <span class="tex-font-style-bf">положительных</span> целых       чисел, сам массив. Если есть несколько возможных ответов, выведите любой.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
3 1</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
1 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
1 1 1</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
8 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
-1</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
0 0
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере, $$$3\oplus 1 = 2$$$ and $$$3 + 1 = 4$$$.       Заметьте, что подходящего массива меньшей длины не существует. </p>     <p>Обратите внимание, что в четвертом примере массив пуст.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #628 (Div. 2)
    1325E
    НАСТОЯЩАЯ Теория чисел от Ехаба </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. НАСТОЯЩАЯ Теория чисел от Ехаба</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>3 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам дан массив $$$a$$$ длины $$$n$$$, который имеет специальное       условие: каждый элемент в этом массиве имеет не более 7 делителей.       Найдите длину кратчайшей непустой подпоследовательности этого       массива, произведение элементов которой является полным квадратом.</p>     <p>Последовательность $$$a$$$ является подпоследовательностью       массива $$$b$$$, если $$$a$$$ можно получить из $$$b$$$, удалив       несколько (возможно, ноль или все) элементов.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит единственное целое число $$$n$$$ ($$$1 \le       n \le 10^5$$$) — длину массива $$$a$$$.</p>     <p>Вторая строка содержит $$$n$$$ целых чисел $$$a_1$$$, $$$a_2$$$,       $$$\ldots$$$, $$$a_{n}$$$ ($$$1 \le a_i \le 10^6$$$) — элементы       массива $$$a$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите длину кратчайшей непустой подпоследовательности $$$a$$$,       произведение элементов которой является полным квадратом. Если       существует несколько таких кратчайших подпоследовательностей, вы       можете найти любую из них. Если такой подпоследовательности нет,       выведите «-1».</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
1 4 6
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
2 3 6 6
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
6 15 10
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
2 3 5 7
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
-1</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере, вы можете выбрать подпоследовательность $$$[1]$$$.</p>     <p>Во втором примере, вы можете выбрать подпоследовательность $$$[6, 6]$$$.</p>     <p>В третьем примере, вы можете выбрать подпоследовательность $$$[6,       15, 10]$$$.</p>     <p>В четвертом примере, такой подпоследовательности не существует.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #628 (Div. 2)
    1325F
    Последняя теорема Ехаба </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Последняя теорема Ехаба</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Идет 5555-й год. У вас есть граф, и вы хотите найти длинный цикл       и огромный независимый набор просто потому, что можете. Но пока       что вы хотите найти хоть одно из двух.</p>     <p>Для связного графа с $$$n$$$ вершинами вы можете или:</p>          <ul> <li> найти независимое множество с <span class="tex-font-style-bf">ровно</span>         $$$\lceil\sqrt{n}\rceil$$$ вершинами.         </li>       <li> найти <span class="tex-font-style-bf">простой</span> цикл         длиной <span class="tex-font-style-bf">не менее</span>         $$$\lceil\sqrt{n}\rceil$$$. </li></ul>          <p>Независимое множество  — это множество вершин такое, что никакие       две вершины из него не связаны ребром. Простой цикл  — это цикл,       который не содержит ни одной вершины дважды. Гарантировано, что вы       всегда можете решить хотя бы одну из этих задач.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит два целых числа $$$n$$$ и $$$m$$$ ($$$5       \le n \le 10^5$$$, $$$n-1 \le m \le 2 \cdot 10^5$$$)  — количество       вершин и ребер в графе.</p>     <p>Каждая из следующих $$$m$$$ строк содержит два разделенных       пробелом целых числа $$$u$$$ и $$$v$$$ ($$$1 \le u,v \le n$$$),       которые означают, что между вершинами $$$u$$$ и $$$v$$$ есть       ребро. Гарантируется, что граф связен и не содержит никаких петель       или двойных ребер.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Если вы решили решить первую задачу, то в первой строке выведите         <span class="tex-font-style-tt">1</span>, а затем строку,       содержащую $$$\lceil\sqrt{n}\rceil$$$ различных целых чисел, не       превышающих $$$n$$$, вершины в желаемом независимом наборе.</p>     <p>Если вы решили решить вторую задачу, то в первой строке выведите         <span class="tex-font-style-tt">2</span>, затем строку,       содержащую одно целое число $$$c$$$, представляющее длину       найденного цикла, за которой следует строка, содержащая $$$c$$$       различных целых чисел, не превышающих $$$n$$$  — вершины в нужном       цикле, <span class="tex-font-style-bf">в порядке, в котором они         идут в цикле</span>.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6 6
1 3
3 4
4 2
2 6
5 6
5 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
1 6 4</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
6 8
1 3
3 4
4 2
2 6
5 6
5 1
1 4
2 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
4
1 5 2 4</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5 4
1 2
1 3
2 4
2 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
3 4 5 </pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере:</p>     <p>       <img class="tex-graphics" src="https://espresso.codeforces.com/64cdb4f94713ef3f85fed23b45e96ac7b168ce63.png" style="max-width: 100.0%;max-height: 100.0%;"/></p>     <p>Обратите внимание, что вы можете решить обе задачи, поэтому вывод       цикла $$$2-4-3-1-5-6$$$ также является решением.</p>     <p>Во втором примере:</p>     <p>       <img class="tex-graphics" src="https://espresso.codeforces.com/198f1db2cc5176e2707516b52a98b61dcc5462cc.png" style="max-width: 100.0%;max-height: 100.0%;"/></p>     <p>Обратите внимание, что если есть несколько ответов, вы можете       вывести любой, поэтому, например, вывод цикла $$$2-5-6$$$ разрешен.</p>     <p>В третьем примере:</p>     <p>       <img class="tex-graphics" src="https://espresso.codeforces.com/b58d7aaccc6d23d08528b3ce4f40f4e8bca8e13e.png" style="max-width: 100.0%;max-height: 100.0%;"/></p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        

        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 84 (рейтинговый для Див. 2)
    1327A
    Сумма нечетных чисел </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Сумма нечетных чисел</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам задано два целых числа $$$n$$$ и $$$k$$$. Ваша задача —       определить, можно ли представить $$$n$$$ в виде суммы $$$k$$$         <span class="tex-font-style-bf">различных положительных       нечетных</span> (не делящихся на $$$2$$$) целых чисел.</p>     <p>Вам необходимо ответить на $$$t$$$ независимых наборов тестовых данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка входных данных содержит одно целое число $$$t$$$       ($$$1 \le t \le 10^5$$$) — количество наборов тестовых данных.</p>     <p>Следующие $$$t$$$ строк описывают наборы тестовых данных.       Единственная строка набора тестовых данных содержит два целых       числа $$$n$$$ и $$$k$$$ ($$$1 \le n, k \le 10^7$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите ответ на каждый набор тестовых данных — «<span class="tex-font-style-tt">YES</span>» (без кавычек), если $$$n$$$       можно представить в виде суммы $$$k$$$ <span class="tex-font-style-bf">различных положительных       нечетных</span> (не делящихся на $$$2$$$) целых чисел, и «<span class="tex-font-style-tt">NO</span>» в противном случае.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
3 1
4 2
10 3
10 2
16 4
16 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
YES
YES
NO
YES
YES
NO
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе тестовых данных вы можете представить $$$3$$$ как $$$3$$$.</p>     <p>Во втором наборе тестовых данных единственным способом       представить $$$4$$$ является $$$1+3$$$.</p>     <p>В третьем наборе тестовых данных вы не можете представить       $$$10$$$ в виде суммы трех различных положительных нечетных целых чисел.</p>     <p>В четвертом наборе тестовых данных вы можете представить $$$10$$$       как, например, $$$3+7$$$.</p>     <p>В пятом наборе тестовых данных вы можете представить $$$16$$$ как $$$1+3+5+7$$$.</p>     <p>В шестом наборе тестовых данных вы не можете представить $$$16$$$       в виде суммы пяти различных положительных нечетных целых чисел.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1327/problem/A' title='Educational Codeforces Round 84 (Rated for Div. 2)'>1327A - Sum of Odd Integers</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>First of all, notice that the sum of the first $$$k$$$ odd       integers is $$$k^2$$$. If $$$k^2 &gt; n$$$ then the answer       obviously &quot;<span class="tex-font-style-tt">NO</span>&quot;.       And if $$$n \% 2 \ne k \% 2$$$ then the answer is &quot;<span class="tex-font-style-tt">NO</span>&quot; also ($$$\%$$$ is modulo       operation). Otherwise, the answer is always &quot;<span class="tex-font-style-tt">YES</span>&quot; and it seems like this:       $$$[1, 3, 5, \dots, 2(k-1)-1, rem]$$$, where $$$rem = n -       \sum\limits_{i=1}^{k-1} (2i-1)$$$. It is obviously greater than       $$$2(k-1)-1$$$ because $$$k^2 \le n$$$ and it is obviously odd       because the parity of $$$n$$$ and $$$k$$$ is the same.</p></div></div></div>

           
            <pre><code>for i in range(int(input())):
    n, k = map(int, input().split())
    print(&#39;YES&#39; if k * k &lt;= n and n % 2 == k % 2 else &#39;NO&#39;)
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 84 (рейтинговый для Див. 2)
    1327B
    Принцессы и принцы </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Принцессы и принцы</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У короля Берляндии Поликарпа LXXXIV есть $$$n$$$ дочерей. Чтобы       показать свою власть соседним королевствам, он хочет выдать своих       дочерей замуж за принцев этих королевств. По счастливой       случайности других королевств так же $$$n$$$.</p>     <p>Поликарп LXXXIV занумеровал своих дочерей от $$$1$$$ до $$$n$$$ и       королевства от $$$1$$$ до $$$n$$$. Дальше для каждой дочери он       собрал списки королевств, за принцев которых она хочет выйти замуж.</p>     <p>Поликарп LXXXIV — очень занятой правитель, поэтому он просто       жадно находит пару своим дочерям одну за другой.</p>     <p>Для первой дочери он выбирает <span class="tex-font-style-bf">королевство с наименьшим номером из ее       списка</span> и выдает дочь за их принца. Для второй дочери он       выбирает <span class="tex-font-style-bf">королевство с наименьшим         номером из ее списка, принц которой еще не женат</span>. Если       нет неженатых принцев в списке, то дочь не выходит замуж ни за       кого, а Поликарп LXXXIV переходит к следующей дочери. Процесс       заканчивается после $$$n$$$-й дочери.</p>     <p>Например, пусть будет $$$4$$$ дочери и королевства, списки       дочерей: $$$[2, 3]$$$, $$$[1, 2]$$$, $$$[3, 4]$$$, $$$[3]$$$, соответственно.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/7d068fb670cc0ee02169fa666a0b4121fa7feb9a.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>В данном случае дочь $$$1$$$ выходит замуж за принца королевства       $$$2$$$, дочь $$$2$$$ выходит замуж за принца королевства $$$1$$$,       дочь $$$3$$$ выходит замуж за принца королевства $$$3$$$, оставляя       дочь $$$4$$$ без возможности выйти замуж за кого-либо.</p>     <p>На самом деле, до начала всех женитьб у Поликарпа LXXXIV есть       время убедить одну из своих дочерей, что за принца какого-либо       королевства тоже можно выйти замуж. Фактически, это значит, что он       может добавить ровно одно королевство в список ровно одной из       своих дочерей. <span class="tex-font-style-bf">Обратите внимание,         что данное королевство не должно содержаться в списке данной дочери.</span></p>     <p>Поликарп LXXXIV хочет увеличить количество женатых пар.</p>     <p>К сожалению, на что у него нет времени, так это на нахождение       записи, которую стоит добавить. Если не существует способа       увеличить количество женатых пар, то сообщите, что женитьбы уже       оптимальны. Иначе найдите такую запись, после добавления которой       итоговое количество женатых пар увеличится.</p>     <p>Если существует несколько способов добавить одну запись так, что       количество женатых пар увеличится, то выведите любой из них.</p>     <p>Для вашего и нашего удобства мы просим вас ответить на $$$t$$$       независимых наборов тестовых данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$t$$$ ($$$1 \le t \le       10^5$$$) — количество наборов тестовых данных.</p>     <p>Затем следуют $$$t$$$ наборов тестовых данных.</p>     <p>В первой строке каждого набора записано одно целое число $$$n$$$       ($$$1 \le n \le 10^5$$$) — количество дочерей и количество королевств.</p>     <p>В каждой из следующих $$$n$$$ строк дано описание списка каждой       дочери. Первое целое число $$$k$$$ ($$$0 \le k \le n$$$) — это       количество записей в списке $$$i$$$-й дочери. Затем следуют       $$$k$$$ различных чисел $$$g_i[1], g_i[2], \dots, g_i[k]$$$ ($$$1       \le g_i[j] \le n$$$) — номера королевств в списке <span class="tex-font-style-bf">в возрастающем порядке</span>       ($$$g_i[1] &lt; g_i[2] &lt; \dots &lt; g_i[k]$$$).</p>     <p>Гарантируется, что суммарное количество дочерей по всем наборам       тестовых данных не превосходит $$$10^5$$$.</p>     <p>Также гарантируется, что суммарное количество королевств в       списках по всем наборам тестовых данных не превосходит $$$10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите ответ на каждый тест.</p>     <p>Выведите «<span class="tex-font-style-tt">IMPROVE</span>» в       первой строке, если Поликарп LXXXIV может добавить одно       королевство в список одной из его дочерей так, чтобы итоговое       количество женатых пар увеличилось. Во второй строке выведите два       целых числа — номер дочери и номер королевства, которое Поликарп       LXXXIV должен добавить в список данной дочери.</p>     <p>Если существует несколько способов добавить одну запись так, что       количество женатых пар увеличится, то выведите любой из них.</p>     <p>В противном случае выведите одно слово «<span class="tex-font-style-tt">OPTIMAL</span>».</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
4
2 2 3
2 1 2
2 3 4
1 3
2
0
0
3
3 1 2 3
3 1 2 3
3 1 2 3
1
1 1
4
1 1
1 2
1 3
1 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
IMPROVE
4 4
IMPROVE
1 1
OPTIMAL
OPTIMAL
OPTIMAL
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Первый набор входных данных изображен на картинке в условии.       Добавление четвертого королевства в список четвертой дочери       позволит ей выйти замуж за принца четвертого королевства.</p>     <p>Во втором наборе входных данных любая новая запись увеличит       количество женатых пар с $$$0$$$ до $$$1$$$.</p>     <p>В третьем и четвертом наборах входных данных не существует       способа добавить запись.</p>     <p>В пятом наборе входных данных не существует способа изменить       количество женитьб добавлением новой записи.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1327/problem/B' title='Educational Codeforces Round 84 (Rated for Div. 2)'>1327B - Princesses and Princes</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Simulate the process without adding the new entry. For this you       can just maintain an array $$$taken$$$, $$$i$$$-th value of which       is true if the $$$i$$$-th prince is married and false otherwise.</p>     <p>Now observe that there are two possible outcomes: </p>     <ol> <li> Every daughter is married — the answer is optimal. </li>       <li> There is a daughter who isn't married. That means that there         is a free prince as well. Marry them to each other because doing         that won't affect any other marriages and add a new one to the         answer. </li></ol>          <p>Overall complexity: $$$O(n + m)$$$.</p></div></div></div>

           
            <pre><code>from sys import stdin, stdout

t = int(stdin.readline())
for _ in range(t):
    n = int(stdin.readline())
    used = [False for i in range(n)]
    v = -1
    for i in range(n):
        l = [int(x) - 1 for x in stdin.readline().split()][1:]
        for j in l:
            if not used[j]:
                used[j] = True
                break
        else:
            v = i
    if v == -1:
        stdout.write(&#34;OPTIMAL\n&#34;)
    else:
        u = used.index(False)
        stdout.write(&#34;IMPROVE\n&#34; + str(v + 1) + &#34; &#34; + str(u + 1) + &#34;\n&#34;)
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 84 (рейтинговый для Див. 2)
    1327C
    Игра с фишками </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Игра с фишками</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У Пети есть прямоугольная доска размера $$$n \times m$$$.       Изначально на доске размещено $$$k$$$ фишек, $$$i$$$-я из них       находится в клетке, на пересечении $$$sx_i$$$-й строки и       $$$sy_i$$$-го столбца.</p>     <p>За одно действие Петя может сдвинуть <span class="tex-font-style-bf">все фишки</span> влево, вправо, вниз       или вверх на $$$1$$$ ячейку.</p>     <p>Если фишка была в клетке $$$(x, y)$$$, то после операции: </p>     <ul> <li> влево, ее координаты будут $$$(x, y - 1)$$$; </li>       <li> вправо, ее координаты будут $$$(x, y + 1)$$$; </li>       <li> вниз, ее координаты будут $$$(x + 1, y)$$$; </li>       <li> вверх, ее координаты будут $$$(x - 1, y)$$$. </li></ul>          <p>Если фишка находится у стенки доски, и действие, выбранное Петей,       двигает ее в направлении стены, то фишка остается на своей текущей       позиции. </p>     <p>       <span class="tex-font-style-bf">Обратите внимание, что несколько         фишек могут располагаться в одной и той же клетке.</span></p>     <p>Для каждой фишки Петя выбрал позицию, в которой она должна       побывать. Обратите внимание, что фишка не обязательно заканчивает       в этой позиции.</p>     <p>Так как у Пети не очень много свободного времени, он готов       сделать не более $$$2nm$$$ действий, описанных выше.</p>     <p>Вам предстоит выяснить, какие действия должен делать Петя, чтобы       все фишки побывали хотя бы раз в выбранных для них клетках. Или       определить, что за $$$2nm$$$ действий выполнить это невозможно.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит три целых числа $$$n, m, k$$$ ($$$1 \le n,       m, k \le 200$$$) — количество строк и столбцов доски и количество       фишек соответственно.</p>     <p>Следующие $$$k$$$ содержат по два целых чисел $$$sx_i, sy_i$$$       ($$$ 1 \le sx_i \le n, 1 \le sy_i \le m$$$) — начальная позиция       $$$i$$$-й фишки.</p>     <p>Следующие $$$k$$$ содержат по два целых чисел $$$fx_i, fy_i$$$       ($$$ 1 \le fx_i \le n, 1 \le fy_i \le m$$$) — позиция, которую       должна посетить $$$i$$$-я фишка хотя бы раз.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>В первой строке выведите количество операций, чтобы каждая фишка       посетила хотя бы раз позицию, которую выбрал для нее Петя.</p>     <p>Во второй строке выведите последовательность операций. Для       обозначения операций влево, вправо, вниз, вверх используйте       символы $$$L, R, D, U$$$ соответственно.</p>     <p>Если искомой последовательности не существует, в единственной       строке выведите <span class="tex-font-style-tt">-1</span>.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3 3 2
1 2
2 1
3 3
3 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
DRD</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5 4 3
3 4
3 1
3 3
5 3
1 3
1 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
9
DDLUUUURR</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1327/problem/C' title='Educational Codeforces Round 84 (Rated for Div. 2)'>1327C - Game with Chips</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Note that $$$2nm$$$ is a fairly large number of operations.       Therefore, we can first collect all the chips in one cell, and       then go around the entire board.</p>     <p>Let's calculate the required number of operations.</p>     <p>First, let's collect all the chips in the $$$(1, 1)$$$ cell. To       do this, let's do $$$n-1$$$ operations $$$U$$$ so that all the       chips are in the first row, then do $$$m-1$$$ operations $$$L$$$.       After such operations, wherever the chip is initially located, it       will end up in the $$$(1, 1)$$$ cell.</p>     <p>After that, we need to go around the entire board. Let's do it in       such a way that the rows with odd numbers are be bypassed from       left to right, and the even ones — from right to left. We also       need $$$n-1$$$ operations $$$D$$$ to move from one row to the next one.</p>     <p>In total, we got $$$(n-1) + (m-1) + n * (m-1) + (n-1) = nm + n +       m - 3$$$ operations, which is completely suitable for us.</p></div></div></div>

           
            <pre><code>n, m, _ = map(int, input().split())

print(2 * (n - 1) + (n + 1) * (m - 1))
print(&#34;U&#34; * (n - 1) + &#34;L&#34; * (m - 1), end=&#34;&#34;)
for i in range(n):
    if i != 0:
        print(&#34;D&#34;, end=&#34;&#34;)
    if i % 2 == 0:
        print(&#34;R&#34; * (m - 1), end=&#34;&#34;)
    else:
        print(&#34;L&#34; * (m - 1), end=&#34;&#34;)
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 84 (рейтинговый для Див. 2)
    1327D
    Бесконечный путь </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Бесконечный путь</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам задана цветная перестановка $$$p_1, p_2, \dots, p_n$$$, то       есть $$$i$$$-й элемент перестановки имеет цвет $$$c_i$$$.</p>     <p>Назовем <span class="tex-font-style-it">бесконечным путем</span>       последовательность $$$i, p[i], p[p[i]], p[p[p[i]]] \dots$$$, в       которой все элементы <span class="tex-font-style-bf">одного       цвета</span> ($$$c[i] = c[p[i]] = c[p[p[i]]] = \dots$$$).</p>     <p>Мы также можем определить умножение перестановок $$$a$$$ и       $$$b$$$, как перестановку $$$c = a \times b$$$, в которой $$$c[i]       = b[a[i]]$$$. Более того, можно определить степень $$$k$$$       перестановки $$$p$$$, как $$$p^k=\underbrace{p \times p \times       \dots \times p}_{k \text{ times}}$$$.</p>     <p>Найдите такое минимальное $$$k &gt; 0$$$, что $$$p^k$$$ содержит       хотя бы один бесконечный путь (т.е. существует позиция $$$i$$$ в       $$$p^k$$$, такая, что последовательность, начинающаяся с $$$i$$$       является бесконечным путем).</p>     <p>Можно доказать, что ответ всегда существует.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке задано единственное число $$$T$$$ ($$$1 \le T \le       10^4$$$) — количество наборов входных данных.</p>     <p>Следующие $$$3T$$$ строк содержат сами наборы — по одному на три       строки. В первой строке задано единственное целое число $$$n$$$       ($$$1 \le n \le 2 \cdot 10^5$$$) — размер перестановки.</p>     <p>Во второй строке задано $$$n$$$ целых чисел $$$p_1, p_2, \dots,       p_n$$$ ($$$1 \le p_i \le n$$$, $$$p_i \neq p_j$$$ при $$$i \neq       j$$$) — перестановка $$$p$$$.</p>     <p>В третьей строке задано $$$n$$$ целых чисел $$$c_1, c_2, \dots,       c_n$$$ ($$$1 \le c_i \le n$$$) — цвета соответствующих элементов перестановки.</p>     <p>Гарантируется, что сумма $$$n$$$ не превосходит $$$2 \cdot 10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$T$$$ целых чисел — по одному на набор входных данных.       Для каждого набора выведите минимальное $$$k &gt; 0$$$ такое, что       $$$p^k$$$ содержит хотя бы один бесконечный путь.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
4
1 3 4 2
1 2 2 3
5
2 3 4 5 1
1 2 3 4 5
8
7 4 5 6 1 8 3 2
5 3 6 4 7 5 8 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
5
2
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе, $$$p^1 = p = [1, 3, 4, 2]$$$ и       последовательность, стартующая с $$$1$$$: $$$1, p[1] = 1, \dots$$$       — бесконечный путь.</p>     <p>Во втором наборе, $$$p^5 = [1, 2, 3, 4, 5]$$$ и, очевидно, она       содержит несколько бесконечных путей.</p>     <p>В третьем наборе, $$$p^2 = [3, 6, 1, 8, 7, 2, 5, 4]$$$ и       последовательность, стартующая с $$$4$$$: $$$4, p^2[4]=8,       p^2[8]=4, \dots$$$ — бесконечный путь, так как $$$c_4 = c_8 = 4$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1327/problem/D' title='Educational Codeforces Round 84 (Rated for Div. 2)'>1327D - Infinite Path</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's look at the permutation as at a graph with $$$n$$$ vertices       and edges $$$(i, p_i)$$$. It's not hard to prove that the graph       consists of several cycles (self-loops are also considered as       cycles). So, the sequence $$$i, p[i], p[p[i]], \dots$$$ is just a       walking on the corresponding cycle.</p>     <p>Let's consider one cycle $$$c_1, c_2, \dots, c_m$$$. In       permutation $$$p$$$ we have $$$p[c_i] = c_{(i + 1) \mod m}$$$. But       since $$$p^2 = p \times p$$$ or $$$p^2[i] = p[p[i]]$$$, so       $$$p^2[c_i] = c_{(i + 2) \mod m}$$$ and in general case,       $$$p^k[c_i] = c_{(i + k) \mod m}$$$.</p>     <p>Now, walking with step $$$k$$$ we can note, that the initial       cycle $$$c$$$ split up on $$$GCD(k, m)$$$ cycles of length       $$$\frac{m}{GCD(k, m)}$$$. Looking at the definition of infinite       path we can understand that all we need to do is to check that at       least one of $$$GCD(k, m)$$$ cycles have all vertices of the same       color. We can check it in $$$O(m)$$$ time for the cycle $$$c$$$       and fixed $$$k$$$.</p>     <p>The final observation is next: for $$$k_1$$$ and $$$k_2$$$ such       that $$$GCD(k_1, m) = GCD(k_2, m)$$$ the produced cycles will have       the same sets of vertices and differ only in the order of walking,       so we can check only one representative for each $$$GCD(k, m)$$$,       i.e. we can take only such $$$k$$$ which divide $$$m$$$.</p>     <p>We can handle each cycle of $$$p$$$ separately. So, using the       approximation that the number of divisors of $$$n$$$ is       $$$O(n^{\frac{1}{3}})$$$, we get $$$O(n^{\frac{4}{3}})$$$ time complexity.</p></div></div></div>

           
            <pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;

#define fore(i, l, r) for(int i = int(l); i &lt; int(r); i++)
#define sz(a) int((a).size())

#define x first
#define y second

typedef long long li;
typedef pair&lt;int, int&gt; pt;

const int INF = int(1e9);
const li INF64 = li(1e18);

int n;
vector&lt;int&gt; p, c;

inline bool read() {
    if(!(cin &gt;&gt; n))
        return false;
    p.resize(n);
    c.resize(n);
    
    fore(i, 0, n) {
        cin &gt;&gt; p[i];
        p[i]--;
    }
    fore(i, 0, n)
        cin &gt;&gt; c[i];
    return true;
}

inline void solve() {
    vector&lt;int&gt; used(n, 0);
    
    int ans = INF;
    fore(st, 0, n) {
        if(used[st])
            continue;
        
        vector&lt;int&gt; cycle;
        int v = st;
        while(!used[v]) {
            used[v] = 1;
            cycle.push_back(v);
            v = p[v];
        }
        
        fore(step, 1, sz(cycle) + 1) {
            if(sz(cycle) % step != 0)
                continue;
            
            fore(s, 0, step) {
                bool eq = true;
                for(int pos = s; pos + step &lt; sz(cycle); pos += step) {
                    if(c[cycle[pos]] != c[cycle[pos + step]])
                        eq = false;
                }
                if(eq) {
                    ans = min(ans, step);
                    break;
                }
            }
        }
    }
    cout &lt;&lt; ans &lt;&lt; endl;
}

int main() {
#ifdef _DEBUG
    freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
    int tt = clock();
#endif
    ios_base::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cout &lt;&lt; fixed &lt;&lt; setprecision(15);
    
    int tc; cin &gt;&gt; tc;
    
    while(tc--) {
        read();
        solve();
        
#ifdef _DEBUG
        cerr &lt;&lt; &#34;TIME = &#34; &lt;&lt; clock() - tt &lt;&lt; endl;
        tt = clock();
#endif
    }
    return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 84 (рейтинговый для Див. 2)
    1327E
    Посчитайте блоки </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. Посчитайте блоки</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вы выписали все целые числа от $$$0$$$ до $$$10^n - 1$$$,       добавляя к ним ведущие нули так, чтобы их длины были равны       $$$n$$$. Например, если $$$n = 3$$$, то вы выпишете следующие       числа: <span class="tex-font-style-tt">000</span>, <span class="tex-font-style-tt">001</span>, ..., <span class="tex-font-style-tt">998</span>, <span class="tex-font-style-tt">999</span>.</p>     <p>Назовем блоком в числе $$$x$$$ последовательный отрезок       одинаковых цифр, который не может быть расширен ни влево, ни вправо.</p>     <p>Например, в числе $$$00027734000$$$ есть три блока длины $$$1$$$,       один блок длины $$$2$$$ и два блока длины $$$3$$$.</p>     <p>Для всех чисел $$$i$$$ от $$$1$$$ до $$$n$$$ посчитайте суммарное       количество блоков длины $$$i$$$ среди выписанных вами чисел.</p>     <p>Так как эти числа могут быть слишком большими, выведите их по       модулю $$$998244353$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В единственной строке содержится число $$$n$$$ ($$$1 \le n \le 2       \cdot 10^5$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>В единственной строке выведите $$$n$$$ чисел. $$$i$$$-е число       равно количеству блоков длины $$$i$$$ среди выписанных вами чисел.</p>     <p>Так как эти числа могут быть слишком большими, выведите их по       модулю $$$998244353$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
10
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
180 10
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1327/problem/E' title='Educational Codeforces Round 84 (Rated for Div. 2)'>1327E - Count The Blocks</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Presume that we want to calculate the number of blocks of length       $$$len$$$. Let's divide this blocks into two types:</p>          <ol> <li> blocks which first element is a first element of integer,         or blocks which last element is a last element of integer (for         example blocks $$$111$$$ and $$$0$$$ in integer $$$11173220$$$); </li>       <li> other blocks. </li></ol>          <p>At first let's calculate the number of blocks of first type. We       can choose $$$2$$$ positions of this block (at the start of end of       the integer). Now we can choose $$$10$$$ digit for this block.       After that we can chose $$$9$$$ digits of adjacent block (if these       blocks contain the same digit then we length of blocks which we       want calculate greater than $$$len$$$, so we have only $$$9$$$       variations of digit in adjacent block). Finally, the can chose the       remaining digit $$$10^{n-len-1}$$$ ways.</p>     <p>So, the total number of block of first type is $$$2 \cdot 10       \cdot 9 \cdot 10^{n-len-1}$$$.</p>     <p>Now let's calculate the number of blocks of second type. We can       choose $$$n - len - 1$$$ positions of this block (all position       except the start and end of integer). Now we can choose 10 digit       for this block. After that we can chose $$$9^2$$$ digits of       adjacent block ($$$9$$$ for block to the left and $$$9$$$ for       block to the right). Finally, the can chose the remaining digit       $$$10^{n−len−2}$$$ ways.</p>     <p>So, the total number of block of second type is $$$(n - len - 1)       \cdot 10 \cdot 9^2 \cdot 10^{n-len-2}$$$.</p>     <p>That's almost all. We have one corner case. If $$$len = n$$$,       then we number of blocks is always $$$10$$$.</p></div></div></div>

           
            <pre><code>MOD = 998244353
p = [1] * 200005
for i in range(1, 200005):
    p[i] = (p[i - 1] * 10) % MOD

n = int(input())
for i in range(1, n):
    res = 2 * 10 * 9 * p[n - i - 1]
    res += (n - 1 - i) * 10 * 9 * 9 * p[n - i - 2]
    print(res % MOD, end = &#39; &#39;)
print(10)
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 84 (рейтинговый для Див. 2)
    1327F
    Отрезки И </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Отрезки И</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>3 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Даны три целых числа $$$n$$$, $$$k$$$, $$$m$$$ и $$$m$$$ условий       $$$(l_1, r_1, x_1), (l_2, r_2, x_2), \dots, (l_m, r_m, x_m)$$$.</p>     <p>Посчитайте количество различных массивов $$$a$$$, состоящих из       $$$n$$$ целых чисел, таких что: </p>     <ul> <li> $$$0 \le a_i &lt; 2^k$$$ для всех $$$1 \le i \le n$$$; </li>       <li> побитовое И чисел $$$a[l_i] \&amp; a[l_i + 1] \&amp; \dots         \&amp; a[r_i] = x_i$$$ для всех $$$1 \le i \le m$$$. </li></ul>          <p>Два массива $$$a$$$ и $$$b$$$ считаются различными, если       существует такая позиция $$$i$$$, что $$$a_i \neq b_i$$$.</p>     <p>Это число может быть довольно велико, поэтому выведите его по       модулю $$$998244353$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записаны три целых числа $$$n$$$, $$$k$$$ и       $$$m$$$ ($$$1 \le n \le 5 \cdot 10^5$$$, $$$1 \le k \le 30$$$,       $$$0 \le m \le 5 \cdot 10^5$$$) — длина массива $$$a$$$, значение       такое, что все числа в массиве $$$a$$$ должны быть меньше, чем       $$$2^k$$$, и количество условий соответственно.</p>     <p>В каждой из следующих $$$m$$$ строк записано одно условие       $$$l_i$$$, $$$r_i$$$ и $$$x_i$$$ ($$$1 \le l_i \le r_i \le n$$$,       $$$0 \le x_i &lt; 2^k$$$) — границы отрезка условия и необходимое       значение побитового И на нем.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одно целое число — количество различных массивов       $$$a$$$, для которых выполняются все приведенные выше условия, по       модулю $$$998244353$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4 3 2
1 3 3
3 4 6
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5 2 3
1 3 2
2 5 0
3 3 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
33
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Можете вспомнить, что такое побитовое И по <a href="https://ru.wikipedia.org/wiki/Битовая_операция#Побитовое_И">ссылке</a>.</p>     <p>В первом примере ответом являются следующие массивы: $$$[3, 3, 7,       6]$$$, $$$[3, 7, 7, 6]$$$ и $$$[7, 3, 7, 6]$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1327/problem/F' title='Educational Codeforces Round 84 (Rated for Div. 2)'>1327F - AND Segments</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>We will solve the problem for each bit separately, and then       multiply the results.</p>     <p>Obviously, if the position is covered by a segment with the value       $$$1$$$, then we have no choice, and we must put $$$1$$$ there.       For segments with the value $$$0$$$, there must be at least one       position that they cover and its value is $$$0$$$.</p>     <p>So we can write the following dynamic programming: $$$dp_i$$$ —       the number of arrays such that the last $$$0$$$ was exactly at the       position $$$i$$$, and all $$$0$$$-segments to the left of it       contain at least one zero.</p>     <p>It remains to determine which states $$$j$$$ we can update from.       The only restriction we have is that there should not be any       segment $$$(l, r)$$$ with the value $$$0$$$, such that $$$j &lt;       l$$$ and $$$r &lt; i$$$. Since in this case, this segment will not       contain any zero values. For each position $$$i$$$, we may       precalculate the rightmost position $$$f_i$$$ where some segment       ending before $$$i$$$ begins, and while calculating $$$dp_i$$$, we       should sum up only the values starting from position $$$f_i$$$.       This can be done with prefix sums.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

#define x first
#define y second
#define sz(a) int((a).size())
#define all(a) (a).begin(), (a).end()
#define forn(i, n) for (int i = 0; i &lt; int(n); ++i)

typedef pair&lt;int, int&gt; pt;

const int MOD = 998244353;
const int N = 500 * 1000 + 13;

int n, k, m;
pair&lt;pt, int&gt; q[N];

int ones[N];
int mx[N], sum[N];

int add(int x, int y) {
    x += y;
    if (x &gt;= MOD) x -= MOD;
    if (x &lt; 0) x += MOD;
    return x;
}

int calc(int t) {
    memset(ones, 0, sizeof(ones));
    memset(mx, -1, sizeof(mx));
    
    forn(i, m) {
        int l = q[i].x.x, r = q[i].x.y;
        if (q[i].y &amp; (1 &lt;&lt; t)) {
            ones[l]++;
            ones[r + 1]--;
        } else {
            mx[r] = max(mx[r], l);
        }
    }
    
    int j = -1;
    forn(i, n) {
        int cur = 0;
        if (!ones[i]) {
            cur = sum[i];
            if (j == -1) cur = add(cur, 1);
            else cur = add(cur, -sum[j]);
        }
        
        sum[i + 1] = add(sum[i], cur);
        ones[i + 1] += ones[i];
        j = max(j, mx[i]);
    }
    
    return add(sum[n], j != -1 ? -sum[j] : 1);
}

int main() {
    scanf(&#34;%d%d%d&#34;, &amp;n, &amp;k, &amp;m);
    forn(i, m) {
        scanf(&#34;%d%d%d&#34;, &amp;q[i].x.x, &amp;q[i].x.y, &amp;q[i].y);
        --q[i].x.x; --q[i].x.y;
    }
    
    int ans = 1;
    forn(i, k) ans = (ans * 1ll * calc(i)) % MOD;
    printf(&#34;%d\n&#34;, ans);
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 84 (рейтинговый для Див. 2)
    1327G
    Буквы и знаки вопроса </h1>

    <div class="problemindexholder" problemindex="G">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">G. Буквы и знаки вопроса</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>4 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на       тест</div>1024 мегабайта</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам даны строка $$$S$$$ и массив строк $$$[t_1, t_2, \dots,       t_k]$$$. Каждая строка $$$t_i$$$ состоит из строчных латинских       букв от <span class="tex-font-style-tt">a</span> до <span class="tex-font-style-tt">n</span>; $$$S$$$ состоит из строчных       латинских букв от <span class="tex-font-style-tt">a</span> до         <span class="tex-font-style-tt">n</span> и <span class="tex-font-style-bf">не более $$$14$$$</span> знаков вопроса.</p>     <p>У каждой строки $$$t_i$$$ есть цена $$$c_i$$$ — целое число.       Стоимость некоторой строки $$$T$$$ считается как $$$\sum\limits_{i       = 1}^{k} F(T, t_i) \cdot c_i$$$, где $$$F(T, t_i)$$$ — количество       вхождений $$$t_i$$$ в $$$T$$$ в качестве подстроки. К примеру,       $$$F(\text{aaabaaa}, \text{aa}) = 4$$$.</p>     <p>Вы должны заменить все знаки вопроса в $$$S$$$ на <span class="tex-font-style-bf">попарно различные</span> строчные       латинские буквы от <span class="tex-font-style-tt">a</span> до         <span class="tex-font-style-tt">n</span> так, чтобы стоимость       $$$S$$$ была максимально возможной.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке задано одно целое число $$$k$$$ ($$$1 \le k \le       1000$$$) — количество строк в массиве $$$[t_1, t_2, \dots, t_k]$$$.</p>     <p>Затем следуют $$$k$$$ строк, каждая из которых содержит строку       $$$t_i$$$ (состоящую из строчных латинских букв от <span class="tex-font-style-tt">a</span> до <span class="tex-font-style-tt">n</span>) и целое число $$$c_i$$$ ($$$1       \le |t_i| \le 1000$$$, $$$-10^6 \le c_i \le 10^6$$$). Сумма длин       всех $$$t_i$$$ не превосходит $$$1000$$$.</p>     <p>В последней строке задана одна строка $$$S$$$ ($$$1 \le |S| \le 4       \cdot 10^5$$$) из латинских букв от <span class="tex-font-style-tt">a</span> до <span class="tex-font-style-tt">n</span> и знаков вопроса. Количество       знаков вопроса в $$$S$$$ не превосходит $$$14$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одно целое число — максимальную стоимость $$$S$$$ после       замены всех знаков вопроса на <span class="tex-font-style-bf">попарно различные</span> строчные       латинские буквы от <span class="tex-font-style-tt">a</span> до         <span class="tex-font-style-tt">n</span>.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
abc -10
a 1
b 1
c 3
?b?
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
5
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
a 1
a 1
?
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
a 1
b 3
ab 4
ab
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
8
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
1
a -1
?????????????
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
1
a -1
??????????????
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
-1
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1327/problem/G' title='Educational Codeforces Round 84 (Rated for Div. 2)'>1327G - Letters and Question Marks</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Suppose we want to calculate the value of some already fixed       string (we should be able to do so at least to solve the test       cases without question marks). How can we do it? We can use some       substring searching algorithms to calculate $$$F(S, t_i)$$$, but a       better solution is to build an Aho-Corasick automaton over the       array $$$[t_1, t_k]$$$, and then for each node calculate the sum       of costs of all strings ending in that node (these are the strings       represented by that node and the strings represented by other       nodes reachable by suffix links). After that, process $$$S$$$ by       the automaton and calculate the sum of the aforementioned values       over all states that were reached. Building an Aho-Corasick       automaton can be done in $$$O(\sum \limits_{i = 1}^{k} |t_i|)$$$,       and processing the string $$$S$$$ — in $$$O(|S|)$$$.</p>     <p>Okay, what if we've got some question marks in our string? The       first solution that comes to mind is to calculate       $$$dp[i][mask][c]$$$ — we processed $$$i$$$ first positions in       $$$S$$$, used a $$$mask$$$ of characters for question marks, and       the current state of the automaton is $$$c$$$; then       $$$dp[i][mask][c]$$$ denotes the maximum value of first $$$i$$$       characters of $$$S$$$ we could have got. But it's       $$$O(L|S|2^KK)$$$, where $$$L = \sum \limits_{i = 1}^{k} |t_i|$$$       and $$$K$$$ is the size of the alphabet, which is too slow.</p>     <p>To speed it up, we can see that there are only $$$14$$$ positions       in our string where we actually choose something in our dynamic       programming. All substrings not containing question marks can be       skipped in $$$O(1)$$$ as follows: for each substring of $$$S$$$       bounded by two question marks (or bounded by one question mark and       one of the ends of $$$S$$$) and each state of the automaton       $$$x$$$, we may precalculate the resulting state of the automaton       and the change to the value of the string, if we process this       substring by the automaton with the initial state $$$x$$$. This       precalculation is done in $$$O(L|S|)$$$ overall, and using this,       we may skip the states of dynamic programming such that $$$i$$$ is       not a position with a question mark, so our complexity becomes       $$$O(L2^KK + L|S|)$$$.</p>     <p>A note about the model solution: it's a bit more complicated       because we wanted to increase the constraints to $$$|S| \le 8       \cdot 10^6$$$, but then we decided that it would be too       complicated to code, so the main function still contains some       parts of the code that were used to improve its complexity. We       will post a clearer version of the model solution soon.</p></div></div></div>

           
            <pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;

const int N = 8000043;
const int K = 15;
const int M = 1043;

int k;
char buf[N], buf2[M];
vector&lt;string&gt; t;
vector&lt;int&gt; c;
string s;

map&lt;char, int&gt; nxt[M];
int lnk[M];
int p[M];
char pchar[M];
map&lt;char, int&gt; go[M];
int term[M];
int ts = 1;
int A[M][K];
int F[M][K];
int dp[M];

int get_nxt(int x, char c)
{
    if(!nxt[x].count(c))
    {
        p[ts] = x;
        pchar[ts] = c;
        nxt[x][c] = ts++;
    }
    return nxt[x][c];
}

void add_string(int i)
{
    int cur = 0;
    for(auto x : t[i])
    {
        cur = get_nxt(cur, x);
    }
    term[cur] += c[i];
}

int get_go(int x, char c);

int get_lnk(int x)
{
    if(lnk[x] != -1)
        return lnk[x];
    if(x == 0 || p[x] == 0)
        return lnk[x] = 0;
    return lnk[x] = get_go(get_lnk(p[x]), pchar[x]);
}

int get_dp(int x)
{
    if(dp[x] != -1)
        return dp[x];
    dp[x] = term[x];
    if(get_lnk(x) != x)
        dp[x] += get_dp(get_lnk(x));
    return dp[x];
}

int get_go(int x, char c)
{
    if(go[x].count(c))
        return go[x][c];
    if(nxt[x].count(c))
        return go[x][c] = nxt[x][c];
    if(x == 0)
        return go[x][c] = 0;
    return go[x][c] = get_go(get_lnk(x), c);
}

void build_skip(const string&amp; s, vector&lt;int&gt;&amp; sA, vector&lt;long long&gt;&amp; sF)
{                     
    sA = vector&lt;int&gt;(ts);
    for(int i = 0; i &lt; ts; i++)
        sA[i] = i;
    sF = vector&lt;long long&gt;(ts);
    for(auto c : s)
    {
        int ci = int(c - &#39;a&#39;);
        for(int i = 0; i &lt; ts; i++)
        {
            sF[i] += F[sA[i]][ci];
            sA[i] = A[sA[i]][ci];
        }
    }
}

long long solve(const string&amp; s)
{
    long long BAD = (long long)(-1e18);

    vector&lt;int&gt; pos;
    for(int i = 0; i &lt; s.size(); i++)
        if(s[i] == &#39;?&#39;)
            pos.push_back(i);
    int cntQ = pos.size();
    vector&lt;vector&lt;int&gt; &gt; skip_A(cntQ + 1);
    vector&lt;vector&lt;long long&gt; &gt; skip_F(cntQ + 1);
    build_skip(s.substr(0, pos[0]), skip_A[0], skip_F[0]);
    for(int i = 1; i &lt; cntQ; i++)
        build_skip(s.substr(pos[i - 1] + 1, pos[i] - pos[i - 1] - 1), skip_A[i], skip_F[i]);
    build_skip(s.substr(pos.back() + 1, s.size() - pos.back() - 1), skip_A[cntQ], skip_F[cntQ]);

    vector&lt;vector&lt;long long&gt; &gt; dp(1 &lt;&lt; (K - 1), vector&lt;long long&gt;(ts, BAD));
    vector&lt;int&gt; used(1 &lt;&lt; K);
    dp[0][skip_A[0][0]] = skip_F[0][0];
    queue&lt;int&gt; q;
    q.push(0);
    used[0] = 1;
    long long ans = BAD;
    while(!q.empty())
    {
        int k = q.front();
        q.pop();
        int step = __builtin_popcount(k);
        if(step == cntQ)
        {
            for(int i = 0; i &lt; ts; i++)
                ans = max(ans, dp[k][i]);
            continue;
        }
        for(int i = 0; i &lt; K - 1; i++)
        {
            if(k &amp; (1 &lt;&lt; i)) continue;
            int nk = (k ^ (1 &lt;&lt; i));
            if(used[nk] == 0)
            {
                used[nk] = 1;
                q.push(nk);
            }
            for(int j = 0; j &lt; ts; j++)
            {
                if(dp[k][j] == BAD)
                    continue;
                int nj = get_go(j, char(&#39;a&#39; + i));
                int newSt = skip_A[step + 1][nj];
                long long add = get_dp(nj) + skip_F[step + 1][nj];
                dp[nk][newSt] = max(dp[nk][newSt], dp[k][j] + add);
            }
        }
    }
    return ans;
}

int main()
{
    scanf(&#34;%d&#34;, &amp;k);
    t.resize(k);
    c.resize(k);
    for(int i = 0; i &lt; k; i++)
    {
        scanf(&#34;%s %d&#34;, buf2, &amp;c[i]);
        t[i] = buf2;
    }    
    scanf(&#34;%s&#34;, buf);
    s = buf;

    for(int i = 0; i &lt; k; i++)
        add_string(i);
    for(int i = 0; i &lt; ts; i++)
    {
        lnk[i] = -1;
        dp[i] = -1;
    }
    for(int i = 0; i &lt; ts; i++)
    {
        get_lnk(i);
        for(char c = &#39;a&#39;; c &lt;= &#39;o&#39;; c++)
            get_go(i, c);
    }
    for(int i = 0; i &lt; ts; i++)
        get_dp(i);                               
    for(int i = 0; i &lt; ts; i++)
    {
        for(int j = 0; j &lt; K; j++)
        {
            A[i][j] = get_go(i, char(&#39;a&#39; + j));
            F[i][j] = dp[A[i][j]];
        }
    }   
    int n = s.size();
    vector&lt;int&gt; leftQ(n, -1);
    vector&lt;int&gt; rightQ(n, -1);
    for(int i = 0; i &lt; n; i++)
    {
        if(i != 0)
            leftQ[i] = leftQ[i - 1];
        if(s[i] == &#39;?&#39;)
            leftQ[i] = i;
    }
    for(int i = n - 1; i &gt;= 0; i--)
    {
        if(i != n - 1)
            rightQ[i] = rightQ[i + 1];
        if(s[i] == &#39;?&#39;)
            rightQ[i] = i;
    }
    vector&lt;int&gt; bad(n, 0);
    
    if(leftQ.back() == -1)
        bad = vector&lt;int&gt;(n, 1);

    long long ans = 0;
    int curSt = 0;
    string news = &#34;&#34;;
    for(int i = 0; i &lt; n; i++)
    {
        int ci = (s[i] == &#39;?&#39; ? 14 : int(s[i] - &#39;a&#39;));
        if(bad[i])
            ans += F[curSt][ci];
        curSt = A[curSt][ci];
        if(!bad[i])
            news.push_back(s[i]);
        else if(i != 0 &amp;&amp; !bad[i - 1])
            news.push_back(&#39;o&#39;);
    }                    
    if(!news.empty())
        ans += solve(news);
    printf(&#34;%lld\n&#34;, ans);
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #629 (Div. 3)
    1328A
    Задача о делимости </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Задача о делимости</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам даны два целых положительных числа $$$a$$$ и $$$b$$$. За один       ход вы можете увеличить $$$a$$$ на $$$1$$$ (заменить $$$a$$$ на       $$$a+1$$$). Ваша задача — найти минимальное количество ходов,       которое необходимо сделать, чтобы получить значение $$$a$$$,       которое делится на $$$b$$$ без остатка. Возможно, вам придётся       сделать $$$0$$$ ходов, так как $$$a$$$ уже делится на $$$b$$$.</p>     <p>Вам нужно ответить на $$$t$$$ независимых наборов входных данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка теста содержит одно целое число $$$t$$$ ($$$1 \le t       \le 10^4$$$) — количество наборов входных данных. Затем следуют       $$$t$$$ наборов входных данных. Единственная строка каждого набора       содержит два целых числа $$$a$$$ и $$$b$$$ ($$$1 \le a, b \le 10^9$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите ответ — минимальное       количество ходов, которое нужно сделать, чтобы получить значение       $$$a$$$, которое без остатка делилось бы на $$$b$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
10 4
13 9
100 13
123 456
92 46
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
5
4
333
0
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1328/problem/A' title='Codeforces Round 629 (Div. 3)'>1328A - Divisibility Problem</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>If $$$a \% b = 0$$$ ($$$a$$$ is divisible by $$$b$$$), just print       $$$0$$$. Otherwise, we need exactly $$$b - a \% b$$$ moves to make       zero remainder of $$$a$$$ modulo $$$b$$$. $$$\%$$$ is modulo operation.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
	
	int t;
	cin &gt;&gt; t;
	while (t--) {
		int a, b;
		cin &gt;&gt; a &gt;&gt; b;
		if (a % b == 0) cout &lt;&lt; 0 &lt;&lt; endl;
		else cout &lt;&lt; b - a % b &lt;&lt; endl;
	}
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #629 (Div. 3)
    1328B
    K-я красивая строка </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. K-я красивая строка</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Для заданного целого числа $$$n$$$ ($$$n &gt; 2$$$) выпишем все       строки длины $$$n$$$, которые содержат в себе $$$n-2$$$ буквы         '<span class="tex-font-style-tt">a</span>' и две буквы '<span class="tex-font-style-tt">b</span>', в <span class="tex-font-style-bf">лексикографическом</span> (алфавитном) порядке.</p>     <p>Напомним, что строка $$$s$$$ длины $$$n$$$ лексиографически       меньше строки $$$t$$$ длины $$$n$$$, если существует такое $$$i$$$       ($$$1 \le i \le n$$$), что $$$s_i &lt; t_i$$$, а для всех $$$j$$$       ($$$1 \le j &lt; i$$$) $$$s_j = t_j$$$. Лексикографическое       сравнение строк реализовано при помощи оператора <span class="tex-font-style-tt">&lt;</span> в современных языках программирования.</p>     <p>Например, если $$$n=5$$$, то получатся следующие строки (их       порядок важен):</p>          <ol> <li> <span class="tex-font-style-tt">aaabb</span> </li>       <li> <span class="tex-font-style-tt">aabab</span> </li>       <li> <span class="tex-font-style-tt">aabba</span> </li>       <li> <span class="tex-font-style-tt">abaab</span> </li>       <li> <span class="tex-font-style-tt">ababa</span> </li>       <li> <span class="tex-font-style-tt">abbaa</span> </li>       <li> <span class="tex-font-style-tt">baaab</span> </li>       <li> <span class="tex-font-style-tt">baaba</span> </li>       <li> <span class="tex-font-style-tt">babaa</span> </li>       <li> <span class="tex-font-style-tt">bbaaa</span> </li></ol>          <p>Легко показать, что такой список строк будет содержать ровно       $$$\frac{n \cdot (n-1)}{2}$$$ строк.</p>     <p>Вам задано $$$n$$$ ($$$n &gt; 2$$$) и $$$k$$$ ($$$1 \le k \le       \frac{n \cdot (n-1)}{2}$$$). Выведите $$$k$$$-ю строку из списка.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Входные данные содержат один или несколько наборов тестовых данных.</p>     <p>Первая строка входных данных содержит одно целое число $$$t$$$       ($$$1 \le t \le 10^4$$$) — количество наборов тестовых данных в       тесте. Затем следуют $$$t$$$ наборов тестовых данных.</p>     <p>Каждый набор тестовых данных содержится на отдельной строке,       содержащей два целых числа $$$n$$$ и $$$k$$$ ($$$3 \le n \le 10^5,       1 \le k \le \min(2\cdot10^9, \frac{n \cdot (n-1)}{2})$$$.</p>     <p>Сумма значений $$$n$$$ по всем наборам тестовых данных не       превосходит $$$10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите $$$k$$$-ю строку из       списка всех описанных выше строк длины $$$n$$$. Строки в списке       отсортированы лексикографически (в алфавитном порядке).</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
7
5 1
5 2
5 8
5 10
3 1
3 2
20 100
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
aaabb
aabab
baaba
bbaaa
abb
bab
aaaaabaaaaabaaaaaaaa
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1328/problem/B' title='Codeforces Round 629 (Div. 3)'>1328B - K-th Beautiful String</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's try to find the position of the leftmost occurrence of         '<span class="tex-font-style-tt">b</span>' (iterate over all       positions from $$$n-2$$$ to $$$0$$$). If $$$k \le n - i - 1$$$       then this is the required position of the leftmost occurrence of         '<span class="tex-font-style-tt">b</span>'. Then the position of       rightmost occurrence is $$$n - k$$$ so we can print the answer.       Otherwise, let's decrease $$$k$$$ by $$$n-i-1$$$ (remove all       strings which have the leftmost '<span class="tex-font-style-tt">b</span>' at the current position) and       proceed to the next position. It is obvious that in such a way we       consider all possible strings in lexicographic order.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

#define forn(i, n) for (int i = 0; i &lt; int(n); i++)

int main() {
    int t;
    cin &gt;&gt; t;
    forn(tt, t) {
        int n, k;
        cin &gt;&gt; n &gt;&gt; k;
        string s(n, &#39;a&#39;);
        for (int i = n - 2; i &gt;= 0; i--) {
            if (k &lt;= (n - i - 1)) {
                s[i] = &#39;b&#39;;
                s[n - k] = &#39;b&#39;;
                cout &lt;&lt; s &lt;&lt; endl;
                break;
            }
            k -= (n - i - 1);
        }
    }
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #629 (Div. 3)
    1328C
    Троичный XOR </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Троичный XOR</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Число называется <span class="tex-font-style-it">троичным</span>,       если оно содержит только цифры $$$0$$$, $$$1$$$ и $$$2$$$.       Например, следующие числа являются троичными: $$$1022$$$,       $$$11$$$, $$$21$$$, $$$2002$$$.</p>     <p>Вам задано длинное троичное число $$$x$$$. Первая (самая левая)       цифра числа $$$x$$$ гарантированно является $$$2$$$, остальные       цифры числа $$$x$$$ могут быть $$$0$$$, $$$1$$$ или $$$2$$$.</p>     <p>Определим троичную операцию XOR $$$\odot$$$ над двумя троичными       числами $$$a$$$ и $$$b$$$ (оба имеют длину $$$n$$$) как число $$$c       = a \odot b$$$ длины $$$n$$$, где $$$c_i = (a_i + b_i) \% 3$$$       (где $$$\%$$$ — операция взятия по модулю). Другими словами,       сложим соответствующие цифры и возьмем остатки от сумм при делении       на $$$3$$$. Например, $$$10222 \odot 11021 = 21210$$$.</p>     <p>Ваша задача — найти такие троичные числа $$$a$$$ и $$$b$$$ (оба       длины $$$n$$$ и без лидирующих нулей), что $$$a \odot b = x$$$ и       $$$max(a, b)$$$ — минимально возможный.</p>     <p>Вам нужно ответить на $$$t$$$ независимых наборов входных данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка теста содержит одно целое число $$$t$$$ ($$$1 \le t       \le 10^4$$$) — количество наборов входных данных. Затем следуют       $$$t$$$ наборов входных данных. Первая строка набора содержит одно       целое число $$$n$$$ ($$$1 \le n \le 5 \cdot 10^4$$$) — длину числа       $$$x$$$. Вторая строка набора содержит троичное число $$$x$$$,       состоящее из $$$n$$$ цифр $$$0, 1$$$ и $$$2$$$. Гарантируется, что       первой цифрой числа $$$x$$$ является $$$2$$$. Также гарантируется,       что сумма всех $$$n$$$ по всем наборам входных данных не       превосходит $$$5 \cdot 10^4$$$ ($$$\sum n \le 5 \cdot 10^4$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите ответ на него — два       троичных числа $$$a$$$ и $$$b$$$ (каждое длины $$$n$$$ и без       лидирующих нулей) таких, что $$$a \odot b = x$$$ и $$$max(a, b)$$$       — минимально возможное. Если есть несколько возможных ответов, вы       можете вывести любой.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
5
22222
5
21211
1
2
9
220222021
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
11111
11111
11000
10211
1
1
110111011
110111010
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1328/problem/C' title='Codeforces Round 629 (Div. 3)'>1328C - Ternary XOR</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's iterate from left to right over the digits of $$$x$$$. If       the current digit is either $$$0$$$ or $$$2$$$ then we can set       $$$a_i = b_i = 0$$$ or $$$a_i = b_i = 1$$$ correspondingly. There       are no better choices. And if the current digit $$$x_i$$$ is       $$$1$$$ then the optimal choise is to set $$$a_i = 1$$$ and $$$b_i       = 0$$$. What happens after the first occurrence of $$$1$$$?       Because of this choice $$$a$$$ is greater than $$$b$$$ even if all       remaining digits in $$$b$$$ are $$$2$$$. So for each $$$j &gt;       i$$$ set $$$a_j = 0$$$ and $$$b_j = x_j$$$ and print the answer.       The case without $$$1$$$ is even easier and in fact we handle it automatically.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
	
	int t;
	cin &gt;&gt; t;
	while (t--) {
		int n;
		string x;
		cin &gt;&gt; n &gt;&gt; x;
		string a(n, &#39;0&#39;), b(n, &#39;0&#39;);
		for (int i = 0; i &lt; n; ++i) {
			if (x[i] == &#39;1&#39;) {
				a[i] = &#39;1&#39;;
				b[i] = &#39;0&#39;;
				for (int j = i + 1; j &lt; n; ++j) {
					b[j] = x[j];
				}
				break;
			} else {
				a[i] = b[i] = &#39;0&#39; + (x[i] - &#39;0&#39;) / 2;
			}
		}
		cout &lt;&lt; a &lt;&lt; endl &lt;&lt; b &lt;&lt; endl;
	}
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #629 (Div. 3)
    1328D
    Карусель, карусель --- это радость для нас </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Карусель, карусель — это радость для нас</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Круглая карусель состоит из $$$n$$$ фигур различных животных.       Фигуры пронумерованы от $$$1$$$ до $$$n$$$ по ходу движения       карусели. Таким образом, после $$$n$$$-й фигуры идёт фигура с       номером $$$1$$$. Каждая фигура имеет вид — это животного этой       фигуры (лошадка, тигр и др.). Вид животного $$$i$$$-й фигуры равен $$$t_i$$$.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/14b03eb81d32a3e2f92254a8c4ea43e5871f2a6d.png" style="max-width: 100.0%;max-height: 100.0%;"/>         <span class="tex-font-size-small">Пример изображения карусели         для $$$n=9$$$ и $$$t=[5, 5, 1, 15, 1, 5, 5, 1, 1]$$$</span>. </center>          <p>Вы хотите покрасить каждую фигуру в один из цветов. Вам кажется       скучным, если в каруселе разные фигуры (с разными видами животных)       идут подряд и покрашены в одинаковые цвета.</p>     <p>Ваша задача — покрасить фигуры так, чтобы количество различных       использованных цветов было минимальным и не существовало двух       фигур разного вида, которые идут подряд и покрашены в один цвет       одновременно. Если Вы используете ровно $$$k$$$ различных цветов,       то цвета фигур должны быть пронумерованы целыми числами от $$$1$$$       до $$$k$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Входные данные состоят из одного или более набора входных данных.</p>     <p>В первой строке записано целое число $$$q$$$ ($$$1 \le q \le       10^4$$$) — количество наборов входных данных в тесте. Далее       следуют описания $$$q$$$ наборов входных данных, по две строки на       каждый набор.</p>     <p>Первая строка набора входных данных содержит одно целое число       $$$n$$$ ($$$3 \le n \le 2 \cdot 10^5$$$) — количество фигур на       карусели. Фигуры пронумерованы от $$$1$$$ до $$$n$$$ по ходу       вращения карусели. Считайте, что после фигуры $$$n$$$ идёт фигура $$$1$$$.</p>     <p>Вторая строка набора входных данных содержит $$$n$$$ целых чисел       $$$t_1, t_2, \dots, t_n$$$ ($$$1 \le t_i \le 2 \cdot 10^5$$$), где       $$$t_i$$$ равно виду животного $$$i$$$-й фигуры.</p>     <p>Сумма значений $$$n$$$ по всем наборам входных данных в тесте не       превосходит $$$2\cdot10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$q$$$ ответов — на для каждого набора входных данных       выведите две строки.</p>     <p>В первую строку выведите одно целое число $$$k$$$ — минимально       возможное количество различных цветов фигур.</p>     <p>Во вторую строку выведите $$$n$$$ целых чисел $$$c_1, c_2, \dots,       c_n$$$ ($$$1 \le c_i \le k$$$), где $$$c_i$$$ обозначает номер       цвета $$$i$$$-й фигуры. Если существует несколько возможных       ответов, вы можете вывести любой из них.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
5
1 2 1 2 2
6
1 2 2 1 2 2
5
1 2 1 2 3
3
10 10 10
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
1 2 1 2 2
2
2 1 2 1 2 1
3
2 3 2 3 1
1
1 1 1 
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1328/problem/D' title='Codeforces Round 629 (Div. 3)'>1328D - Carousel</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>The answer to this problem is at most $$$3$$$. Let's prove it by construction.</p>     <p>Firstly, if all $$$t_i$$$ are equal then the answer is $$$1$$$.       Otherwise, there are at least two different values in the array       $$$t$$$ so the answer is at least $$$2$$$. If $$$n$$$ is even then       the answer is always $$$2$$$ because you can color figures in the       following way: $$$[1, 2, 1, 2, \dots, 1, 2]$$$. If $$$n$$$ is odd       then consider two cases. The first case is when some pair of       adjacent figures have the same type. Then the answer is $$$2$$$       because you can merge these two values into one and get the case       of even $$$n$$$. Otherwise, all pairs of adjacent figures have       different types and if you consider this cyclic array as a graph       (cycle of length $$$n$$$) then you can notice that it isn't       bipartite so you need at least $$$3$$$ colors to achieve the       answer (color all vertices in such a way that any two adjacent       vertices have different colors). And the answer looks like $$$[1,       2, 1, 2, \dots, 1, 2, 3]$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int solve() {
	int n;
	cin &gt;&gt; n;
	vector&lt;int&gt; a(n);
	for (int i = 0; i &lt; n; ++i) {
		cin &gt;&gt; a[i];
	}
	
	if (count(a.begin(), a.end(), a[0]) == n) {
		cout &lt;&lt; 1 &lt;&lt; endl;
		for (int i = 0; i &lt; n; ++i) {
			cout &lt;&lt; 1 &lt;&lt; &#34; &#34;;
		}
		cout &lt;&lt; endl;
		return 0;
	}
	
	if (n % 2 == 0) {
		cout &lt;&lt; 2 &lt;&lt; endl;
		for (int i = 0; i &lt; n; ++i) {
			cout &lt;&lt; i % 2 + 1 &lt;&lt; &#34; &#34;;
		}
		cout &lt;&lt; endl;
		return 0;
	}
	
	for (int i = 0; i &lt; n; ++i) {
		if (a[i] == a[(i + 1) % n]) {
			vector&lt;int&gt; ans(n);
			for (int j = 0, pos = i + 1; pos &lt; n; ++pos, j ^= 1) {
				ans[pos] = j + 1;
			}
			for (int j = 0, pos = i; pos &gt;= 0; --pos, j ^= 1) {
				ans[pos] = j + 1;
			}
			cout &lt;&lt; 2 &lt;&lt; endl;
			for (int pos = 0; pos &lt; n; ++pos) {
				cout &lt;&lt; ans[pos] &lt;&lt; &#34; &#34;;
			}
			cout &lt;&lt; endl;
			return 0;
		}
	}
	
	cout &lt;&lt; 3 &lt;&lt; endl;
	for (int i = 0; i &lt; n - 1; ++i) {
		cout &lt;&lt; i % 2 + 1 &lt;&lt; &#34; &#34;;
	}
	cout &lt;&lt; 3 &lt;&lt; endl;
    return 0;    
}

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif

int q;
cin &gt;&gt; q;
for (int qq = 0; qq &lt; q; qq++) {
    solve();
}

	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #629 (Div. 3)
    1328E
    Запросы на дереве </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. Запросы на дереве</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам дано корневое дерево, состоящее из $$$n$$$ вершин,       пронумерованных от $$$1$$$ до $$$n$$$. Корень дерева находится в       вершине с номером $$$1$$$.</p>     <p>Дерево — это связный неориентированный граф с $$$n-1$$$ ребром.</p>     <p>Вам заданы $$$m$$$ запросов. $$$i$$$-й запрос состоит из       множества $$$k_i$$$ различных вершин $$$v_i[1], v_i[2], \dots,       v_i[k_i]$$$. Ваша задача — определить, существует ли путь от корня       до некоторой вершины $$$u$$$ такой, что каждая из заданных $$$k$$$       вершин или принадлежит этому пути, или расположена на расстоянии       $$$1$$$ от некоторой вершины на этом пути.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка теста содержит два целых числа $$$n$$$ и $$$m$$$       ($$$2 \le n \le 2 \cdot 10^5$$$, $$$1 \le m \le 2 \cdot 10^5$$$) —       количество вершин в дереве и количество запросов.</p>     <p>Каждая из следующих $$$n-1$$$ строк описывает ребро дерева. Ребро       $$$i$$$ задается двумя целыми числами $$$u_i$$$ и $$$v_i$$$ —       номерами вершин, которые это ребро соединяет $$$(1 \le u_i, v_i       \le n, u_i \ne v_i$$$).</p>     <p>Гарантируется, что заданные ребра формируют дерево.</p>     <p>Следующие $$$m$$$ строк описывают запросы. $$$i$$$-я строка       описывает $$$i$$$-й запрос и начинается с целого числа $$$k_i$$$       ($$$1 \le k_i \le n$$$) — количества вершин в текущем запросе.       Затем следуют $$$k_i$$$ целых чисел: $$$v_i[1], v_i[2], \dots,       v_i[k_i]$$$ ($$$1 \le v_i[j] \le n$$$), где $$$v_i[j]$$$ — это       $$$j$$$-я вершина в $$$i$$$-м запросе.</p>     <p>Гарантируется, что все вершины в одном запросе различны.</p>     <p>Также гарантируется, что сумма всех $$$k_i$$$ не превосходит $$$2       \cdot 10^5$$$ ($$$\sum\limits_{i=1}^{m} k_i \le 2 \cdot 10^5$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого запроса выведите ответ — «<span class="tex-font-style-tt">YES</span>», если существует путь от       корня до некоторой вершины $$$u$$$ такой, что каждая из $$$k$$$       заданных вершин или принадлежит этому пути, или расположена на       расстоянии $$$1$$$ от какой-либо вершины на этом пути, и «<span class="tex-font-style-tt">NO</span>» в противном случае.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
10 6
1 2
1 3
1 4
2 5
2 6
3 7
7 8
7 9
9 10
4 3 8 9 10
3 2 4 6
3 2 1 5
3 4 8 2
2 6 10
3 5 4 7
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
YES
YES
YES
YES
NO
NO
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Изображение, относящееся к примеру:</p>     <p>       <img class="tex-graphics" src="https://espresso.codeforces.com/e76bd5b034f329b9a83adf0b8731c659d4d0c096.png" style="max-width: 100.0%;max-height: 100.0%;"/></p>     <p>Рассмотрим запросы.</p>     <p>Первый запрос — $$$[3, 8, 9, 10]$$$. Ответ — «<span class="tex-font-style-tt">YES</span>», так как вы можете выбрать       путь от корня $$$1$$$ до вершины $$$u=10$$$. Тогда вершины $$$[3,       9, 10]$$$ принадлежат пути от $$$1$$$ до $$$10$$$ и вершина       $$$8$$$ расположена на расстоянии $$$1$$$ от вершины $$$7$$$,       которая также принадлежит этому пути.</p>     <p>Второй запрос — $$$[2, 4, 6]$$$. Ответ — «<span class="tex-font-style-tt">YES</span>», так как вы можете выбрать       путь до вершины $$$u=2$$$. Тогда вершина $$$4$$$ находится на       расстоянии $$$1$$$ от вершины $$$1$$$, которая принадлежит этому       пути, а вершина $$$6$$$ находится на расстоянии $$$1$$$ от вершины       $$$2$$$, которая принадлежит этому пути.</p>     <p>Третий запрос — $$$[2, 1, 5]$$$. Ответ — «<span class="tex-font-style-tt">YES</span>», так как вы можете выбрать       путь до вершины $$$u=5$$$ и все вершины из запроса будут       принадлежать этому пути.</p>     <p>Четвертый запрос — $$$[4, 8, 2]$$$. Ответ — «<span class="tex-font-style-tt">YES</span>», так как вы можете выбрать       путь до вершины $$$u=9$$$, и вершины $$$2$$$ и $$$4$$$ расположены       на расстоянии $$$1$$$ от вершины $$$1$$$, которая принадлежит       этому пути, а вершина $$$8$$$ расположена на расстоянии $$$1$$$ от       вершины $$$7$$$, которая принадлежит этому пути.</p>     <p>Ответ и на пятый, и на шестой запросы — «<span class="tex-font-style-tt">NO</span>», потому что вы не можете       выбрать подходящую вершину $$$u$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1328/problem/E' title='Codeforces Round 629 (Div. 3)'>1328E - Tree Queries</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Firstly, let's choose some deepest (farthest from the root)       vertex $$$fv$$$ in the query (among all such vertices we can       choose any). It is obvious that every vertex in the query should       either belong to the path from the root to $$$fv$$$ or the       distance to some vertex of this path should be at most one. Now       there are two ways: write some LCA algorithms and other hard stuff       which is unnecessary in this problem or write about $$$15$$$ lines       of code and solve the problem.</p>     <p>Let's take every non-root vertex (except $$$fv$$$) and replace it       with its parent. So, what's next? Now the answer is &quot;<span class="tex-font-style-tt">YES</span>&quot; if <span class="tex-font-style-bf">each</span> vertex (after       transformation) belongs to the path from root to $$$fv$$$. Now we       just need to check if it is true.</p>     <p>We can do this using the very standard technique: firstly, let's       run dfs from the root and calculate for each vertex the first time       we visited it ($$$tin$$$) and the last time we visited it ($$$tout$$$).</p>     <p>We can do this using the following code: </p>     <pre class="verbatim"><br />void dfs(int v, int par = -1) {<br />    tin[v] = T++;<br />    for (auto to : g[v]) {<br />        if (to == par) continue;<br />        dfs(to, v);<br />    }<br />    tout[v] = T++;<br />}<br /></pre>          <p>Initially, $$$T$$$ equals zero. Now we have a beautiful structure       giving us so much information about the tree. Consider all       segments $$$[tin_v; tout_v]$$$. We can see that there is no pair       of intersecting segments. The pair of segments $$$[tin_v;       tout_v]$$$ and $$$[tin_u; tout_u]$$$ is either non-intersecting at       all or one segment lies inside the other one. The second beautiful       fact is that for each vertex $$$u$$$ in the subtree of $$$v$$$ the       segment $$$[tin_u; tout_u]$$$ lies inside the segment $$$[tin_v; tout_v]$$$.</p>     <p>So, we can check if one vertex is the parent of the other: the       vertex $$$v$$$ is the parent of the vertex $$$u$$$ if and only if       $$$tin_v \le tin_u$$$ and $$$tout_u \le tout_v$$$ (the vertex is       the parent of itself).</p>     <p>How do we check if the vertex $$$u$$$ lies on the path from the       root to the vertex $$$fv$$$? It lies on this path if the root is       the parent of $$$u$$$ (it is always true) and $$$u$$$ is the       parent of $$$fv$$$. This approach can be used for each <span class="tex-font-style-bf">vertical</span> path (such a path from       $$$x$$$ to $$$y$$$ that $$$lca(x, y)$$$ is either $$$x$$$ or $$$y$$$).</p>     <p>Time complexity: $$$O(n + m)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int T;
vector&lt;int&gt; p, d;
vector&lt;int&gt; tin, tout;
vector&lt;vector&lt;int&gt;&gt; g;

void dfs(int v, int par = -1, int dep = 0) {
	p[v] = par;
	d[v] = dep;
	tin[v] = T++;
	for (auto to : g[v]) {
		if (to == par) continue;
		dfs(to, v, dep + 1);
	}
	tout[v] = T++;
}

bool isAnc(int v, int u) {
	return tin[v] &lt;= tin[u] &amp;&amp; tout[u] &lt;= tout[v];
}

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
	
	int n, m;
	cin &gt;&gt; n &gt;&gt; m;
	T = 0;
	p = d = vector&lt;int&gt;(n);
	tin = tout = vector&lt;int&gt;(n);
	g = vector&lt;vector&lt;int&gt;&gt;(n);
	for (int i = 0; i &lt; n - 1; ++i) {
		int x, y;
		cin &gt;&gt; x &gt;&gt; y;
		--x, --y;
		g[x].push_back(y);
		g[y].push_back(x);
	}
	dfs(0);
	
	for (int i = 0; i &lt; m; ++i) {
		int k;
		cin &gt;&gt; k;
		vector&lt;int&gt; v(k);
		for (auto &amp;it : v) {
			cin &gt;&gt; it;
			--it;
		}
		
		int u = v[0];
		for (auto it : v) if (d[u] &lt; d[it]) u = it;
		for (auto &amp;it : v) {
			if (it == u) continue;
			if (p[it] != -1) it = p[it];
		}
		bool ok = true;
		for (auto it : v) ok &amp;= isAnc(it, u);
		if (ok) cout &lt;&lt; &#34;YES&#34; &lt;&lt; endl;
		else cout &lt;&lt; &#34;NO&#34; &lt;&lt; endl;
	}
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #629 (Div. 3)
    1328F
    Сделай k одинаковых </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Сделай k одинаковых</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам задан массив $$$a$$$, состоящий из $$$n$$$ элементов, и целое       число $$$k \le n$$$.</p>     <p>Вы хотите получить <span class="tex-font-style-bf">не менее       чем</span> $$$k$$$ одинаковых элементов в массиве $$$a$$$. За один       ход вы можете совершить одну из следующих двух операций:</p>          <ul> <li> Взять <span class="tex-font-style-bf">один</span> из         минимальных элементов в массиве и увеличить его значение на один         (более формально, если минимальный элемент в $$$a$$$ равен         $$$mn$$$, то вы выбираете такой индекс $$$i$$$, что $$$a_i =         mn$$$, и присваиваете $$$a_i := a_i + 1$$$); </li>       <li> взять <span class="tex-font-style-bf">один</span> из         максимальных элементов в массиве и уменьшить его значение на         один (более формально, если максимальный элемент в $$$a$$$ равен         $$$mx$$$, то вы выбираете такой индекс $$$i$$$, что $$$a_i =         mx$$$, и присваиваете $$$a_i := a_i - 1$$$). </li></ul>          <p>Ваша задача — посчитать минимальное количество ходов,       необходимое, чтобы получить <span class="tex-font-style-bf">не         менее чем</span> $$$k$$$ одинаковых элементов в массиве.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка теста содержит два целых числа $$$n$$$ и $$$k$$$       ($$$1 \le k \le n \le 2 \cdot 10^5$$$) — количество элементов в       $$$a$$$ и необходимое количество одинаковых элементов.</p>     <p>Вторая строка теста содержит $$$n$$$ целых чисел $$$a_1, a_2,       \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$), где $$$a_i$$$ —       $$$i$$$-й элемент в $$$a$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одно целое число — минимальное количество ходов,       необходимое, чтобы получить <span class="tex-font-style-bf">не         менее чем</span> $$$k$$$ одинаковых элементов в массиве.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6 5
1 2 2 4 2 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
7 5
3 3 2 1 1 1 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
4
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1328/problem/F' title='Codeforces Round 629 (Div. 3)'>1328F - Make k Equal</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>This problem is just all about the implementation. Firstly, let's       sort the initial values and compress them to pairs $$$(i,       cnt[val])$$$, where $$$cnt[val]$$$ is the number of elements       $$$val$$$. The first observation is pretty standard and easy: some       equal elements will remain unchanged. So let's iterate over all       elements $$$val$$$ in some order and suppose that all elements       $$$val$$$ will remain unchanged. Firstly, we need $$$need = max(0,       k - cnt[val])$$$ elements which we should obtain by some moves.       The second observation is that we first need to take elements from       one end (only less or only greater) and only then from the other       (if needed).</p>     <p>Consider the case when we first take less elements. The other       case is almost symmetric.</p>     <p>Let $$$needl = min(need, prefcnt_{prv})$$$ be the number of less       than $$$val$$$ which we need to increase to $$$val$$$. If $$$needl       = 0$$$ then skip the following step. Otherwise, let       $$$prefcnt_i$$$ be the number of elements less than or equal to       $$$i$$$, $$$prefsum_i$$$ be the sum of all elements less than or       equal to $$$i$$$ and $$$prv$$$ be the previous value (the maximum       value less than $$$val$$$). Then we need to increase all elements       less than or equal to $$$prv$$$ at least to the value $$$val-1$$$.       It costs $$$(val - 1) \cdot prefcnt_{prv} - prefsum_{prv}$$$       moves. And then we need $$$needl$$$ moves to increase $$$needl$$$       elements to $$$val$$$.</p>     <p>And let $$$needr = max(0, need - needl)$$$ be the number of       elements greater than $$$val$$$ which we need to decrease to       $$$val$$$ if we increased $$$needl$$$ elements already. If       $$$needr = 0$$$ then skip the following step. Otherwise, let       $$$sufcnt_i$$$ be the number of elements greater than or equal to       $$$i$$$, $$$prefsum_i$$$ be the sum of all elements greater than       or equal to $$$i$$$ and $$$nxt$$$ be the next value (the minimum       value greater than $$$val$$$). Then we need to decrease all       elements greater than or equal to $$$prv$$$ at least to the value       $$$val+1$$$. It costs $$$sufsum_{nxt} - (val + 1) \cdot       sufcnt_{nxt}$$$ moves. And then we need $$$needr$$$ moves to       decrease $$$needr$$$ elements to $$$val$$$.</p>     <p>So we can update the answer with the sum of values described       above and proceed to the next value. Arrays $$$prefcnt, sufcnt,       prefsum, sufsum$$$ are just simple prefix and suffix sums which       can be calculated in $$$O(n)$$$ using very standard and easy       dynamic programming. Don't forget about the overflow.</p>     <p>Total time complexity: $$$O(n \log n)$$$ because of sorting.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

const long long INF64 = 1e18;

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
	
	int n, k;
	cin &gt;&gt; n &gt;&gt; k;
	vector&lt;int&gt; a(n);
	for (auto &amp;it : a) cin &gt;&gt; it;
	
	sort(a.begin(), a.end());
	vector&lt;pair&lt;int, int&gt;&gt; cnt;
	for (auto it : a) {
		if (cnt.empty() || cnt.back().first != it) {
			cnt.push_back({it, 1});
		} else {
			++cnt.back().second;
		}
	}
	vector&lt;long long&gt; prefsum, sufsum;
	vector&lt;int&gt; prefcnt, sufcnt; 
	for (int i = 0; i &lt; int(cnt.size()); ++i) {
		long long cursum = cnt[i].first * 1ll * cnt[i].second;
		int curcnt = cnt[i].second;
		if (prefsum.empty()) {
			prefsum.push_back(cursum);
			prefcnt.push_back(curcnt);
		} else {
			prefsum.push_back(prefsum.back() + cursum);
			prefcnt.push_back(prefcnt.back() + curcnt);
		}
	}
	for (int i = int(cnt.size()) - 1; i &gt;= 0; --i) {
		long long cursum = cnt[i].first * 1ll * cnt[i].second;
		int curcnt = cnt[i].second;
		if (sufsum.empty()) {
			sufsum.push_back(cursum);
			sufcnt.push_back(curcnt);
		} else {
			sufsum.push_back(sufsum.back() + cursum);
			sufcnt.push_back(sufcnt.back() + curcnt);
		}
	}
	reverse(sufsum.begin(), sufsum.end());
	reverse(sufcnt.begin(), sufcnt.end());
	
	long long ans = INF64;
	for (int i = 0; i &lt; int(cnt.size()); ++i) {
		int cur = max(0, k - cnt[i].second);
		
		int needl = 0;
		if (i &gt; 0) needl = min(cur, prefcnt[i - 1]);
		int needr = max(0, cur - needl);
		long long res = 0;
		if (i &gt; 0 &amp;&amp; needl &gt; 0) {
			res += prefcnt[i - 1] * 1ll * (cnt[i].first - 1) - prefsum[i - 1];
			res += needl;
		}
		if (i + 1 &lt; int(cnt.size()) &amp;&amp; needr &gt; 0) {
			res += sufsum[i + 1] - sufcnt[i + 1] * 1ll * (cnt[i].first + 1);
			res += needr;
		}
		ans = min(ans, res);
		
		needr = 0;
		if (i + 1 &lt; int(cnt.size())) needr = min(cur, sufcnt[i + 1]);
		needl = max(0, cur - needr);
		res = 0;
		if (i &gt; 0 &amp;&amp; needl &gt; 0) {
			res += prefcnt[i - 1] * 1ll * (cnt[i].first - 1) - prefsum[i - 1];
			res += needl;
		}
		if (i + 1 &lt; int(cnt.size()) &amp;&amp; needr &gt; 0) {
			res += sufsum[i + 1] - sufcnt[i + 1] * 1ll * (cnt[i].first + 1);
			res += needr;
		}
		ans = min(ans, res);
	}
	
	cout &lt;&lt; ans &lt;&lt; endl;
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #631 (Div. 1) - Thanks, Denis aramis Shitov!
    1329A
    Dreamoon любит красить </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Dreamoon любит красить</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Dreamoon очень любит красить клетки.</p>     <p>Есть ряд из $$$n$$$ клеток. Исходно, все клетки пустые (не       содержат никакой цвет). Клетки пронумерованы от $$$1$$$ до $$$n$$$.</p>     <p>Вам дано целое число $$$m$$$ и $$$m$$$ целых чисел $$$l_1, l_2,       \ldots, l_m$$$ ($$$1 \le l_i \le n$$$)</p>     <p>Dreamoon совершит $$$m$$$ операций.</p>     <p>В $$$i$$$-й операции, Dreamoon выберет число $$$p_i$$$ из отрезка       $$$[1, n-l_i+1]$$$ (включительно) и покрасит все клетки от       $$$p_i$$$ до $$$p_i+l_i-1$$$ (включительно) в $$$i$$$-й цвет.       Обратите внимание, что клетки могут быть покрашены несколько раз,       в таком случае, клетка будет покрашена в цвет из самой последней операции.</p>     <p>Dreamoon надеется, что после $$$m$$$ операций, все цвета будут       встречаться хотя бы один раз и все клетки будут покрашены.       Пожалуйста, помогите Dreamoon выбрать $$$p_i$$$ в каждой операции,       чтобы удовлетворить всем ограничениям.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записаны два целых числа $$$n,m$$$ ($$$1 \leq m       \leq n \leq 100\,000$$$).</p>     <p>Во второй строке записано $$$m$$$ целых чисел $$$l_1, l_2,       \ldots, l_m$$$ ($$$1 \leq l_i \leq n$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Если невозможно совершить $$$m$$$ операций, чтобы удовлетворить       всем ограничениям, выведите «<span class="tex-font-style-tt">-1</span>» (без кавычек).</p>     <p>Иначе, выведите $$$m$$$ целых чисел $$$p_1, p_2, \ldots, p_m$$$       ($$$1 \leq p_i \leq n - l_i + 1$$$), после этих $$$m$$$ операций,       все цвета должны встречаться хотя бы один раз и все клетки должны       быть покрашены. </p>     <p>Если есть несколько возможных решений, вы можете вывести любое.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5 3
3 2 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2 4 1
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
10 1
1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
-1
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1329/problem/A' title='Codeforces Round 631 (Div. 1) - Thanks, Denis aramis Shitov!'>1329A - Dreamoon Likes Coloring</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>After reading the statement, you may find this is a problem that       will be tagged as &quot;constructive algorithms&quot; in       Codefores. And you also can find this problem is just problem A in       Div. 1. So basically we can expect there exist some simple methods       to solve it.</p>     <p>If a &quot;constructive algorithms&quot; problem asks you to       determine whether the solution exists or not, usually they have a       common pattern(especially in problem hardness which is before Div.       1 B(inclusive)), this is, there are some simple constraints can       divide test data into &quot;Yes&quot;, and &quot;No&quot;.       Therefore, the first thing to solve this problem is finding some       trivial conditions that cannot achieve Dreamoon's hope. </p>     <p>After some try, you may find there are two trivial conditions       that achieving Dreamoon's hope is impossible. The two conditions       are listed as follows:</p>     <p>1. Sum of $$$l_i$$$ is less than $$$n$$$. In this condition,       there always is at least one empty grid.</p>     <p>2. There exists some $$$i$$$ such that $$$l_i + i - 1 &gt; n$$$.       If $$$n - l_i &lt; i - 1$$$, it means after you do $$$i$$$-th       operation, there only $$$n - l_i$$$ grid is not colored by       $$$i$$$-th color. So at least one of previous $$$i-1$$$ color will       disapear after this operation. </p>     <p>Now I want to talk about another feature of some       &quot;constructive algorithms&quot; first. </p>     <p>Sometimes, the condition given by the problem is to       &quot;open&quot;, this is to say that if we added some more strict       constraint, the problem is still can be solved. And when the       constraint it more strict, we can deduce the solution more easily.</p>     <p>One of common &quot;strict constraint&quot; is       &quot;sorted&quot;. I believe you have ever seen many problems       that the first step is sorting something. Now, we also want to       apply &quot;sorted&quot; in the problem.</p>     <p>After applying &quot;sort&quot;, we firstly consider the edge       cases of above two impossible conditions. The first case is       &quot;sum of $$$l_i$$$ is equal to $$$n$$$&quot;. In this case, we       have a unique solution after applying &quot;sort&quot;, $$$p_i = m       - \sum\limits_{j=i+1}^{m} l_j + 1$$$. The second case is $$$l_i +       i - 1 = n$$$ is hold for all $$$i$$$. In this case, there is also       a unique solution that $$$p_i = i$$$. The two cases coressond to       $$$n$$$ is largest and $$$n$$$ is smallest among all $$$n$$$ that       exist solutions for same $$$l_i$$$. And for same $$$l_i$$$, when       we decrase $$$n$$$ from the largest possible value, we can just       change $$$p_i$$$ from $$$m - \sum\limits_{j=i+1}^{m} l_j + 1$$$ to       $$$i$$$ for some smallest indices $$$i$$$ to get solution. To sum       it up, finally, we get the answer. The answer is just $$$p_i =       \max(i, n - suffix\_sum[i] + 1)$$$, for each $$$i$$$.</p>     <p>There exist many other methods to construct solutions. I believe       the construction method one can think out is relative to the study experience.</p></div></div></div>

           
            <pre><code>#include&lt;bits/stdc++.h&gt;
const int SIZE = 100002;
int len[SIZE];
long long suffix_sum[SIZE];
void err() {puts(&#34;-1&#34;);}
void solve() {
    int N, M;
    scanf(&#34;%d%d&#34;, &amp;N, &amp;M);
    for(int i = 1; i &lt;= M; i++) {
        scanf(&#34;%d&#34;, &amp;len[i]);
        if(len[i] + i - 1 &gt; N) {
            err();
            return;
        }
    }
    for(int i = M; i &gt; 0; i--) {
        suffix_sum[i] = suffix_sum[i + 1] + len[i];
    }
    if(suffix_sum[1] &lt; N) {
        err();
        return;
    }
    for(int i = 1; i &lt;= M; i++) {
        printf(&#34;%lld&#34;, std::max((long long)i, N - suffix_sum[i] + 1));
        if(i &lt; M) putchar(&#39; &#39;);
        else puts(&#34;&#34;);
    }
}
int main() {
    solve();
    return 0;
}
</code></pre>
           
            <pre><code>#include&lt;bits/stdc++.h&gt;
const int SIZE = 100002;
int len[SIZE];
long long suffix_sum[SIZE];
void err() {puts(&#34;-1&#34;);}
void solve() {
    int N, M;
    scanf(&#34;%d%d&#34;, &amp;N, &amp;M);
    for(int i = 1; i &lt;= M; i++) {
        scanf(&#34;%d&#34;, &amp;len[i]);
        if(len[i] + i - 1 &gt; N) {
            err();
            return;
        }
    }
    for(int i = M; i &gt; 0; i--) {
        suffix_sum[i] = suffix_sum[i + 1] + len[i];
    }
    if(suffix_sum[1] &lt; N) {
        err();
        return;
    }
    for(int i = 1; i &lt;= M; i++) {
        printf(&#34;%lld&#34;, std::max((long long)i, N - suffix_sum[i] + 1));
        if(i &lt; M) putchar(&#39; &#39;);
        else puts(&#34;&#34;);
    }
}
int main() {
    solve();
    return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #631 (Div. 1) - Thanks, Denis aramis Shitov!
    1329B
    Dreamoon любит последовательности </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Dreamoon любит последовательности</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Dreamoon очень любит последовательности. Поэтому он придумал       задачу про последовательность, которую нельзя найти на OEIS: </p>     <p>Вам дано два целых числа $$$d, m$$$, вам нужно найти количество       массивов $$$a$$$, удовлетворяющих следующим ограничениям:</p>          <ul> <li> Длина $$$a$$$ равна $$$n$$$, $$$n \ge 1$$$ </li>       <li> $$$1 \le a_1 &lt; a_2 &lt; \dots &lt; a_n \le d$$$ </li>       <li> Рассмотрим следующий массив $$$b$$$ длины $$$n$$$: $$$b_1 =         a_1$$$, $$$\forall i &gt; 1, b_i = b_{i - 1} \oplus a_i$$$, где         $$$\oplus$$$ это побитовое исключащее или (xor). После         построения массива $$$b$$$, должно выполняться ограничение         $$$b_1 &lt; b_2 &lt; \dots &lt; b_{n - 1} &lt; b_n$$$. </li></ul>          <p>Так как количество возможных массивов может быть слишком большим,       вам нужно найти его по модулю $$$m$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано целое число $$$t$$$ ($$$1 \leq t \leq       100$$$) обозначающее количество наборов входных данных в задаче.</p>     <p>Каждая из следующих $$$t$$$ строк содержит два целых числа $$$d,       m$$$ ($$$1 \leq d, m \leq 10^9$$$).</p>     <p>Обратите внимание, что $$$m$$$ необязательно простое!</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных, выведите количество массивов       $$$a$$$, удовлетворяющих всем ограничениям, по модулю $$$m$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
10
1 1000000000
2 999999999
3 99999998
4 9999997
5 999996
6 99995
7 9994
8 993
9 92
10 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
3
5
11
17
23
29
59
89
0
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1329/problem/B' title='Codeforces Round 631 (Div. 1) - Thanks, Denis aramis Shitov!'>1329B - Dreamoon Likes Sequences</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Firstly, we define a function $$$h(x)$$$ as the position of the       highest bit which is set to 1 in a positive integer $$$x$$$. For       example, $$$h(1) = 0, h(2) = h(3) = 1$$$, and $$$h(4) = h(7) = 2$$$.</p>     <p>If the constraints in this problem is satisfied, there is some       observations, $$$h(a_i) = h(b_i)$$$ and $$$h(a_i)$$$ must less       than $$$h(a_{i+1})$$$. And luckily, if $$$h(a_i) &lt;       h(a_{i+1})$$$ is always hold, the constraints in this problem will       also be satisfied (Please prove them by yourself or wait for       someone prove it in comments : ) P.S. the link of proof written by       someone is int the end. )</p>     <p>In other words, for each non-negative integer $$$v$$$, there is       at most one $$$i$$$ such that $$$h(a_i) = v$$$. This is, at most       one of the positive numbers in range $$$[2^v,       min(2^{(v+1)}-1,d)]$$$ can occur in $$$a_i$$$. In each non-empty       range, we can choose one integer in it or don't choose anyone. So       for each of them we have $$$min(2^{(v+1)}-1,d) - 2^v + 2$$$       different choice. Then according to the rule of product, we can       multiply all number of choices for different $$$v$$$ and minus the       value by one to get the answer. For example, when d = 6, there are       $$$2$$$ choices for $$$v = 0$$$, $$$3$$$ choices for $$$v=1$$$,       $$$4$$$ choices for $$$v=2$$$. So the answer for $$$d = 6$$$ is       $$$2 \times 3 \times 4 - 1 = 23$$$. </p></div></div></div>

           
            <pre><code>#include&lt;bits/stdc++.h&gt;
void solve(){
    int d, m;
    scanf(&#34;%d%d&#34;,&amp;d, &amp;m);
    long long answer=1;
    for(int i = 0; i &lt; 30; i++) {
        if(d &lt; (1 &lt;&lt; i)) break;
        answer = answer * (std::min((1 &lt;&lt; (i+1)) - 1, d) - (1 &lt;&lt; i) + 2) % m;
    }
    answer--;
    if(answer &lt; 0) answer += m;
    printf(&#34;%lld\n&#34;,answer);
}
int main() {
    int T;
    scanf(&#34;%d&#34;, &amp;T);
    while(T--) {
        solve();
    }
}
</code></pre>
           
            <pre><code>#include&lt;bits/stdc++.h&gt;
void solve(){
    int d, m;
    scanf(&#34;%d%d&#34;,&amp;d, &amp;m);
    long long answer=1;
    for(int i = 0; i &lt; 30; i++) {
        if(d &lt; (1 &lt;&lt; i)) break;
        answer = answer * (std::min((1 &lt;&lt; (i+1)) - 1, d) - (1 &lt;&lt; i) + 2) % m;
    }
    answer--;
    if(answer &lt; 0) answer += m;
    printf(&#34;%lld\n&#34;,answer);
}
int main() {
    int T;
    scanf(&#34;%d&#34;, &amp;T);
    while(T--) {
        solve();
    }
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #631 (Div. 1) - Thanks, Denis aramis Shitov!
    1329C
    Drazil любит кучи </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Drazil любит кучи</div>     <div class="time-limit"><div class="property-title">ограничение по времени на       тест</div>1.5 секунд</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Drazil очень любит кучи, поэтому он придумал задачу про кучу:</p>     <p>Есть куча на максимум глубины $$$h$$$, реализованная на массиве.       Эта куча устроена следующим образом: куча содержит ровно $$$2^h -       1$$$ <span class="tex-font-style-bf">различных</span>       положительных ненулевых целых чисел. Все целые числа различны. Эти       числа содержатся в массиве $$$a$$$, в котором элементы       пронумерованы от $$$1$$$ до $$$2^h-1$$$. Для всех $$$1 &lt; i &lt;       2^h$$$, $$$a[i] &lt; a[\left \lfloor{\frac{i}{2}}\right \rfloor]$$$.</p>     <p>Теперь он хочет уменьшить глубину кучи так, чтобы глубина стала       $$$g$$$, и куча содержала ровно $$$2^g-1$$$ чисел. Чтобы уменьшить       глубину, нужно применить следующую операцию $$$2^h-2^g$$$ раз:</p>     <p>Выбрать индекс $$$i$$$, который содержит элемент, и запустить       функцию $$$f$$$ от индекса $$$i$$$:</p>     <p>       <img class="tex-graphics" src="https://espresso.codeforces.com/d748546cbc8f1d0d4241d4bdbee9e783c3c48411.png" style="max-width: 100.0%;max-height: 100.0%;"/></p>     <p>Обратите внимание, что мы считаем, что если $$$a[i]=0$$$, то       индекс $$$i$$$ не содержит элемент.</p>     <p>После всех операций, оставшиеся $$$2^g-1$$$ элементов должны       находиться в индексах от $$$1$$$ до $$$2^g-1$$$. Теперь Drazil       хочет узнать, какая может быть минимальная сумма оставшихся       $$$2^g-1$$$ элементов. Пожалуйста, найдите эту сумму и       последовательность вызовов функции, на которой эта сумма достигается.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$t$$$ ($$$1 \leq t       \leq 70\,000$$$): количество наборов входных данных.</p>     <p>Каждый набор входных данных содержит две строки. В первой строке       записаны два целых числа $$$h$$$ и $$$g$$$ ($$$1 \leq g &lt; h       \leq 20$$$). Во второй строке записаны $$$n = 2^h-1$$$ <span class="tex-font-style-bf">различных</span> положительных целых       чисел $$$a[1], a[2], \ldots, a[n]$$$ ($$$1 \leq a[i] &lt;       2^{20}$$$). Для всех $$$i$$$ от $$$2$$$ до $$$2^h - 1$$$, $$$a[i]       &lt; a[\left \lfloor{\frac{i}{2}}\right \rfloor]$$$.</p>     <p>Сумма по всем $$$n$$$ меньше чем $$$2^{20}$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных, выведите две строки.</p>     <p>В первой строке вы должны вывести минимальную сумму элементов       после уменьшения глубины кучи до $$$g$$$. Вторая строка должна       содержать $$$2^h - 2^g$$$ целых чисел $$$v_1, v_2, \ldots,       v_{2^h-2^g}$$$. В $$$i$$$-й операции должна быть вызвана $$$f(v_i)$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
3 2
7 6 3 5 4 2 1
3 2
7 6 5 4 3 2 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
10
3 2 3 1
8
2 1 3 1
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1329/problem/C' title='Codeforces Round 631 (Div. 1) - Thanks, Denis aramis Shitov!'>1329C - Drazil Likes Heap</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>The property of heap we concern in this problem mainly are: </p>     <p>1. The tree is a binary tree, each node has a weight value.</p>     <p>2. The weight of a node is always larger than the weight of its children.</p>     <p>3. We use $$$a[I]$$$ to record the weight of vertex $$$i$$$, and       the number of its children are $$$2 \times i$$$ and vertex $$$2       \times i + 1$$$ (if exist). </p>     <p>Another key point we should consider seriously is before all       operations and after all operations, the tree must be a perfect       binary tree. Many contestants didn't notice the constraint during       the contest. </p>     <p>I think there are two different thinking directions for this       problem. One is considering node from bottom to top. Another one       is considering node from top to bottom. For me, from bottom to top       is more intuitive.</p>     <p>Now we talk about &quot;from bottom to top&quot; first, it means       we consider node from larger index to smaller index in the tree       after all operations (call it final tree after). For the leaves in       the final tree, it's not hard to know, the minimum possible final       weight of each leaf is the minimum weight of nodes in its subtree       before all operations (call it beginning tree after). For the       other nodes in the final tree, its weight must satisfy two       constraints, one is it should be larger than the final weight of       his children, another is the weight should exist in its subtree of       the beginning tree. Luckily, these lower bounds are all       constraints we should consider to get the answer. For each leaf in       the final tree, we maintain a data structure that stores all       weight of its subtree in the beginning tree. Then the minimum       value in this data structure is its final weight. For other nodes       in the final tree, we merge the two data structures of its       children. the remove all value which is less than the final weight       of his children. There are many data structure can do these       operations, such as min heap(author's code) or sorted       array(isaf27's code). </p>     <p>With the above method, we get the minimum possible sum of the       remaining $$$2^g-1$$$ elements. But we still don't know how to       construct it. All we know is which weight values are reaming in       the final tree. Now I want to prove that no matter how the order I       call the function $$$f$$$, if the remaining weight values set is       the same, the final shape of the final tree will be the same. </p>     <p>This time I prove it from top to bottom. We only know which       weight values set to remain in the final, Then We iterate node       from smallest index to the larger one. We always can determine the       weight value of the iterated node, because the weight value only       can be the maximum value in its subtree. This trait also can let       us know that the final tree we get in our method is a perfect       binary tree.</p>     <p>Conclude all things above. after we can apply the function       $$$f$$$ from bottom to top on these nodes with weight value       doesn't exist in the final tree.</p>     <p>In the &quot;from bottom to top&quot; method, it has some       thinking level difference between calculating the minimum sum and       constructing a list of possible operations. So I determine let       competitors output the operations. </p>     <p>- - -</p>     <p>Now we talk about the &quot;from top to bottom&quot; method. The       main idea of this method is iterating index from $$$1$$$ to       $$$2^g-1$$$ and in each iteration, applying the function $$$f$$$       on $$$i$$$-th node until the shape of the final tree is impossible       to become a perfect binary tree. The method is quite easy to write       and almost has no difference when asking you to output the       operations. But I think it's hard to prove. Evenly, I think the       solution should be wrong until I write this solution and test it.</p>     <p>Firstly I want to prove the minimum possible final weight value       of node $$$1$$$ is the same as the above &quot;from top to       bottom&quot; method get. We call the value as $$$mi_1$$$. If some       algorithm $$$B$$$ can get more small weight value in the final       tree, It means all weight values which are not smaller than       $$$mi_1$$$ disappear. But according to the conclusion &quot;if the       remaining weight values set is the same, the final shape of the       final tree will be the same.&quot;. the final tree generated by       $$$B$$$ can also get with firstly applying the function $$$f$$$ on       node $$$1$$$ at least one more time than above &quot;from top to       bottom&quot; algorithm, and do some other operations. But it will       make the final tree is impossible to be the perfect binary tree.       Now we disprove it.</p>     <p>Now we want to prove the final weight value of node       $$$i$$$($$$i&gt;1$$$) is the same as the above &quot;from top to       bottom&quot; method get. Only when applying function $$$f$$$ on       ancestors and descendants of node $$$i$$$ will affect the final       weight value of node $$$i$$$. And when we apply on its ancestors,       the $$$f$$$ may recursively apply $$$f$$$ on $$$it$$$ at most       once. So each time $$$f$$$ applies on its ancestors is equivalent       to apply on itself once or do nothing. Therefore, The proof can be       don as what we do on node $$$1$$$ just by only considering the       subtree of node $$$i$$$. </p>     <p>Now, we have proved the &quot;top to bottom&quot; algorithm can       make each node of the final tree has the minimum possible weight       value. </p>     <p>When I found the &quot;top to bottom&quot; algorithm during       preparing the contest, I ever consider changing the problem to       something else because the method is too easy to guess and to       write. But I have no other more proper problem that can be used.       It's a little pity for me.</p></div></div></div>

           
            <pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int SIZE = 1&lt;&lt;20;
int INF = 1000000001;
pair&lt;int, int&gt; a[SIZE];
int final_v[SIZE];
bool used[SIZE];
int h, g;
void pull(int id) {
    while(a[id] &gt; min(a[id&lt;&lt;1], a[(id&lt;&lt;1)|1])) {
        if(a[id&lt;&lt;1] &lt; a[(id &lt;&lt; 1) | 1]) {
            swap(a[id&lt;&lt;1], a[id]);
            id &lt;&lt;= 1;
        }
        else {
            swap(a[(id&lt;&lt;1)|1], a[id]);
            id = (id &lt;&lt; 1) | 1;
        }
        if(id &gt;= (1 &lt;&lt; h)) return;
    }
}
void solve() {
    scanf(&#34;%d%d&#34;, &amp;h, &amp;g);
    long long an = 0;
    for(int i = 1; i &lt; (1 &lt;&lt; h); i++) {
        used[i] = 0;
        scanf(&#34;%d&#34;, &amp;a[i].first);
        a[i].second = i;
        final_v[i] = 0;
    }
    h--;
    for(int lv = h - 1; lv &gt;= 0; lv--) {
        int ll = 1 &lt;&lt; lv;
        int rr = 1 &lt;&lt; (lv + 1);
        for(int i = ll; i &lt; rr; i++) {
            pair&lt;int, int&gt; tmp = a[i];
            int bot = i &lt;&lt; (h - lv);
            a[i] = a[bot];
            a[bot] = make_pair(INF, 0);
            pull(i);
            if(lv &lt; g) {
                int need_mi = max(final_v[i * 2], final_v[i * 2 + 1]);
                while(a[i].first &lt; need_mi) {
                    a[i] = make_pair(INF, 0);
                    pull(i);
                }
                an += final_v[i] = a[i].first;
                used[a[i].second] = 1;
                a[i] = tmp;
                pull(i);
            }
            else {
                a[bot] = tmp;
            }
        }
    }
    printf(&#34;%lld\n&#34;, an);
    bool first_time = true;
    for(int i = (1 &lt;&lt; (h + 1)) - 1; i &gt; 0; i--) {
        if(!used[i]) {
            if(!first_time) printf(&#34; &#34;);
            else first_time = false;
            printf(&#34;%d&#34;, i);
        }
    }
    puts(&#34;&#34;);
}
int main(){
    int T;
    scanf(&#34;%d&#34;, &amp;T);
    while(T--) solve();
    return 0;
}
</code></pre>
           
            <pre><code>//#pragma GCC optimize(&#34;O3&#34;)
#include &lt;bits/stdc++.h&gt;

using namespace std;

//defines
typedef long long ll;
typedef long double ld;
#define TIME clock() * 1.0 / CLOCKS_PER_SEC
#define prev _prev
#define y0 _y0
#define kill _kill

//permanent constants
const ld pi = acos(-1.0);
const int day[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
const int digarr[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};
const int dx[4] = {0, 1, 0, -1};
const int dy[4] = {1, 0, -1, 0};
const int dxo[8] = {-1, -1, -1, 0, 1, 1, 1, 0};
const int dyo[8] = {-1, 0, 1, 1, 1, 0, -1, -1};
const int alf = 26;
const int dig = 10;
const int two = 2;
const int th = 3;
const ll prost = 239;
const ll btc = 30;
const ld eps = 1e-8;
const ll INF = (ll)(1e18 + 239);
const int BIG = (int)(1e9 + 239);
const int MOD = 1e9 + 7; //

//random
mt19937 rnd(239); //(chrono::high_resolution_clock::now().time_since_epoch().count());

//constants
const int M = (int)(2e5 + 239);
const int N = (int)(2e3 + 239);
const int L = 20;
const int T = (1 &lt;&lt; 20) + 239;
const int B = 500;
const int X = 35;
const int T2 = 2 * T;

int h, g, a[T2], n;
bool mark[T];
int id[T], buf[T], timer;

bool cmp(int i, int j)
{
    return (a[i] &lt; a[j]);
}

int pos;

void dfs_write(int p)
{
    id[pos++] = p;
    if (2 * p + 1 &lt;= n)
    {
        dfs_write(2 * p);
        dfs_write(2 * p + 1);
    }
}

int dfs(int p, int sz)
{
    if ((1 &lt;&lt; (g - 1)) &lt;= p &amp;&amp; p &lt; (1 &lt;&lt; g))
    {
        int l = timer;
        timer += sz;
        pos = l;
        dfs_write(p);
        sort(id + l, id + l + sz, cmp);
        mark[id[l]] = true;
        return id[l];
    }
    int l = timer;
    int new_sz = ((sz - 1) / 2);
    int s1 = dfs(2 * p, new_sz);
    int s2 = dfs(2 * p + 1, new_sz);
    merge(id + l, id + l + new_sz, id + l + new_sz, id + l + new_sz + new_sz, buf, cmp);
    buf[sz - 1] = p;
    for (int i = 0; i &lt; sz; i++)
        id[i + l] = buf[i];
    timer++;
    if (cmp(s1, s2))
        s1 = s2;
    for (int i = 0; i &lt; sz; i++)
        if (cmp(s1, id[i + l]))
        {
            mark[id[i + l]] = true;
            return id[i + l];
        }
    return 0;
}

void rm(int i)
{
    if (a[2 * i] == 0 &amp;&amp; a[2 * i + 1] == 0)
    {
        a[i] = 0;
        mark[i] = false;
        return;
    }
    if (a[2 * i] &gt; a[2 * i + 1])
    {
        a[i] = a[2 * i];
        mark[i] = mark[2 * i];
        rm(2 * i);
    }
    else
    {
        a[i] = a[2 * i + 1];
        mark[i] = mark[2 * i + 1];
        rm(2 * i + 1);
    }
}

void dfs_ans(int p)
{
    while (a[p] != 0 &amp;&amp; !mark[p])
    {
        cout &lt;&lt; p &lt;&lt; &#34; &#34;;
        rm(p);
    }
    if (a[p] == 0)
        return;
    dfs_ans(2 * p);
    dfs_ans(2 * p + 1);
}

void solve()
{
    cin &gt;&gt; h &gt;&gt; g;
    n = (1 &lt;&lt; h) - 1;
    for (int i = 1; i &lt;= n; i++)
        cin &gt;&gt; a[i];
    for (int i = 1; i &lt;= n; i++)
        mark[i] = false;
    timer = 0;
    dfs(1, n);
    ll ans = 0;
    for (int i = 1; i &lt;= n; i++)
        if (mark[i])
            ans += a[i];
    cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
    dfs_ans(1);
    cout &lt;&lt; &#34;\n&#34;;
    for (int i = 0; i &lt;= n; i++)
        a[i] = 0;
}

int32_t main()
{
#ifdef ONPC
    freopen(&#34;input&#34;, &#34;r&#34;, stdin);
#endif
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    int t;
    cin &gt;&gt; t;
    while (t--)
        solve();
    return 0;
}
</code></pre>
           
            <pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int SIZE = 1&lt;&lt;20;
int INF = 1000000001;
int a[SIZE], ops[SIZE];
int h, g;
int qq[24], qn;
int pull(int id) {
    int tmp = a[id];
    a[id] = 0;
    qn = 0;
    qq[qn++] = id;
    while(id * 2 &lt; (1 &lt;&lt; h) &amp;&amp; a[id] &lt; max(a[id&lt;&lt;1], a[(id&lt;&lt;1)|1])) {
        if(a[id&lt;&lt;1] &gt; a[(id &lt;&lt; 1) | 1]) {
            swap(a[id&lt;&lt;1], a[id]);
            id &lt;&lt;= 1;
        }
        else {
            swap(a[(id&lt;&lt;1)|1], a[id]);
            id = (id &lt;&lt; 1) | 1;
        }
        qq[qn++] = id;
    }
    if(id &lt; (1 &lt;&lt; g)) {
        for(int i = qn - 1; i &gt; 0; i--) {
            a[qq[i]] = a[qq[i - 1]];
        }
        a[qq[0]] = tmp;
        return 0;
    }
    return tmp;
}
void solve() {
    scanf(&#34;%d%d&#34;, &amp;h, &amp;g);
    long long an = 0;
    for(int i = 1; i &lt; (1 &lt;&lt; h); i++) {
        scanf(&#34;%d&#34;, &amp;a[i]);
        an += a[i];
    }
    int need = 0;
    for(int i = 1; i &lt; (1 &lt;&lt; g); i++) {
        while(1) {
            int v = pull(i);
            if(v) {
                an -= v;
                ops[need++] = i;
            }
            else break;
        }
    }
    printf(&#34;%lld\n&#34;, an);
    for(int i = 0; i &lt; need; i++) printf(&#34;%d%c&#34;, ops[i], &#34; \n&#34;[i == need - 1]);
}
int main(){
    int T;
    scanf(&#34;%d&#34;, &amp;T);
    while(T--) solve();
    return 0;
}
</code></pre>
           
            <pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int SIZE = 1&lt;&lt;20;
int INF = 1000000001;
pair&lt;int, int&gt; a[SIZE];
int final_v[SIZE];
bool used[SIZE];
int h, g;
void pull(int id) {
    while(a[id] &gt; min(a[id&lt;&lt;1], a[(id&lt;&lt;1)|1])) {
        if(a[id&lt;&lt;1] &lt; a[(id &lt;&lt; 1) | 1]) {
            swap(a[id&lt;&lt;1], a[id]);
            id &lt;&lt;= 1;
        }
        else {
            swap(a[(id&lt;&lt;1)|1], a[id]);
            id = (id &lt;&lt; 1) | 1;
        }
        if(id &gt;= (1 &lt;&lt; h)) return;
    }
}
void solve() {
    scanf(&#34;%d%d&#34;, &amp;h, &amp;g);
    long long an = 0;
    for(int i = 1; i &lt; (1 &lt;&lt; h); i++) {
        used[i] = 0;
        scanf(&#34;%d&#34;, &amp;a[i].first);
        a[i].second = i;
        final_v[i] = 0;
    }
    h--;
    for(int lv = h - 1; lv &gt;= 0; lv--) {
        int ll = 1 &lt;&lt; lv;
        int rr = 1 &lt;&lt; (lv + 1);
        for(int i = ll; i &lt; rr; i++) {
            pair&lt;int, int&gt; tmp = a[i];
            int bot = i &lt;&lt; (h - lv);
            a[i] = a[bot];
            a[bot] = make_pair(INF, 0);
            pull(i);
            if(lv &lt; g) {
                int need_mi = max(final_v[i * 2], final_v[i * 2 + 1]);
                while(a[i].first &lt; need_mi) {
                    a[i] = make_pair(INF, 0);
                    pull(i);
                }
                an += final_v[i] = a[i].first;
                used[a[i].second] = 1;
                a[i] = tmp;
                pull(i);
            }
            else {
                a[bot] = tmp;
            }
        }
    }
    printf(&#34;%lld\n&#34;, an);
    bool first_time = true;
    for(int i = (1 &lt;&lt; (h + 1)) - 1; i &gt; 0; i--) {
        if(!used[i]) {
            if(!first_time) printf(&#34; &#34;);
            else first_time = false;
            printf(&#34;%d&#34;, i);
        }
    }
    puts(&#34;&#34;);
}
int main(){
    int T;
    scanf(&#34;%d&#34;, &amp;T);
    while(T--) solve();
    return 0;
}
</code></pre>
           
            <pre><code>//#pragma GCC optimize(&#34;O3&#34;)
#include &lt;bits/stdc++.h&gt;

using namespace std;

//defines
typedef long long ll;
typedef long double ld;
#define TIME clock() * 1.0 / CLOCKS_PER_SEC
#define prev _prev
#define y0 _y0
#define kill _kill

//permanent constants
const ld pi = acos(-1.0);
const int day[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
const int digarr[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};
const int dx[4] = {0, 1, 0, -1};
const int dy[4] = {1, 0, -1, 0};
const int dxo[8] = {-1, -1, -1, 0, 1, 1, 1, 0};
const int dyo[8] = {-1, 0, 1, 1, 1, 0, -1, -1};
const int alf = 26;
const int dig = 10;
const int two = 2;
const int th = 3;
const ll prost = 239;
const ll btc = 30;
const ld eps = 1e-8;
const ll INF = (ll)(1e18 + 239);
const int BIG = (int)(1e9 + 239);
const int MOD = 1e9 + 7; //

//random
mt19937 rnd(239); //(chrono::high_resolution_clock::now().time_since_epoch().count());

//constants
const int M = (int)(2e5 + 239);
const int N = (int)(2e3 + 239);
const int L = 20;
const int T = (1 &lt;&lt; 20) + 239;
const int B = 500;
const int X = 35;
const int T2 = 2 * T;

int h, g, a[T2], n;
bool mark[T];
int id[T], buf[T], timer;

bool cmp(int i, int j)
{
    return (a[i] &lt; a[j]);
}

int pos;

void dfs_write(int p)
{
    id[pos++] = p;
    if (2 * p + 1 &lt;= n)
    {
        dfs_write(2 * p);
        dfs_write(2 * p + 1);
    }
}

int dfs(int p, int sz)
{
    if ((1 &lt;&lt; (g - 1)) &lt;= p &amp;&amp; p &lt; (1 &lt;&lt; g))
    {
        int l = timer;
        timer += sz;
        pos = l;
        dfs_write(p);
        sort(id + l, id + l + sz, cmp);
        mark[id[l]] = true;
        return id[l];
    }
    int l = timer;
    int new_sz = ((sz - 1) / 2);
    int s1 = dfs(2 * p, new_sz);
    int s2 = dfs(2 * p + 1, new_sz);
    merge(id + l, id + l + new_sz, id + l + new_sz, id + l + new_sz + new_sz, buf, cmp);
    buf[sz - 1] = p;
    for (int i = 0; i &lt; sz; i++)
        id[i + l] = buf[i];
    timer++;
    if (cmp(s1, s2))
        s1 = s2;
    for (int i = 0; i &lt; sz; i++)
        if (cmp(s1, id[i + l]))
        {
            mark[id[i + l]] = true;
            return id[i + l];
        }
    return 0;
}

void rm(int i)
{
    if (a[2 * i] == 0 &amp;&amp; a[2 * i + 1] == 0)
    {
        a[i] = 0;
        mark[i] = false;
        return;
    }
    if (a[2 * i] &gt; a[2 * i + 1])
    {
        a[i] = a[2 * i];
        mark[i] = mark[2 * i];
        rm(2 * i);
    }
    else
    {
        a[i] = a[2 * i + 1];
        mark[i] = mark[2 * i + 1];
        rm(2 * i + 1);
    }
}

void dfs_ans(int p)
{
    while (a[p] != 0 &amp;&amp; !mark[p])
    {
        cout &lt;&lt; p &lt;&lt; &#34; &#34;;
        rm(p);
    }
    if (a[p] == 0)
        return;
    dfs_ans(2 * p);
    dfs_ans(2 * p + 1);
}

void solve()
{
    cin &gt;&gt; h &gt;&gt; g;
    n = (1 &lt;&lt; h) - 1;
    for (int i = 1; i &lt;= n; i++)
        cin &gt;&gt; a[i];
    for (int i = 1; i &lt;= n; i++)
        mark[i] = false;
    timer = 0;
    dfs(1, n);
    ll ans = 0;
    for (int i = 1; i &lt;= n; i++)
        if (mark[i])
            ans += a[i];
    cout &lt;&lt; ans &lt;&lt; &#34;\n&#34;;
    dfs_ans(1);
    cout &lt;&lt; &#34;\n&#34;;
    for (int i = 0; i &lt;= n; i++)
        a[i] = 0;
}

int32_t main()
{
#ifdef ONPC
    freopen(&#34;input&#34;, &#34;r&#34;, stdin);
#endif
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    int t;
    cin &gt;&gt; t;
    while (t--)
        solve();
    return 0;
}
</code></pre>
           
            <pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int SIZE = 1&lt;&lt;20;
int INF = 1000000001;
int a[SIZE], ops[SIZE];
int h, g;
int qq[24], qn;
int pull(int id) {
    int tmp = a[id];
    a[id] = 0;
    qn = 0;
    qq[qn++] = id;
    while(id * 2 &lt; (1 &lt;&lt; h) &amp;&amp; a[id] &lt; max(a[id&lt;&lt;1], a[(id&lt;&lt;1)|1])) {
        if(a[id&lt;&lt;1] &gt; a[(id &lt;&lt; 1) | 1]) {
            swap(a[id&lt;&lt;1], a[id]);
            id &lt;&lt;= 1;
        }
        else {
            swap(a[(id&lt;&lt;1)|1], a[id]);
            id = (id &lt;&lt; 1) | 1;
        }
        qq[qn++] = id;
    }
    if(id &lt; (1 &lt;&lt; g)) {
        for(int i = qn - 1; i &gt; 0; i--) {
            a[qq[i]] = a[qq[i - 1]];
        }
        a[qq[0]] = tmp;
        return 0;
    }
    return tmp;
}
void solve() {
    scanf(&#34;%d%d&#34;, &amp;h, &amp;g);
    long long an = 0;
    for(int i = 1; i &lt; (1 &lt;&lt; h); i++) {
        scanf(&#34;%d&#34;, &amp;a[i]);
        an += a[i];
    }
    int need = 0;
    for(int i = 1; i &lt; (1 &lt;&lt; g); i++) {
        while(1) {
            int v = pull(i);
            if(v) {
                an -= v;
                ops[need++] = i;
            }
            else break;
        }
    }
    printf(&#34;%lld\n&#34;, an);
    for(int i = 0; i &lt; need; i++) printf(&#34;%d%c&#34;, ops[i], &#34; \n&#34;[i == need - 1]);
}
int main(){
    int T;
    scanf(&#34;%d&#34;, &amp;T);
    while(T--) solve();
    return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #631 (Div. 1) - Thanks, Denis aramis Shitov!
    1329D
    Dreamoon любит строки </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Dreamoon любит строки</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Dreamoon любит строки. Сегодня он придумал игру про строки:</p>     <p>Строка $$$s_1, s_2, \ldots, s_n$$$ <span class="tex-font-style-bf">красивая</span> если и только если для       всех $$$1 \le i &lt; n, s_i \ne s_{i+1}$$$.</p>     <p>Исходно, у Dreamoon есть строка $$$a$$$. За один ход Dreamoon       может выбрать <span class="tex-font-style-bf">красивую</span>       подстроку $$$a$$$ и удалить ее. Затем он должен сконкатенировать       оставшиеся символы (в правильном порядке).</p>     <p>Dreamoon хочет использовать минимальное число ходов, чтобы       сделать $$$a$$$ пустой. Пожалуйста, помогите Dreamoon, и выведите       любую последовательность, состоящую из минимального числа ходов,       чтобы сделать $$$a$$$ пустой.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано целое число $$$t$$$ ($$$1 \leq t \leq       200\,000$$$), равное количество наборов входных данных.</p>     <p>Каждый набор входных данных содержит одну строку $$$a$$$ из       строчных латинских символов.</p>     <p>Гарантируется, что суммарный размер строк не превосходит $$$200\,000$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных, в первой строке вы должны       вывести $$$m$$$: минимальное количество ходов, чтобы сделать       $$$a$$$ пустой. Каждая из следующих $$$m$$$ строк должна содержать       два целых числа $$$l_i, r_i$$$ ($$$1 \leq l_i \leq r_i \leq       |a|$$$), описывающих, что на $$$i$$$-м шагу нужно удалить символы       с индексами от $$$l_i$$$ до $$$r_i$$$ из исходной строки. (Индексы       пронумерованы начиная с $$$1$$$). </p>     <p>Обратите внимание, что после удаления подстроки, индексы       оставшихся символов могут измениться, и $$$r_i$$$ не должен       превышать текущий размер $$$a$$$.</p>     <p>Если есть несколько возможных решений, вы можете вывести любое.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
aabbcc
aaabbb
aaa
abacad
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
3 3
2 4
1 2
3
3 4
2 3
1 2
3
1 1
1 1
1 1
1
1 6</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1329/problem/D' title='Codeforces Round 631 (Div. 1) - Thanks, Denis aramis Shitov!'>1329D - Dreamoon Likes Strings</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Denoting a string of length two which contains two $$$i$$$-th       letter as $$$t_i$$$. For example, $$$t_0$$$ is &quot;aa&quot;,       $$$t_1$$$ is &quot;bb&quot; . </p>     <p>And let $$$c_i$$$ be the occurrence count of $$$t_i$$$ as a       substring in $$$a$$$. For example, when $$$a =$$$       &quot;aaabbcaa&quot;, $$$c_0 = 3, c_1 = 1$$$, and for other       $$$i$$$, $$$c_i = 0$$$.</p>     <p>In this problem, if only asking contestants output the smallest       number of steps to make $$$a$$$ empty, the answer is simple. You       just need to output $$$\max(\left \lceil\frac{\sum c_i}{2}       \right\rceil,\max_{0 \le i \le 25}\limits{c_i})+1$$$. (I will call       this fomula for a given string $$$a$$$ as $$$f(a)$$$ behind.)</p>     <p>Firstly, let's see how the value of all $$$c_i$$$ change in one       step. There are only four kinds of possible change for all $$$c_i$$$.</p>     <p>1. For some $$$i$$$, $$$c_i$$$ is decreased by one. For example,       deleting the first two letters of &quot;abb&quot;.</p>     <p>2. For two different values $$$i$$$ and $$$j$$$. $$$c_i$$$ and       $$$c_j$$$ are both decrease by one. For example, deleting the       second and third letter of &quot;aabb&quot;.</p>     <p>3. Nothing changes for all $$$c_i$$$. For example, deleting the       first letter from &quot;abb&quot;.</p>     <p>4. For some $$$i$$$, $$$c_i$$$ is added by one. For example,       deleting the second letter from &quot;aba&quot;.</p>     <p>Now, Let's consider how will these changes affect the $$$f(a)$$$.       Amazing! All possible changes will decrease the value of       $$$f(a)$$$ at most one! So if we can construct an algorithm to       achieve it, then we solve it.</p>     <p>Now I introduce an algorithm of which time complexity is $$$O(n)$$$.</p>     <p>The algorithm can be divided into three phases.</p>     <p>1.</p>     <p>In this phase, we maintain a stack that stores the position of       substring $$$t_i$$$ in the current string from left to right. When       we iterate to a string $$$t_i$$$, there are two cases. Assum the       top element in the stack is $$$t_j$$$. When $$$i$$$ is equal to       $$$j$$$, we just add t_i into the stack. But if $$$i \ne j$$$, we       do a step that removing all letters from the second letter of       $$$t_j$$$ to the first letter of $$$t_i$$$. and pop $$$t_j$$$ from       the stack. If there is any moment that $$$\left \lceil\frac{\sum       c_i}{2} \right\rceil \le \max_{0 \le i \le 25}\limits{c_i})+1$$$       is hold (So maybe you won't do anything in this phase), the phase       will be terminated.</p>     <p>2. </p>     <p>In this phase, there must be an unique $$$x$$$ satisifying $$$c_x       \ge \left \lceil\frac{\sum c_i}{2} \right\rceil$$$.</p>     <p>we also maintain a stack that stores the position of substring       $$$t_i$$$ in the current string from left to right. But when we       iterate to a string $$$t_i$$$, the action we should do are       different from the first phase. </p>     <p>Assum the top element in the stack is $$$t_j$$$. When there is       exactly one number among $$$i$$$ and $$$j$$$ is $$$x$$$, we do a       step that removing all letters from the second letter of $$$t_j$$$       to the first letter of $$$t_i$$$. and pop $$$t_j$$$ from the       stack. Otherwise, we just add $$$t_i$$$ into the stack.</p>     <p>3. </p>     <p>When the algorithm enters the phase, for all $$$i$$$ except       $$$x$$$, $$$c_i$$$ will be $$$0$$$. So we can use all occurrence       of $$$t_x$$$ to divide the string into $$$c_x+1$$$ segment and       remove each segment one by on. After that the string will become empty.</p>     <p>Please see the reference code for the implementation detail.</p></div></div></div>

           
            <pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int SIZE = 2e5+10;
char s[SIZE];
int cnt[SIZE];
int cc[26];
int all_cnt;
int ma;
void update_ma() {
    while(ma &gt; 0 &amp;&amp; !cnt[ma]) ma--;
}
void dec1(int id) {
    cnt[cc[id]]--;
    cc[id]--;
    cnt[cc[id]]++;
}
pair&lt;int, int&gt; stk[SIZE];
int sn;
int m;
int now;
int last_len;
void add(int i, bool flag) {
    if(flag) {
        dec1(stk[sn - 1].second);
        dec1(stk[i].second);
        all_cnt -= 2;
        printf(&#34;%d %d\n&#34;,now + 1, now + stk[i].first);
        update_ma();
        sn--;
        now -= stk[sn].first;
        if(i + 1 &lt; m) {
            stk[i + 1].first += stk[sn].first;
        }
        else{
            last_len += stk[sn].first;
        }
    }
    else {
        stk[sn++] = stk[i];
        now += stk[i].first;
    }
}
void solve(){
    scanf(&#34;%s&#34;, s);
    int n = strlen(s);
    all_cnt = 0;
    int lt = 0;
    m = 0;
    for(int i = 1; i &lt; n; i++) {
        if(s[i] == s[i - 1]) {
            cc[s[i] - &#39;a&#39;]++;
            all_cnt++;
            stk[m++] = make_pair(i - lt, (int)(s[i] - &#39;a&#39;));
            lt = i;
        }
    }
    last_len = n - lt;
    ma = 0;
    for(int i = 0; i &lt; 26; i++) {
        cnt[cc[i]]++;
        ma = max(ma, cc[i]);
    }
    printf(&#34;%d\n&#34;, 1 + max(ma, (all_cnt + 1) / 2));
    if(ma * 2 &lt; all_cnt) {
        sn = now = 0;
        for(int i = 0; i &lt; m; i++) {
            add(i, sn &amp;&amp; stk[sn - 1].second != stk[i].second &amp;&amp; ma * 2 &lt; all_cnt);
        }
        m = sn;
    }
    int main_id = -1;
    for(int i = 0; i &lt; 26; i++) {
        if(cc[i] == ma) main_id = i;
    }
    sn = now = 0;
    for(int i = 0; i &lt; m; i++) {
        add(i, sn &amp;&amp; ((stk[sn - 1].second == main_id) ^ (stk[i].second == main_id)));
    }
    for(int i = 0; i &lt; sn; i++) {
        printf(&#34;%d %d\n&#34;,1 ,stk[i].first);
    }
    printf(&#34;%d %d\n&#34;, 1, last_len);
    memset(cc, 0, sizeof(cc));
    memset(cnt, 0, sizeof(int) * (ma + 1));
}
int main(){
    int T;
    scanf(&#34;%d&#34;, &amp;T);
    for(int i = 1; i &lt;= T; i++) solve();
    return 0;
}
</code></pre>
           
            <pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int SIZE = 2e5+10;
char s[SIZE];
int cnt[SIZE];
int cc[26];
int all_cnt;
int ma;
void update_ma() {
    while(ma &gt; 0 &amp;&amp; !cnt[ma]) ma--;
}
void dec1(int id) {
    cnt[cc[id]]--;
    cc[id]--;
    cnt[cc[id]]++;
}
pair&lt;int, int&gt; stk[SIZE];
int sn;
int m;
int now;
int last_len;
void add(int i, bool flag) {
    if(flag) {
        dec1(stk[sn - 1].second);
        dec1(stk[i].second);
        all_cnt -= 2;
        printf(&#34;%d %d\n&#34;,now + 1, now + stk[i].first);
        update_ma();
        sn--;
        now -= stk[sn].first;
        if(i + 1 &lt; m) {
            stk[i + 1].first += stk[sn].first;
        }
        else{
            last_len += stk[sn].first;
        }
    }
    else {
        stk[sn++] = stk[i];
        now += stk[i].first;
    }
}
void solve(){
    scanf(&#34;%s&#34;, s);
    int n = strlen(s);
    all_cnt = 0;
    int lt = 0;
    m = 0;
    for(int i = 1; i &lt; n; i++) {
        if(s[i] == s[i - 1]) {
            cc[s[i] - &#39;a&#39;]++;
            all_cnt++;
            stk[m++] = make_pair(i - lt, (int)(s[i] - &#39;a&#39;));
            lt = i;
        }
    }
    last_len = n - lt;
    ma = 0;
    for(int i = 0; i &lt; 26; i++) {
        cnt[cc[i]]++;
        ma = max(ma, cc[i]);
    }
    printf(&#34;%d\n&#34;, 1 + max(ma, (all_cnt + 1) / 2));
    if(ma * 2 &lt; all_cnt) {
        sn = now = 0;
        for(int i = 0; i &lt; m; i++) {
            add(i, sn &amp;&amp; stk[sn - 1].second != stk[i].second &amp;&amp; ma * 2 &lt; all_cnt);
        }
        m = sn;
    }
    int main_id = -1;
    for(int i = 0; i &lt; 26; i++) {
        if(cc[i] == ma) main_id = i;
    }
    sn = now = 0;
    for(int i = 0; i &lt; m; i++) {
        add(i, sn &amp;&amp; ((stk[sn - 1].second == main_id) ^ (stk[i].second == main_id)));
    }
    for(int i = 0; i &lt; sn; i++) {
        printf(&#34;%d %d\n&#34;,1 ,stk[i].first);
    }
    printf(&#34;%d %d\n&#34;, 1, last_len);
    memset(cc, 0, sizeof(cc));
    memset(cnt, 0, sizeof(int) * (ma + 1));
}
int main(){
    int T;
    scanf(&#34;%d&#34;, &amp;T);
    for(int i = 1; i &lt;= T; i++) solve();
    return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #631 (Div. 1) - Thanks, Denis aramis Shitov!
    1329E
    Dreamoon любит AA </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. Dreamoon любит AA</div>     <div class="time-limit"><div class="property-title">ограничение по времени на       тест</div>3.5 секунд</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Есть строка длины $$$n+1$$$ из символов 'A' и 'B'. Первый и       последний символ в этой строке равны 'A'.</p>     <p>Вам таже дано $$$m$$$ индексов $$$p_1, p_2, \ldots, p_m$$$ (в       $$$0$$$-индексации), описывающих другие позиции символов 'A' в строке.</p>     <p> Обозначим минимальное расстояние между соседними буквами 'A' за       $$$l$$$, а максимальное расстояние между соседними 'A' за $$$r$$$.</p>     <p>Например, $$$(l,r)$$$ строки "ABBAABBBA" равно $$$(1,4)$$$.</p>     <p>Обозначим за <span class="tex-font-style-bf">степень       баланса</span> строки величину $$$r-l$$$.</p>     <p>Теперь Dreamoon хочет изменить ровно $$$k$$$ символов 'B' на 'A',       и он хочет сделать <span class="tex-font-style-bf">степень       баланса</span> строки как можно меньше.</p>     <p>Пожалуйста, найдите минимальное возможное значение степени баланса.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$t$$$, содержащее       количество наборов входных данных ($$$1 \leq t \leq 400\,000$$$).</p>     <p>В каждом наборе входных данных, первая строка содержит три целых       числа $$$n$$$, $$$m$$$ и $$$k$$$ ($$$1 \leq n \leq 10^{15}, 0 \leq       m \leq 400\,000, 0 \leq k &lt; n - m$$$).</p>     <p>Во второй строке записаны $$$m$$$ целых чисел $$$p_1, p_2,       \ldots, p_m$$$, ($$$0 &lt; p_1 &lt; p_2 &lt; \ldots &lt; p_m &lt; n$$$).</p>     <p>Сумма по всем $$$m$$$ не превосходит $$$400\,000$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных, выведите одно целое число:       минимальное возможное значение степени баланса после $$$k$$$       изменений 'B' на 'A'.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
80 3 5
11 24 50
81 7 12
4 10 17 26 37 48 61
25 10 14
3 4 7 12 13 15 17 19 21 23
1 0 0

10 2 0
2 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
5
2
0
0
4
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1329/problem/E' title='Codeforces Round 631 (Div. 1) - Thanks, Denis aramis Shitov!'>1329E - Dreamoon Loves AA</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>The idea of this problem comes to my brain when I recall that I'm       cooking and I want to cut a carrot into many pieces and make the       size of each piece as evenly as possible. I think this problem is       very interesting. So that's why I determine to prepare a       Codeforces contest after so many years. I hope I can share this       problem with as many people as possible. </p>     <p>There are some methods to solve this problem. I only show the       most beautiful one below. This method is given by isaf27 (And most       AC users solve it with this method. I admire them very much).</p>     <p>Firstly, we translate the problem into a more convenient model. </p>     <p>Let $$$p_{m+1} = n$$$, $$$a_i = p_i - p_{i-1}$$$ ($$$1 \le i \le       m+1$$$), $$$M = m + 1$$$, and $$$K = m + 1 + k$$$. Then the       problem is equivalent to we want to do integer partition on       $$$M$$$ integers $$$a_1, a_2, \ldots, a_M$$$, such that $$$a_i$$$       is divided into $$$d_i$$$ positive integers where $$$\sum d_i =       K$$$. Our target is to minimize the difference between the largest       integer and smallest integer after division.</p>     <p>An important observation is, we always can achieve our target by       making the difference of the largest integer and the smallest       integer that is divided from the same integer is at most one. So       our target is minimizing $$$\max_{1 \le i \le       M}\limits{(\left\lceil \frac{a_i}{d_i} \right \rceil)} - \min_{1       \le i \le M}\limits{(\left\lfloor \frac{a_i}{d_i} \right       \rfloor)}$$$ where $$$1 \le d_i$$$ and $$$\sum_{i=1 \sim M}\limits       d_i = K$$$.</p>     <p>There are two key values under the constraints $$$1 \le d_i$$$       and $$$\sum_{i=1 \sim M}\limits d_i = K$$$, one is the minimum       value of $$$\max_{1 \le i \le M}\limits{(\left\lceil       \frac{a_i}{d_i} \right \rceil)}$$$ (Let's call it $$$U$$$ after),       another is the maximum value of $$$\min_{1 \le i \le       M}\limits{(\left\lfloor \frac{a_i}{d_i} \right \rfloor)}$$$ (Let's       call it $$$D$$$ after). $$$L$$$ and $$$U$$$ can be calculated by       binary searching with time complexity $$$O(M log M)$$$. (This part       is relatively easy so I won't mention it here.)</p>     <p>There are two conditions after calculating $$$L$$$ and $$$U$$$.       One is, for all valid $$$i$$$, there exists at least one positive       integer $$$d_i$$$ such that $$$L \le \left\lfloor \frac{a_i}{d_i}       \right \rfloor \le \left\lceil \frac{a_i}{d_i} \right \rceil \le       U$$$. In this case, the answer is just $$$U - L$$$. proof is as below.</p>     <p>Let $$$du_i$$$ as the largest positive integer such that $$$L \le       \left\lfloor \frac{a_i}{d_i} \right \rfloor$$$ and $$$dl_i$$$ as       the smallest positive integer such that $$$\left\lceil       \frac{a_i}{d_i} \right \rceil \le U$$$. By the define of $$$L$$$       and $$$U$$$, we can get $$$\sum\limits_{i=1 \sim M} du_i \ge K$$$       and $$$\sum\limits_{i=1 \sim M} dl_i \le K$$$. So we always can       choose some d_i where $$$d_l \le d_i \le d_u$$$ such that       $$$\sum\limits_{i=1 \sim M} d_i = K$$$ and $$$L \le \left\lfloor       \frac{a_i}{d_i} \right \rfloor \le \left\lceil \frac{a_i}{d_i}       \right \rceil \le U$$$.</p>     <p>Now the essential condition is resolved. Another condition is       there are some indices $$$i$$$ that we cannot find any positive       integer $$$d_i$$$ such that $$$L \le \left\lfloor \frac{a_i}{d_i}       \right \rfloor \le \left\lceil \frac{a_i}{d_i} \right \rceil \le       U$$$. Let's call the set of these indices as $$$I$$$. For each       element $$$j \in I$$$, let's calculate another two key values for       index $$$j$$$. That is, we want to know the closest two values of       $$$\frac{a_j}{d_j}$$$ near to range $$$[L, U]$$$ (one is above       $$$[L,U]$$$ another is below $$$[L,U]$$$). Formulaically say, let       $$$v$$$ be the smallest $$$d_j$$$ such that $$$\left\lfloor       \frac{a_j}{d_j} \right \rfloor &lt; L$$$ and call $$$\left\lfloor       \frac{a_j}{v} \right \rfloor$$$ as $$$x_j$$$. And let $$$u$$$ be       the largest $$$d_j$$$ such that $$$\left\lceil \frac{a_j}{d_j}       \right \rceil &gt; U$$$ and call $$$\left\lceil \frac{a_j}{u}       \right \rceil$$$ as $$$y_j$$$. Imaging we have a set $$$S$$$       initially contains two positive integer $$$L$$$ and $$$U$$$. Now       for each $$$j \in I$$$, we want to choose either $$$x_i$$$ or       $$$y_i$$$ to add to $$$S$$$. Then the minimum possbile value of       difference between largest element and smallest element in $$$S$$$       is the answer in this condition. The minimum possible value can be       calculated as below.</p>     <p>Initially, for all $$$j \in I$$$, we choose $$$y_j$$$ to add to       the set $$$S$$$. Then iterate from largest $$$y_j$$$ to smallest       $$$y_j$$$. In each iteration, we remove $$$y_j$$$ from $$$S$$$ and       add $$$x_j$$$ to $$$S$$$. The minimum possible value will exist       during the process. These steps can also be done in time       complexity $$$O(M log M)$$$.</p>     <p>The proof of correctness of the second condition is almost same       as the first condition. We always can adjust $$$d_i$$$ such that       $$$\sum\limits_{i=1 \sim M} d_i$$$ equal to $$$K$$$ for       constructed result.</p>     <p>The overall time complexity is $$$O(m log m)$$$ for the above method.</p>     <p>In the end, I want to thanks everyone who takes part in this       contest. The worth of the contest will reveal on you, when you       learn thing from these problems. Thanks a lot.</p></div></div></div>

           
            <pre><code>//#pragma GCC optimize(&#34;O3&#34;)
#include &lt;bits/stdc++.h&gt;

using namespace std;

//defines
typedef long long ll;
typedef long double ld;
#define TIME clock() * 1.0 / CLOCKS_PER_SEC
#define prev _prev
#define y0 _y0
#define kill _kill

//permanent constants
const ld pi = acos(-1.0);
const int day[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
const int digarr[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};
const int dx[4] = {0, 1, 0, -1};
const int dy[4] = {1, 0, -1, 0};
const int dxo[8] = {-1, -1, -1, 0, 1, 1, 1, 0};
const int dyo[8] = {-1, 0, 1, 1, 1, 0, -1, -1};
const int alf = 26;
const int dig = 10;
const int two = 2;
const int th = 3;
const ll prost = 239;
const ll btc = 30;
const ld eps = 1e-8;
const ll INF = (ll)(1e18 + 239);
const int BIG = (int)(1e9 + 239);
const int MOD = 1e9 + 7; //

//random
mt19937 rnd(239); //(chrono::high_resolution_clock::now().time_since_epoch().count());

//constants
const int M = (int)(4e5 + 239);
const int N = (int)(2e3 + 239);
const int L = 20;
const int T = (1 &lt;&lt; 18) + 239;
const int B = 500;
const int X = 210;

ll up(ll a, ll b)
{
    return (a + b - 1) / b;
}

ll down(ll a, ll b)
{
    return a / b;
}

int m;
ll l[M], n, k;

void solve()
{
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    ll pr = 0;
    for (int i = 0; i &lt; m; i++)
    {
        ll p;
        cin &gt;&gt; p;
        l[i] = p - pr;
        pr = p;
    }
    l[m++] = n - pr;
    //for (int i = 0; i &lt; m; i++)
    //    cerr &lt;&lt; l[i] &lt;&lt; &#34; &#34;;
    //cerr &lt;&lt; &#34;\n&#34;;
    ll sum = k + m;
    ll bl = 1;
    ll br = n + 1;
    while (br - bl &gt; 1)
    {
        ll h = (bl + br) &gt;&gt; 1LL;
        ll cur = 0;
        for (int i = 0; i &lt; m; i++)
            cur += down(l[i], h);
        if (sum &lt;= cur)
            bl = h;
        else
            br = h;
    }
    ll MIN = bl;
    bl = 0;
    br = n + 1;
    while (br - bl &gt; 1)
    {
        ll h = (bl + br) &gt;&gt; 1LL;
        ll cur = 0;
        for (int i = 0; i &lt; m; i++)
            cur += up(l[i], h);
        if (sum &gt;= cur)
            br = h;
        else
            bl = h;
    }
    ll MAX = br;
    vector&lt;pair&lt;ll, ll&gt;&gt; ban;
    for (int i = 0; i &lt; m; i++)
    {
        if (up(l[i], MAX) &lt;= down(l[i], MIN))
            continue;
        ll bl = 0;
        ll br = MIN;
        while (br - bl &gt; 1)
        {
            ll h = (bl + br) &gt;&gt; 1LL;
            if (down(l[i], h) == down(l[i], MIN))
                br = h;
            else
                bl = h;
        }
        ll first = MIN - br;
        bl = MAX;
        br = INF;
        while (br - bl &gt; 1)
        {
            ll h = (bl + br) &gt;&gt; 1LL;
            if (up(l[i], MAX) == up(l[i], h))
                bl = h;
            else
                br = h;
        }
        ll second = bl - MAX;
        ban.push_back(make_pair(first, second));
    }
    ll add = MAX - MIN;
    if (ban.empty())
    {
        cout &lt;&lt; add &lt;&lt; &#34;\n&#34;;
        return;
    }
    sort(ban.begin(), ban.end());
    vector&lt;pair&lt;ll, ll&gt;&gt; a;
    for (int i = 0; i &lt; (int)ban.size(); i++)
    {
        while (!a.empty() &amp;&amp; a.back().second &lt;= ban[i].second)
            a.pop_back();
        a.push_back(ban[i]);
    }
    ll ans = INF;
    ans = min(a[0].second + 1, ans);
    ans = min(a.back().first + 1, ans);
    for (int i = 0; i + 1 &lt; (int)a.size(); i++)
        ans = min(ans, a[i].first + a[i + 1].second + 2);
    cout &lt;&lt; ans + add &lt;&lt; &#34;\n&#34;;
}

int32_t main()
{
#ifdef ONPC
    freopen(&#34;input&#34;, &#34;r&#34;, stdin);
#endif
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    int t;
    cin &gt;&gt; t;
    while (t--)
        solve();
    return 0;
}

</code></pre>
           
            <pre><code>/*{{{*/
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;sstream&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#include&lt;bitset&gt;
#include&lt;vector&gt;
#include&lt;limits.h&gt;
#include&lt;assert.h&gt;
#define SZ(X) ((int)(X).size())
#define ALL(X) (X).begin(), (X).end()
#define REP(I, N) for (int I = 0; I &lt; (N); ++I)
#define REPP(I, A, B) for (int I = (A); I &lt; (B); ++I)
#define FOR(I, A, B) for (int I = (A); I &lt;= (B); ++I)
#define FORS(I, S) for (int I = 0; S[I]; ++I)
#define RS(X) scanf(&#34;%s&#34;, (X))
#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))
#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())
#define CASET int ___T; scanf(&#34;%d&#34;, &amp;___T); for(int cs=1;cs&lt;=___T;cs++)
#define MP make_pair
#define PB push_back
#define MS0(X) memset((X), 0, sizeof((X)))
#define MS1(X) memset((X), -1, sizeof((X)))
#define LEN(X) strlen(X)
#define F first
#define S second
using namespace std;
typedef long long LL;
typedef unsigned long long ULL;
typedef long double LD;
typedef pair&lt;int,int&gt; PII;
typedef vector&lt;int&gt; VI;
typedef vector&lt;LL&gt; VL;
typedef vector&lt;PII&gt; VPII;
typedef pair&lt;LL,LL&gt; PLL;
typedef vector&lt;PLL&gt; VPLL;
template&lt;class T&gt; void _R(T &amp;x) { cin &gt;&gt; x; }
void _R(int &amp;x) { scanf(&#34;%d&#34;, &amp;x); }
void _R(LL &amp;x) { scanf(&#34;%lld&#34;, &amp;x); }
void _R(double &amp;x) { scanf(&#34;%lf&#34;, &amp;x); }
void _R(char &amp;x) { scanf(&#34; %c&#34;, &amp;x); }
void _R(char *x) { scanf(&#34;%s&#34;, x); }
void R() {}
template&lt;class T, class... U&gt; void R(T &amp;head, U &amp;... tail) { _R(head); R(tail...); }
template&lt;class T&gt; void _W(const T &amp;x) { cout &lt;&lt; x; }
void _W(const int &amp;x) { printf(&#34;%d&#34;, x); }
void _W(const LL &amp;x) { printf(&#34;%lld&#34;, x); }
void _W(const double &amp;x) { printf(&#34;%.16f&#34;, x); }
void _W(const char &amp;x) { putchar(x); }
void _W(const char *x) { printf(&#34;%s&#34;, x); }
template&lt;class T,class U&gt; void _W(const pair&lt;T,U&gt; &amp;x) {_W(x.F); putchar(&#39; &#39;); _W(x.S);}
template&lt;class T&gt; void _W(const vector&lt;T&gt; &amp;x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(&#39; &#39;); }
void W() {}
template&lt;class T, class... U&gt; void W(const T &amp;head, const U &amp;... tail) { _W(head); putchar(sizeof...(tail) ? &#39; &#39; : &#39;\n&#39;); W(tail...); }
#ifdef HOME
 #define DEBUG(...) {printf(&#34;# &#34;);printf(__VA_ARGS__);puts(&#34;&#34;);}
#else
 #define DEBUG(...)
#endif
int MOD = 1e9+7;
void ADD(LL&amp; x,LL v){x=(x+v)%MOD;if(x&lt;0)x+=MOD;}
/*}}}*/
const int SIZE = 1e6+10;
LL a[SIZE],num[SIZE];
bool done[SIZE],be_added[SIZE];
int n;
LL K;
LL get_upper_bound(int i){
    LL v=a[i]/num[i];
    if(v*num[i]!=a[i])v++;
    return v;
}
LL get_next_upper_bound(int i){
    LL v=a[i]/(num[i]-1);
    if(v*(num[i]-1)!=a[i])v++;
    return v;
}
LL go(){
    if(K==n){
        return a[n-1]-a[0];
    }
    LL ll=1,rr=a[n-1];
    while(ll&lt;rr){
        LL mm=(ll+rr)/2;
        LL need=0;
        REP(i,n){
            if(a[i]&gt;mm)need+=a[i]/mm;
            else need++;
        }
        if(need&gt;=K)ll=mm+1;
        else rr=mm;
    }
    LL low=ll;
    VPLL pp;
    LL need=0;
    REP(i,n){
        if(a[i]&gt;=low){
            num[i]=a[i]/low;
            pp.PB({a[i]/(num[i]+1),i});
        }
        else {
            num[i]=1;
        }
        need+=num[i];
    }
    {
        bool fail=0;
        REP(i,n){
            if(get_upper_bound(i)&gt;=low){
                fail=1;
                break;
            }
        }
        if(!fail) return low-1-min(low-1,a[0]);
    }
    REP(i,n){
        if(a[i]&gt;=low&amp;&amp;a[i]/(num[i]+1)==low-1){
            LL v=a[i]/(low-1);
            LL mi=min(v-num[i],K-need);
            num[i]+=mi;
            need+=mi;
            if(need==K)break;
        }
    }
    priority_queue&lt;PLL,VPLL,greater&lt;PLL&gt;&gt;added;
    priority_queue&lt;PLL&gt;top;
    LL mi=a[0];
    REP(i,n){
        if(num[i]&gt;1){
            added.push(MP(get_next_upper_bound(i),i));
        }
        top.push(MP(get_upper_bound(i),i));
        mi=min(mi,a[i]/num[i]);
    }
    LL an=top.top().F-mi;
    REP(i,n)be_added[i]=done[i]=0;
    LL ma=low-1;
    while(!top.empty()&amp;&amp;!added.empty()){
        int id=top.top().S;
        if(be_added[id])break;
        done[id]=1;
        top.pop();
        num[id]++;
        mi=min(mi,a[id]/num[id]);
        auto tmp=added.top();
        added.pop();
        if(done[tmp.S])break;
        be_added[tmp.S]=1;
        num[tmp.S]--;
        if(num[tmp.S]&gt;1)added.push({get_next_upper_bound(tmp.S),tmp.S});
        ma=max(ma,tmp.F);
        an=min(an,(top.empty()?ma:max(ma,top.top().F))-mi);
    }
    return an;
}
void solve(){
    LL L;
    //R(n,K,L);
    R(L,n,K);
    K+=n+1;
    LL lt=0;
    REP(i,n){
        LL x;
        R(x);
        a[i]=x-lt;
        lt=x;
    }
    a[n++]=L-lt;
    sort(a,a+n);
    W(go());
}
int main(){
    CASET{
        solve();
    }
    return 0;
}
</code></pre>
           
            <pre><code>//#pragma GCC optimize(&#34;O3&#34;)
#include &lt;bits/stdc++.h&gt;

using namespace std;

//defines
typedef long long ll;
typedef long double ld;
#define TIME clock() * 1.0 / CLOCKS_PER_SEC
#define prev _prev
#define y0 _y0
#define kill _kill

//permanent constants
const ld pi = acos(-1.0);
const int day[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
const int digarr[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};
const int dx[4] = {0, 1, 0, -1};
const int dy[4] = {1, 0, -1, 0};
const int dxo[8] = {-1, -1, -1, 0, 1, 1, 1, 0};
const int dyo[8] = {-1, 0, 1, 1, 1, 0, -1, -1};
const int alf = 26;
const int dig = 10;
const int two = 2;
const int th = 3;
const ll prost = 239;
const ll btc = 30;
const ld eps = 1e-8;
const ll INF = (ll)(1e18 + 239);
const int BIG = (int)(1e9 + 239);
const int MOD = 1e9 + 7; //

//random
mt19937 rnd(239); //(chrono::high_resolution_clock::now().time_since_epoch().count());

//constants
const int M = (int)(4e5 + 239);
const int N = (int)(2e3 + 239);
const int L = 20;
const int T = (1 &lt;&lt; 18) + 239;
const int B = 500;
const int X = 210;

ll up(ll a, ll b)
{
    return (a + b - 1) / b;
}

ll down(ll a, ll b)
{
    return a / b;
}

int m;
ll l[M], n, k;

void solve()
{
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    ll pr = 0;
    for (int i = 0; i &lt; m; i++)
    {
        ll p;
        cin &gt;&gt; p;
        l[i] = p - pr;
        pr = p;
    }
    l[m++] = n - pr;
    //for (int i = 0; i &lt; m; i++)
    //    cerr &lt;&lt; l[i] &lt;&lt; &#34; &#34;;
    //cerr &lt;&lt; &#34;\n&#34;;
    ll sum = k + m;
    ll bl = 1;
    ll br = n + 1;
    while (br - bl &gt; 1)
    {
        ll h = (bl + br) &gt;&gt; 1LL;
        ll cur = 0;
        for (int i = 0; i &lt; m; i++)
            cur += down(l[i], h);
        if (sum &lt;= cur)
            bl = h;
        else
            br = h;
    }
    ll MIN = bl;
    bl = 0;
    br = n + 1;
    while (br - bl &gt; 1)
    {
        ll h = (bl + br) &gt;&gt; 1LL;
        ll cur = 0;
        for (int i = 0; i &lt; m; i++)
            cur += up(l[i], h);
        if (sum &gt;= cur)
            br = h;
        else
            bl = h;
    }
    ll MAX = br;
    vector&lt;pair&lt;ll, ll&gt;&gt; ban;
    for (int i = 0; i &lt; m; i++)
    {
        if (up(l[i], MAX) &lt;= down(l[i], MIN))
            continue;
        ll bl = 0;
        ll br = MIN;
        while (br - bl &gt; 1)
        {
            ll h = (bl + br) &gt;&gt; 1LL;
            if (down(l[i], h) == down(l[i], MIN))
                br = h;
            else
                bl = h;
        }
        ll first = MIN - br;
        bl = MAX;
        br = INF;
        while (br - bl &gt; 1)
        {
            ll h = (bl + br) &gt;&gt; 1LL;
            if (up(l[i], MAX) == up(l[i], h))
                bl = h;
            else
                br = h;
        }
        ll second = bl - MAX;
        ban.push_back(make_pair(first, second));
    }
    ll add = MAX - MIN;
    if (ban.empty())
    {
        cout &lt;&lt; add &lt;&lt; &#34;\n&#34;;
        return;
    }
    sort(ban.begin(), ban.end());
    vector&lt;pair&lt;ll, ll&gt;&gt; a;
    for (int i = 0; i &lt; (int)ban.size(); i++)
    {
        while (!a.empty() &amp;&amp; a.back().second &lt;= ban[i].second)
            a.pop_back();
        a.push_back(ban[i]);
    }
    ll ans = INF;
    ans = min(a[0].second + 1, ans);
    ans = min(a.back().first + 1, ans);
    for (int i = 0; i + 1 &lt; (int)a.size(); i++)
        ans = min(ans, a[i].first + a[i + 1].second + 2);
    cout &lt;&lt; ans + add &lt;&lt; &#34;\n&#34;;
}

int32_t main()
{
#ifdef ONPC
    freopen(&#34;input&#34;, &#34;r&#34;, stdin);
#endif
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    int t;
    cin &gt;&gt; t;
    while (t--)
        solve();
    return 0;
}

</code></pre>
           
            <pre><code>/*{{{*/
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;sstream&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#include&lt;bitset&gt;
#include&lt;vector&gt;
#include&lt;limits.h&gt;
#include&lt;assert.h&gt;
#define SZ(X) ((int)(X).size())
#define ALL(X) (X).begin(), (X).end()
#define REP(I, N) for (int I = 0; I &lt; (N); ++I)
#define REPP(I, A, B) for (int I = (A); I &lt; (B); ++I)
#define FOR(I, A, B) for (int I = (A); I &lt;= (B); ++I)
#define FORS(I, S) for (int I = 0; S[I]; ++I)
#define RS(X) scanf(&#34;%s&#34;, (X))
#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))
#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())
#define CASET int ___T; scanf(&#34;%d&#34;, &amp;___T); for(int cs=1;cs&lt;=___T;cs++)
#define MP make_pair
#define PB push_back
#define MS0(X) memset((X), 0, sizeof((X)))
#define MS1(X) memset((X), -1, sizeof((X)))
#define LEN(X) strlen(X)
#define F first
#define S second
using namespace std;
typedef long long LL;
typedef unsigned long long ULL;
typedef long double LD;
typedef pair&lt;int,int&gt; PII;
typedef vector&lt;int&gt; VI;
typedef vector&lt;LL&gt; VL;
typedef vector&lt;PII&gt; VPII;
typedef pair&lt;LL,LL&gt; PLL;
typedef vector&lt;PLL&gt; VPLL;
template&lt;class T&gt; void _R(T &amp;x) { cin &gt;&gt; x; }
void _R(int &amp;x) { scanf(&#34;%d&#34;, &amp;x); }
void _R(LL &amp;x) { scanf(&#34;%lld&#34;, &amp;x); }
void _R(double &amp;x) { scanf(&#34;%lf&#34;, &amp;x); }
void _R(char &amp;x) { scanf(&#34; %c&#34;, &amp;x); }
void _R(char *x) { scanf(&#34;%s&#34;, x); }
void R() {}
template&lt;class T, class... U&gt; void R(T &amp;head, U &amp;... tail) { _R(head); R(tail...); }
template&lt;class T&gt; void _W(const T &amp;x) { cout &lt;&lt; x; }
void _W(const int &amp;x) { printf(&#34;%d&#34;, x); }
void _W(const LL &amp;x) { printf(&#34;%lld&#34;, x); }
void _W(const double &amp;x) { printf(&#34;%.16f&#34;, x); }
void _W(const char &amp;x) { putchar(x); }
void _W(const char *x) { printf(&#34;%s&#34;, x); }
template&lt;class T,class U&gt; void _W(const pair&lt;T,U&gt; &amp;x) {_W(x.F); putchar(&#39; &#39;); _W(x.S);}
template&lt;class T&gt; void _W(const vector&lt;T&gt; &amp;x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(&#39; &#39;); }
void W() {}
template&lt;class T, class... U&gt; void W(const T &amp;head, const U &amp;... tail) { _W(head); putchar(sizeof...(tail) ? &#39; &#39; : &#39;\n&#39;); W(tail...); }
#ifdef HOME
 #define DEBUG(...) {printf(&#34;# &#34;);printf(__VA_ARGS__);puts(&#34;&#34;);}
#else
 #define DEBUG(...)
#endif
int MOD = 1e9+7;
void ADD(LL&amp; x,LL v){x=(x+v)%MOD;if(x&lt;0)x+=MOD;}
/*}}}*/
const int SIZE = 1e6+10;
LL a[SIZE],num[SIZE];
bool done[SIZE],be_added[SIZE];
int n;
LL K;
LL get_upper_bound(int i){
    LL v=a[i]/num[i];
    if(v*num[i]!=a[i])v++;
    return v;
}
LL get_next_upper_bound(int i){
    LL v=a[i]/(num[i]-1);
    if(v*(num[i]-1)!=a[i])v++;
    return v;
}
LL go(){
    if(K==n){
        return a[n-1]-a[0];
    }
    LL ll=1,rr=a[n-1];
    while(ll&lt;rr){
        LL mm=(ll+rr)/2;
        LL need=0;
        REP(i,n){
            if(a[i]&gt;mm)need+=a[i]/mm;
            else need++;
        }
        if(need&gt;=K)ll=mm+1;
        else rr=mm;
    }
    LL low=ll;
    VPLL pp;
    LL need=0;
    REP(i,n){
        if(a[i]&gt;=low){
            num[i]=a[i]/low;
            pp.PB({a[i]/(num[i]+1),i});
        }
        else {
            num[i]=1;
        }
        need+=num[i];
    }
    {
        bool fail=0;
        REP(i,n){
            if(get_upper_bound(i)&gt;=low){
                fail=1;
                break;
            }
        }
        if(!fail) return low-1-min(low-1,a[0]);
    }
    REP(i,n){
        if(a[i]&gt;=low&amp;&amp;a[i]/(num[i]+1)==low-1){
            LL v=a[i]/(low-1);
            LL mi=min(v-num[i],K-need);
            num[i]+=mi;
            need+=mi;
            if(need==K)break;
        }
    }
    priority_queue&lt;PLL,VPLL,greater&lt;PLL&gt;&gt;added;
    priority_queue&lt;PLL&gt;top;
    LL mi=a[0];
    REP(i,n){
        if(num[i]&gt;1){
            added.push(MP(get_next_upper_bound(i),i));
        }
        top.push(MP(get_upper_bound(i),i));
        mi=min(mi,a[i]/num[i]);
    }
    LL an=top.top().F-mi;
    REP(i,n)be_added[i]=done[i]=0;
    LL ma=low-1;
    while(!top.empty()&amp;&amp;!added.empty()){
        int id=top.top().S;
        if(be_added[id])break;
        done[id]=1;
        top.pop();
        num[id]++;
        mi=min(mi,a[id]/num[id]);
        auto tmp=added.top();
        added.pop();
        if(done[tmp.S])break;
        be_added[tmp.S]=1;
        num[tmp.S]--;
        if(num[tmp.S]&gt;1)added.push({get_next_upper_bound(tmp.S),tmp.S});
        ma=max(ma,tmp.F);
        an=min(an,(top.empty()?ma:max(ma,top.top().F))-mi);
    }
    return an;
}
void solve(){
    LL L;
    //R(n,K,L);
    R(L,n,K);
    K+=n+1;
    LL lt=0;
    REP(i,n){
        LL x;
        R(x);
        a[i]=x-lt;
        lt=x;
    }
    a[n++]=L-lt;
    sort(a,a+n);
    W(go());
}
int main(){
    CASET{
        solve();
    }
    return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #631 (Div. 2) - Thanks, Denis aramis Shitov!
    1330A
    Dreamoon и сбор мест </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Dreamoon и сбор мест</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Dreamoon — большой фанат соревнований на Codeforces!</p>     <p>Однажды, он сказал, что соберет все места от $$$1$$$ до $$$54$$$       после двух следующих рейтинговых контестов. Это удивительно!</p>     <p>Вдохновившись его высказыванием, вы придумали следующую задачу:</p>     <p>Есть человек, который принял участие в $$$n$$$ раундах на       Codeforces. Его место на первом раунде — $$$a_1$$$, его место на       втором раунде — $$$a_2$$$, ..., его место на $$$n$$$-м раунде — $$$a_n$$$.</p>     <p>Вам дано положительное целое число $$$x$$$.</p>     <p>Пожалуйста, найдите наибольшее такое $$$v$$$, что этот человек       сможет собрать все места от $$$1$$$ до $$$v$$$ спустя $$$x$$$       следующих рейтинговых контестов.</p>     <p>Другими словами, вам нужно найти наибольшее $$$v$$$, что возможно       такое, что после $$$x$$$ следующих контестов, для каждого $$$1       \leq i \leq v$$$, будет существовать контест, в котором он занял       $$$i$$$-е место.</p>     <p>Например, если $$$n=6$$$, $$$x=2$$$ и $$$a=[3,1,1,5,7,10]$$$, то       ответ $$$v=5$$$, так как, если занятые места в двух следующих       раундах будут $$$2$$$ и $$$4$$$, то будут собраны все места от       $$$1$$$ до $$$5$$$, то есть можно получить $$$v=5$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$t$$$ ($$$1 \leq t       \leq 5$$$): количество наборов входных данных.</p>     <p>В первой строке каждого набора входных данных написано два целых       числа $$$n, x$$$ ($$$1 \leq n, x \leq 100$$$).</p>     <p>В следующей строке набора записано $$$n$$$ положительных целых       чисел $$$a_1, a_2, \ldots, a_n$$$ ($$$1 \leq a_i \leq 100$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных, выведите наибольшее $$$v$$$,       что возможно такое, что после $$$x$$$ других контестов, для       каждого $$$1 \leq i \leq v$$$, будет существовать контест, в       котором он занял $$$i$$$-е место.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
6 2
3 1 1 5 7 10
1 100
100
11 1
1 1 1 1 1 1 1 1 1 1 1
1 1
1
4 57
80 60 40 20
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
5
101
2
2
60
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Первый набор входных данных разобран в условии.</p>     <p>Во втором наборе входных данных, у человека есть сто будущих       контестов, так что он может занять места $$$1,2,\ldots,99$$$ и       место $$$101$$$ на них в каком-то порядке, чтобы собрать места $$$1,2,\ldots,101$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1330/problem/A' title='Codeforces Round 631 (Div. 2) - Thanks, Denis aramis Shitov!'>1330A - Dreamoon and Ranking Collection</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>The total number of rounds this person participates after $$$x$$$       more rated contests is $$$n+x$$$. So the number of places this       person collects cannot exceed $$$n + x$$$. Then we can iterate       $$$k$$$ from $$$n+x$$$ to $$$1$$$. In each iteration, let $$$r$$$       be the number of integers from $$$1$$$ to $$$k$$$ which doesn't       appear in $$$a_i$$$. This person can collect all places from       $$$1$$$ to $$$k$$$ if only if $$$r \le x$$$. So the answer is the       first $$$k$$$ meeting the condition $$$r \le x$$$ when iterating.       The solution can be implemented in time complexity       $$$O((n+x)^2)$$$ as a reference solution.</p>     <p>There are also many $$$O(n)$$$ solutions that can solve this       problem. But in the experience of author and testers, it's easy to       make some mistake in the detail when writing $$$O(n)$$$ solution :       ) Please try it by yourself.</p></div></div></div>

           
            <pre><code>#include&lt;cstdio&gt;
const int MAX_V = 201;
bool achieve[MAX_V];
void solve() {
    int n, x;
    scanf(&#34;%d%d&#34;, &amp;n, &amp;x);
    for(int i = 1; i &lt;= n + x; i++) {
        achieve[i] = false;
    }
    for(int i = 1; i &lt;= n; i++) {
        int ranking;
        scanf(&#34;%d&#34;, &amp;ranking);
        achieve[ranking] = true;
    }
    for(int k = n + x; k &gt; 0; k--) {
        int v = 0;
        for(int i = 1; i &lt;= k; i++) {
            if(!achieve[i]) v++;
        }
        if(v &lt;= x) {
            printf(&#34;%d\n&#34;, k);
            return;
        }
    }
}
int main() {
    int T;
    scanf(&#34;%d&#34;, &amp;T);
    while(T--) solve();
    return 0;
}
</code></pre>
           
            <pre><code>#include&lt;cstdio&gt;
const int MAX_V = 201;
bool achieve[MAX_V];
void solve() {
    int n, x;
    scanf(&#34;%d%d&#34;, &amp;n, &amp;x);
    for(int i = 1; i &lt;= n + x; i++) {
        achieve[i] = false;
    }
    for(int i = 1; i &lt;= n; i++) {
        int ranking;
        scanf(&#34;%d&#34;, &amp;ranking);
        achieve[ranking] = true;
    }
    for(int k = n + x; k &gt; 0; k--) {
        int v = 0;
        for(int i = 1; i &lt;= k; i++) {
            if(!achieve[i]) v++;
        }
        if(v &lt;= x) {
            printf(&#34;%d\n&#34;, k);
            return;
        }
    }
}
int main() {
    int T;
    scanf(&#34;%d&#34;, &amp;T);
    while(T--) solve();
    return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #631 (Div. 2) - Thanks, Denis aramis Shitov!
    1330B
    Dreamoon любит перестановки </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Dreamoon любит перестановки</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Последовательность из $$$m$$$ целых чисел называется <span class="tex-font-style-it">перестановкой</span>, если она содержит       все целые числа от $$$1$$$ до $$$m$$$ ровно один раз. Число       $$$m$$$ называется длиной перестановки.</p>     <p>У Dreamoon есть две перестановки $$$p_1$$$ и $$$p_2$$$ имеющих       ненулевые длины $$$l_1$$$ и $$$l_2$$$.</p>     <p>Затем, Dreamoon конкатенирует эти две перестановки в       последовательность $$$a$$$ длины $$$l_1 + l_2$$$. Первые $$$l_1$$$       элементов $$$a$$$ это перестановка $$$p_1$$$ а следующие $$$l_2$$$       элементов $$$a$$$ это перестановка $$$p_2$$$. </p>     <p>Вам дана последовательность $$$a$$$, вам нужно найти восстановить       перестановки $$$p_1$$$ и $$$p_2$$$. Если есть несколько возможных       способов, вам нужно найти все. (Обратите внимание, что также       возможно, что способов не будет.)</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано целое число $$$t$$$ ($$$1 \le t \le       10\,000$$$): количество наборов входных данных.</p>     <p>Каждый набор входных данных описывается двумя строками.</p>     <p>В первой строке записано целое число $$$n$$$ ($$$2 \leq n \leq       200\,000$$$): длина $$$a$$$.</p>     <p>Во второй строке записано $$$n$$$ целых чисел $$$a_1, a_2,       \ldots, a_n$$$ ($$$1 \leq a_i \leq n-1$$$).</p>     <p>Сумма по всем $$$n$$$ не превосходит $$$200\,000$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных, в первой строке требуется       вывести число $$$k$$$: количество способов разбить $$$a$$$ на       перестановки $$$p_1$$$ и $$$p_2$$$.</p>     <p>Каждая из следующих $$$k$$$ строк должна содержать два целых       числа $$$l_1$$$ и $$$l_2$$$ ($$$1 \leq l_1, l_2 \leq n, l_1 + l_2       = n$$$), обозначающих, что $$$a$$$ можно разбить на две       перестановки длин $$$l_1$$$ и $$$l_2$$$ ($$$p_1$$$ это первые       $$$l_1$$$ элементов $$$a$$$, а $$$p_2$$$ это последние $$$l_2$$$       элементов $$$a$$$). Вы можете выводить решения в любом порядке.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
5
1 4 3 2 1
6
2 4 1 3 2 1
4
2 1 1 3
4
1 3 3 1
12
2 1 3 4 5 6 7 8 9 1 10 2
3
1 1 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
1 4
4 1
1
4 2
0
0
1
2 10
0
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере, есть два возможных способа разбить $$$a$$$ на       перестановки: $$$\{1\} + \{4, 3, 2, 1\}$$$ and $$$\{1,4,3,2\} + \{1\}$$$.</p>     <p>Во втором примере, есть только один способ разбить $$$a$$$ на       перестановки: $$$\{2,4,1,3\} + \{2,1\}$$$.</p>     <p>В третьем примере, нет ни одного искомого разбиения.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1330/problem/B' title='Codeforces Round 631 (Div. 2) - Thanks, Denis aramis Shitov!'>1330B - Dreamoon Likes Permutations</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let $$$ma$$$ be the maximum value of all elements in $$$a$$$ . </p>     <p>If you can recover the the array $$$a$$$ to two permutations       $$$p1$$$ abd $$$p2$$$, then $$$ma$$$ must be $$$\max(len1,       len2)$$$. </p>     <p>So there are at most two case: </p>     <p>1. $$$len1 = ma, len2 = n - ma$$$, </p>     <p>2. $$$len1 = n - ma, len2 = ma$$$. </p>     <p>We can check the two cases separately with time complexity       $$$O(n)$$$. Please see the example code for detail. </p></div></div></div>

           
            <pre><code>#include&lt;cstdio&gt;
const int SIZE = 200000;
int p[SIZE];
int ans[SIZE][2];
int ans_cnt;
bool judge(int a[], int n){
    static int used[SIZE+1];
    for(int i = 1; i &lt;= n; i++) used[i] = 0;
    for(int i = 0; i &lt; n; i++) used[a[i]] = 1;
    for(int i = 1; i &lt;= n; i++) {
        if(!used[i]) return 0;
    }
    return 1;
}
bool judge(int len1, int n){
    return judge(p, len1) &amp;&amp; judge(p + len1, n - len1);
}
int main() {
    int t = 0;
    scanf(&#34;%d&#34;, &amp;t);
    while(t--) {
        ans_cnt = 0;
        int n;
        scanf(&#34;%d&#34;, &amp;n);
        int ma=0;
        for(int i = 0; i &lt; n; i++) {
            scanf(&#34;%d&#34;, &amp;p[i]);
            if(ma &lt; p[i]) ma = p[i];
        }
        if(judge(n - ma,n)) {
            ans[ans_cnt][0] = n - ma;
            ans[ans_cnt++][1] = ma;
        }
        if(ma * 2 != n &amp;&amp; judge(ma,n)) {
            ans[ans_cnt][0] = ma;
            ans[ans_cnt++][1] = n - ma;
        }
        printf(&#34;%d\n&#34;, ans_cnt);
        for(int i = 0; i &lt; ans_cnt; i++) {
            printf(&#34;%d %d\n&#34;, ans[i][0], ans[i][1]);
        }
    }
    return 0;
}
</code></pre>
           
            <pre><code>#include&lt;cstdio&gt;
const int SIZE = 200000;
int p[SIZE];
int ans[SIZE][2];
int ans_cnt;
bool judge(int a[], int n){
    static int used[SIZE+1];
    for(int i = 1; i &lt;= n; i++) used[i] = 0;
    for(int i = 0; i &lt; n; i++) used[a[i]] = 1;
    for(int i = 1; i &lt;= n; i++) {
        if(!used[i]) return 0;
    }
    return 1;
}
bool judge(int len1, int n){
    return judge(p, len1) &amp;&amp; judge(p + len1, n - len1);
}
int main() {
    int t = 0;
    scanf(&#34;%d&#34;, &amp;t);
    while(t--) {
        ans_cnt = 0;
        int n;
        scanf(&#34;%d&#34;, &amp;n);
        int ma=0;
        for(int i = 0; i &lt; n; i++) {
            scanf(&#34;%d&#34;, &amp;p[i]);
            if(ma &lt; p[i]) ma = p[i];
        }
        if(judge(n - ma,n)) {
            ans[ans_cnt][0] = n - ma;
            ans[ans_cnt++][1] = ma;
        }
        if(ma * 2 != n &amp;&amp; judge(ma,n)) {
            ans[ans_cnt][0] = ma;
            ans[ans_cnt++][1] = n - ma;
        }
        printf(&#34;%d\n&#34;, ans_cnt);
        for(int i = 0; i &lt; ans_cnt; i++) {
            printf(&#34;%d %d\n&#34;, ans[i][0], ans[i][1]);
        }
    }
    return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #630 (Div. 2)
    1332A
    Прогулка </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Прогулка</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У Алисы есть миленькая кошечка. Чтобы кошка была в форме, Алиса       хочет спланировать маршрут для прогулки кошки.</p>     <p>Изначально, кошка Алиса находится в ячейке $$$(x,y)$$$ на       бесконечном клетчатом поле. По теории Алисы кошка должна пройти: </p>     <ul> <li> ровно $$$a$$$ шагов влево: из $$$(u,v)$$$ в $$$(u-1,v)$$$; </li>       <li> ровно $$$b$$$ шагов вправо: из $$$(u,v)$$$ в $$$(u+1,v)$$$; </li>       <li> ровно $$$c$$$ шагов вниз: из $$$(u,v)$$$ в $$$(u,v-1)$$$; </li>       <li> ровно $$$d$$$ шагов вверх: из $$$(u,v)$$$ в $$$(u,v+1)$$$. </li></ul>          <p>Обратите внимание, что шаги можно делать в <span class="tex-font-style-bf">произвольном порядке</span>. Например,       если кошка должна сделать $$$1$$$ шаг влево, $$$3$$$ шага вправо и       $$$2$$$ шага вниз, то маршрут вправо, вниз, влево, вправо, вправо,       вниз корректный.</p>     <p>С другой стороны, Алиса волнуется, что кошка может потеряться,       если уйдет очень далеко от нее. Поэтому она надеется, что ее кошка         <span class="tex-font-style-bf">всегда</span> находится в       области $$$[x_1,x_2]\times [y_1,y_2]$$$, то есть для любой позиции       $$$(u,v)$$$ маршрута выполняется $$$x_1 \le u \le x_2$$$ и $$$y_1       \le v \le y_2$$$.</p>     <p>Также обратите внимание, что кошка может посещать одну и ту же       клетку несколько раз.</p>     <p>Помогите Алисе понять, существует ли маршрут, который       удовлетворяет ее желаниям.</p>     <p>Формально, путь должен состоять ровно из $$$a+b+c+d$$$ единичных       шагов ($$$a$$$ влево, $$$b$$$ вправо, $$$c$$$ вниз, $$$d$$$       вверх). Алиса может совершать шаги в <span class="tex-font-style-bf">любом</span> порядке. Её текущая позиция       $$$(u, v)$$$ <span class="tex-font-style-bf">всегда</span> должна       удовлетворять ограничениям: $$$x_1 \le u \le x_2$$$, $$$y_1 \le v       \le y_2$$$. Путь начинается из точки $$$(x, y)$$$.</p>     <p>Требуется решить задачу для $$$t$$$ наборов входных данных       независимо друг от друга.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$t$$$ ($$$1 \le t \le       10^3$$$) — количество наборов входных данных.</p>     <p>В первой строке каждого набора входных данных записаны четыре       целых числа $$$a$$$, $$$b$$$, $$$c$$$, $$$d$$$ ($$$0 \le a,b,c,d       \le 10^8$$$, $$$a+b+c+d \ge 1$$$).</p>     <p>Во второй строке каждого набора входных данных записаны шесть       целых чисел $$$x$$$, $$$y$$$, $$$x_1$$$, $$$y_1$$$, $$$x_2$$$,       $$$y_2$$$ ($$$-10^8 \le x_1\le x \le x_2 \le 10^8$$$, $$$-10^8 \le       y_1 \le y \le y_2 \le 10^8$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите «<span class="tex-font-style-tt">YES</span>» в отдельной строке, если       существует маршрут, который удовлетворяет ее желаниям. Иначе       выведите «<span class="tex-font-style-tt">NO</span>» в отдельной строке.</p>     <p>Можно выводить каждую букву в любом регистре (верхнем или нижнем).</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
3 2 2 2
0 0 -2 -2 2 2
3 1 4 1
0 0 -1 -1 1 1
1 1 1 1
1 1 1 1 1 1
0 0 0 1
0 0 0 0 0 1
5 1 1 1
0 0 -100 -100 0 100
1 1 5 1
0 0 -100 -100 100 0
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
Yes
No
No
Yes
Yes
Yes
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных в примере один из допустимых       маршрутов такой: $$$$$$(0,0)\rightarrow (-1,0) \rightarrow       (-2,0)\rightarrow (-2,1) \rightarrow (-2,2)\rightarrow       (-1,2)\rightarrow(0,2)\rightarrow (0,1)\rightarrow (0,0)       \rightarrow (-1,0)$$$$$$</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1332/problem/A' title='Codeforces Round 630 (Div. 2)'>1332A - Exercising Walk</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>The key observation is x-axis and y-axis is independent in this       task as the area is a rectangle. Therefore, we should only       consider 1D case (x-axis, for example). The optimal path to choose       alternates between right and left moves until only one type of       move is possible. And sometimes there is no place to make even one       move, which has to handled separately. So the verdict is         &quot;<span class="tex-font-style-tt">Yes</span>&quot; if and       only if $$$x_1 \le x-a+b \le x_2$$$ and ($$$x_1&lt;x_2$$$ or       $$$a+b=0$$$). </p></div></div></div>

           
            <pre><code>t = int(input())
for _ in range(t):
	a, b, c, d = map(int, input().split())
	x, y, x1, y1, x2, y2 = map(int, input().split())
	x += b - a
	y += d - c
	if a + b &gt; 0 and x1 == x2:
		print(&#34;No&#34;)
	elif c + d &gt; 0 and y1 == y2:
		print(&#34;No&#34;)
	elif x1 &lt;= x &lt;= x2 and y1 &lt;= y &lt;= y2:
		print(&#34;Yes&#34;)
	else:
		print(&#34;No&#34;)
</code></pre>
           
            <pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

int a,b,c,d,x,y,x1,y1,x2,y2,xx,yy;

int main(){
    int t;
    cin&gt;&gt;t;
    while (t--){
        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;
        xx=x,yy=y;
        x+=-a+b, y+=-c+d;
        if (x&gt;=x1&amp;&amp;x&lt;=x2&amp;&amp;y&gt;=y1&amp;&amp;y&lt;=y2&amp;&amp;(x2&gt;x1||a+b==0)&amp;&amp;(y2&gt;y1||c+d==0)){
            cout&lt;&lt;&#34;Yes\n&#34;;
        }
        else{
            cout&lt;&lt;&#34;No\n&#34;;
        }
    }
    return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #630 (Div. 2)
    1332B
    Непростая покраска </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Непростая покраска</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Положительное целое число называется <span class="tex-font-style-it">составным</span>, если оно представимо в       виде произведения двух положительных целых чисел, каждое из       которых больше $$$1$$$. Например, следующие числа составные:       $$$6$$$, $$$4$$$, $$$120$$$, $$$27$$$. Следующие числа составными       не являются: $$$1$$$, $$$2$$$, $$$3$$$, $$$17$$$, $$$97$$$.</p>     <p>Задана последовательность из $$$n$$$ составных чисел $$$a_1,a_2,\ldots,a_n$$$.</p>     <p>Алиса хочет выбрать любое целое число $$$m \le 11$$$ и покрасить       каждый элемент в один из $$$m$$$ цветов от $$$1$$$ до $$$m$$$ так, что:</p>          <ul> <li> для каждого цвета от $$$1$$$ до $$$m$$$ существует хотя бы         один элемент этого цвета; </li>       <li> каждый элемент покрашен и притом ровно в один цвет; </li>       <li> наибольший общий делитель любых двух одноцветных элементов         больше $$$1$$$, то есть $$$\gcd(a_i, a_j)&gt;1$$$ для любой пары         индексов $$$i, j$$$, если эти элементы покрашены в одинаковый         цвет. </li></ul>          <p>Обратите внимание, что одинаковые элементы могут быть покрашены в       разные цвета — просто для каждого индекса от $$$1$$$ до $$$n$$$       надо выбрать один из $$$m$$$ цветов.</p>     <p>Алиса уже показала, что если все $$$a_i \le 1000$$$, то она       всегда может решить эту задачу, выбрав некоторое $$$m \le 11$$$.</p>     <p>Помогите Алисе найти требуемую покраску элементов. Обратите       внимание, что вам не нужно минимизировать или максимизировать       количество цветов, достаточно найти решения с любым $$$m$$$ от       $$$1$$$ до $$$11$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано целое число $$$t$$$ ($$$1 \le t \le       1000$$$) — количество наборов входных данных в тесте. Далее       содержатся сами описания наборов.</p>     <p>В первой строке набора записано целое число $$$n$$$ ($$$1 \le n       \le 1000$$$) — количество чисел в последовательности $$$a$$$.</p>     <p>Вторая строка набора входных данных содержит $$$n$$$ составных       целых чисел $$$a_1,a_2,\ldots,a_n$$$ ($$$4 \le a_i \le 1000$$$).</p>     <p>Гарантируется, что сумма значений $$$n$$$ по всем наборам входных       данных не превосходит $$$10^4$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите $$$2$$$ строки. В       первую выведите $$$m$$$ ($$$1 \le m \le 11$$$) — количество       использованных цветов. Считайте, что цвета пронумерованы от       $$$1$$$ до $$$m$$$. Во вторую строку выведите любую раскраску       элементов, которая удовлетворяет условиям выше. Выведите $$$n$$$       целых чисел $$$c_1, c_2, \dots, c_n$$$ ($$$1 \le c_i \le m$$$),       где $$$c_i$$$ — цвет $$$i$$$-го элемента. Если решений несколько,       то выведите любое из них. Обратите внимание, что вам не нужно       минимизировать или максимизировать количество цветов, достаточно       найти решения с любым $$$m$$$ от $$$1$$$ до $$$11$$$.</p>     <p>Помните, что каждый цвет от $$$1$$$ до $$$m$$$ должен быть       использован хотя бы раз. Любые два одноцветных элемента должны не       быть взаимно просты (то есть их НОД должен быть больше $$$1$$$).</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
3
6 10 15
2
4 9
23
437 519 865 808 909 391 194 291 237 395 323 365 511 497 781 737 871 559 731 697 779 841 961
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
1 1 1
2
2 1
11
4 7 8 10 7 3 10 7 7 8 3 1 1 5 5 9 2 2 3 3 4 11 6
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных $$$\gcd(6,10)=2$$$,       $$$\gcd(6,15)=3$$$ и $$$\gcd(10,15)=5$$$. Таким образом, допустимо       раскрасить все три элемента в один цвет. Обратите внимание, что       для данного набора входных данных существуют и другие раскраски,       которые удовлетворяют требованиям Алисы.</p>     <p>Во втором наборе входных данных в каждый цвет покрашен только       один элемент, так что раскраска точно походит под все требования Алисы.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1332/problem/B' title='Codeforces Round 630 (Div. 2)'>1332B - Composite Coloring</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>The solution is obvious once one note that for any composite       number $$$k$$$, there exists a prime $$$d$$$ such that $$$d \le       \sqrt{k}$$$ and $$$k$$$ is divisible by $$$d$$$. Coincidentally,       there are exactly $$$11$$$ primes below $$$\sqrt{1000}$$$. Thus,       one can color balls according to their smallest divisor. That       works because if all numbers of the same color have the same       divisor then each pair has at least this divisor in their GCD.</p></div></div></div>

           
            <pre><code>from math import gcd

def getprime(x):
	for i in range(2, x):
		if x % i == 0:
			return i
	return -1

primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31]

t = int(input())
for _ in range(t):
	n = int(input())
	a = [int(x) for x in input().split()]
	used = [False for i in range(11)]
	clr = []
	for i in range(n):
		x = primes.index(getprime(a[i]))
		used[x] = True
		clr.append(x)
	cnt = 0
	num = []
	for i in range(11):
		num.append(cnt)
		if used[i]:
			cnt += 1
	print(cnt)
	for i in range(n):
		x = primes.index(getprime(a[i]))
		print(num[x] + 1, end = &#34; &#34;)
	print()
</code></pre>
           
            <pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
 
int n,t;
vector&lt;int&gt; ans[1007];
int res[1007];
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    auto f=[&amp;](int u){
        for (int i=2;i&lt;=u;++i){
            if (u%i==0) return i;
        }
    };
    cin&gt;&gt;t;
    while (t--){
        cin&gt;&gt;n;
        for (int i=1;i&lt;=1000;++i) ans[i].clear();
        for (int i=1;i&lt;=n;++i){
           int u;
           cin&gt;&gt;u; ans[f(u)].push_back(i);
        }
        int ret=0;
        for (int i=1;i&lt;=1000;++i){
            if (ans[i].size()){
                ++ret;
                for (auto c:ans[i]){
                    res[c]=ret;
                }
            }
        }
        cout&lt;&lt;ret&lt;&lt;&#34;\n&#34;;
        for (int i=1;i&lt;=n;++i){
            cout&lt;&lt;res[i]&lt;&lt;&#34; &#34;;
        }
        cout&lt;&lt;&#34;\n&#34;;
    }
    return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #630 (Div. 2)
    1332C
    K-полное слово </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. K-полное слово</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Слово $$$s$$$ длины $$$n$$$ называется $$$k$$$-полным, если </p>     <ul> <li> $$$s$$$ — палиндром, то есть $$$s_i=s_{n+1-i}$$$ для всех         $$$1 \le i \le n$$$; </li>       <li> $$$s$$$ имеет период $$$k$$$, то есть $$$s_i=s_{k+i}$$$ для         всех $$$1 \le i \le n-k$$$. </li></ul>          <p>Например, «<span class="tex-font-style-tt">abaaba</span>» — это       $$$3$$$-полное слово, а «<span class="tex-font-style-tt">abccba</span>» нет.</p>     <p>Бобу вручили слово $$$s$$$ длины $$$n$$$, состоящее только из       строчных букв латинского алфавита, и целое число $$$k$$$ такое,       что $$$n$$$ делится на $$$k$$$. Он хочет превратить слово $$$s$$$       в любое $$$k$$$-полное слово.</p>     <p>Для этого Боб может выбирать некоторую позицию $$$i$$$ ($$$1 \le       i \le n$$$) и заменять букву на позиции $$$i$$$ на любую другую       строчную букву латинского алфавита.</p>     <p>Поэтому теперь Боба интересует минимальное количество позиций,       буквы на которых ему необходимо заменить, чтобы превратить $$$s$$$       в любое $$$k$$$-полное слово.</p>     <p>Обратите внимание, что Боб может сделать ноль изменений, если       слово $$$s$$$ уже $$$k$$$-полное.</p>     <p>Требуется ответить на $$$t$$$ <span class="tex-font-style-bf">независимых</span> наборов входных данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$t$$$ ($$$1 \le t\le       10^5$$$) — количество наборов входных данных.</p>     <p>В первой строке каждого набора входных данных записаны два целых       числа $$$n$$$ и $$$k$$$ ($$$1 \le k &lt; n \le 2 \cdot 10^5$$$,       $$$n$$$ делится на $$$k$$$).</p>     <p>Во второй строке записано слово $$$s$$$ длины $$$n$$$.</p>     <p>Гарантируется, что слово $$$s$$$ состоит только из строчных букв       латинского алфавита. Также гарантируется, что сумма $$$n$$$ по       всем наборам входных данных не превосходит $$$2 \cdot 10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите одно целое число,       обозначающее минимальное количество позиций, буквы на которых ему       придется заменить, чтобы превратить $$$s$$$ в любое $$$k$$$-полное слово.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
6 2
abaaba
6 3
abaaba
36 9
hippopotomonstrosesquippedaliophobia
21 7
wudixiaoxingxingheclp
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
0
23
16
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных одно из оптимальных решений — это         «<span class="tex-font-style-tt">a<span class="tex-font-style-underline">           <span class="tex-font-style-bf">a</span></span>aa<span class="tex-font-style-underline">           <span class="tex-font-style-bf">a</span></span>a</span>».</p>     <p>Во втором наборе входных данных слово уже $$$k$$$-полное.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1332/problem/C' title='Codeforces Round 630 (Div. 2)'>1332C - K-Complete Word</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>One should notice that word $$$s$$$ of length $$$n$$$ is       $$$k$$$-complete if and only if there exists a palindrome $$$t$$$       of length $$$k$$$ such that $$$s$$$ can be generated by several       concatenations of $$$t$$$.</p>     <p>So in the final string all characters at positions $$$i$$$, $$$k       - i + 1$$$, $$$k + i$$$, $$$2k - i + 1$$$, $$$2k + i$$$, $$$3k - i       + 1$$$, $$$\dots$$$ for all $$$1 \le i \le k$$$ should all be       equal. This helps us to solve the problem independently for each       $$$i$$$. To minimize the required number of changes, you should       make all the letters equal to the one which appears at these       positions the most initially. Calculate that maximum number of       appearances and sum up over all $$$i$$$. Be careful with an odd       $$$k$$$ because the letter in the center of each block has a       different formula.</p></div></div></div>

           
            <pre><code>from sys import stdin

t = int(stdin.readline())
for _ in range(t):
	n, k = map(int, stdin.readline().split())
	s = stdin.readline()
	cnt = [[0 for i in range(26)] for j in range((k + 1) // 2)]
	for i in range(n):
		cnt[min(i % k, k - i % k - 1)][ord(s[i]) - ord(&#39;a&#39;)] += 1
	ans = 0
	for i in range(k // 2):
		ans += 2 * n // k - max(cnt[i])
	if k % 2 == 1:
		ans += n // k - max(cnt[k // 2])
	print(ans)
</code></pre>
           
            <pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn=200007;

int n,k,ans=0;
int cnt[maxn][26];
string s;

int differ(int u,int v){
    int ret=0,mx=0;
    for (int j=0;j&lt;26;++j){
        ret+=cnt[u][j]+cnt[v][j];
        mx=max(mx,cnt[u][j]+cnt[v][j]);
    }
    return ret-mx;
}

int main(){
    int t;
    cin&gt;&gt;t;
    while (t--){
        cin&gt;&gt;n&gt;&gt;k&gt;&gt;s;
        for (int i=0;i&lt;k;++i){
            for (int j=0;j&lt;26;++j){
                cnt[i][j]=0;
            }
        }
        for (int i=0;i&lt;n;++i){
            cnt[i%k][s[i]-&#39;a&#39;]++;
        }
        int ans=0;
        for (int i=0;i&lt;k;++i){
            ans+=differ(i,k-1-i);
        }
        cout&lt;&lt;ans/2&lt;&lt;&#34;\n&#34;;
    }
    return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #630 (Div. 2)
    1332D
    Прогулка по матрице </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Прогулка по матрице</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Боб играет в игру под названием «Прогулка по матрице»</p>     <p>В этой игре игроку дается $$$n \times m$$$ матрица       $$$A=(a_{i,j})$$$, то есть элемент в $$$i$$$-й строке в $$$j$$$-м       столбце — $$$a_{i,j}$$$. В начале игры игрок стоит на позиции       $$$(1,1)$$$ со счетом $$$a_{1,1}$$$.</p>     <p>Чтобы достичь финиша, позиции $$$(n,m)$$$, игрок может ходить       вправо или вниз, то есть из $$$(x,y)$$$ в $$$(x,y+1)$$$ или       $$$(x+1,y)$$$, до тех пор, пока не выходит за пределы матрицы.</p>     <p>Каждый шаг, однако, изменяет счет игрока на <a href="https://ru.wikipedia.org/wiki/Битовые_операции#Побитовое_И">побитовое       И</a> текущего счета и значения клетки, в которую он переходит.</p>     <p>Конечно же, Боб сразу решил вычислить максимальный счет, который       он может набрать, с помощью недавно изученной им техники       динамического программирования. Вот его алгоритм для данной       задачи. </p>     <center> <img class="tex-graphics" src="https://espresso.codeforces.com/2965b19a1f80fccdcfef54a99d5f90bed309d2c4.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>Однако, он тут же понял, что его алгоритм неправильно находит       максимальный счет для некоторой матрицы $$$A$$$. Поэтому теперь он       хочет для каждого неотрицательного целого числа $$$k$$$ найти       такую $$$n \times m$$$ матрицу $$$A=(a_{i,j})$$$, что </p>     <ul> <li> $$$1 \le n,m \le 500$$$ (Боб ненавидит большие матрицы); </li>       <li> $$$0 \le a_{i,j} \le 3 \cdot 10^5$$$ для всех $$$1 \le i\le         n,1 \le j\le m$$$ (Боб ненавидит большие числа); </li>       <li> разница между максимальным счетом, который он может набрать,         и выводом алгоритма составляет <span class="tex-font-style-bf">ровно</span> $$$k$$$. </li></ul>          <p>Можно показать, что для любого целого $$$k$$$ такого, что $$$0       \le k \le 10^5$$$, существует матрица, удовлетворяющая данным условиям.</p>     <p>Помогите Бобу с этой задачей!</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В единственной строке записано одно целое число $$$k$$$ ($$$0 \le       k \le 10^5$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>В первой строке выведите два целых числа $$$n$$$, $$$m$$$ ($$$1       \le n,m \le 500$$$), обозначающие размеры матрицы.</p>     <p>Затем выведите $$$n$$$ строк по $$$m$$$ целых чисел в каждой       строке, $$$a_{i,j}$$$ в $$$(i+1)$$$-й строке, $$$j$$$-м столбце.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
0
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1 1
300000</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3 4
7 3 3 1
4 8 3 6
7 7 7 3</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере максимальный счет, который может набрать Боб,       равен $$$300000$$$, и вывод его алгоритма тоже $$$300000$$$.</p>     <p>Во втором примере максимальный счет, который Боб может набрать,       равен $$$7\&amp;3\&amp;3\&amp;3\&amp;7\&amp;3=3$$$, когда вывод       его алгоритма — это $$$2$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1332/problem/D' title='Codeforces Round 630 (Div. 2)'>1332D - Walk on Matrix</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>In fact, the following matrix will work: $$$$$$\left(       \begin{array}{ccc} 2^{17}+k &amp; 2^{17} &amp; 0\\ k &amp;       2^{17}+k &amp; k\\ \end{array} \right)$$$$$$</p>     <p>To find such a matrix, one should find out why the dp solution fails.</p>     <p>One should notice that       $$$dp_{2,2}=\max(a_{1,1}\&amp;a_{1,2}\&amp;a_{2,2},a_{1,1}\&amp;a_{2,1}\&amp;a_{2,2})$$$       and dp solution will choose the optimal path from $$$(1,1)$$$ to       $$$(2,2)$$$ for later decision. However, we should notice that we       can only discard the suboptimal result if and only if       $$$ans_{suboptimal} \&amp; ans_{optimal}=ans_{suboptimal}$$$       rather than $$$ans_{suboptimal} &lt; ans_{optimal}$$$. Based on       above analysis, we can construct the matrix easily. </p>     <p>In fact, even if $$$n,m$$$ is fixed satisfying that $$$n \ge 2,m       \ge 2$$$ and $$$n\cdot m&gt;4$$$, we could easily construct a       matrix for a given $$$k$$$ based on our $$$2 \times 3$$$ matrix.</p></div></div></div>

           
            <pre><code>k = int(input())
x = 2**17
print(2, 3)
print(x^k, x, 0)
print(k, x^k, k)
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #630 (Div. 2)
    1332E
    Все высоты равны </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. Все высоты равны</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Алиса недавно подсела на игру, которая называется Сиртет.</p>     <p>В игре Сиртет игроку дается поле $$$n \times m$$$. В начале игры       $$$a_{i,j}$$$ кубиков поставлены друг на друга в клетке       $$$(i,j)$$$. Две клетки называются соседними, если у них есть       общая сторона. Игрок может делать следующие ходы: </p>     <ul> <li> поставить по одному кубику на две <span class="tex-font-style-bf">соседние</span> клетки; </li>       <li> поставить два кубика в одну клетку. </li></ul>          <p>Упомянутые кубики все одинаковой высоты.</p>     <p>Пример игры изображен на картинке. Состояния справа достигаются с       помощью выполнения данных ходов из состояния слева, и после хода       добавляются серые кубики.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/bd8574b9be3f621ede621e3db5e94253b8440b0f.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>Цель игрока — <span class="tex-font-style-bf">сделать высоты всех         клеток одинаковыми</span> (то есть в каждой клетке должно быть       одинаковое количество кубиков) при помощи данных ходов.</p>     <p>Алиса обнаружила, что на некоторых начальных полях невозможно       достичь цели, какие бы ходы игрок не делал. Поэтому ей стало       интересно, сколько существует таких начальных полей, что </p>     <ul> <li> $$$L \le a_{i,j} \le R$$$ для всех $$$1 \le i \le n$$$,         $$$1 \le j \le m$$$; </li>       <li> игрок может достичь цели, используя данные ходы. </li></ul>          <p>Пожалуйста, помогите Алисе с этим. Обратите внимание, что ответ       может быть довольно большой, поэтому выведите его по модулю $$$998,244,353$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В единственной строке записаны четыре целых числа $$$n$$$,       $$$m$$$, $$$L$$$ и $$$R$$$ ($$$1\le n,m,L,R \le 10^9$$$, $$$L \le       R$$$, $$$n \cdot m \ge 2$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одно целое число, обозначающее ответ по модулю $$$998,244,353$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2 2 1 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
1 2 1 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере единственное поле, которое удовлетворяет       условиям — это $$$a_{1,1}=a_{2,1}=a_{1,2}=a_{2,2}=1$$$. Поэтому       ответ $$$1$$$.</p>     <p>Во втором примере начальные поля, которые удовлетворяют условиям,       — это $$$a_{1,1}=a_{1,2}=1$$$ и $$$a_{1,1}=a_{1,2}=2$$$. Поэтому       ответ $$$2$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1332/problem/E' title='Codeforces Round 630 (Div. 2)'>1332E - Height All the Same</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>       <span class="tex-font-style-bf">Observation 1.</span> The actual       values in the cells don't matter, only parity matters.</p>     <p>       <span class="tex-font-style-bf">Proof.</span> Using the second       operation one can make all the values of same parity equal by       applying it to the lowest value until done.</p>     <p>That observation helps us to get rid of the second operation, let       us only have the first one.</p>     <p>       <span class="tex-font-style-bf">Observation 2.</span> Player is       able to change parity of any pair of cells at the same time.</p>     <p>       <span class="tex-font-style-bf">Proof.</span> For any given cell       $$$u$$$ and cell $$$v$$$, there exists a path from $$$u$$$ to       $$$v$$$, namely $$$p=w_0w_1\ldots w_k$$$, such that $$$w_0=u$$$       and $$$w_n=v$$$. Perform operation for adjacent cells       $$$w_{i-1}$$$ and $$$w_{i}$$$ for all $$$1 \le i \le n$$$</p>     <p>       <span class="tex-font-style-bf">Observation 3.</span> If $$$n       \times m$$$ is odd, player can always reach the goal no matter       what the initial state is.</p>     <p>       <span class="tex-font-style-bf">Proof.</span> There are two cases:       there is an even number of even cells or there is an even number       of odd cells. Whichever of these holds, we can change all cells of       that parity to the opposite one with the aforementioned operation,       making all cells the same parity.</p>     <p>       <span class="tex-font-style-bf">Observation 4.</span> If $$$n       \times m$$$ is even, and $$$\sum_{i=1}^n \sum_{j=1}^m a_{i,j}$$$       is even, player can reach the goal.</p>     <p>       <span class="tex-font-style-bf">Proof.</span> Similar to the proof       of Observation 3. Proof is omitted.</p>     <p>       <span class="tex-font-style-bf">Observation 5.</span> If $$$n       \times m$$$ is even and $$$\sum_{i=1}^n \sum_{j=1}^m a_{i,j}$$$ is       odd, player can never reach the goal no matter what strategies       player takes.</p>     <p>       <span class="tex-font-style-bf">Proof.</span> Note that applying       the operation never changes the parity of the number of cells of       each parity (i.e. if we start with an odd number of odd cells and       an odd number of even cells, they will both be odd until the end).       Thus, there is no way to make zero cells of some parity.</p>     <p>How does that help us to calculate the answer?</p>     <p>The first case ($$$n \times m$$$ is odd) is trivial, the answer       is all grids. Let's declare this as $$$total$$$ value.</p>     <p>The second case ($$$n \times m$$$ is even) is harder. Me and       pikmike have different formulas to obtain it but the answer is the same.</p>     <p>WLOG, let's move the range of values from $$$[L; R]$$$ to $$$[0;       R - L]$$$, let $$$k = R - L$$$.</p>     <p>       <span class="tex-font-style-bf">Easy combinatorics solution (me):</span></p>     <p>Let's find out the number of ways to choose the grid such that       the number of even cells is even and $$$0 \le a_i \le k$$$.</p>     <p>Suppose that there are $$$E$$$ even numbers in $$$[0,k]$$$,       $$$O$$$ odds. Therefore, for any given $$$0 \le i \le nm$$$, the       number of ways to have exactly $$$i$$$ even numbers should be       $$$E^i O^{nm-i} \times \binom{nm}{i}$$$. Thus, the total answer       should be $$$\sum \limits_{i=0}^{nm/2} E^{2i} O^{nm-2i}       \binom{nm}{2i}$$$, which should remind you of the Newton expansion.</p>     <p>Note that       $$$$$$(E+O)^{nm}=\sum_{i=0}^{nm/2}E^{2i}O^{nm-2i}\binom{nm}{2i}+\sum_{i=1}^{nm/2}E^{2i-1}       O^{nm-(2i-1)} \binom{nm}{2i-1}$$$$$$</p>     <p>and </p>      <p>$$$$$$(E-O)^{nm}=\sum_{i=0}^{nm/2}E^{2i}O^{nm-2i}\binom{nm}{2i}-\sum_{i=1}^{nm/2}E^{2i-1}       O^{nm-(2i-1)} \binom{nm}{2i-1}$$$$$$.</p>     <p>Adding those two formulas will get us exactly the formula we were       looking for but doubled. Thus, the answer is that divided by $$$2$$$.</p>     <p>       <span class="tex-font-style-bf">Easy intuition solution (pikmike)</span>:</p>     <p>There is a general solution to this kind of problems. Let's try       to pair up each valid grid with exactly one invalid grid. Valid in       our problem is such a grid that the number of even cells is even.       If such a matching exists then the answer is exactly half of all       grids $$$(\frac{total}{2})$$$.</p>     <p>Let's come up with some way to pair them up. For example, this       works but leaves us with two cases to handle.</p>     <p>Let $$$k$$$ be odd. For each grid let's replace $$$a_{0,0}$$$       with $$$a_{0,0}~xor~1$$$. You can see that the parity changed,       thus the number of even cells also changed its parity. So if the       grid was invalid it became valid and vice versa.</p>     <p>For an even $$$k$$$ it's slightly trickier but actually one can       show that almost all grids pair up with each other and only a       single grid remains unpaired. So we can add a fake grid and claim       that the answer is $$$\frac{total + 1}{2}$$$.</p>     <p>The algorithm is the following. Find the first position such that       the value $$$a_{i,j}$$$ on it is not equal to $$$k$$$. Replace it       with $$$a_{i,j}~xor~1$$$. You can easily see that only grid that       consists of all numbers $$$k$$$ has no pair.</p></div></div></div>

           
            <pre><code>MOD = 998244353

n, m, l, r = map(int, input().split())
if n * m % 2 == 1:
	print(pow(r - l + 1, n * m, MOD))
elif (r - l + 1) % 2 == 0:
	print(pow(r - l + 1, n * m, MOD) * (MOD + 1) // 2 % MOD)
else:
	print((pow(r - l + 1, n * m, MOD) + 1) * (MOD + 1) // 2 % MOD)
</code></pre>
           
            <pre><code>MOD = 998244353

n, m, l, r = map(int, input().split())
if n * m % 2 == 1:
	print(pow(r - l + 1, n * m, MOD))
else:
	e = r // 2 - (l - 1) // 2	
	o = (r - l + 1) - e
	print((pow(e + o, n * m, MOD) + pow(e - o, n * m, MOD)) * (MOD + 1) // 2 % MOD)
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #630 (Div. 2)
    1332F
    Независимое множество </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Независимое множество</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Эрик — учитель по теории графов. Сегодня он рассказывает       независимое множество и реберно-порожденный подграф.</p>     <p>Для данного графа $$$G=(V,E)$$$ <span class="tex-font-style-it">независимым множеством</span>       называется такое подмножество вершин $$$V' \subset V$$$, что для       каждой пары $$$u,v \in V'$$$, $$$(u,v) \not \in E$$$ (то есть в       $$$E$$$ нет ребра, соединяющего две вершины из $$$V'$$$).</p>     <p>       <span class="tex-font-style-it">Реберно-порожденный подграф</span>       состоит из подмножества ребер $$$E' \subset E$$$ и всех вершин       оригинального графа, которые инцидентны хотя бы одному ребру подграфа.</p>     <p>Для $$$E' \subset E$$$ обозначим за $$$G[E']$$$       реберно-порожденный подграф такой, что $$$E'$$$ — это множество       ребер этого подграфа. Иллюстрации этих определений:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/f4b22999f9d16047bd47abc9d9d0ab6a68771932.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>В качестве упражнения на закрепление материала он дал студентам       следующую задачу:</p>     <p>Дано дерево $$$G=(V,E)$$$, посчитайте сумму $$$w(H)$$$ по всем       реберно-порожденным подграфам $$$H$$$ графа $$$G$$$, кроме       пустого, где $$$w(H)$$$ — это количество независимых множеств в       $$$H$$$. Формально, посчитайте $$$\sum \limits_{\emptyset \not= E'       \subset E} w(G[E'])$$$.</p>     <p>Докажите Эрику, что вы умнее его учеников, предъявив правильный       ответ как можно скорее. Обратите внимание, что ответ может быть       довольно большой, поэтому выведите его по модулю $$$998,244,353$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$n$$$ ($$$2 \le n \le       3 \cdot 10^5$$$), обозначающее количество вершин в графе $$$G$$$.</p>     <p>В каждой из следующих $$$n-1$$$ строк записаны два целых числа       $$$u$$$ and $$$v$$$ ($$$1 \le u,v \le n$$$, $$$u \not= v$$$),       задающие ребра данного дерева.</p>     <p>Гарантируется, что данные ребра образуют дерево.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одно целое число, обозначающее ответ по модулю $$$998,244,353$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
2 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
1 2
3 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
11
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Во втором примере все независимые множества изображены на рисунке.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/b360e29972dda24fdfc4d42a0855a4803d63d3fc.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1332/problem/F' title='Codeforces Round 630 (Div. 2)'>1332F - Independent Set</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>We will call one vertice is colored if and only if it is in the       independent set. And a coloring is valid if and only if no two       adjacent vertices are both colored.</p>     <p>Therefore, we are asked to calculate the sum of number of valid       colorings over all edge induced subgraphs.</p>     <p>To deal with the task, one should notice that for a edge induced       subgraph and one valid coloring, we may add those vertices which       are removed due to the generation of edge induced subgraph, and       remain it uncolored.</p>     <p>Therefore, for a coloring on the original graph $$$G=(V,E)$$$, we       could consider removing edges such that it will behave the same       with above procedure.</p>     <p>In fact, given a coloring, we can define edge removing is valid       if and only if there is no adjacent colored vertice and <span class="tex-font-style-bf">no isolated vertex is colored</span>.       We can actually show that there is almost a one to one       corresponding relation betweeen those two procedure except for the       case where all vertices remains uncolored and all edges are removed.</p>     <p>Therefore, we can actually solve the following task:</p>     <p>Given a tree $$$G=(V,E)$$$, for any given coloring, define a edge       removal is valid if it satisfies above constrains.</p>     <p>And it will suddenly becoming something easy to solve with tree       dp. Define $$$dp_{u,0}$$$ be the answer for subtree rooted at       $$$u$$$ with additional constraint such that $$$u$$$ is not       colored, $$$dp_{u,1}$$$ be the answer where $$$u$$$ is colored and       $$$dp_u$$$ be the answer where edges from $$$u$$$ to its children       are removed.</p>     <p>Therefore, the dp formula should be </p>     <ul>                     <li> $$$dp_{u,0}=\prod_{v}(2dp_{v,0}+2dp_{v,1}-dp_v)$$$ </li>       <li> $$$dp_{u,1}=\prod_{v}(2dp_{v,0}+dp_{v,1}-dp_v)$$$ </li>       <li> $$$dp_{u}=\prod_{v}(dp_{v,0}+dp_{v,1}-dp_v)$$$         </li></ul>          <p>The answer is easily calculated with those three states.</p></div></div></div>

           
            <pre><code>#include&lt;bits/stdc++.h&gt;
#define int long long
#define ULL unsigned long long
#define F first
#define S second
#define pb push_back
#define rep(i,n) for(int i=0;i&lt;(int)(n);++i)
#define rep1(i,n) for(int i=1;i&lt;=(int)(n);++i)
#define range(a) a.begin(), a.end()
#define PI pair&lt;int,int&gt;
#define VI vector&lt;int&gt;
#define debug cout&lt;&lt;&#34;potxdy&#34;&lt;&lt;endl; 
using namespace std;
 
typedef long long ll;
 
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

const int maxn=300007;
const int mod=998244353;

int n,dp[maxn][2],f[maxn]; 
VI vec[maxn];

int mult(int u,int v){
    u=(u%mod+mod)%mod, v=(v%mod+mod)%mod;
    return 1ll*u*v%mod;
}

void dfs(int u,int p){
    dp[u][0]=dp[u][1]=f[u]=1;
    for (auto c:vec[u]){
        if (c==p) continue;
        dfs(c,u);
        dp[u][0]=mult(dp[u][0],2*dp[c][0]+2*dp[c][1]-f[c]);
        dp[u][1]=mult(dp[u][1],dp[c][1]+2*dp[c][0]-f[c]);
        f[u]=mult(f[u],dp[c][0]+dp[c][1]-f[c]);
    }
}

#undef int
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin&gt;&gt;n;
    for (int i=1;i&lt;n;++i){
        int u,v;
        cin&gt;&gt;u&gt;&gt;v;
        vec[u].pb(v), vec[v].pb(u);
    }
    dfs(1,0);
    cout&lt;&lt;(dp[1][0]+dp[1][1]-f[1]-1+2*mod)%mod&lt;&lt;endl;
    return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #630 (Div. 2)
    1332G
    Без монотонных троек </h1>

    <div class="problemindexholder" problemindex="G">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">G. Без монотонных троек</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Для данной последовательности целых чисел $$$a$$$ длины $$$n$$$       тройка $$$(i,j,k)$$$ называется монотонной, если </p>     <ul> <li> $$$1 \le i&lt;j&lt;k\le n$$$; </li>       <li> $$$a_i \le a_j \le a_k$$$ или $$$a_i \ge a_j \ge a_k$$$         выполняется. </li></ul>          <p>Например, $$$a=[5,3,4,5]$$$, тогда $$$(2,3,4)$$$ — это монотонная       тройка для последовательности $$$a$$$, а $$$(1,3,4)$$$ нет.</p>     <p>Бобу на экзамене по математике дали последовательность целых       чисел $$$a$$$ длины $$$n$$$. Сам же экзамен представляет собой       вопросы вида $$$L, R$$$, на каждый из которых его просят найти       любую подпоследовательность $$$b$$$ <span class="tex-font-style-bf">размера больше, чем $$$2$$$ (то есть         $$$|b| \ge 3$$$)</span> последовательности $$$a_L,       a_{L+1},\ldots, a_{R}$$$.</p>     <p>Напомним, что последовательность $$$b$$$ является       подпоследовательностью $$$a$$$, если $$$b$$$ может быть получена       удалением нескольких (возможно, ни одного или всех) элементов.</p>     <p>Однако, он ненавидит монотонные штуки, поэтому он хочет выбрать       подпоследовательность <span class="tex-font-style-bf">без         монотонных троек</span>. Кроме того, он хочет выбрать       подпоследовательность с <span class="tex-font-style-bf">наибольшей</span> длиной среди всех       подпоследовательностей без монотонных троек для каждого запроса.</p>     <p>Помогите Бобу найти подпоследовательность, удовлетворяющую       приведенным условиям.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записаны два числа $$$n$$$, $$$q$$$ ($$$3 \le n       \le 2 \cdot 10^5$$$, $$$1 \le q \le 2 \cdot 10^5$$$) — длина       последовательности $$$a$$$ и количество запросов.</p>     <p>Во второй строке записаны $$$n$$$ целых чисел $$$a_1,a_2,\ldots,       a_n$$$ ($$$1 \le a_i \le 10^{9}$$$) — последовательность $$$a$$$.</p>     <p>Затем в каждой из следующих $$$q$$$ строк записаны по два целых       числа $$$L$$$, $$$R$$$ ($$$1 \le L,R \le n$$$, $$$R-L\ge 2$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого запроса выведите $$$0$$$, если не существует       подпоследовательности $$$b$$$, удовлетворяющей всем условиям из       легенды. Можно вывести пустую строку после этого, но это не обязательно.</p>     <p>В противном случае выведите одно целое число $$$k$$$ ($$$k &gt;       2$$$), обозначающее длину последовательности $$$b$$$, затем       выведите $$$k$$$ целых чисел $$$i_1, i_2, \ldots, i_k$$$ ($$$L \le       i_1 &lt; i_2&lt;\ldots&lt;i_k\le R$$$), где $$$b_j = a_{i_j}$$$       для $$$1 \le j \le k$$$.</p>     <p>Если существует несколько ответов с наибольшей длиной, то       выведите любой из них.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6 2
3 1 4 1 5 9
1 3
4 6
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
1 2 3 
0

</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере в самой последовательности уже нет монотонных троек.</p>     <p>Во втором примере можно показать, что не существует       подпоследовательности $$$b$$$ длиной больше, чем $$$2$$$, такой,       что в $$$b$$$ нет монотонных троек.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1332/problem/G' title='Codeforces Round 630 (Div. 2)'>1332G - No Monotone Triples</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>We will solve this task with the following observations.</p>     <p>       <span class="tex-font-style-bf">Observation 1.</span> If an array       $$$x$$$ of length $$$k$$$ ($$$k \ge 3$$$) has no monotone triple,       then one of the following is true: </p>     <ul> <li> $$$x_1&lt;x_2&gt;x_3&lt;x_4&gt;x_5&lt;\ldots$$$ </li>       <li> $$$x_1&gt;x_2&lt;x_3&gt;x_4&lt;x_5&gt;\ldots$$$ </li></ul>          <p>       <span class="tex-font-style-bf">Observation 2.</span> If an array       $$$x$$$ of length $$$k$$$ ($$$k \ge 4$$$) has no monotone triple,       then its subsequence has no monotone triple.</p>     <p>       <span class="tex-font-style-bf">Observation 3.</span> If an array       $$$x$$$ of length 4 has no monotone triple, then       $$$max(x_2,x_3)&gt;max(x_1,x_4)$$$,       $$$min(x_2,x_3)&lt;min(x_1,x_4)$$$,vice versa.</p>     <p>       <span class="tex-font-style-bf">Proof.</span> WLOG, we assume       $$$max(x_2,x_3)\le x_1$$$, by observation 1 we will know that       $$$x_1&gt;x_2&lt;x_3&gt;x_4$$$, since $$$x_1\ge x_3$$$, we get a       monotone triple $$$(1,3,4)$$$, leading to contradiction. Second       part can be verified easily.</p>     <p>       <span class="tex-font-style-bf">Observation 4.</span> For every       array $$$x$$$ of length $$$k$$$ ($$$k \ge 5$$$), $$$x$$$ must have       monotone triple.</p>     <p>       <span class="tex-font-style-bf">Proof.</span> WLOG, we just need       to prove the observation holds when $$$k=5$$$ and cases when not       all elements are equal. In that case, one of extremal can be       reached in position other than $$$3$$$. WLOG, we will assume that       maximum is reached at position $$$2$$$. However,       $$$x_2,x_3,x_4,x_5$$$ cannot be monotone-triple-free, leading to contradiction!</p>     <p>Combining those observations (or Erdos–Szekeres theorem if you       know it), we would like to get the following solution, which runs       in $$$O(q n^4)$$$. </p>     <ul> <li> If the subsequence is monotone, the answer should be 0. </li>       <li> If there exists $$$i,j,k,l$$$ such that $$$L \le         i&lt;j&lt;k&lt;l \le R$$$ and $$$a_i$$$, $$$a_l$$$ fails to         reach maximum and minimum among those four numbers, the answer         should be 4. </li>       <li> Otherwise, the answer should be 3. </li></ul>          <p>In the following paragraphs, we will only focus on the case of       $$$4$$$. Other stuffs can be dealt similarly (or easily).</p>     <p>       <span class="tex-font-style-bf">$$$O(n^2)$$$ solution</span>(the       observation is crucial to obtain a faster solution)</p>     <p>Notice that constraint is equivalent to that there exists       $$$i,j$$$ such that $$$a_i,a_j$$$ fails to reach maximum and       minimum among $$$a_i,a_{i+1},\ldots,a_j$$$. This observation       allows us to solve this task in $$$O(n^2)$$$ with some       precalculation. (though it's still not enough to get accepted).</p>     <p>       <span class="tex-font-style-bf">$$$O(n \log n)$$$ solution</span></p>     <p>Let's solve the task for a sequence of a pairwise distinct       numbers and then change the conditions to a general sequence.</p>     <p>Let's fix $$$a_i$$$ — the leftmost element of $$$b$$$ and look at       what we are asked to find. So there should be some position       $$$j$$$ to the right of $$$i$$$ so that the range of values on       positions $$$[i, j]$$$ excluding the greatest and the smallest       values includes both $$$a_i$$$ and $$$a_j$$$.</p>     <p>Let's process the array from right to left, maintaining two       stacks. The top element in both stacks is the currently processed       one. Next element of the first stack is the closest to the right       element greater than the top one, and the next element of the       second stack is the closest to the right smaller than the top one.       And the stacks go like that until the end of array.</p>     <p>Iterating over one of these stacks will show the increase of the       range of values in one direction, iterating over both at the same       time will show how the range of values changes in total.</p>     <p>So I claim that the sequence we are looking for exists iff both       stacks include more than $$$1$$$ element and there is an element       to the right of second elements of both stacks such that it is       included in neither of the stacks. Naturally that condition tells       that there is some position in which neither maximum, nor minimum       values are updated.</p>     <p>The values that are in neither of stacks can be maintained in a       queue or in a BIT.</p>     <p>Basically, the position when the range of values doesn't change       is such a value which is both smaller than the maximum value on       the segment and greater than the minimum one. Thus, we can choose       $$$a_i$$$, the latest elements in both stacks up to that position       and that position itself.</p>     <p>How to deal with not pairwise distinct elements? Well, it's       enough to change the conditions in stacks to the next greater or       equal and the next smaller or equal. However, that will push the       elements equal to the current one right next to it to the both       stacks. Previously we kinda used the fact that no element except       the current one is in both stacks. I think that the easiest way to       deal with it is to get the answer for the rightmost of the       consecutive equal elements and then just say that the answer for       the rest of them is the same. Finally, push all these consecutive       equal elements to the both stacks.</p>     <p>As for queries. I previously said that we can take the position       where the value range doesn't change. Basically, the first valid       position is coincidentally the shortest length valid segment       starting from $$$i$$$. So to find the first position you just need       to do a binary search over that queue or BIT of the values which       are in neither of the stacks. We can easily remember it for each       position and then do a range minimum query checking if any of the       positions in $$$[l, r]$$$ have their shortest right border smaller       than $$$r$$$.</p></div></div></div>

           
            <pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;

const int maxn=200007;
int n,q,a[maxn],b[maxn],c[maxn],t[maxn],sum[maxn];
int st1[maxn],st2[maxn],p1,p2,r1,r2,s1,s2;
int ans1[maxn][4],ans2[maxn][4];
set&lt;int&gt; s;

bool cmp1(int u,int v){
    return a[u]&lt;a[v];
}

bool cmp2(int u,int v){
    return a[u]&gt;a[v];
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    cin&gt;&gt;n&gt;&gt;q;
    for (int i=1;i&lt;=n;++i){
        cin&gt;&gt;a[i];
    }
    p1=p2=r1=r2=0;
    s.insert(n+1);
    for (int i=n;i&gt;0;--i){
        while (p1){
            int u=st1[p1];
            if (a[u]&gt;a[i]){
                t[u]--;
                if (!t[u]) s.insert(u);
                p1--;
                r1=0;
            }
            else{
                break;
            }
        }
        while (p2){
            int u=st2[p2];
            if (a[u]&lt;a[i]){
                t[u]--;
                if (!t[u]) s.insert(u);
                p2--;
                r2=0;
            }
            else{
                break;
            }
        }
        s1=lower_bound(st1+1,st1+p1+1,i,cmp1)-st1-1, s2=lower_bound(st2+1,st2+p2+1,i,cmp2)-st2-1;
        b[i]=i+max(r1,r2)+1;
        ans1[i][0]=i, ans1[i][1]=b[i]-1, ans1[i][2]=b[i];
        if (s1&amp;&amp;s2){
            c[i]=*s.lower_bound(max(st1[s1],st2[s2]));
            if (c[i]&lt;=n){
                int u=lower_bound(st1+1,st1+p1+1,c[i],greater&lt;int&gt;())-st1,v=lower_bound(st2+1,st2+p2+1,c[i],greater&lt;int&gt;())-st2;
                ans2[i][0]=i, ans2[i][1]=min(st1[u],st2[v]), ans2[i][2]=max(st1[u],st2[v]), ans2[i][3]=c[i];
            }
        }
        else{
            c[i]=n+1;
        }
        st1[++p1]=i;
        st2[++p2]=i;
        r1++, r2++;
        t[i]+=2;
        if (i&lt;n&amp;&amp;b[i]&gt;b[i+1]){
            b[i]=b[i+1];
            for (int j=0;j&lt;3;++j){
                ans1[i][j]=ans1[i+1][j];
            }
        }
        if (i&lt;n&amp;&amp;c[i]&gt;c[i+1]){
            c[i]=c[i+1];
            for (int j=0;j&lt;4;++j){
                ans2[i][j]=ans2[i+1][j];
            }
        }
    }
    while (q--){
        int l,r;
        cin&gt;&gt;l&gt;&gt;r;
        if (r&gt;=c[l]){
            cout&lt;&lt;&#34;4\n&#34;;
            for (int j=0;j&lt;4;++j){
                cout&lt;&lt;ans2[l][j]&lt;&lt;&#34; &#34;;
            }
            cout&lt;&lt;&#34;\n&#34;;
        }
        else{
            if (r&gt;=b[l]){
                cout&lt;&lt;&#34;3\n&#34;;
                for (int j=0;j&lt;3;++j){
                    cout&lt;&lt;ans1[l][j]&lt;&lt;&#34; &#34;;
                }
                cout&lt;&lt;&#34;\n&#34;;
            }
            else{
                cout&lt;&lt;&#34;0\n\n&#34;;
            }
        }
    }
    return 0;    
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #632 (Div. 2)
    1333A
    Маленький Артем </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Маленький Артем</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Маленькому мальчику Артему понадобилась помощь его мамы Медины в       одной раскраске. Медина очень занята, поэтому она просит вашей помощи.</p>     <p>Артем хочет раскрасить доску $$$n \times m$$$. Каждая клетка       доски должна быть покрашена либо в белый, либо в черный цвет.</p>     <p>Пусть $$$B$$$  — количество черных клеток, у которых есть хотя бы       один белый сосед по стороне. Аналогично $$$W$$$  — количество       белых клеток, у которых есть хотя бы один черный сосед по стороне.       Раскраска доски называется <span class="tex-font-style-bf">хорошей</span>, если $$$B = W + 1$$$.</p>     <p>На первой из раскрасок ниже $$$B=5$$$, $$$W=4$$$ (каждая клетка       имеет хотя бы одного соседа противоположного цвета). На второй же       раскраска плохая, так как $$$B=4$$$, $$$W=4$$$ (только правая       нижняя клетка не имеет соседа противоположного цвета).</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/5611f0803c61268019d39e2781107538b4c56aeb.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>Пожалуйста, помогите Медине найти любую <span class="tex-font-style-bf">хорошую</span> раскраску. Гарантируется,       что для данных ограничений решение всегда существует. Если       существует несколько различных решений, выведите любое из них.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Каждый тест содержит несколько наборов входных данных.</p>     <p>Первая строка содержит количество наборов входных данных $$$t$$$       ($$$1 \le t \le 20$$$). Каждя из следующих $$$t$$$ строк содержит       два целых числа $$$n, m$$$ ($$$2 \le n,m \le 100$$$)  — размеры       таблицы, которую нужно покрасить.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого тестового случая выведите $$$n$$$ строк, каждая длины       $$$m$$$, где $$$i$$$-я обозначает $$$i$$$-ю строку раскрашенной       таблицы (<span class="tex-font-style-tt">B</span> обозначает       черную клетку и <span class="tex-font-style-tt">W</span>       обозначает белую клетку). Выводите все без использования кавычек.</p>     <p>Гарантируется, что для данных ограничений решение всегда существует.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
3 2
3 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
BW
WB
BB
BWB
BWW
BWB</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом тестовом случае $$$B=3$$$ и $$$W=2$$$.</p>     <p>Во втором тестовом случае $$$B=5$$$, $$$W=4$$$. Пример этой       раскраски есть в условии.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1333/problem/A' title='Codeforces Round 632 (Div. 2)'>1333A - Little Artem</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>In this problem it is enough to simply paint the upper left       corner white and all the others black for any size of the board       Like this:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/9edf990adfc3d4c4de05ac74491e6938308a387f.png" style="max-width: 100.0%;max-height: 100.0%;" /> </center>          <p>And there are $$$W=1$$$ (cell with coordinates $$$\{1, 1\}$$$)       and $$$B=2$$$ (cells with coordinates $$$\{1, 2\}$$$ and $$$\{2, 1\}$$$).</p>     <p>In the first version, the task restrictions were $$$1 \le n,       m$$$, but we thought it would be too difficult for div2A.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;


void solve() {
    int n, m; cin &gt;&gt; n &gt;&gt; m;
    string black_row(m, &#39;B&#39;);
    vector&lt;string&gt; result(n, black_row);
    result[0][0] = &#39;W&#39;;
    for (int i = 0; i &lt; n; ++i) {
        cout &lt;&lt; result[i] &lt;&lt; &#39;\n&#39;;
    }
}


int main() {
    int t; cin &gt;&gt; t;
    while(t--) solve();
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #632 (Div. 2)
    1333B
    Добрый Антон </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Добрый Антон</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Борису опять нужна помощь Антона в составлении задачи. На этот       раз Антону нужно решить для Бориса следующую задачу:</p>     <p>Есть две массива целых чисел $$$a$$$ и $$$b$$$ длины $$$n$$$.       Оказалось, что массив $$$a$$$ содержит элементы только из       множества $$$\{-1, 0, 1\}$$$.</p>     <p>Антон может проделать следующую последовательность операций любое       количество раз:</p>          <ol>  <li> Выбрать любую пару индексов $$$(i, j)$$$ такую, что $$$1         \le i &lt; j \le n$$$. Одну и ту же пару индексов $$$(i, j)$$$         можно выбирать сколько угодно раз.  </li>       <li> Добавить $$$a_i$$$ к $$$a_j$$$. Другими словами, $$$j$$$-й         элемент массива становится равным $$$a_i + a_j$$$. </li></ol>          <p>Например, из массива $$$[1, -1, 0]$$$ за одну операцию можно       получить массивы $$$[1, -1, -1]$$$, $$$[1, 0, 0]$$$ и $$$[1, -1, 1]$$$.</p>     <p>Антон хочет узнать, можно ли применить некоторое количество       (возможно, нулевое) операций выше к массиву $$$a$$$, чтобы       получить массив $$$b$$$. Можете ли вы ему помочь?</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Каждый тест содержит несколько наборов входных данных.</p>     <p>Первая строка содержит количество наборов входных данных $$$t$$$       ($$$1 \le t \le 10000$$$). Далее следуют описания наборов входных данных.</p>     <p>Первая строка каждого тестового случая содержит единственное       целое положительное число $$$n$$$ ($$$1 \le n \le 10^5$$$)  —       длину массивов.</p>     <p>Вторая строка каждого тестового случая содержит $$$n$$$ чисел       $$$a_1, a_2, \dots, a_n$$$ ($$$-1 \le a_i \le 1$$$)  — элементы       массива $$$a$$$. Среди этих элементов могут быть одинаковые значения.</p>     <p>Третья строка каждого тестового случая содержит $$$n$$$ чисел       $$$b_1, b_2, \dots, b_n$$$ ($$$-10^9 \le b_i \le 10^9$$$)  —       элементы массива $$$b$$$. Среди этих элементов могут быть       одинаковые значения.</p>     <p>Гарантируется, что сумма $$$n$$$ по всем тестовым случаям не       превосходит $$$10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого наборов входных данных выведите одну строку       содержащую «<span class="tex-font-style-tt">YES</span>» если можно       преобразовать массив $$$a$$$ так, чтобы он стал равен массиву       $$$b$$$, или «<span class="tex-font-style-tt">NO</span>» иначе.</p>     <p>Вы можете выводить каждую букву каждого ответа в любом регистре       (верхнем или нижнем).</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
3
1 -1 0
1 1 -2
3
0 1 1
0 2 2
2
1 0
1 41
2
-1 0
-1 -41
5
0 1 -1 1 -1
1 1 -1 1 -1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
YES
NO
YES
YES
NO
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных можно выбрать $$$(i, j)=(2, 3)$$$       дважды, затем $$$(i, j)=(1, 2)$$$ также дважды. Эти операции       изменят массив следующим образом: $$$[1, -1, 0] \to [1, -1, -2]       \to [1, 1, -2]$$$.</p>     <p>Во втором наборе входных данных нельзя сделать числа на второй       позиции равными.</p>     <p>В третьем наборе входных данных можно выбрать $$$(i, j)=(1, 2)$$$       $$$41$$$ раз. Аналогично в четвертом.</p>     <p>В последнем наборе входных данных преобразовать массив $$$a$$$ в       массив $$$b$$$ невозможно.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1333/problem/B' title='Codeforces Round 632 (Div. 2)'>1333B - Kind Anton</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>First of all, note that we can add an element with index $$$i$$$       to an element with index $$$j$$$ iff $$$i &lt; j$$$. This means       that the element $$$a_n$$$ cannot be added to any other element       because there is no index $$$j &gt; n$$$ in the array. This is why       we can first equalize the elements $$$a_n$$$ and $$$b_n$$$. If       $$$a_n = b_n$$$, they are already equal. If $$$a_n &lt; b_n$$$,       then we need to have element equal to $$$1$$$ along the elements       $$$a$$$ with indexes $$$\{1,..., n-1\}$$$. For $$$a_n &gt; b_n$$$,       we need to have $$$-1$$$ along these elements. After the elements       with index $$$n$$$ become equal, we can go to the element with       index $$$n-1$$$ and do the same. Then indexes $$$n-2$$$,       $$$n-3$$$, ..., $$$1$$$. You can implement this idea yourself!</p>     <p>Final time complexity: $$$O(n)$$$</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

void solve() {
    int n; cin &gt;&gt; n;
    vector&lt;int&gt; a(n), b(n);
    for (int i = 0; i &lt; n; ++i) {
        cin &gt;&gt; a[i];
    }
    for (int i = 0; i &lt; n; ++i) {
        cin &gt;&gt; b[i];
    }
    vector&lt;int&gt; good(2, 0);
    for (int i = 0; i &lt; n; ++i) {
        if (a[i] &gt; b[i] &amp;&amp; !good[0]) {
            cout &lt;&lt; &#34;NO\n&#34;;
            return;
        } else if (a[i] &lt; b[i] &amp;&amp; !good[1]) {
            cout &lt;&lt; &#34;NO\n&#34;;
            return;
        }
        if (a[i] == -1) good[0] = 1;
        if (a[i] == 1) good[1] = 1;
    }
    cout &lt;&lt; &#34;YES\n&#34;;
}

int main() {
    int t; cin &gt;&gt; t;
    while(t--) {
        solve();
    }
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #632 (Div. 2)
    1333C
    Евгений и массив </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Евгений и массив</div>     <div class="time-limit"><div class="property-title">ограничение по времени на       тест</div>1.5 секунд</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Евгений любит работать с массивами. Сегодня ему нужна ваша       помощь, чтобы решить одну сложную задачку.</p>     <p>Массив $$$c$$$ является подмассивом $$$b$$$, если $$$c$$$ может       быть получен из $$$b$$$ удалением нескольких (возможно, ни одного       или всех) элементов из начала и нескольких (возможно, ни одного       или всех) элементов из конца.</p>     <p>Назовем непустой массив <span class="tex-font-style-bf">хорошим</span>, если для любого       непустого подмассива этого массива, сумма его элементов не равна       нулю. К примеру, массив $$$[-1, 2, -3]$$$ является <span class="tex-font-style-bf">хорошим</span>, так как все массивы       $$$[-1]$$$, $$$[-1, 2]$$$, $$$[-1, 2, -3]$$$, $$$[2]$$$, $$$[2,       -3]$$$, $$$[-3]$$$ имеют ненулевую сумму элементов. В то же время,       массив $$$[-1, 2, -1, -3]$$$ не является <span class="tex-font-style-bf">хорошим</span>, так как его подмассив       $$$[-1, 2, -1]$$$ имеет сумму элементов равную $$$0$$$.</p>     <p>Помогите Евгению посчитать количество непустых <span class="tex-font-style-bf">хороших</span> подмассивов данного       массива $$$a$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка входных данных содержит одно целое число $$$n$$$       ($$$1 \le n \le 2 \times 10^5$$$)  — длину массива $$$a$$$.</p>     <p>Вторая строка входных данных содержит $$$n$$$ целых чисел $$$a_1,       a_2, \dots, a_n$$$ ($$$-10^9 \le a_i \le 10^9$$$)  — элементы       массива $$$a$$$. </p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одно целое число  — количество хороших подмассивов $$$a$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
1 2 -3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
5
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
41 -41 41
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере следующие подмассивы являются <span class="tex-font-style-bf">хорошими</span>: $$$[1]$$$, $$$[1,       2]$$$, $$$[2]$$$, $$$[2, -3]$$$, $$$[-3]$$$, Однако подмассив       $$$[1, 2, -3]$$$ не является <span class="tex-font-style-bf">хорошим</span>, поскольку его подмассив       $$$[1, 2, -3]$$$ имеет сумму элементов, равную $$$0$$$.</p>     <p>Во втором примере все три подмассива размера 1 <span class="tex-font-style-bf">хорошие</span> и только они. В то же       время, подмассив $$$[41, -41, 41]$$$ не является <span class="tex-font-style-bf">хорошим</span>, поскольку его подмассив       $$$[41, -41]$$$ имеет сумму элементов, равную $$$0$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1333/problem/C' title='Codeforces Round 632 (Div. 2)'>1333C - Eugene and an array</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's solve this problem in $$$O(n^2 \times log (n))$$$for now.</p>     <p>Note that if the subarray $$$[a_i,..., a_j]$$$ is good, then the       subarray $$$[a_i,..., a_{j-1}]$$$ is also good, and if the subset       $$$[a_i,..., a_j]$$$ is not good, then the subarray $$$[a_i,...,       a_{j+1}]$$$ is not good either. Then for each left border       $$$a_i$$$ we want to find the rightmost border $$$a_j$$$ such that       $$$[a_i,..., a_j]$$$ is good and add to the answer $$$j - i + 1$$$       (subarrays $$$[a_i, ..., a_j], [a_i, ..., a_{j-1}], ..., [a_i]$$$)       [1]. Let's denote the rightmost border $$$j$$$ for border $$$i$$$       as $$$R (i)$$$.</p>     <p>Let's calculate the prefix-sum of the array $$$P$$$.</p>     <p>$$$P_0 = 0, P_i = a_1 + .. + a_i, 1 \le i \le n$$$.</p>     <p>Note that a subset of $$$[a_i,..., a_j]$$$ has a zero sum iff       $$$P_{i-1} = P_j$$$. Then the subset $$$[a_i,..., a_j]$$$ is a       good iff sum of prefixes $$$[P_{i-1},..., P_j]$$$ has no       duplicates [2].</p>     <p>Using [1] and [2], we can simply iterate over $$$i$$$ from       $$$0$$$ to $$$n$$$ and over $$$j$$$ from $$$i$$$ to $$$n$$$ and       count the set of prefix sums $$$[P_i,..., P_j]$$$. The first       moment $$$j_0$$$ when this set contains duplicates gives us the       rightmost border $$$j_0-1$$$, and we add $$$(j_0-1) - i$$$ (no       $$$+1$$$, because it is an array of prefix sums) to answer.</p>     <p>To improve this solution to $$$O (n \times log(n))$$$, we need to       note that $$$R(i)$$$ is monotonous over $$$i$$$. Now we can       iterate over $$$i$$$ from $$$0$$$ to $$$n$$$ and over $$$j$$$ from       $$$R (i-1)$$$ to $$$n$$$ uses a set of prefix sums from the       previous iteration. Thus we have a solution $$$O (n \times       log(n))$$$, because $$$j$$$ points to each element of the array       exactly once.</p>     <p>If you code in C++, it is important not to use std::       unordered_set in this task, but use std::set. One of the       participants hacked the solution using std:: unordered_set, using       collisions in this structure. I highly recommend you to read this       blog for more info https://codeforces.com/blog/entry/62393.</p>     <p>Final time complexity: $$$O(n \times log(n))$$$</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;


int main() {
    int n; cin &gt;&gt; n;
    vector&lt;long long&gt; prefix(n + 1, 0);
    for (int i = 0; i &lt; n; ++i) {
        int x; cin &gt;&gt; x;
        prefix[i + 1] = prefix[i] + x;
    }
    int begin = 0, end = 0;
    long long ans = 0;
    set&lt;long long&gt; s = {0};
    while(begin &lt; n) {
        while(end &lt; n &amp;&amp; !s.count(prefix[end + 1])) {
            ++end;
            s.insert(prefix[end]);
        }
        ans += end - begin;
        s.erase(prefix[begin]);
        ++begin;
    }
    cout &lt;&lt; ans &lt;&lt; endl;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #632 (Div. 2)
    1333D
    Досуг в школе №41 </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Досуг в школе №41</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>В средней школе №41 учатся $$$n$$$ детей. Всем известно, что они       хорошие математики. Однажды на перемене ребята решили провести       исследование. Они выстроились в один ряд и повернули головы налево       или направо. </p>     <p>Дети проделывали следующую операцию: каждую секунду несколько пар       соседних в ряду детей, <span class="tex-font-style-bf">смотрящих         друг на друга</span>, могли <span class="tex-font-style-bf">одновременно</span> развернуться в       противоположную сторону. Таким образом, ребенок, смотрящий на       правого соседа, повернется налево, и наоборот для второго ребенка.       Более того, каждую секунду <span class="tex-font-style-bf">хотя бы       одна</span> пара соседних детей проделывала подобную операцию.       Процесс заканчивается, когда нет пары соседних детей смотрящих       друг на друга.</p>     <p>Дано число детей $$$n$$$, изначальная расстановка детей в ряду и       целое положительное число $$$k$$$. Необходимо найти       последовательность действий детей, завершающий процесс ровно за       $$$k$$$ секунд. Более формально, на каждый из $$$k$$$ ходов нужно       вывести номера детей, которые повернутся налево во время хода. </p>     <p>Для примера, дети могут действовать с конфигурацией приведенной       ниже и $$$k = 2$$$ следующим образом: </p>     <center> <img class="tex-graphics" src="https://espresso.codeforces.com/4418aa990b80704c3a74798df6d5de59155922b7.png" style="max-width: 100.0%;max-height: 100.0%;"/>     </center> На первом ходу развернутся две пары: $$$(1, 2)$$$ и $$$(3,     4)$$$. После этого получается такая конфигурация: <center> <img class="tex-graphics" src="https://espresso.codeforces.com/b9871e5eb8801b26aabc1d002dbf5efbc66f6132.png" style="max-width: 100.0%;max-height: 100.0%;"/>     </center> На втором ходу развернется только пара $$$(2, 3)$$$. В     итоговой конфигурации никакая пара детей не смотрит друг на друга.     Хорошая работа. <center> <img class="tex-graphics" src="https://espresso.codeforces.com/ff52419b92aa6c431791d79d2e4c284b2ddbb2a3.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>Если решение существует, то гарантируется что дети совершат не       более чем $$$n^2$$$ разворотов.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка входных данных содержит два целых числа $$$n$$$,       $$$k$$$ ($$$2 \le n \le 3000$$$, $$$1 \le k \le 3000000$$$)  —       количество детей и количество ходов через которые нужно закончить.</p>     <p>Вторая строка входных данных содержит строку длины $$$n$$$,       которая состоит только из символов <span class="tex-font-style-tt">L</span> и <span class="tex-font-style-tt">R</span>. <span class="tex-font-style-tt">L</span> значит, что ребенок смотрит       налево, а <span class="tex-font-style-tt">R</span>  — направо.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Если решения не существует, выведите $$$-1$$$.</p>     <p>Иначе, вывод должен состоять из $$$k$$$ строк. Каждая строка       должна начинаться с положительного целого числа $$$n_i$$$ ($$$1\le       n_i \le \frac{n}{2}$$$)  — количества пар детей, которые       развернутся на этом ходу. Далее в этой же строке должно следовать       $$$n_i$$$ <span class="tex-font-style-bf">попарно различных</span>       чисел  — номера детей, которые повернут голову налево во время       этого хода. </p>     <p>После проведения всех разворотов, не должно быть пары соседних       детей, смотрящих друг на друга.</p>     <p>Если существует более одного решения, выведите любое из них.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2 1
RL
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1 1 
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
2 1
LR
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
-1</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
4 2
RLRL
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2 1 3 
1 2
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Первый тест описывает пару детей смотрящих друг на друга. За один       ход они развернутся.</p>     <p>Во втором тесте дети не могут сделать ни одного хода. В итоге они       не смогут закончить за $$$k&gt;0$$$ ходов.</p>     <p>Третий тест описан в условии.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1333/problem/D' title='Codeforces Round 632 (Div. 2)'>1333D - Challenges in school №41</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>If solution exist let's count the minimum and maximum bounds for       $$$k$$$ for initial arrangement of children. A minimum $$$k$$$       achieved all possible pairs of children turn theirs heads at every       step. The maximum $$$k$$$ reached if only one of possible pairs of       children turn theirs heads at every step. This values is easy to       count, I'll leave it to you!</p>     <p>If $$$k$$$ from the statement not fit within our bounds, then we       need to print $$$-1$$$. Otherwise solution exist and we need to       construct them. For each next move we can use all pairs of       children to turn theirs heads, decrease $$$k$$$ by 1 and       recalculate maximum bound (lets call it $$$U$$$) on $$$k$$$ (just       decrease them on the number of pairs used). If after moving new       value of $$$k$$$ fits in the bound ($$$k \le U$$$), then we       proceed to the next iteration. Otherwise, we roll back to the       previous iteration and use $$$U - k + 1$$$ pairs in this move.       Number of remaining moves will be $$$k - 1$$$ and upper bound will       be $$$U - (U - k + 1) = k - 1$$$. And from that moment, just use       only one pair in one move to the end of the process (to find one       of the pair quickly we need to store them in the queue).</p>     <p>Final time complexity: $$$O(n^2)$$$</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int n, k;

vector&lt;int&gt; find_steps(const vector&lt;int&gt;&amp; a) {
    vector&lt;int&gt; steps;
    for (int i = 0; i &lt; n - 1; ++i) {
        if (a[i] == 1 &amp;&amp; a[i + 1] == 0) steps.push_back(i);
    }
    return steps;
}


int main() {
    cin &gt;&gt; n &gt;&gt; k;
    string s; cin &gt;&gt; s;
    vector&lt;int&gt; a(n);
    for (int i = 0; i &lt; n; ++i) a[i] = (s[i] == &#39;L&#39;) ? 0 : 1;
    int maxi = 0, mini = 0;
    int cnt = 0;
    int last = -1;
    for (int i = n - 1; i &gt;= 0; --i) {
        if (a[i] == 0) {
            ++cnt;
        } else {
            if (cnt == 0) continue;
            maxi += cnt;
            mini = max(cnt, last + 1);
            last = mini;
        }
    }
    if (k &lt; mini || k &gt; maxi) {
        cout &lt;&lt; -1;
        return 0;
    }
    bool is_min = false;
    vector&lt;int&gt; have_step;
    for (int i = 0; i &lt; k; ++i) {
        if (!is_min) {
            auto steps = find_steps(a);
            cout &lt;&lt; min(int(steps.size()), maxi - k + i + 1) &lt;&lt; &#39; &#39;;
            int cur = 0;
            while (k - i - 1 &lt; maxi &amp;&amp; cur &lt; steps.size()) {
                cout &lt;&lt; steps[cur] + 1 &lt;&lt; &#39; &#39;;
                a[steps[cur]] = 0;
                a[steps[cur] + 1] = 1;
                ++cur;
                --maxi;
            }
            if (maxi == k - i - 1) {
                is_min = true;
                have_step = find_steps(a);
            }
        } else {
            int v = have_step.back();
            have_step.pop_back();
            cout &lt;&lt; &#34;1 &#34; &lt;&lt; v + 1;
            a[v] = 0;
            a[v + 1] = 1;
            if (v &gt; 0 &amp;&amp; a[v - 1] == 1) {
                have_step.push_back(v - 1);
            }
            if (v + 2 &lt; n &amp;&amp; a[v + 2] == 0) {
                have_step.push_back(v + 1);
            }
        }
        cout &lt;&lt; &#39;\n&#39;;
    }
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #632 (Div. 2)
    1333E
    Путь к 1600 </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. Путь к 1600</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Егор стремится набрать 1600 баллов на известном шахматном портале       ChessForces и ему нужна ваша помощь!</p>     <p>Прежде чем приступить к решению проблемы, Егор хочет напомнить       вам, как ходят шахматные фигуры. Шахматная <span class="tex-font-style-bf">ладья</span> движется по прямым линиям       вверх и вниз, влево и вправо на столько квадратов, сколько       захочет. И когда она хочет, может остановиться. <span class="tex-font-style-bf">Ферзь</span> ходит во всех направлениях       по вертикали, горизонтали и по диагоналям на любом расстоянии. Вы       можете увидеть примеры ниже.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/f248a178246631ca6da7e0c538d2a70f35c77fea.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>Для достижения цели Егор должен исследовать следующую проблему:</p>     <p>Дана доска $$$N \times N$$$. Каждая ячейка доски имеет число от       $$$1$$$ до $$$N ^ 2$$$, и все числа в клетках попарно различны.</p>     <p>В начале некоторая фигура ставится в ячейку с номером $$$1$$$.       Заметьте, что эта ячейка уже считается посещенной. После этого       каждый ход определяется следующим образом:</p>          <ol> <li> Среди всех пока <span class="tex-font-style-bf">непосещенных</span> клеток, которые         могут быть достигнуты одним движением фигуры, фигура движется в         ячейку с <span class="tex-font-style-bf">минимальным</span> номером.         </li>       <li> Если все доступные ячейки уже посещены и на доске остались         непосещенные клетки, то шахматная фигура телепортируется в         непосещенную клетку с минимальным номером. В конце этого шага         фигура вынуждена заплатить $$$1$$$ <span class="tex-font-style-bf">vun</span>.         </li>       <li> Если все ячейки уже посещены, тогда процесс останавливается. </li></ol>          <p>Егор должен найти такую нумерацию доски размера $$$N \times N$$$,       что ладья, обойдя всю доску, заплатит <span class="tex-font-style-bf">строго меньше vun–ов</span>, чем ферзь       на этой доске. Помогите Егору найти подходящую доску размера $$$N       \times N$$$, или скажите, что ее не существует.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Единственная строка содержит число $$$N$$$  — размер доски,       $$$1\le N \le 500$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Вывод должен содержать $$$N$$$ строк.</p>     <p>В $$$i$$$–ой строке выведите $$$N$$$ чисел  — числа в $$$i$$$-м       горизонтальном ряду доски. Все числа от $$$1$$$ до $$$N \times       N$$$ должны быть использованы ровно один раз.</p>     <p>На вашей доске ладья должна платить строго меньше vun–ов, чем ферзь.</p>     <p>Если решения не существует, выведите $$$-1$$$.</p>     <p>Если существует более одного решения, выведите любое из них.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
-1</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
4 3 6 12 
7 5 9 15 
14 1 11 10 
13 8 16 2 
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В случае с доской размера $$$1 \times 1$$$, и ладья, и ферзь не       платят ничего.</p>     <p>Во втором примере <span class="tex-font-style-tt">ладья</span>       проходит через клетки $$$1 \to 3 \to 4 \to 6 \to 9 \to 5 \to 7 \to       13 \to 2 \to 8 \to 16 \to 11 \to 10 \to 12 \to 15 \to \textbf{(1       vun)} \to 14$$$.</p>     <p>       <span class="tex-font-style-tt">Ферзь</span> проходит через $$$1       \to 3 \to 4 \to 2 \to 5 \to 6 \to 9 \to 7 \to 13 \to 8 \to 11 \to       10 \to 12 \to 15 \to \textbf{(1 vun)} \to 14 \to \textbf{(1 vun)}       \to 16$$$. </p>     <p>В результате ладья платит 1 vun, а ферзь платит 2 vun.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1333/problem/E' title='Codeforces Round 632 (Div. 2)'>1333E - Road to 1600</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>First of all notice that there are no such boards for       $$$N=1,2$$$. Then you can find an example for $$$N=3$$$ by       yourself or with counting all cases with program. One of possible       examples (I find it using paper, pencil and my hands):</p>     <p>$$$N=3$$$:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/6f63f1f06ce3e63d9b1c7088248563c2269ce253.png" style="max-width: 100.0%;max-height: 100.0%;" /> </center>          <p>For large $$$N$$$ we can walk by spiral (like snake) to the case $$$N=3$$$.</p>     <p>$$$N=4$$$:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/922d9c3ca8a77836271826fca961156c88c2e8ad.png" style="max-width: 100.0%;max-height: 100.0%;" /> </center>          <p>$$$N=5$$$:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/804e2c44dd85e9c649e7c6cb515a771702bf835e.png" style="max-width: 100.0%;max-height: 100.0%;" /> </center>          <p>Rook and Queen first going in a spiral and arrive to $$$N=3$$$       case. It can be used any of such spiral, not just this one.</p>     <p>Final time complexity: $$$O(N^2)$$$</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;


int main() {
    int n; cin &gt;&gt; n;
    if (n &lt; 3) {
        cout &lt;&lt; -1;
        return 0;
    }
    vector&lt;int&gt; solution = {
        1, 3, 4, 8, 2, 7, 9, 5, 6
    };
    vector&lt;vector&lt;int&gt;&gt; table(n, vector&lt;int&gt;(n, 0));
    int cur = 1;
    for (int i = 0; i &lt; n - 3; ++i) {
        if (i &amp; 1) {
            for (int j = n - 1; j &gt;= 0; --j) {
                table[i][j] = cur;
                ++cur;
            }
        } else {
            for (int j = 0; j &lt; n; ++j) {
                table[i][j] = cur;
                ++cur;
            }
        }
    }
    if ((n - 3) &amp; 1) {
        for (int j = n - 1; j &gt;= 0; --j) {
            if (j &amp; 1) {
                for (int i = n - 3; i &lt; n; ++i) {
                    if (j &gt; 2) {
                        table[i][j] = cur;
                        ++cur;
                    } else {
                        table[i][j] = solution[(2 - j) * 3 + i - n + 3] + n * n - 9;
                    }
                }
            } else {
                for (int i = n - 1; i &gt;= n - 3; --i) {
                    if (j &gt; 2) {
                        table[i][j] = cur;
                        ++cur;
                    } else {
                        table[i][j] = solution[(2 - j) * 3 + n - 1 - i] + n * n - 9;
                    }
                }
            }
        }
    } else {
        for (int j = 0; j &lt; n; ++j) {
            if (j &amp; 1) {
                for (int i = n - 1; i &gt;= n - 3; --i) {
                    if (j &lt; n - 3) {
                        table[i][j] = cur;
                        ++cur;
                    } else {
                        table[i][j] = solution[(j - n + 3) * 3 + n - 1 - i] + n * n - 9;
                    }
                }
            } else {
                for (int i = n - 3; i &lt; n; ++i) {
                    if (j &lt; n - 3) {
                        table[i][j] = cur;
                        ++cur;
                    } else {
                        table[i][j] = solution[(j - n + 3) * 3 + i - n + 3] + n * n - 9;
                    }
                }
            }
        }
    }
    for (int i = 0; i &lt; n; ++i) {
        for (int j = 0; j &lt; n; ++j) {
            cout &lt;&lt; table[i][j] &lt;&lt; &#39; &#39;;
        }
        cout &lt;&lt; &#39;\n&#39;;
    }
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #632 (Div. 2)
    1333F
    Катя и несовершенства </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Катя и несовершенства</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У Кати есть множество $$$S$$$ состоящее из $$$n$$$ чисел $$$\{1,       \dots, n\} $$$. </p>     <p>Катя считает, что <span class="tex-font-style-bf">уродливость</span> множества $$$M       \subseteq S$$$ равна <span class="tex-font-style-bf">максимуму</span> из $$$gcd(a, b)$$$, по       всем парам $$$(a, b)$$$ таким, что и $$$a$$$ и $$$b$$$ лежат в       $$$M$$$, и $$$a \neq b$$$. </p>     <p>Катя очень аккуратная девушка, поэтому для каждого $$$k \in \{2,       \dots, n\}$$$ она хочет найти подмножество имеющее <span class="tex-font-style-bf">наименьшую уродливость</span> среди       всех подмножеств $$$S$$$ размера $$$k$$$. Подмножеств заданного       размера с минимальной уродливостью может быть больше одного, но       вам не стоит беспокоиться по этому поводу. Катя найдет нужное ей       подмножество сама. От вас ей нужно узнать лишь минимальную       возможную уродливость для каждого $$$k$$$ определенного выше,       назовем ее $$$I_k$$$.</p>     <p>Пожалуйста, помогите Кате найти $$$I_2$$$, $$$I_3$$$, ..., $$$I_n$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая и единственная строка входных данных состоит из одного       целого положительного числа $$$n$$$ ($$$2\le n \le 5 \cdot       10^5$$$)  — размер заданного множества $$$S$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Вам нужно вывести только одну строку содержащую $$$n - 1$$$       число: $$$I_2$$$, $$$I_3$$$, ..., $$$I_n$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1 </pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1 1 </pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Ответ на первый пример 1, так как $$$gcd(1, 2) = 1$$$.</p>     <p>Во втором примере существуют подмножества $$$S$$$ размеров $$$2,       3$$$ с уродливостью 1. Например, $$$\{2,3\}$$$ и $$$\{1, 2, 3\}$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1333/problem/F' title='Codeforces Round 632 (Div. 2)'>1333F - Kate and imperfection</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let $$$A = \{a_1, a_2, ..., a_k\}$$$ be one of the possible       subsets with smallest imperfection. If for any number $$$a_i$$$ in       $$$A$$$ not all of its divisors contained in $$$A$$$ then we can       replace $$$a_i$$$ with one of it divisor. The size os the subset       does not change and imperfection may only decrease. Then we can       assume that for any $$$a_i$$$ all of it divisors contained in       $$$A$$$. Let $$$d(n)$$$ be the greatest divisor of $$$n$$$ exclude       $$$n$$$ ($$$d(1)=1$$$). Since $$$A$$$ contains element with its       divisors then smallest gcd of pair of an elements not less than       maximum of $$$d(a_i)$$$ over elements of $$$A$$$ (because $$$A$$$       contains $$$a_i$$$ with $$$d(a_i)$$$). And for any element       $$$a_i$$$ there is no element $$$a_j &lt; a_i$$$ in $$$A$$$ with       $$$gcd(a_i, a_j) &gt; d(a_i)$$$ (because $$$d(a_i)$$$ is the       greatest divisor). Then imperfection of $$$A$$$ is equal to       greatest $$$d(a_i)$$$ over elements of $$$A$$$. After this       observation we can just sort elements $$$\{1, ..., n\}$$$ by       theirs $$$d(*)$$$ and take smallest $$$k$$$ for every $$$2 \le k       \le n$$$. You can calculate $$$d(*)$$$ using the sieve of Eratosthenes.</p>     <p>Final time complexity: $$$O(n \times log(n))$$$</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;


vector&lt;int&gt; max_div;

void eratosthenes(int limit) {
    max_div.assign(limit + 1, 0);
    max_div[0] = limit + 10;
    max_div[1] = 1;
    for (int i = 2; i &lt;= limit; ++i) {
        if (max_div[i]) continue;
        for (int j = i; j &lt;= limit; j += i) {
            if (max_div[j]) continue;
            max_div[j] = j / i;
        }
    }
}


int main() {
    int n; cin &gt;&gt; n;
    eratosthenes(n);
    sort(max_div.begin(), max_div.end());
    for (int i = 1; i &lt; n; ++i) {
        cout &lt;&lt; max_div[i] &lt;&lt; &#39; &#39;;
    }
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 85 (рейтинговый для Див. 2)
    1334A
    Статистика по уровню </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Статистика по уровню</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Поликарп недавно создал новый уровень в этой новой клевой игре       Berlio Maker 85 и загрузил его в сеть. Теперь игроки со всего мира       могут попробовать его уровень.</p>     <p>У каждого уровня в этой игре есть статистика — две величины:       количество попыток и количество успешных прохождений. Так если       игрок играет уровень, то количество попыток увеличивается на       $$$1$$$. Если же он еще и успешно его завершает, то количество       успешных прохождений тоже увеличивается на $$$1$$$. <span class="tex-font-style-bf">Обратите внимание, что обе величины         обновляются одновременно</span> (то есть если игрок успешно       завершает уровень, то количество попыток обновится одновременно с       количеством успешных прохождений).</p>     <p>Поликарпу не терпится узнать, насколько же сложный уровень у него       получился, поэтому он постоянно смотрит статистику.</p>     <p>Более точно, он взглянул на статистику $$$n$$$ раз и выписал       $$$n$$$ пар целых чисел — $$$(p_1, c_1), (p_2, c_2), \dots, (p_n,       c_n)$$$, где $$$p_i$$$ — это количество попыток (от слова plays) в       $$$i$$$-й момент времени, а $$$c_i$$$ — это количество успешных       прохождений (от слова clears) в тот же момент времени. <span class="tex-font-style-bf">Статистика дана в хронологическом       порядке</span> (то есть порядок данных пар точно совпадает с тем,       как Поликарп их выписывал).</p>     <p>Между двумя последовательными моментами времени, когда Поликарп       смотрел статистику, много (но возможно и ноль) игроков могли       попробовать уровень.</p>     <p>Наконец, Поликарпу интересно, не ошибся ли он нигде в своих       записях. Если существует такая последовательность попыток игроков       (и успешных прохождений, соответственно), что статистика была       ровно такая, как Поликарп выписал, то он считает свои записи правильными.</p>     <p>Помогите ему определить правильность его записей.</p>     <p>Для вашего удобства вам потребуется ответить на несколько       независимых наборов входных данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$T$$$ $$$(1 \le T \le       500)$$$ — количество наборов входных данных.</p>     <p>В первой строке каждого набора входных данных записано одно целое       число $$$n$$$ ($$$1 \le n \le 100$$$) — количество моментов       времени, когда Поликарп смотрел статистику.</p>     <p>В каждой из следующих $$$n$$$ строк записаны по два целых числа       $$$p_i$$$ и $$$c_i$$$ ($$$0 \le p_i, c_i \le 1000$$$) — количество       попыток и количество успешных прохождений уровня в $$$i$$$-й       момент времени.</p>     <p>       <span class="tex-font-style-bf">Обратите внимание, что статистика         задана в хронологическом порядке.</span></p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите одну строку.</p>     <p>Если существует такая последовательность попыток игроков (и       успешных прохождений, соответственно), что статистика была ровно       такая, как Поликарп выписал, то выведите «<span class="tex-font-style-tt">YES</span>».</p>     <p>Иначе выведите «<span class="tex-font-style-tt">NO</span>».</p>     <p>Вы можете выводить каждую букву в любом регистре (строчную или заглавную).</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
3
0 0
1 1
1 2
2
1 0
1000 3
4
10 1
15 2
10 2
15 2
1
765 432
2
4 4
4 3
5
0 0
1 0
1 0
1 0
1 0
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
NO
YES
NO
YES
NO
YES
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных в третий момент времени количество       успешных прохождений увеличилось, а количество попыток нет, чего       не могло произойти.</p>     <p>Второй набор входных данных — это неплохой пример Super Expert уровня.</p>     <p>В третьем наборе входных данных количество попыток уменьшилось,       что невозможно.</p>     <p>Четвертый набор входных данных — это скорее всего авто уровень с       одним прыжком через шипы.</p>     <p>В пятом наборе входных данных количество успешных попыток       уменьшилось, что также невозможно.</p>     <p>Никто не хотел играть шестой набор входных данных; мама Поликарпа       попробовала, чтобы он не расстраивался, однако, не смогла пройти уровень.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1334/problem/A' title='Educational Codeforces Round 85 (Rated for Div. 2)'>1334A - Level Statistics</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's use the fact that initially the level has $$$0$$$ plays and       $$$0$$$ clears. Call the differences before the previous stats and       the current ones $$$\Delta p$$$ and $$$\Delta c$$$.</p>     <p>The stats are given in chronological order, so neither the number       of plays, nor the number of clears should decrease (i.e. $$$\Delta       p \ge 0$$$ and $$$\Delta c \ge 0$$$).</p>     <p>Finally, $$$\Delta p$$$ should be greater or equal to $$$\Delta       c$$$. It's easy to show that if $$$\Delta c$$$ players pass the       level successfully and $$$\Delta p - \Delta c$$$ players just try       the level then such deltas are achieved.</p>     <p>So in implementation it's enough to check these three conditions       between the consecutive pieces of data (including the initial       ($$$0, 0$$$)).</p>     <p>Overall complexity: $$$O(n)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

#define forn(i, n) for (int i = 0; i &lt; int(n); i++)

using namespace std;


int main() {
	int tc;
	scanf(&#34;%d&#34;, &amp;tc);
	while (tc--){
		int n;
		scanf(&#34;%d&#34;, &amp;n);
		int p = 0, c = 0;
		bool fl = true;
		forn(i, n){
			int x, y;
			scanf(&#34;%d%d&#34;, &amp;x, &amp;y);
			if (x &lt; p || y &lt; c || y - c &gt; x - p)
				fl = false;
			p = x, c = y;
		}
		puts(fl ? &#34;YES&#34; : &#34;NO&#34;);
	}
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 85 (рейтинговый для Див. 2)
    1334B
    Средний класс </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Средний класс</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Давным-давно Берляндия была маленькой страной, в которой       проживало только $$$n$$$ человек. Каждый из них имел некоторое       количество сбережений: у $$$i$$$-го человека было $$$a_i$$$ бурлей.</p>     <p>Правительство считало человека богатым, если у него было хотя бы       $$$x$$$ бурлей. Чтобы увеличить количество богатых людей в       Берляндии, решили провести несколько реформ. Каждая реформа       выглядела следующим образом: </p>     <ul> <li> правительство выбирает некоторое подмножество людей         (возможно, всех); </li>       <li> правительство забирает все сбережения у выбранных людей и         перераспределяет их среди выбранных людей поровну. </li></ul>          <p>Например, представим сбережения как список $$$[5, 1, 2, 1]$$$:       если правительство выбирает $$$1$$$-го и $$$3$$$-го человека, то       оно, сначала заберет у них все $$$5 + 2 = 7$$$ бурлей, а потом       вернет каждому по $$$3.5$$$ бурлей. В результате сбережения примут       вид $$$[3.5, 1, 3.5, 1]$$$.</p>     <p>Много информации было потеряно с того времени, поэтому мы не       знаем, сколько реформ было проведено и на ком. Все, что мы можем —       это попросить вас посчитать максимально возможное количество       богатых людей после некоторого (возможно нулевого) количества реформ.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке задано единственное число $$$T$$$ ($$$1 \le T \le       1000$$$) — количество наборов входных данных.</p>     <p>В следующих $$$2T$$$ строках заданы сами наборы — по две строки       на набор. В первой строке заданы два целых числа $$$n$$$ и $$$x$$$       ($$$1 \le n \le 10^5$$$, $$$1 \le x \le 10^9$$$) — количество       человек и минимальное количество денег, чтобы считаться богатым.</p>     <p>Во второй строке заданы $$$n$$$ целых чисел $$$a_1, a_2, \dots,       a_n$$$ ($$$1 \le a_i \le 10^9$$$) — первоначальное количество       сбережений у каждого человека.</p>     <p>Гарантируется, что сумма всех $$$n$$$ не превосходит $$$10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$T$$$ чисел — по одному на набор входных данных. Для       каждого набора выведите максимально возможное количество богатых       людей после некоторого (возможно нулевого) количества реформ.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
4 3
5 1 2 1
4 10
11 9 11 9
2 5
4 3
3 7
9 4 9
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
4
0
3
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Первый пример описан в условии задачи.</p>     <p>Во втором примере правительство, например, могло провести       следующие реформы: $$$[\underline{11}, \underline{9}, 11, 9]       \rightarrow [10, 10, \underline{11}, \underline{9}] \rightarrow       [10, 10, 10, 10]$$$.</p>     <p>В третьем примере правительство не сможет сделать даже одно       человека богатым.</p>     <p>В четвертом примере правительство могло выбрать всех людей в       реформе: $$$[\underline{9}, \underline{4}, \underline{9}]       \rightarrow [7\frac{1}{3}, 7\frac{1}{3}, 7\frac{1}{3}]$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1334/problem/B' title='Educational Codeforces Round 85 (Rated for Div. 2)'>1334B - Middle Class</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>In fact, to carry out only one reform is always enough. And it's       easy to prove if you make only one reform it's always optimal to       take the maximum such $$$k$$$ that the average of $$$k$$$ maximums       in the array $$$a$$$ is at least $$$x$$$ (i.e. sum greater or       equal to $$$kx$$$). So the solution is next: sort array $$$a$$$       and find the suffix with maximum length $$$k$$$ such that the sum       on the suffix is at least $$$kx$$$.</p>     <p>===</p>     <p>To prove the fact about one reform we can prove another fact:       after each reform, the sum of $$$k$$$ maximums doesn't increase       for each $$$k$$$. We'll prove it in two steps.</p>     <p>The first step. Let's look at some reform and form an array       $$$b$$$ from the chosen elements in $$$a$$$ in descending order.       After the reform we'll get array $$$b'$$$ where all $$$b'[i] =       \frac{1}{|b|} \sum_{i=1}^{|b|}{b[i]}$$$. Let's just skip the proof       and say it's obvious enough that $$$\sum_{i=1}^{y}{b[i]} \ge       \sum_{i=1}^{y}{b'[i]}$$$ for any $$$y$$$.</p>     <p>The second step. Let fix $$$k$$$ and divide array $$$a$$$ on two       parts: $$$k$$$ maximums as $$$a_1$$$ and other $$$n - k$$$       elements as $$$a_2$$$. And let's make the same division of       $$$a'$$$ (the array after performing the reform) on $$$a'_1$$$ and       $$$a'_2$$$. So, we need to prove that $$$sum(a'_1) \le       sum(a_1)$$$. </p>     <p>Suppose $$$m$$$ elements were chosen in the reform: $$$cnt$$$ of       them were in $$$a_1$$$ and $$$cnt'$$$ now in $$$a'_1$$$. If $$$cnt       \ge cnt'$$$ then we can think like maximum $$$cnt'$$$ elements       from $$$cnt$$$ elements in $$$a$$$ were replaced by the average       and other $$$cnt - cnt'$$$ were replaced by elements from       $$$a_2$$$. Since $$$\sum_{i=1}^{cnt'}{b[i]} \ge       \sum_{i=1}^{cnt'}{b'[i]}$$$ and any element from $$$a_1$$$ is       greater or equal to any element from $$$a_2$$$ then we proved that       $$$sum(a'_1) \le sum(a_1)$$$ when $$$cnt \ge cnt'$$$.</p>     <p>If $$$cnt &lt; cnt'$$$ then let's look at $$$a_2$$$ and       $$$a'_2$$$. The $$$a_2$$$ has $$$m - cnt$$$ chosen elements and       $$$a'_2$$$ has $$$m - cnt'$$$, so $$$m - cnt &gt; m - cnt'$$$ and       we can prove that $$$sum(a'_2) \ge sum(a_2)$$$ practically in the       same way as before. Obviously, if $$$sum(a') = sum(a)$$$ and       $$$sum(a'_2) \ge sum(a_2)$$$ then $$$sum(a'_1) \le sum(a_1)$$$. Q.E.D.</p>     <p>The last step is easy, let's prove that the only reform is       enough. The answer after several reforms is clearly equal to       $$$k$$$ maximums which are at least $$$x$$$. But it means that the       sum of $$$k$$$ maximums is at least $$$kx$$$, therefore the sum of       $$$k$$$ maximums in the initial array is at least $$$kx$$$. So we       can make them all at least $$$k$$$ by only one reform. </p></div></div></div>

           
            <pre><code>fun main() {
    val T = readLine()!!.toInt()
    for (tc in 1..T) {
        val (n, x) = readLine()!!.split(&#39; &#39;).map { it.toInt() }
        val a = readLine()!!.split(&#39; &#39;).map { it.toInt() }.sortedDescending()

        var cnt = 0
        var sum = 0L
        while (cnt &lt; n &amp;&amp; sum + a[cnt] &gt;= (cnt + 1) * x.toLong()) {
            sum += a[cnt]
            cnt++
        }
        println(cnt)
    }
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 85 (рейтинговый для Див. 2)
    1334C
    Круг монстров </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Круг монстров</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вы играете в очередную компьютерную игру, и теперь вам предстоит       убить $$$n$$$ монстров. Эти монстры стоят в круге, пронумерованном       по часовой стрелке от $$$1$$$ до $$$n$$$. Изначально $$$i$$$-й       монстр имеет $$$a_i$$$ единиц здоровья.</p>     <p>Вы можете стрелять в монстров, чтобы убить их. Каждый выстрел       требует ровно одной пули и уменьшает здоровье монстра на $$$1$$$       (наносит ему $$$1$$$ единицу урона). Кроме того, когда здоровье       некоторого монстра $$$i$$$ становится $$$0$$$ или меньше $$$0$$$,       он умирает и взрывается, нанося $$$b_i$$$ урон следующему монстру       (монстру под номером $$$i + 1$$$, если $$$i &lt; n$$$, или монстру       под номером $$$1$$$, если $$$i = n$$$). Если следующий монстр уже       мертв, то ничего не происходит. Если взрыв убивает следующего       монстра, он тоже взрывается, повреждая монстра после него и,       возможно, вызывая еще один взрыв, и так далее.</p>     <p>Вы должны посчитать минимальное количество пуль, которое нужно       выстрелить, чтобы убить всех $$$n$$$ монстров в кругу.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит одно целое число $$$T$$$ ($$$1 \le T \le       150000$$$) — количество наборов входных данных.</p>     <p>Затем следуют наборы входных данных, каждый из них начинается со       строки, содержащей одно целое число $$$n$$$ ($$$2 \le n \le       300000$$$) — количество монстров. Затем следуют $$$n$$$ строк,       каждая из которых содержит два целых числа $$$a_i$$$ и $$$b_i$$$       ($$$1 \le a_i, b_i \le 10^{12}$$$) — параметры $$$i$$$-го монстра       в круге.</p>     <p>Гарантируется, что общее количество монстров во всех тестовых       случаях не превышает $$$300000$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите одно целое число —       минимальное количество пуль, которые нужно выстрелить, чтобы убить       всех монстров.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
1
3
7 15
2 14
5 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
6
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1334/problem/C' title='Educational Codeforces Round 85 (Rated for Div. 2)'>1334C - Circle of Monsters</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>We cannot utilize the explosion of the last monster we kill. So       the naive approach is to iterate on the monster we kill the last,       break the circle between this monster and the next one, and then       shoot the first monster in the broken circle until it's dead, then       the second one, and so on.</p>     <p>Let's calculate the number of bullets we will fire this way. If       the circle is broken after the monster $$$i$$$, then the first       monster gets $$$a_{i + 1}$$$ bullets, the second one — $$$\max(0,       a_{i + 2} - b_{i + 1})$$$, and so on; all monsters except the       first one get exactly $$$\max(0, a_i - b_{i - 1})$$$ bullets. </p>     <p>So we should choose an index $$$i$$$ such that $$$a_{i + 1} -       \max(0, a_{i + 1} - b_i)$$$ is minimum possible, since this is the       number of bullets we have to spend additionally since we cannot       utilize the explosion of the $$$i$$$-th monster. After breaking       the circle between the monsters $$$i$$$ and $$$i + 1$$$, you may       use a formula to calculate the required number of bullets, or just       model the shooting.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

#define forn(i, n) for (int i = 0; i &lt; int(n); ++i)

typedef long long li;

const int N = 300 * 1000 + 13;

int n;
li a[N], b[N];

void solve() {
	scanf(&#34;%d&#34;, &amp;n);
	forn(i, n) scanf(&#34;%lld%lld&#34;, &amp;a[i], &amp;b[i]);
	
	li ans = 0, mn = 1e18;
	forn(i, n) {
		int ni = (i + 1) % n;
		li val = min(a[ni], b[i]);
		ans += a[ni] - val;
		mn = min(mn, val);
	}
	ans += mn;
	printf(&#34;%lld\n&#34;, ans);
}

int main() {
	int T;
	scanf(&#34;%d&#34;, &amp;T);
	forn(i, T)
		solve();
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 85 (рейтинговый для Див. 2)
    1334D
    Минимальный эйлеров цикл </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Минимальный эйлеров цикл</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам задан <span class="tex-font-style-it">полный       ориентированный</span> граф $$$K_n$$$ из $$$n$$$ вершин: у каждой       пары вершин $$$u \neq v$$$ в $$$K_n$$$ есть обе дуги $$$(u, v)$$$       и $$$(v, u)$$$; петель в графе нет.</p>     <p>Вам нужно найти такой цикл в $$$K_n$$$, который проходит по       каждой дуге ровно один раз (вершины можно посещать несколько раз).</p>     <p>Мы можем выписать такой цикл как список из $$$n(n - 1) + 1$$$       вершин $$$v_1, v_2, v_3, \dots, v_{n(n - 1) - 1}, v_{n(n - 1)},       v_{n(n - 1) + 1} = v_1$$$ — порядок обхода, в котором каждая дуга       $$$(v_i, v_{i + 1})$$$ встречается по одному разу.</p>     <p>Найдите <span class="tex-font-style-bf">лексикографически       минимальный</span> такой цикл. Не трудно доказать, что такой цикл       всегда существует.</p>     <p>Так как ответ может быть слишком большим, выведите только его       $$$[l, r]$$$ отрезок, то есть $$$v_l, v_{l + 1}, \dots, v_r$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке задано единственное число $$$T$$$ ($$$1 \le T \le       100$$$) — количество наборов входных данных.</p>     <p>В следующих $$$T$$$ строках заданы сами наборы входных данных —       по одному на строку. В данной строке задано три целых числа       $$$n$$$, $$$l$$$ и $$$r$$$ ($$$2 \le n \le 10^5$$$, $$$1 \le l \le       r \le n(n - 1) + 1$$$, $$$r - l + 1 \le 10^5$$$) — количество       вершин в $$$K_n$$$ и отрезок цикла, который нужно вывести.</p>     <p>Гарантируется, что сумма по $$$n$$$ не превосходит $$$10^5$$$ и       сумма длин отрезков $$$r - l + 1$$$ не превосходит $$$10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите отрезок $$$v_l, v_{l +       1}, \dots, v_r$$$ лексикографически минимального цикла, который       проходит по каждой дуге ровно один раз.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
2 1 3
3 3 6
99995 9998900031 9998900031
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1 2 1 
1 3 2 3 
1 
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Во втором наборе, лексикографически минимальный цикл выглядит       следующим образом: $$$1, 2, 1, 3, 2, 3, 1$$$.</p>     <p>В третьем примере, довольно очевидно, что цикл должен начинаться       и заканчиваться в вершине $$$1$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1334/problem/D' title='Educational Codeforces Round 85 (Rated for Div. 2)'>1334D - Minimum Euler Cycle</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>The solution of the problem can be found clearly in constructive       way. An example for $$$n=5$$$: (1 2 1 3 1 4 1 5 (2 3 2 4 2 5 (3 4       3 5 (4 5 ()))) 1) where brackets mean that we call here some       recursive function $$$calc$$$.</p>     <p>Since on each level of recursion we have only $$$O(n)$$$ elements       and there $$$O(n)$$$ levels then the generation of the certificate       is quite easy: if on the currect level of recursion we can skip       the whole part — let's just skip it. Otherwise let's build this       part. Anyway, the built part of the cycle will have only $$$O(n +       (r - l))$$$ length so the whole algorithm has $$$O(n + (r - l))$$$ complexity.</p>     <p>The answer is lexicographically minimum by the construction,       since on each level of recursion there is no way to build       lexicographically smaller sequence.</p></div></div></div>

           
            <pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;

#define fore(i, l, r) for(int i = int(l); i &lt; int(r); i++)
#define sz(a) int((a).size())

#define x first
#define y second

typedef long long li;
typedef long double ld;
typedef pair&lt;int, int&gt; pt;

int n;
li l, r;

inline bool read() {
	if(!(cin &gt;&gt; n &gt;&gt; l &gt;&gt; r))
		return false;
	return true;
}

bool intersect(li l1, li r1, li l2, li r2) {
	return min(r1, r2) &gt; max(l1, l2);
}

vector&lt;int&gt; ans;

void calc(int lf, int rg, li &amp;id) {
	if(lf == rg) return;
	
	if(intersect(l, r, id, id + 2 * (rg - lf))) {
		fore(to, lf + 1, rg + 1) {
			if(l &lt;= id &amp;&amp; id &lt; r)
				ans.push_back(lf);
			id++;
			
			if(l &lt;= id &amp;&amp; id &lt; r)
				ans.push_back(to);
			id++;
		}
	} else
		id += 2 * (rg - lf);
	
	calc(lf + 1, rg, id);
	
	if(lf == 0) {
		if(l &lt;= id &amp;&amp; id &lt; r)
			ans.push_back(lf);
		id++;
	}
}

inline void solve() {
	ans.clear();
	li id = 0;
	l--;
	calc(0, n - 1, id);
	
	assert(sz(ans) == r - l);
	assert(id == n * li(n - 1) + 1);
	
	for(int v : ans)
		cout &lt;&lt; v + 1 &lt;&lt; &#34; &#34;;
	cout &lt;&lt; endl;
}

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
	int tt = clock();
#endif
	ios_base::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cout &lt;&lt; fixed &lt;&lt; setprecision(15);
	
	int tc; cin &gt;&gt; tc;
	
	while(tc--) {
		read();
		solve();
		
#ifdef _DEBUG
		cerr &lt;&lt; &#34;TIME = &#34; &lt;&lt; clock() - tt &lt;&lt; endl;
		tt = clock();
#endif
	}
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 85 (рейтинговый для Див. 2)
    1334E
    Пути по делителям </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. Пути по делителям</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>3 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Задано целое положительное число $$$D$$$. Построим из него       следующий граф: </p>     <ul> <li> каждая вершина является делителем $$$D$$$ (не обязательно         простым, $$$1$$$ и $$$D$$$ тоже включаются); </li>       <li> между двумя вершинами $$$x$$$ и $$$y$$$ ($$$x &gt; y$$$) есть         неориентированное ребро, если $$$x$$$ делится на $$$y$$$ и         $$$\frac x y$$$ — простое число; </li>       <li> вес ребра — это количество делителей $$$x$$$, которые не         являются делителями $$$y$$$. </li></ul>          <p>Например, граф для $$$D=12$$$: </p>     <center> <img class="tex-graphics" src="https://espresso.codeforces.com/9ce70289d27adde3575a5aa840a6cc7f1d3682bb.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>У ребра $$$(4,12)$$$ вес $$$3$$$, потому что у $$$12$$$ делители       $$$[1,2,3,4,6,12]$$$, а у $$$4$$$ делители $$$[1,2,4]$$$. Поэтому       существует $$$3$$$ делителя $$$12$$$, которые не являются       делителями $$$4$$$ — $$$[3,6,12]$$$.</p>     <p>Между $$$3$$$ и $$$2$$$ нет ребра, потому что $$$3$$$ не делится       на $$$2$$$. Между $$$12$$$ и $$$3$$$ нет ребра, потому что       $$$\frac{12}{3}=4$$$ не простое число.</p>     <p>Длина пути между некоторыми вершинами $$$v$$$ и $$$u$$$ в графе       равна сумме весов ребер в нем. Например, длина пути $$$[(1, 2),       (2, 6), (6, 12), (12, 4), (4, 2), (2, 6)]$$$ равен       $$$1+2+2+3+1+2=11$$$. Длина пустого пути равна $$$0$$$.</p>     <p>Тогда кратчайший путь между двумя вершинами $$$v$$$ и $$$u$$$ —       это путь, длина которого минимальна.</p>     <p>Два пути $$$a$$$ и $$$b$$$ различны, если либо содержат различное       количество ребер, либо существует такая позиция $$$i$$$, что ребра       $$$a_i$$$ и $$$b_i$$$ различны.</p>     <p>Даны $$$q$$$ запросов вида: </p>     <ul> <li> $$$v$$$ $$$u$$$ — посчитайте <span class="tex-font-style-bf">количество кратчайших путей</span>         между вершинами $$$v$$$ и $$$u$$$. </li></ul>          <p>Ответ может быть довольно большим, поэтому выведите его по модулю $$$998244353$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$D$$$ ($$$1 \le D \le       10^{15}$$$) — число, из которого строится граф.</p>     <p>Во второй строке записано одно целое число $$$q$$$ ($$$1 \le q       \le 3 \cdot 10^5$$$) — количество запросов.</p>     <p>В каждой из следующих $$$q$$$ строк записаны два целых числа       $$$v$$$ и $$$u$$$ ($$$1 \le v, u \le D$$$). Гарантируется, что       $$$D$$$ делится и на $$$v$$$, и на $$$u$$$ (и $$$v$$$, и $$$u$$$,       являются делителями $$$D$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$q$$$ целых чисел — для каждого запроса выведите <span class="tex-font-style-bf">количество кратчайших путей</span>       между двумя данными вершинами по модулю $$$998244353$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
12
3
4 4
12 1
3 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
3
1
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
1
1
1 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
288807105787200
4
46 482955026400
12556830686400 897
414 12556830686400
4443186242880 325
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
547558588
277147129
457421435
702277623
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере: </p>     <ul> <li> на первый запрос только пустой путь — длина $$$0$$$; </li>       <li> на второй запрос пути $$$[(12, 4), (4, 2), (2, 1)]$$$ (длина         $$$3+1+1=5$$$), $$$[(12, 6), (6, 2), (2, 1)]$$$ (длина         $$$2+2+1=5$$$) и $$$[(12, 6), (6, 3), (3, 1)]$$$ (длина         $$$2+2+1=5$$$). </li>       <li> на третий запрос только путь $$$[(3, 1), (1, 2), (2, 4)]$$$         (длина $$$1+1+1=3$$$). </li></ul></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1334/problem/E' title='Educational Codeforces Round 85 (Rated for Div. 2)'>1334E - Divisor Paths</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's define the semantics of moving along the graph. On each       step the current number is either multiplied by some prime or       divided by it.</p>     <p>I claim that the all shortest paths from $$$x$$$ to $$$y$$$       always go through $$$gcd(x, y)$$$. Moreover, the vertex numbers on       the path first only decrease until $$$gcd(x, y)$$$ and only       increase after it.</p>     <p>Let's watch what happens to the divisors list on these paths. At       first, all the divisors of $$$x$$$ that are not divisors of       $$$y$$$ are removed from the list. Now we reach gcd and we start       adding the divisors of $$$y$$$ that are missing from the list. The       length of the path is this total number of changes to the list.       That shows us that these paths are the shortest by definition.</p>     <p>If we ever take a turn off that path, we either will add some       divisor that we will need to remove later or remove some divisor       that we will need to add later. That makes the length of the path       not optimal.</p>     <p>Now let's learn to calculate the number of paths. The parts       before gcd and after it will be calculated separately, the answer       is the product of answers for both parts.</p>     <p>How many paths are there to gcd? Well, let's divide $$$x$$$ by       $$$gcd$$$, that will give us the primes that should be removed       from $$$x$$$. You can remove them in any order because the length       of the path is always the same. That is just the number of their       permutations with repetitions (you might also know that formula as       multinomial coefficient).</p>     <p>The number of paths from $$$gcd$$$ to $$$y$$$ is calculated the       same way.</p>     <p>To find the primes in $$$\frac{x}{gcd(x, y)}$$$ you can factorize       $$$D$$$ beforehand and only iterate over the primes of $$$D$$$.</p>     <p>Overall complexity: $$$O(\sqrt{D} + q \log D)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

#define forn(i, n) for (int i = 0; i &lt; int(n); i++)

using namespace std;

const int MOD = 998244353;

int add(int a, int b){
	a += b;
	if (a &gt;= MOD)
		a -= MOD;
	if (a &lt; 0)
		a += MOD;
	return a;
}

int mul(int a, int b){
	return a * 1ll * b % MOD;
}

int binpow(int a, int b){
	int res = 1;
	while (b){
		if (b &amp; 1)
			res = mul(res, a);
		a = mul(a, a);
		b &gt;&gt;= 1;
	}
	return res;
}

int main() {
	long long d;
	scanf(&#34;%lld&#34;, &amp;d);
	int q;
	scanf(&#34;%d&#34;, &amp;q);
	
	vector&lt;long long&gt; primes;
	for (long long i = 2; i * i &lt;= d; ++i) if (d % i == 0){
		primes.push_back(i);
		while (d % i == 0) d /= i;
	}
	if (d &gt; 1){
		primes.push_back(d);
	}
	
	vector&lt;int&gt; fact(100), rfact(100);
	fact[0] = 1;
	for (int i = 1; i &lt; 100; ++i)
		fact[i] = mul(fact[i - 1], i);
	rfact[99] = binpow(fact[99], MOD - 2);
	for (int i = 98; i &gt;= 0; --i)
		rfact[i] = mul(rfact[i + 1], i + 1);
	
	forn(i, q){
		long long x, y;
		scanf(&#34;%lld%lld&#34;, &amp;x, &amp;y);
		vector&lt;int&gt; up, dw;
		for (auto p : primes){
			int cnt = 0;
			while (x % p == 0){
				--cnt;
				x /= p;
			}
			while (y % p == 0){
				++cnt;
				y /= p;
			}
			if (cnt &lt; 0) dw.push_back(-cnt);
			else if (cnt &gt; 0) up.push_back(cnt);
		}
		int ans = 1;
		ans = mul(ans, fact[accumulate(up.begin(), up.end(), 0)]);
		for (auto it : up) ans = mul(ans, rfact[it]);
		ans = mul(ans, fact[accumulate(dw.begin(), dw.end(), 0)]);
		for (auto it : dw) ans = mul(ans, rfact[it]);
		printf(&#34;%d\n&#34;, ans);
	}
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 85 (рейтинговый для Див. 2)
    1334F
    Странная функция </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Странная функция</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>3 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Введем функцию $$$f$$$ следующим образом. Эта функция принимает       массив $$$a$$$ длины $$$n$$$ и возвращает массив. Изначально       результат — пустой массив. Для каждого $$$i$$$ от $$$1$$$ до       $$$n$$$ мы добавляем $$$a_i$$$ в конец результата, если этот       элемент больше всех предыдущих (формально, если $$$a_i &gt;       \max\limits_{1 \le j &lt; i}a_j$$$). Примеры применения функции $$$f$$$:</p>          <ol> <li> если $$$a = [3, 1, 2, 7, 7, 3, 6, 7, 8]$$$, то $$$f(a) =         [3, 7, 8]$$$; </li>       <li> если $$$a = [1]$$$, то $$$f(a) = [1]$$$; </li>       <li> если $$$a = [4, 1, 1, 2, 3]$$$, то $$$f(a) = [4]$$$; </li>       <li> если $$$a = [1, 3, 1, 2, 6, 8, 7, 7, 4, 11, 10]$$$, то         $$$f(a) = [1, 3, 6, 8, 11]$$$. </li></ol>          <p>Вам даны два массива: $$$a_1, a_2, \dots , a_n$$$ и $$$b_1, b_2,       \dots , b_m$$$. Вы можете удалить некоторые элементы массива       $$$a$$$ (возможно, никакие). Чтобы удалить элемент $$$a_i$$$, вы       должны заплатить $$$p_i$$$ монет (значение $$$p_i$$$ может быть       отрицательным, тогда за удаление элемента вы получаете $$$|p_i|$$$       монет). Посчитайте минимальное кол-во монет (возможно,       отрицательное), которое вы должны потратить, чтобы условие $$$f(a)       = b$$$ выполнялось.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке задано одно целое число $$$n$$$ $$$(1 \le n \le 5       \cdot 10^5)$$$ — длина массива $$$a$$$.</p>     <p>Во второй строке заданы $$$n$$$ целых чисел $$$a_1, a_2, \dots,       a_n$$$ $$$(1 \le a_i \le n)$$$ — массив $$$a$$$.</p>     <p>В третьей строке заданы $$$n$$$ целых чисел $$$p_1, p_2, \dots,       p_n$$$ $$$(|p_i| \le 10^9)$$$ — массив $$$p$$$.</p>     <p>В четвертой строке задано целое число $$$m$$$ $$$(1 \le m \le       n)$$$ — длина массива $$$b$$$.</p>     <p>В пятой строке заданы $$$m$$$ целых чисел $$$b_1, b_2, \dots,       b_m$$$ $$$(1 \le b_i \le n, b_{i-1} &lt; b_i)$$$ — массив $$$b$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Если ответ существует, выведите <span class="tex-font-style-tt">YES</span> в первой строке, а во второй       — минимальное количество монет, которое надо потратить, чтобы       условие $$$f(a) = b$$$ выполнилось. </p>     <p>Иначе выведите <span class="tex-font-style-tt">NO</span>.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
11
4 1 3 3 7 8 7 9 10 7 11
3 5 0 -2 5 3 6 7 8 2 4
3
3 7 10
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
YES
20
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
2 1 5 3 6 5
3 -9 0 16 22 -14
4
2 3 5 6
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
NO
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1334/problem/F' title='Educational Codeforces Round 85 (Rated for Div. 2)'>1334F - Strange Function</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>The &quot;naive&quot; version of the solution is just dynamic       programming: let $$$dp_{i, j}$$$ be the minimum cost of removed       elements (or the maximum cost of remaining elements) if we       considered first $$$i$$$ elements of $$$a$$$, and the resulting       sequence maps to the first $$$j$$$ elements of $$$b$$$. There are       two versions of this solution, both working in $$$O(n^2)$$$:</p>          <ul> <li> calculate this dp &quot;as it is&quot;, so there are         $$$O(nm)$$$ states and $$$O(1)$$$ transitions from each state; </li>       <li> ensure that the $$$i$$$-th element is taken into $$$f(a)$$$,         so there are $$$O(n)$$$ states (since each element appears in         $$$b$$$ exactly once, the second state can be deduces from the         first one), but up to $$$O(n)$$$ transitions from each state. </li></ul>          <p>It turns out that we can optimize the second approach. Let's       calculate the values of $$$dp_i$$$ in ascending order of       $$$a_i$$$: first of all, we calculate the values of $$$dp_i$$$       such that $$$a_i = b_1$$$, then transition into states such that       $$$a_i = b_2$$$, and so on.</p>     <p>Calculating $$$dp_i$$$ for $$$a_i = b_1$$$ is easy: since the       first element of $$$a$$$ is always the first element of       $$$f(a)$$$, we should delete all elements before the $$$i$$$-th if       we want it to be the first element in $$$f(a)$$$. So, if       $$$dp_i$$$ is the maximum possible sum of costs of remaining       elements, if we considered the first $$$i$$$ elements of $$$a$$$       (and the $$$i$$$-th element gets included in $$$f(a)$$$), then       $$$dp_i = c_i$$$ for indices $$$i$$$ such that $$$a_i = b_1$$$.</p>     <p>Okay, now let's consider advancing from $$$b_k$$$ to $$$b_{k +       1}$$$. If we want to go from $$$dp_i$$$ to $$$dp_j$$$ such that       $$$a_i = b_k$$$ and $$$a_j = b_{k + 1}$$$, we should leave the       element $$$a_j$$$ in the array and delete some elements between       indices $$$i$$$ and $$$j$$$. Which ones should be deleted? First       of all, they are all elements with negative deletion cost; but we       should also get rid of all elements which could replace $$$a_j$$$       in $$$f(a)$$$ — that is, all elements that are greater than       $$$a_i$$$. So the remaining elements are $$$x$$$ which have $$$i       &lt; x &lt; j$$$, $$$c_x &gt; 0$$$ and $$$a_x \le a_i$$$, and we       should be able to compute the sum of such elements.</p>     <p>Even if we manage to do it in $$$O(\log n)$$$, which is possible,       there may be up to $$$O(n^2)$$$ possible pairs of $$$dp_i$$$ and       $$$dp_j$$$ to consider. The easiest way to get rid of that is to       sort all occurences of $$$b_k$$$ and $$$b_{k + 1}$$$, and process       them in ascending order, maintaining the best $$$dp_i$$$ that was       already met. That way, each of the elements of $$$a$$$ will be       considered at most twice, so this solution runs in $$$O(n \log n)$$$.</p>     <p>We know how to calculate the $$$dp$$$ values now, but how to       determine the answer? We should consider all values of $$$dp_i$$$       such that $$$a_i = b_m$$$ and delete all elements with negative       costs and all elements that are greater than $$$a_i$$$ from the       suffix $$$[i + 1, n]$$$ — so this is another query of the form       &quot;compute the sum of $$$c_x$$$ over $$$x$$$ which have $$$i       &lt; x &lt; j$$$, $$$c_x &gt; 0$$$ and $$$a_x \le a_i$$$&quot;.       The most straightforward way to process them in $$$O(\log n)$$$ is       to use a persistent segment tree, but since $$$a_i$$$ does not       decrease in these queries as we process them, we may maintain the       elements we are interested in with a much simpler data structure,       for example, Fenwick tree.</p></div></div></div>

           
            <pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;

typedef long long li;
const li INF64 = li(1e18);
const int N = 500043;

li f[N];

li get(int x)
{
    li ans = 0;    
    for (; x &gt;= 0; x = (x &amp; (x + 1)) - 1)
        ans += f[x];
    return ans;
}

void inc(int x, li d)
{
    for (; x &lt; N; x = (x | (x + 1)))
        f[x] += d;    
}

li get(int l, int r)
{
    return get(r) - get(l - 1);
}

li dp[N];
int a[N], b[N], p[N];
int n, m;

int main()
{
    scanf(&#34;%d&#34;, &amp;n);
    for(int i = 0; i &lt; n; i++)
        scanf(&#34;%d&#34;, &amp;a[i]);
    for(int i = 0; i &lt; n; i++)
        scanf(&#34;%d&#34;, &amp;p[i]);
    scanf(&#34;%d&#34;, &amp;m);
    for(int i = 0; i &lt; m; i++)
        scanf(&#34;%d&#34;, &amp;b[i]);

    for(int i = 0; i &lt; n; i++)
        dp[i] = -INF64;
    map&lt;int, vector&lt;int&gt; &gt; pos;
    for(int i = 0; i &lt; n; i++)
        pos[a[i]].push_back(i);
    set&lt;pair&lt;int, int&gt; &gt; q;
    for(int i = 0; i &lt; n; i++)
        q.insert(make_pair(a[i], i));
    
    for(auto x : pos[b[0]])
        dp[x] = p[x];
    while(!q.empty() &amp;&amp; q.begin()-&gt;first &lt;= b[0])
    {
        int k = q.begin()-&gt;second;
        q.erase(q.begin());
        if(p[k] &gt; 0)
            inc(k, p[k]);
    }  

    for(int i = 1; i &lt; m; i++)
    {
        int i1 = b[i - 1], i2 = b[i];
        vector&lt;int&gt; both_pos;
        for(auto x : pos[i1])
            both_pos.push_back(x);
        for(auto x : pos[i2])
            both_pos.push_back(x);
        li best = -INF64;
        int last = -1;
        sort(both_pos.begin(), both_pos.end());
        for(auto x : both_pos)
        {
            best += get(last + 1, x);
            last = x;
            if(a[x] == i1)
                best = max(best, dp[x]);
            else
                dp[x] = best + p[x];
        }
        while(!q.empty() &amp;&amp; q.begin()-&gt;first &lt;= i2)
        {
            int k = q.begin()-&gt;second;
            q.erase(q.begin());
            if(p[k] &gt; 0)
                inc(k, p[k]);
        }
    }

    li best_dp = -INF64;
    for(int i = 0; i &lt; n; i++)
        if(a[i] == b[m - 1])
            best_dp = max(best_dp, dp[i] + get(i + 1, n - 1));
    li ans = 0;
    for(int i = 0; i &lt; n; i++)
        ans += p[i];
    ans -= best_dp;
    if(ans &gt; li(1e15))
        puts(&#34;NO&#34;);
    else     
        printf(&#34;YES\n%lld\n&#34;, ans);
    
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 85 (рейтинговый для Див. 2)
    1334G
    Поиск подстроки </h1>

    <div class="problemindexholder" problemindex="G">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">G. Поиск подстроки</div>     <div class="time-limit"><div class="property-title">ограничение по времени на       тест</div>1.25 секунд</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Дана перестановка $$$p$$$, состоящая из $$$26$$$ целых чисел от       $$$1$$$ до $$$26$$$ (так как это перестановка, каждое число от       $$$1$$$ до $$$26$$$ встречается в $$$p$$$ ровно один раз), а также       две строки $$$s$$$ и $$$t$$$, состоящие из строчных букв       латинского алфавита.</p>     <p>Подстрока $$$t'$$$ строки $$$t$$$ является <span class="tex-font-style-bf">вхождением</span> строки $$$s$$$, если       выполняются следующие условия:</p>          <ol> <li> $$$|t'| = |s|$$$; </li>       <li> для каждого $$$i \in [1, |s|]$$$ либо $$$s_i = t'_i$$$, либо         $$$p_{idx(s_i)} = idx(t'_i)$$$, где $$$idx(c)$$$ — номер символа         $$$c$$$ в латинском алфавите ($$$idx(\text{a}) = 1$$$,         $$$idx(\text{b}) = 2$$$, $$$idx(\text{z}) = 26$$$). </li></ol>          <p>Например, если $$$p_1 = 2$$$, $$$p_2 = 3$$$, $$$p_3 = 1$$$, $$$s       = \text{abc}$$$, $$$t = \text{abcaaba}$$$, три подстроки $$$t$$$       являются вхождениями $$$s$$$ ($$$t' = \text{abc}$$$, $$$t' =       \text{bca}$$$ и $$$t' = \text{aba}$$$).</p>     <p>Для каждой подстроки $$$t$$$ с длиной, равной $$$|s|$$$,       проверьте, является ли она <span class="tex-font-style-bf">вхождением</span> строки $$$s$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке заданы $$$26$$$ целых чисел $$$p_1$$$, $$$p_2$$$,       ..., $$$p_{26}$$$ ($$$1 \le p_i \le 26$$$, все эти числа попарно различны).</p>     <p>Во второй строке задана строка $$$s$$$, а в третьей — строка       $$$t$$$ ($$$2 \le |s| \le |t| \le 2 \cdot 10^5$$$), обе они       состоят из строчных латинских букв.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите строку из $$$|t| - |s| + 1$$$ символов, каждый из       которых должен быть либо <span class="tex-font-style-tt">0</span>,       либо <span class="tex-font-style-tt">1</span>. $$$i$$$-й символ       должен быть <span class="tex-font-style-tt">1</span> тогда и       только тогда, когда подстрока $$$t$$$, начинающаяся с $$$i$$$-го       символа и заканчивающаяся $$$(i + |s| - 1)$$$-м символом       (включительно), является <span class="tex-font-style-bf">вхождением</span> строки $$$s$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2 3 1 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
abc
abcaaba
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
11001</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1334/problem/G' title='Educational Codeforces Round 85 (Rated for Div. 2)'>1334G - Substring Search</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>We will run two tests for each substring of $$$t$$$ we are       interested in. If at least one of them shows that the substring is       not an occurence of $$$s$$$, we print <span class="tex-font-style-tt">0</span>, otherwise we print <span class="tex-font-style-tt">1</span>.</p>     <p>The first test is fairly easy. The given permutation can be       decomposed into cycles. Let's replace each character with the       index of its cycle (in both strings) and check if each substring       of $$$t$$$ is equal to $$$s$$$ after this replacement (for       example, using regular KMP algorithm). If some substring is not       equal to $$$s$$$ after the replacement, then it is definitely not       an occurence.</p>     <p>The second test will help us distinguish the characters belonging       to the same cycle. Let $$$[c_1, c_2, \dots, c_k]$$$ be some cycle       in our permutation (elements are listed in the order they appear       in the cycle, so $$$p_{c_i} = c_{i + 1}$$$). We will replace each       character with a complex number in such a way that the case when       they match are easily distinguishable from the case when they       don't match. One of the ways to do this is to replace $$$c_i$$$       with a complex number having magnitude equal to $$$1$$$ and       argument equal to $$$\dfrac{2 \pi i}{k}$$$ (if this character       belongs to $$$s$$$) or to $$$\dfrac{\pi - 2 \pi i}{k}$$$ (if this       character belongs to $$$t$$$).</p>     <p>How does this replacement help us checking the occurence? If we       multiply the numbers for two matching characters, we get a complex       number with argument equal to $$$\dfrac{\pi}{k}$$$ or to       $$$-\dfrac{\pi}{k}$$$, and its real part will be $$$\cos       \dfrac{\pi}{k}$$$. In any other case, the real part of the       resulting number will be strictly less than $$$\cos       \dfrac{\pi}{k}$$$, and the difference will be at least $$$0.06$$$.       So, if we compute the value of $$$\sum \limits_{i = 1}^{|s|}       f(s_i) \cdot f(t_{j + i - 1})$$$ for the $$$j$$$-th substring of       $$$t$$$ (where $$$f(c)$$$ is the number that replaced the       character $$$c$$$), we can check if the real part of the result is       close to the value we would get if we matched $$$s$$$ with itself       (and if the difference is big enough, at least one pair of       characters didn't match). The only case when this method fails is       if we try to match characters from different cycles of the       permutation, that's why we needed the first test.</p>     <p>Overall, the first test can be done in $$$O(|s| + |t|)$$$ using       prefix function (or any other linear substring search algorithm),       and the second test can be done in $$$O((|s| + |t|) \log(|s| +       |t|))$$$, if we compute the aforementioned values for each       substring using FFT.</p></div></div></div>

           
            <pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;

#define forn(i, n) for(int i = 0; i &lt; n; i++)
#define sz(a) ((int)(a).size())

const int LOGN = 20;
const int N = (1 &lt;&lt; LOGN);

typedef long double ld;
typedef long long li;

const ld PI = acos(-1.0);

struct comp 
{
    ld x, y;
    comp(ld x = .0, ld y = .0) : x(x), y(y) {}
    inline comp conj() { return comp(x, -y); }
};

inline comp operator +(const comp &amp;a, const comp &amp;b) 
{
    return comp(a.x + b.x, a.y + b.y);
}

inline comp operator -(const comp &amp;a, const comp &amp;b) 
{
    return comp(a.x - b.x, a.y - b.y);
}

inline comp operator *(const comp &amp;a, const comp &amp;b) 
{
    return comp(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

inline comp operator /(const comp &amp;a, const ld &amp;b) 
{
    return comp(a.x / b, a.y / b);
}

vector&lt;comp&gt; w[LOGN];
vector&lt;int&gt; rv[LOGN];

void precalc() 
{
    for(int st = 0; st &lt; LOGN; st++) 
    {
        w[st].assign(1 &lt;&lt; st, comp());
        for(int k = 0; k &lt; (1 &lt;&lt; st); k++) 
        {
            double ang = PI / (1 &lt;&lt; st) * k;
            w[st][k] = comp(cos(ang), sin(ang));
        }
        
        rv[st].assign(1 &lt;&lt; st, 0);
        if(st == 0) 
        {
            rv[st][0] = 0;
            continue;
        }
        int h = (1 &lt;&lt; (st - 1));
        for(int k = 0; k &lt; (1 &lt;&lt; st); k++)
            rv[st][k] = (rv[st - 1][k &amp; (h - 1)] &lt;&lt; 1) | (k &gt;= h);
    }
}

inline void fft(comp a[N], int n, int ln, bool inv) 
{
    for(int i = 0; i &lt; n; i++) 
    {
        int ni = rv[ln][i];
        if(i &lt; ni)
            swap(a[i], a[ni]);
    }
    
    for(int st = 0; (1 &lt;&lt; st) &lt; n; st++) 
    {
        int len = (1 &lt;&lt; st);
        for(int k = 0; k &lt; n; k += (len &lt;&lt; 1)) 
        {
            for(int pos = k; pos &lt; k + len; pos++) 
            {
                comp l = a[pos];
                comp r = a[pos + len] * (inv ? w[st][pos - k].conj() : w[st][pos - k]);
                
                a[pos] = l + r;
                a[pos + len] = l - r;
            }
        }
    }
    
    if(inv) for(int i = 0; i &lt; n; i++)
        a[i] = a[i] / n;
}

comp aa[N];
comp bb[N];
comp cc[N];

inline void multiply(comp a[N], int sza, comp b[N], int szb, comp c[N], int &amp;szc) 
{
    int n = 1, ln = 0;
    while(n &lt; (sza + szb))
        n &lt;&lt;= 1, ln++;
    for(int i = 0; i &lt; n; i++)
        aa[i] = (i &lt; sza ? a[i] : comp());
    for(int i = 0; i &lt; n; i++)
        bb[i] = (i &lt; szb ? b[i] : comp());
        
    fft(aa, n, ln, false);
    fft(bb, n, ln, false);
    
    for(int i = 0; i &lt; n; i++)
        cc[i] = aa[i] * bb[i];
        
    fft(cc, n, ln, true);
    
    szc = n;
    for(int i = 0; i &lt; n; i++)
        c[i] = cc[i];
}

comp a[N];
comp b[N];
comp c[N];

vector&lt;int&gt; p_function(const vector&lt;int&gt;&amp; v)
{
    int n = v.size();
    vector&lt;int&gt; p(n);
    for(int i = 1; i &lt; n; i++)
    {
        int j = p[i - 1];
        while(j &gt; 0 &amp;&amp; v[j] != v[i])
            j = p[j - 1];
        if(v[j] == v[i])
            j++;
        p[i] = j;   
    }
    return p;
}

int p[26];
char buf[N];
string s, t;

int main()
{
    precalc();                  
    for(int i = 0; i &lt; 26; i++)
    {
        scanf(&#34;%d&#34;, &amp;p[i]);
        p[i]--;
    }
    scanf(&#34;%s&#34;, buf);
    s = buf;
    scanf(&#34;%s&#34;, buf);
    t = buf;

    int n = s.size();
    int m = t.size();
    vector&lt;int&gt; color(26, 0);
    vector&lt;vector&lt;int&gt; &gt; cycles;
    for(int i = 0; i &lt; 26; i++)
    {
        if(color[i])
            continue;
        vector&lt;int&gt; cycle;
        int cc = cycles.size() + 1;
        int cur = i;
        while(color[cur] == 0)
        {
            cycle.push_back(cur);
            color[cur] = cc;
            cur = p[cur];
        }
        cycles.push_back(cycle);
    }

    vector&lt;int&gt; ans(m - n + 1);
    vector&lt;int&gt; s1, t1;
    for(int i = 0; i &lt; n; i++)
        s1.push_back(color[int(s[i] - &#39;a&#39;)]);
    for(int i = 0; i &lt; m; i++)
        t1.push_back(color[int(t[i] - &#39;a&#39;)]);
    vector&lt;int&gt; st = s1;
    st.push_back(0);
    for(auto x : t1)
        st.push_back(x);
    vector&lt;int&gt; pf = p_function(st);
    for(int i = 0; i &lt; m - n + 1; i++)
        if(pf[2 * n + i] == n)
            ans[i] = 1;
    map&lt;char, comp&gt; m1, m2;
    for(auto cur : cycles)
    {
        int k = cur.size();
        for(int i = 0; i &lt; k; i++)
        {
            ld ang1 = 2 * PI * i / k;
            ld ang2 = (PI - 2 * PI * i) / k;
            m1[char(&#39;a&#39; + cur[i])] = comp(cosl(ang1), sinl(ang1));
            m2[char(&#39;a&#39; + cur[i])] = comp(cosl(ang2), sinl(ang2));
        }
    }

    ld ideal = 0;
    for(int i = 0; i &lt; n; i++)
        ideal += (m1[s[i]] * m2[s[i]]).x;
    reverse(s.begin(), s.end());
    for(int i = 0; i &lt; n; i++)                  
        a[i] = m1[s[i]];                
    for(int i = 0; i &lt; m; i++)
        b[i] = m2[t[i]];
    int szc;
    multiply(a, n, b, m, c, szc);
    for(int i = 0; i &lt; m - n + 1; i++)
        if(fabsl(c[i + n - 1].x - ideal) &gt; 0.01)
            ans[i] = 0;
    

    for(int i = 0; i &lt; m - n + 1; i++)
        printf(&#34;%d&#34;, ans[i]);
    return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #634 (Div. 3)
    1335A
    Конфеты и две сестры </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Конфеты и две сестры</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>В задаче речь пойдет о двух сёстрах — Алисе и Бетти. У вас есть       $$$n$$$ конфет. Вам хочется распределить все эти $$$n$$$ конфет       между сёстрами так, что:</p>          <ul> <li> Алиса получит $$$a$$$ ($$$a &gt; 0$$$) конфет; </li>       <li> Бетти получит $$$b$$$ ($$$b &gt; 0$$$) конфет; </li>       <li> каждая сестра получит некоторое <span class="tex-font-style-bf">целое</span> количество конфет; </li>       <li> Алиса получит больше конфет, чем Бетти (то есть $$$a &gt;         b$$$); </li>       <li> все конфеты будут отданы одной из двух сестёр (то есть         $$$a+b=n$$$). </li></ul>          <p>Ваша задача — посчитать количество способов распределить $$$n$$$       конфет между девочками так, как описано выше. Учтите, что конфеты       неразличимы между собой.</p>     <p>Формально, найдите количество способов представить $$$n$$$ как       сумму $$$n=a+b$$$, где $$$a$$$ и $$$b$$$ — положительные целые       числа и $$$a&gt;b$$$.</p>     <p>Вам нужно ответить на $$$t$$$ независимых наборов тестовых данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка теста содержит одно целое число $$$t$$$ ($$$1 \le t       \le 10^4$$$) — количество наборов тестовых данных. Затем следуют       $$$t$$$ наборов тестовых данных.</p>     <p>Единственная строка набора содержит одно целое число $$$n$$$       ($$$1 \le n \le 2 \cdot 10^9$$$) — количество конфет, которое у       вас есть.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите ответ на него —       количество способов распределить ровно $$$n$$$ конфет между       девочками так, как описано в условии задачи. Если не существует       способа, удовлетворяющего всем условиям, выведите $$$0$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
7
1
2
3
2000000000
763243547
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
0
0
1
999999999
381621773
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Для первого набора тестовых данных возможные $$$3$$$ способа       распределения конфет — это:</p>          <ul> <li> $$$a=6$$$, $$$b=1$$$; </li>       <li> $$$a=5$$$, $$$b=2$$$; </li>       <li> $$$a=4$$$, $$$b=3$$$. </li></ul></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1335/problem/A' title='Codeforces Round 634 (Div. 3)'>1335A - Candies and Two Sisters</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>The answer is $$$\lfloor\frac{n-1}{2}\rfloor$$$, where $$$\lfloor       x \rfloor$$$ is $$$x$$$ rounded down.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
	
	int t;
	cin &gt;&gt; t;
	while (t--) {
		int n;
		cin &gt;&gt; n;
		cout &lt;&lt; (n - 1) / 2 &lt;&lt; endl;
	}
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #634 (Div. 3)
    1335B
    Построить строку </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Построить строку</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам даны три целых положительных числа $$$n$$$, $$$a$$$ и       $$$b$$$. Вам хочется построить такую строку $$$s$$$ длины $$$n$$$,       состоящую из строчных букв латинского алфавита, что <span class="tex-font-style-bf">каждая подстрока</span> длины $$$a$$$       содержит <span class="tex-font-style-bf">ровно</span> $$$b$$$       различных букв. Гарантируется, что ответ существует.</p>     <p>Вам нужно ответить на $$$t$$$ независимых наборов тестовых данных.</p>     <p>Напомним, что подстрокой строки $$$s[l \dots r]$$$ называется       строка $$$s_l, s_{l+1}, \dots, s_{r}$$$, длина которой равна $$$r       - l + 1$$$. В этой задаче вам интересны только подстроки длины $$$a$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка теста содержит одно целое число $$$t$$$ ($$$1 \le t       \le 2000$$$) — количество наборов тестовых данных. Затем следуют       $$$t$$$ наборов тестовых данных.</p>     <p>Единственная строка каждого набора содержит три разделенных       пробелами целых числа $$$n$$$, $$$a$$$ и $$$b$$$ ($$$1 \le a \le n       \le 2000, 1 \le b \le \min(26, a)$$$), где $$$n$$$ — длина       необходимой строки, $$$a$$$ — длина подстроки, а $$$b$$$ —       требуемое количество различных букв в каждой подстроке длины $$$a$$$.</p>     <p>Гарантируется, что сумма чисел $$$n$$$ по всем наборам тестовых       данных не превосходит $$$2000$$$ ($$$\sum n \le 2000$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите ответ на него — такую       строку $$$s$$$ длины $$$n$$$, состоящую из строчных букв       латинского алфавита, что <span class="tex-font-style-bf">каждая       подстрока</span> длины $$$a$$$ содержит <span class="tex-font-style-bf">ровно</span> $$$b$$$ различных букв.       Если ответов несколько, выведите любой из них. Гарантируется, что       ответ существует.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
7 5 3
6 1 1
6 6 1
5 2 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
tleelte
qwerty
vvvvvv
abcde
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе тестовых данных примера посмотрим на все       подстроки длины $$$5$$$:</p>          <ul> <li> «<span class="tex-font-style-tt">tleel</span>» — в ней три         различных буквы $$$3$$$, </li>       <li> «<span class="tex-font-style-tt">leelt</span>» — в ней три         различных буквы $$$3$$$, </li>       <li> «<span class="tex-font-style-tt">eelte</span>» — в ней три         различных буквы $$$3$$$. </li></ul></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1335/problem/B' title='Codeforces Round 634 (Div. 3)'>1335B - Construct the String</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>If we represent letters with digits, then the answer can be       represented as $$$1, 2, \dots, b, 1, 2, \dots, b, \dots$$$. There       is no substring containing more than $$$b$$$ distinct characters       and each substring of length $$$a$$$ contains exactly $$$b$$$       distinct characters because of the condition $$$b \le a$$$.</p>     <p>Time complexity: $$$O(n)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
	
	int t;
	cin &gt;&gt; t;
	while (t--) {
		int n, a, b;
		cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;
		for (int i = 0; i &lt; n; ++i) {
			cout &lt;&lt; char(&#39;a&#39; + i % b);
		}
		cout &lt;&lt; endl;
	}
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #634 (Div. 3)
    1335C
    Составление двух команд </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Составление двух команд</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Под вашим контролем находятся $$$n$$$ студентов и вам нужно       составить <span class="tex-font-style-bf">ровно две       команды</span>, состоящие из некоторого подмножества ваших       студентов. У каждого студента есть свой собственный навык, навык       $$$i$$$-го студента обозначен числом $$$a_i$$$ (у различных       студентов могут быть одинаковые навыки).</p>     <p>Итак, о командах. Во-первых, эти две команды должны быть       одинакового размера. Есть еще два требования:</p>          <ul> <li> Первая команда должна состоять из студентов с <span class="tex-font-style-bf">различными</span> навыками (то есть         нет одинаковых навыков среди студентов первой команды). </li>       <li> Вторая команда должна состоять из студентов с <span class="tex-font-style-bf">одинаковыми</span> навыками (то есть         все навыки среди студентов второй команды равны между собой). </li></ul>          <p>Отметим, что допустимо, что какой-то студент первой команды имеет       такой же навык, как и студент второй команды.</p>     <p>Рассмотрим несколько примеров (перечислены навыки для команд):</p>          <ul> <li> $$$[1, 2, 3]$$$, $$$[4, 4]$$$ не являются подходящей парой         команд, потому что их размеры должны быть одинаковыми; </li>       <li> $$$[1, 1, 2]$$$, $$$[3, 3, 3]$$$ не являются подходящей парой         команд, потому что первая команда не должна включать студентов с         одинаковыми навыками; </li>       <li> $$$[1, 2, 3]$$$, $$$[3, 4, 4]$$$ не являются подходящей парой         команд, потому что вторая команда должна включать студентов с         одинаковыми навыками; </li>       <li> $$$[1, 2, 3]$$$, $$$[3, 3, 3]$$$ — подходящая пара команд; </li>       <li> $$$[5]$$$, $$$[6]$$$ — тоже подходящая пара команд. </li></ul>          <p>Ваша задача — найти максимально возможный размер команд $$$x$$$,       для которого возможно составить подходящую пару команд, где каждая       команда имеет размер $$$x$$$ (в первой команде все навыки       различны, во второй — все навыки равны между собой). Студент не       может входить более чем в одну команду.</p>     <p>Вам нужно ответить на $$$t$$$ независимых наборов входных данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка теста содержит одно целое число $$$t$$$ ($$$1 \le t       \le 10^4$$$) — количество наборов тестовых данных. Затем следуют       $$$t$$$ наборов тестовых данных.</p>     <p>Первая строка набора содержит одно целое число $$$n$$$ ($$$1 \le       n \le 2 \cdot 10^5$$$) — количество студентов. Вторая строка       набора содержит $$$n$$$ целых чисел $$$a_1, a_2, \dots, a_n$$$       ($$$1 \le a_i \le n$$$), где $$$a_i$$$ — это навык $$$i$$$-го       студента. У различных студентов могут быть одинаковые навыки.</p>     <p>Гарантируется, что сумма чисел $$$n$$$ по всем наборам тестовых       данных не превосходит $$$2 \cdot 10^5$$$ ($$$\sum n \le 2 \cdot 10^5$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите ответ на него —       максимально возможный размер команд $$$x$$$, для которого возможно       составить подходящую пару команд, где каждая команда имеет размер $$$x$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
7
4 2 4 1 4 3 4
5
2 1 5 4 3
1
1
4
1 1 1 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
1
0
2
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе тестовых данных примера возможно составить две       команды размера $$$3$$$: первая команда может иметь вид $$$[1, 2,       4]$$$, вторая команда может иметь вид $$$[4, 4, 4]$$$. Заметим,       есть и другие способы выбрать две команды размера $$$3$$$, которые       соответствуют требованиям выше.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1335/problem/C' title='Codeforces Round 634 (Div. 3)'>1335C - Two Teams Composing</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let the number of students with the skill $$$i$$$ is $$$cnt_i$$$       and the number of different skills is $$$diff$$$. Then the size of       the first team can not exceed $$$diff$$$ and the size of the       second team can not exceed $$$maxcnt = max(cnt_1, cnt_2, \dots,       cnt_n)$$$. So the answer is not greater than the minimum of these       two values. Moreover, let's take a look at the skill with a       maximum value of $$$cnt$$$. Then there are two cases: all students       with this skill go to the second team then the sizes of teams are       at most $$$diff-1$$$ and $$$maxcnt$$$ correspondingly. Otherwise,       at least one student with this skill goes to the first team and       the sizes are at most $$$diff$$$ and $$$maxcnt - 1$$$       correspondingly. So the answer is $$$max(min(diff - 1, maxcnt),       min(diff, maxcnt - 1))$$$.</p>     <p>Time complexity: $$$O(n)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
	
	int t;
	cin &gt;&gt; t;
	while (t--) {
		int n;
		cin &gt;&gt; n;
		vector&lt;int&gt; cnt(n + 1);
		for (int i = 0; i &lt; n; ++i) {
			int x;
			cin &gt;&gt; x;
			++cnt[x];
		}
		int mx = *max_element(cnt.begin(), cnt.end());
		int diff = n + 1 - count(cnt.begin(), cnt.end(), 0);
		cout &lt;&lt; max(min(mx - 1, diff), min(mx, diff - 1)) &lt;&lt; endl;
	}
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #634 (Div. 3)
    1335D
    Анти-судоку </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Анти-судоку</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам дано корректное решение головоломки судоку. Если вы не       знаете, что такое судоку, то вы можете прочитать об этом <a href="http://tiny.cc/o26xmz">здесь</a>.</p>     <p>Картинка, показывающая корректное решение судоку:</p>     <p>       <img class="tex-graphics" src="https://espresso.codeforces.com/b80d5452b6026b409a6f8a4abae636177ccdfed7.png" style="max-width: 100.0%;max-height: 100.0%;"/></p>     <p>Блоки ограничены жирным черным цветом.</p>     <p>Ваша задача — заменить <span class="tex-font-style-bf">не       более</span> $$$9$$$ элементов этого поля (то есть, выбрать       некоторые $$$1 \le i, j \le 9$$$ и заменить число в позиции $$$(i,       j)$$$ на любое другое число в отрезке $$$[1; 9]$$$), чтобы       получить <span class="tex-font-style-bf">анти-судоку</span>. <span class="tex-font-style-bf">Анти-судоку</span> — это поле размера       $$$9 \times 9$$$, в котором:</p>          <ul> <li> Каждое число на этом поле находится в отрезке $$$[1;         9]$$$; </li>       <li> каждая строка содержит как минимум два одинаковых элемента; </li>       <li> каждый столбец содержит как минимум два одинаковых элемента; </li>       <li> каждый блок размера $$$3 \times 3$$$ (о том, что такое блок,         вы можете прочитать по ссылке выше) содержит как минимум два         одинаковых элемента. </li></ul>          <p>Гарантируется, что ответ существует.</p>     <p>Вам нужно ответить на $$$t$$$ независимых наборов тестовых данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка тестовых данных содержит одно целое число $$$t$$$       ($$$1 \le t \le 10^4$$$) — количество наборов тестовых данных.       Затем следуют $$$t$$$ наборов тестовых данных.</p>     <p>Каждый набор состоит из $$$9$$$ строк, каждая строка состоит из       $$$9$$$ символов от $$$1$$$ до $$$9$$$ без пробелов — то есть,       представляет собой корректное решение головоломки судоку.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите ответ на него —       заданное изначально поле с <span class="tex-font-style-bf">не         более, чем</span> $$$9$$$ измененными в нем элементами так, что       полученное поле является <span class="tex-font-style-bf">анти-судоку</span>. Если существует       несколько подходящих решений, вы можете вывести любое.       Гарантируется, что ответ существует.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
1
154873296
386592714
729641835
863725149
975314628
412968357
631457982
598236471
247189563
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
154873396
336592714
729645835
863725145
979314628
412958357
631457992
998236471
247789563
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1335/problem/D' title='Codeforces Round 634 (Div. 3)'>1335D - Anti-Sudoku</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Well, if we replace all occurrences of the number $$$2$$$ with       the number $$$1$$$, then the initial solution will be anti-sudoku.       It is easy to see that this replacement will make exactly two       copies of $$$1$$$ in every row, column, and block. There are also       other correct approaches but I found this one the most pretty.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
	
	int t;
	cin &gt;&gt; t;
	while (t--) {
		for (int i = 0; i &lt; 9; ++i) {
			string s;
			cin &gt;&gt; s;
			for (auto &amp;c : s) if (c == &#39;2&#39;) c = &#39;1&#39;;
			cout &lt;&lt; s &lt;&lt; endl;
		}
	}
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #634 (Div. 3)
    1335F
    Роботы на поле </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Роботы на поле</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>3 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Задано прямоугольное поле размера $$$n \times m$$$. Каждая клетка       поля покрашена либо в черный цвет ('<span class="tex-font-style-tt">0</span>'), либо в белый цвет ('<span class="tex-font-style-tt">1</span>'). Цвет клетки $$$(i, j)$$$       обозначается как $$$c_{i, j}$$$. Вам также задана карта       направлений: для каждой клетки указано направление $$$s_{i, j}$$$,       которое равно одному из четырех символов '<span class="tex-font-style-tt">U</span>', '<span class="tex-font-style-tt">R</span>', '<span class="tex-font-style-tt">D</span>' и '<span class="tex-font-style-tt">L</span>'.</p>          <ul> <li> Если $$$s_{i, j}$$$ равно '<span class="tex-font-style-tt">U</span>', то из клетки $$$(i, j)$$$         есть переход в клетку $$$(i - 1, j)$$$; </li>       <li> если $$$s_{i, j}$$$ равно '<span class="tex-font-style-tt">R</span>', то из клетки $$$(i, j)$$$         есть переход в клетку $$$(i, j + 1)$$$; </li>       <li> если $$$s_{i, j}$$$ равно '<span class="tex-font-style-tt">D</span>', то из клетки $$$(i, j)$$$         есть переход в клетку $$$(i + 1, j)$$$; </li>       <li> если $$$s_{i, j}$$$ равно '<span class="tex-font-style-tt">L</span>', то из клетки $$$(i, j)$$$         есть переход в клетку $$$(i, j - 1)$$$. </li></ul>          <p>Гарантируется, что самая верхняя строка не содержит символов         '<span class="tex-font-style-tt">U</span>', самая нижняя строка       не содержит символов '<span class="tex-font-style-tt">D</span>',       самый левый столбец не содержит символов '<span class="tex-font-style-tt">L</span>' и самый правый столбец не       содержит символов '<span class="tex-font-style-tt">R</span>'.</p>     <p>Вы хотите поставить роботов на поле (не более одного робота в       клетку). При этом следующие условия должны быть соблюдены.</p>          <ul> <li> Во-первых, каждый робот <span class="tex-font-style-bf">всегда обязан перемещаться</span>         (то есть он не может пропустить ход). <span class="tex-font-style-bf">За один ход каждый робот           перемещается в соседнюю клетку в соответствии с текущим         направлением</span>. </li>       <li> Во-вторых, вам необходимо поставить роботов таким образом,         что <span class="tex-font-style-bf">не найдется такого         хода</span>, перед которым два различных робота стоят в одной и         той же клетке (это также значит, что вы не можете поставить двух         роботов в одну и ту же клетку). Таким образом, Если поле равно           «<span class="tex-font-style-tt">RL</span>» (одна строка, два         столбца, цвета здесь не важны), то вы можете поставить двух         роботов в клетки $$$(1, 1)$$$ и $$$(1, 2)$$$, но если поле равно           «<span class="tex-font-style-tt">RLL</span>», то вы не можете         поставить роботов в клетки $$$(1, 1)$$$ и $$$(1, 3)$$$, потому         что в течение первой секунды оба робота будут стоять в клетке         $$$(1, 2)$$$. </li></ul>          <p>Роботы делают бесконечное количество ходов.</p>     <p>Ваша задача — поставить максимальное количество роботов таким       образом, чтобы удовлетворить все условия, описанные выше, а среди       всех таких способов вам необходимо выбрать такой, что количество         <span class="tex-font-style-bf">черных</span> клеток, на которых       стоят роботы <span class="tex-font-style-bf">перед началом всех       перемещений</span> является максимально возможным. <span class="tex-font-style-bf">Заметьте, что вы можете ставить         роботов только перед началом всех перемещений</span>.</p>     <p>Вам необходимо ответить на $$$t$$$ независимых наборов тестовых данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка входных данных содержит одно целое число $$$t$$$       ($$$1 \le t \le 5 \cdot 10^4$$$) — количество наборов тестовых       данных. Затем следуют $$$t$$$ наборов тестовых данных.</p>     <p>Первая строка набора тестовых данных содержит два целых числа       $$$n$$$ и $$$m$$$ ($$$1 &lt; nm \le 10^6$$$) — количество строк и       количество столбцов соответственно.</p>     <p>Следующие $$$n$$$ строк содержат по $$$m$$$ символов каждая, где       $$$j$$$-й символ $$$i$$$-й строки равен $$$c_{i, j}$$$ ($$$c_{i,       j}$$$ равно либо '<span class="tex-font-style-tt">0</span>', если       клетка $$$(i, j)$$$ покрашена в черный цвет, либо '<span class="tex-font-style-tt">1</span>', если клетка $$$(i, j)$$$       покрашена в белый цвет).</p>     <p>Следующие $$$n$$$ строк также содержат по $$$m$$$ символов       каждая, где $$$j$$$-й символ $$$i$$$-й строки равен $$$s_{i, j}$$$       ($$$s_{i, j}$$$ равно '<span class="tex-font-style-tt">U</span>',         '<span class="tex-font-style-tt">R</span>', '<span class="tex-font-style-tt">D</span>' или '<span class="tex-font-style-tt">L</span>', и описывает направление       клетки $$$(i, j)$$$).</p>     <p>Гарантируется, что сумма размеров полей не превосходит $$$10^6$$$       ($$$\sum nm \le 10^6$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите два числа —       максимальное количество роботов, которое вы можете поставить,       чтобы удовлетворить все ограничения, указанные в условии задачи, и       максимальное количество <span class="tex-font-style-bf">черных</span> клеток, в которых       находятся роботы <span class="tex-font-style-bf">перед началом         всех перемещений</span>, если количество поставленных роботов       максимально. <span class="tex-font-style-bf">Заметьте, что вы         можете ставить роботов только перед началом всех перемещений</span>.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
1 2
01
RL
3 3
001
101
110
RLL
DLD
ULL
3 3
000
000
000
RRD
RLD
ULL
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2 1
4 3
2 2
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1335/problem/F' title='Codeforces Round 634 (Div. 3)'>1335F - Robots on a Grid</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>First of all, I want to say about $$$O(nm)$$$ solution. You can       extract cycles in the graph, do some dynamic programming on trees,       use some hard formulas and so on, but it is a way harder to       implement than the other solution that only has an additional log,       so I'll describe the one which is easier to understand and much       easier to implement.</p>     <p>Firstly, consider the problem from the other side. What is this       grid? It is a functional graph (such a directed graph that each       its vertex has exactly one outgoing edge). This graph seems like a       set of cycles and ordered trees going into these cycles. How can       it help us? Let's notice that if two robots meet after some move,       then they'll go together infinitely from this moment. It means       that if we try to make at least $$$nm$$$ moves from each possible       cell, we will obtain some &quot;equivalence classes&quot; (it       means that if endpoints of two cells coincide after $$$nm$$$ moves       then you cannot place robots in both cells at once).</p>     <p>So, if we could calculate such endpoints, then we can take for       each possible endpoint the robot starting from the black cell (if       such exists) and otherwise the robot starting from the white cell       (if such exists).</p>     <p>How can we calculate such endpoints? Let's number all cells from       $$$0$$$ to $$$nm-1$$$, where the number of the cell $$$(i, j)$$$       is $$$i \cdot m + j$$$. Let the next cell after $$$(i, j)$$$ is       $$$(ni, nj)$$$ (i.e. if you make a move from $$$(i, j)$$$, you go       to $$$(ni, nj)$$$). Also, let's create the two-dimensional array       $$$nxt$$$, where $$$nxt[v][deg]$$$ means the number of the cell in       which you will be if you start in the cell number $$$v$$$ and make       $$$2^{deg}$$$ moves. What is the upper bound of $$$deg$$$? It is       exactly $$$lognm = \lceil\log_{2}(nm + 1)\rceil$$$.</p>     <p>Well, we need to calculate this matrix somehow. It is obvious       that if the number of the cell $$$(i, j)$$$ is $$$id$$$ and the       number of the next cell $$$(ni, nj)$$$ is $$$nid$$$ then       $$$nxt[id][0] = nid$$$. Then let's iterate over all degrees       $$$deg$$$ from $$$1$$$ to $$$lognm - 1$$$ and for each vertex       $$$v$$$ set $$$nxt[v][deg] = nxt[nxt[v][deg - 1]][deg - 1]$$$. The       logic behind this expresion is very simple: if we want to jump       $$$2^{deg}$$$ times from $$$v$$$ and we have all values for       $$$2^{deg - 1}$$$ calculated then let's just jump $$$2^{deg -       1}$$$ times from $$$v$$$ and $$$2^{deg - 1}$$$ times from the       obtained vertex. This technique is called binary lifting.</p>     <p>Now we can jump from every cell $$$nm$$$ times in $$$O(\log       nm)$$$ time: just iterate over all degrees $$$deg$$$ from $$$0$$$       to $$$lognm-1$$$ and if $$$nm$$$ has the $$$deg$$$-th bit on, just       jump from the current vertex $$$2^{deg}$$$ times (set $$$v :=       nxt[v][deg]$$$). The rest of solution is described above.</p>     <p>Time complexity: $$$O(nm \log_{2}nm)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int n, m, lognm;
vector&lt;string&gt; c, s;
vector&lt;vector&lt;int&gt;&gt; used, nxt;

void getnext(int x, int y, int &amp;nx, int &amp;ny) {
	if (s[x][y] == &#39;U&#39;) nx = x - 1, ny = y;
	if (s[x][y] == &#39;R&#39;) nx = x, ny = y + 1;
	if (s[x][y] == &#39;D&#39;) nx = x + 1, ny = y;
	if (s[x][y] == &#39;L&#39;) nx = x, ny = y - 1;
}

void dfs(int x, int y) {
	used[x][y] = 1;
	int nx = -1, ny = -1;
	getnext(x, y, nx, ny);
	assert(0 &lt;= nx &amp;&amp; nx &lt; n &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; m);
	int v = x * m + y, to = nx * m + ny;
	if (!used[nx][ny]) dfs(nx, ny);
	nxt[v][0] = to;
}

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
	
	int t;
	cin &gt;&gt; t;
	while (t--) {
		cin &gt;&gt; n &gt;&gt; m;
		lognm = 0;
		int nm = n * m;
		while ((1 &lt;&lt; lognm) &lt;= nm) ++lognm;
		c = s = vector&lt;string&gt;(n);
		for (auto &amp;it : c) cin &gt;&gt; it;
		for (auto &amp;it : s) cin &gt;&gt; it;
		
		used = vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(m));
		nxt = vector&lt;vector&lt;int&gt;&gt;(n * m, vector&lt;int&gt;(lognm));
		for (int i = 0; i &lt; n; ++i) {
			for (int j = 0; j &lt; m; ++j) {
				if (!used[i][j]) dfs(i, j);
			}
		}
		for (int deg = 1; deg &lt; lognm; ++deg) {
			for (int i = 0; i &lt; n; ++i) {
				for (int j = 0; j &lt; m; ++j) {
					int id = i * m + j;
					nxt[id][deg] = nxt[nxt[id][deg - 1]][deg - 1];
				}
			}
		}
		
		vector&lt;vector&lt;int&gt;&gt; black, white;
		black = white = vector&lt;vector&lt;int&gt;&gt;(n, vector&lt;int&gt;(m));
		for (int i = 0; i &lt; n; ++i) {
			for (int j = 0; j &lt; m; ++j) {
				int v = i * m + j, to = v;
				for (int deg = lognm - 1; deg &gt;= 0; --deg) {
					if ((nm &gt;&gt; deg) &amp; 1) to = nxt[to][deg];
				}
				if (c[i][j] == &#39;0&#39;) ++black[to / m][to % m];
				else ++white[to / m][to % m];
			}
		}
		
		int all = 0, good = 0;
		for (int i = 0; i &lt; n; ++i) {
			for (int j = 0; j &lt; m; ++j) {
				if (black[i][j]) {
					++all;
					++good;
				} else if (white[i][j]) {
					++all;
				}
			}
		}
		cout &lt;&lt; all &lt;&lt; &#34; &#34; &lt;&lt; good &lt;&lt; endl;
	}
	
	return 0;
}
</code></pre>
           
            <pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;queue&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;iomanip&gt;
#include &lt;fstream&gt;
#include &lt;cassert&gt;
#include &lt;cstring&gt;
#include &lt;unordered_set&gt;
#include &lt;unordered_map&gt;
#include &lt;numeric&gt;
#include &lt;ctime&gt;
#include &lt;bitset&gt;
#include &lt;complex&gt;
#include &lt;chrono&gt;
#include &lt;random&gt;
#include &lt;functional&gt;

using namespace std;

const int N = 1e6 + 7;
const int K = 24;

int f[N];
int dp[N];
int ndp[N];
int sel[N];

int fans[N];
int sans[N];

void solve() {
	int n, m;
	cin &gt;&gt; n &gt;&gt; m;
	for (int i = 0; i &lt; n; i++) {
		string s;
		cin &gt;&gt; s;
		for (int j = 0; j &lt; m; j++) {
			sel[i * m + j] = (s[j] == &#39;0&#39;);
		}
	}
	for (int i = 0; i &lt; n; i++) {
		string s;
		cin &gt;&gt; s;
		for (int j = 0; j &lt; m; j++) {
			int to = -1;
			if (s[j] == &#39;U&#39;) to = (i - 1) * m + j;
			if (s[j] == &#39;D&#39;) to = (i + 1) * m + j;
			if (s[j] == &#39;L&#39;) to = i * m + (j - 1);
			if (s[j] == &#39;R&#39;) to = i * m + (j + 1);
			f[i * m + j] = to;
		}
	}
	n *= m;
	for (int i = 0; i &lt; n; i++) {
		dp[i] = f[i];
	}
	for (int j = 0; j &lt; K; j++) {
		for (int i = 0; i &lt; n; i++) {
			ndp[i] = dp[dp[i]];
		}
		for (int i = 0; i &lt; n; i++) {
			dp[i] = ndp[i];
		}
	}
	fill(fans, fans + n, 0);
	fill(sans, sans + n, 0);
	for (int i = 0; i &lt; n; i++) {
		fans[dp[i]]++;
		sans[dp[i]] += sel[i];
	}
	int fs = 0, ss = 0;
	for (int i = 0; i &lt; n; i++) {
		fs += (fans[i] &gt; 0);
		ss += (sans[i] &gt; 0);
	}
	cout &lt;&lt; fs &lt;&lt; &#39; &#39; &lt;&lt; ss &lt;&lt; &#39;\n&#39;;
}

signed main() {
	ios_base::sync_with_stdio(false);
	cin.tie(0);

	int q;
	cin &gt;&gt; q;
	while (q--) {
		solve();
	}
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #635 (Div. 1)
    1336A
    Linova и королевство </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Linova и королевство</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Написание легких романов является очень важной частью жизни       Linova. Прошлой ночью ей приснилось сказочное королевство. Linova       написала легкий роман про это королевство, как только проснулась.       Конечно, она стала его королевой.</p>          <center>       <img class="tex-graphics" src="https://espresso.codeforces.com/df63f4ac458c231c1258e895434dcb4c2f090f09.png" style="max-width: 100.0%;max-height: 100.0%;"/></center>      <p>Всего есть $$$n$$$ городов и $$$n-1$$$ двусторонняя дорога,       соединяющая некоторые пары городов королевства. Из любого города       вы можете попасть в любой другой город, пройдя по некоторым       дорогам. Города пронумерованы от $$$1$$$ до $$$n$$$ и город       $$$1$$$ является столицей королевства. Таким образом, структура       королевства является деревом.</p>     <p>Как королева, Linova планирует выбрать <span class="tex-font-style-bf">ровно</span> $$$k$$$ городов для       развития индустрии, тогда как в остальных городах будет       развиваться туризм. Столица также может быть как индустриальным,       так и туристическим городом.</p>     <p>Раз в год в столице будет проходить встреча. Для участия во       встрече, каждый <span class="tex-font-style-bf">индустриальный       город</span> посылает участника. Все посланники приедут в столицу       по кратчайшему пути (который как известно единственный в дереве).</p>     <p>Путешествие по туристическим городам очень приятно. Для каждого       посланника, его <span class="tex-font-style-it">уровень       счастья</span> равен количеству <span class="tex-font-style-bf">туристических городов</span> на его пути.</p>     <p>Для того, чтобы люди любили королеву, Linova хочет выбрать       $$$k$$$ городов так, чтобы максимизировать сумму <span class="tex-font-style-it">уровней счастья</span> всех       посланников. Можете ли вы посчитать максимальную возможную сумму       для нее?</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит два целых числа $$$n$$$ и $$$k$$$ ($$$2\le       n\le 2 \cdot 10^5$$$, $$$1\le k&lt; n$$$)  — количество городов и       индустриальных городов, соответственно.</p>     <p>Каждая из следующих $$$n-1$$$ строк содержит два целых числа       $$$u$$$ и $$$v$$$ ($$$1\le u,v\le n$$$), обозначающих наличие       дороги, соединяющей города $$$u$$$ и $$$v$$$.</p>     <p>Гарантируется, что из любого города можно достичь любой другой по дорогам.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите строку, содержащую единственное целое число  —       максимальную возможную сумму <span class="tex-font-style-it">уровней счастья</span> всех       посланников, которую можно достичь.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
7 4
1 2
1 3
1 4
3 5
3 6
4 7
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
7</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
4 1
1 2
1 3
2 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
8 5
7 5
1 7
6 1
3 7
8 3
2 1
4 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
9</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>       <img class="tex-graphics" src="https://espresso.codeforces.com/d811810ac8e2c43cb201a3388ae50f1b3e17a687.png" style="max-width: 100.0%;max-height: 100.0%;"/></p>     <p>В первом тесте, Linova может выбрать города $$$2$$$, $$$5$$$,       $$$6$$$, $$$7$$$ для развития индустрии, тогда <span class="tex-font-style-it">уровень счастья</span> посланника из       города $$$2$$$ будет равен $$$1$$$, <span class="tex-font-style-it">уровни счастья</span> посланников из       городов $$$5$$$, $$$6$$$, $$$7$$$ будут равны $$$2$$$. Таким       образом, сумма <span class="tex-font-style-it">уровней       счастья</span> будет равна $$$7$$$ и можно доказать, что это       максимальная возможная сумма, которая может быть.</p>     <p>       <img class="tex-graphics" src="https://espresso.codeforces.com/3ffb39c877eca7565234f5b27836c176c6a85f3f.png" style="max-width: 100.0%;max-height: 100.0%;"/></p>     <p>Во втором тесте, выбрав города $$$3$$$ и $$$4$$$ для развития       индустрии можно достичь суммы $$$3$$$, но обратите внимание, что       Linova планирует выбрать <span class="tex-font-style-bf">ровно</span> $$$k$$$ городов для       развития индустрии, поэтому максимальная сумма равна $$$2$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1336/problem/A' title='Codeforces Round 635 (Div. 1)'>1336A - Linova and Kingdom</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Lemma: In the optimum solution, if a node (except the root) is       chosen to develop tourism, its parent must be chosen to develop       tourism, too.</p>     <p>Proof: Otherwise, if we choose its parent to develop tourism       instead of itself, the sum of happiness will be greater.</p>     <p>Then we can calculate how much happiness we will get if we choose       a certain node to develop tourism. Suppose the depth of node       $$$u$$$ is $$$dep_u$$$ (i.e. there are $$$dep_u$$$ nodes on the       path $$$(1,u)$$$), the size of the subtree rooted on $$$u$$$ is       $$$siz_u$$$ (i.e. there are $$$siz_u$$$ nodes $$$v$$$ that $$$u$$$       is on the path $$$(1,v)$$$). Then, if we choose $$$u$$$ to develop       tourism, compared to choose it to develop industry, the total       happiness will be increased by $$$siz_u-dep_u$$$: the envoy of       $$$u$$$ won't be sent, we will lose $$$dep_u-1$$$ happiness; a       total of $$$siz_u-1$$$ envoys of all nodes in the subtree rooted       on $$$u$$$ except $$$u$$$ itself will get one more happiness.</p>     <p>So, just use DFS to calculate all $$$siz_u-dep_u$$$, then sort       them from big to small, calculate the sum of the first $$$n-k$$$       elements. You can also use <span class="tex-font-style-tt">std::nth_element</span> in STL to get an       $$$O(n)$$$ solution.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;
#define maxn 200005
std::vector&lt;int&gt;conj[maxn];
int n,k,u,v,depth[maxn]={0},size[maxn]={0},det[maxn];
long long ans=0;
int cmp(int a,int b){return a&gt;b;}
int dfs(int u,int f){depth[u]=depth[f]+1;size[u]=1;
	for (int i=0;i&lt;conj[u].size();++i){
		if ((v=conj[u][i])==f)continue;
		size[u]+=dfs(v,u);
	}det[u]=size[u]-depth[u];return size[u];
}
int main(){
	scanf(&#34;%d%d&#34;,&amp;n,&amp;k);
	for (int i=1;i&lt;n;++i){
		scanf(&#34;%d%d&#34;,&amp;u,&amp;v);conj[u].push_back(v);conj[v].push_back(u);
	}dfs(1,0);
	std::nth_element(det+1,det+n-k,det+n+1,cmp);
	for (int i=1;i&lt;=n-k;++i)ans+=det[i];std::cout&lt;&lt;ans;
	return 0;
}
</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;
#define maxn 200005
std::vector&lt;int&gt;conj[maxn];
int n,k,u,v,depth[maxn]={0},size[maxn]={0},det[maxn];
long long ans=0;
int cmp(int a,int b){return a&gt;b;}
int dfs(int u,int f){depth[u]=depth[f]+1;size[u]=1;
	for (int i=0;i&lt;conj[u].size();++i){
		if ((v=conj[u][i])==f)continue;
		size[u]+=dfs(v,u);
	}det[u]=size[u]-depth[u];return size[u];
}
int main(){
	scanf(&#34;%d%d&#34;,&amp;n,&amp;k);
	for (int i=1;i&lt;n;++i){
		scanf(&#34;%d%d&#34;,&amp;u,&amp;v);conj[u].push_back(v);conj[v].push_back(u);
	}dfs(1,0);
	std::nth_element(det+1,det+n-k,det+n+1,cmp);
	for (int i=1;i&lt;=n-k;++i)ans+=det[i];std::cout&lt;&lt;ans;
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #635 (Div. 1)
    1336B
    Xenia и разноцветные камушки </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Xenia и разноцветные камушки</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>3 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Xenia девочка, рожденная дворянкой. От скуки и одиночества, Xenia       вынуждена сама искать какие-то способы развлечься.</p>          <center>       <img class="tex-graphics" src="https://espresso.codeforces.com/f3da718b55ccc1ed3494e6615f1db496fd70b0ad.png" style="max-width: 100.0%;max-height: 100.0%;"/></center>      <p>Недавно Xenia купила $$$n_r$$$ красных камушков, $$$n_g$$$       зеленых камушков и $$$n_b$$$ голубых камушков. Каждый камушек       имеет некоторый вес.</p>     <p>Сейчас она хочет выбрать три камушка.</p>     <p>Xenia любит разноцветные вещи, поэтому она выберет ровно один       камушек каждого цвета.</p>     <p>Xenia любит баланс, поэтому она хочет выбрать камушки с как можно       меньшей разнице в весе.</p>     <p>Более точно, если положить веса выбранных камушков за $$$x$$$,       $$$y$$$ и $$$z$$$, Xenia хочет выбрать камушки, так, чтобы       значение $$$(x-y)^2+(y-z)^2+(z-x)^2$$$ было как можно меньше. Как       ее лучший друг, можете ли вы помочь ей?</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит единственное целое число $$$t$$$ ($$$1\le       t \le 100$$$)  — количество тестовых случаев. Затем следует       описание $$$t$$$ тестовых случаев.</p>     <p>Первая строка описания каждого тестового случая содержит три       целых числа $$$n_r,n_g,n_b$$$ ($$$1\le n_r,n_g,n_b\le 10^5$$$)  —       количество красных камушков, зеленых камушков и голубых камушков, соответственно.</p>     <p>Вторая строка описания каждого тестового случая содержит       $$$n_r$$$ целых чисел $$$r_1,r_2,\ldots,r_{n_r}$$$ ($$$1\le r_i       \le 10^9$$$)  — $$$r_i$$$ равно весу $$$i$$$-о красного камушка.</p>     <p>Третья строка описания каждого тестового случая содержит       $$$n_g$$$ целых чисел $$$g_1,g_2,\ldots,g_{n_g}$$$ ($$$1\le g_i       \le 10^9$$$)  — $$$g_i$$$ равно весу $$$i$$$-о зеленого камушка.</p>     <p>Четвертая строка описания каждого тестового случая содержит       $$$n_b$$$ целых чисел $$$b_1,b_2,\ldots,b_{n_b}$$$ ($$$1\le b_i       \le 10^9$$$)  — $$$b_i$$$ равно весу $$$i$$$-о голубого камушка.</p>     <p>Гарантируется, что $$$\sum n_r \le 10^5$$$, $$$\sum n_g \le       10^5$$$, $$$\sum n_b \le 10^5$$$ (сумма берется по всем тестовым случаям).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого тестового случая выведите целое число  — минимальное       возможное значение, которое Xenia может получить.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
2 2 3
7 8
6 3
3 1 4
1 1 1
1
1
1000000000
2 2 2
1 2
5 4
6 7
2 2 2
1 2
3 4
6 7
3 4 1
3 2 1
7 3 3 4
6
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
14
1999999996000000002
24
24
14
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом тестовом случае, Xenia купила следующие камушки:</p>     <p>       <img class="tex-graphics" src="https://espresso.codeforces.com/7e400036e7fb1bb1013d79825f1eb0157cb807e7.png" style="max-width: 100.0%;max-height: 100.0%;"/></p>     <p>Если она возьмет красный камушек с весом $$$7$$$, зеленый камушек       с весом $$$6$$$ и голубой камушек с весом $$$4$$$, она получит       самый сбалансированный выбор со значением $$$(x-y)^2+(y-z)^2+(z-x)^2=(7-6)^2+(6-4)^2+(4-7)^2=14$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1336/problem/B' title='Codeforces Round 635 (Div. 1)'>1336B - Xenia and Colorful Gems</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>First, let's assume that there exists an optimum solution in       which we choose $$$r_x$$$, $$$g_y$$$ and $$$b_z$$$ satisfying       $$$r_x \le g_y \le b_z$$$.</p>     <p>Here's a lemma:</p>     <p>When $$$y$$$ is fixed, $$$r_x$$$ is the maximum one that $$$r_x       \le g_y$$$, and $$$b_z$$$ is the minimum one that $$$g_y \le b_z$$$.</p>     <p>It's easy to prove: no matter what $$$z$$$ is, the bigger       $$$r_x$$$ is, the smaller $$$(r_x-g_y)^2$$$ and $$$(r_x-b_z)^2$$$       are; for $$$b_z$$$ it's similar.</p>     <p>So, if we know that in one of the optimum solutions, $$$r_x \le       g_y \le b_z$$$, we can sort each array at first and then find       $$$x$$$ and $$$z$$$ by binary search or maintaining some pointers       while enumerating $$$y$$$.</p>     <p>Back to the original problem without $$$r_x \le g_y \le b_z$$$,       we can enumerate the six possible situations: $$$r_x \le g_y \le       b_z$$$, $$$r_x \le b_z \le g_y$$$, $$$g_y \le r_x \le b_z$$$,       $$$g_y \le b_z \le r_x$$$, $$$b_z \le r_x \le g_y$$$ and $$$b_z       \le g_y \le r_x$$$. Find the optimum solution in each situation       and the optimum one among them is the answer.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int t, nr, ng, nb;
long long ans;

long long sq(int x) { return 1ll * x * x; }

void solve(vector&lt;int&gt; a, vector&lt;int&gt; b, vector&lt;int&gt; c) {
    for (auto x : a) {
        auto y = lower_bound(b.begin(), b.end(), x);
        auto z = upper_bound(c.begin(), c.end(), x);
        if (y == b.end() || z == c.begin()) { continue; }
        z--; ans = min(ans, sq(x - *y) + sq(*y - *z) + sq(*z - x));
    }
}

int main() {
    for (cin &gt;&gt; t; t; t--) {
        cin &gt;&gt; nr &gt;&gt; ng &gt;&gt; nb;
        vector&lt;int&gt; r(nr), g(ng), b(nb);
        for (int i = 0; i &lt; nr; i++) { cin &gt;&gt; r[i]; }
        for (int i = 0; i &lt; ng; i++) { cin &gt;&gt; g[i]; }
        for (int i = 0; i &lt; nb; i++) { cin &gt;&gt; b[i]; }
        sort(r.begin(), r.end());
        sort(g.begin(), g.end());
        sort(b.begin(), b.end());
        ans = 9e18;
        solve(r, g, b); solve(r, b, g);
        solve(g, b, r); solve(g, r, b);
        solve(b, r, g); solve(b, g, r);
        cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int t, nr, ng, nb;
long long ans;

long long sq(int x) { return 1ll * x * x; }

void solve(vector&lt;int&gt; a, vector&lt;int&gt; b, vector&lt;int&gt; c) {
    for (auto x : a) {
        auto y = lower_bound(b.begin(), b.end(), x);
        auto z = upper_bound(c.begin(), c.end(), x);
        if (y == b.end() || z == c.begin()) { continue; }
        z--; ans = min(ans, sq(x - *y) + sq(*y - *z) + sq(*z - x));
    }
}

int main() {
    for (cin &gt;&gt; t; t; t--) {
        cin &gt;&gt; nr &gt;&gt; ng &gt;&gt; nb;
        vector&lt;int&gt; r(nr), g(ng), b(nb);
        for (int i = 0; i &lt; nr; i++) { cin &gt;&gt; r[i]; }
        for (int i = 0; i &lt; ng; i++) { cin &gt;&gt; g[i]; }
        for (int i = 0; i &lt; nb; i++) { cin &gt;&gt; b[i]; }
        sort(r.begin(), r.end());
        sort(g.begin(), g.end());
        sort(b.begin(), b.end());
        ans = 9e18;
        solve(r, g, b); solve(r, b, g);
        solve(g, b, r); solve(g, r, b);
        solve(b, r, g); solve(b, g, r);
        cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #635 (Div. 1)
    1336C
    Kaavi и магическое заклинание </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Kaavi и магическое заклинание</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Kaavi, таинственная гадалка, глубоко верит в то, что судьба       человека неизбежна и неотвратима. Конечно, она зарабатывает себе       на жизнь предсказывая будущее других людей. Занимаясь гаданием,       Kaavi верит, что магические заклинания могут дать ей огромную силу       видеть будущее.</p>          <center>       <img class="tex-graphics" src="https://espresso.codeforces.com/e031f1a741db6090fee9d6722704d37d130f468e.png" style="max-width: 100.0%;max-height: 100.0%;"/></center>      <p>У Kaavi есть строка $$$T$$$ длины $$$m$$$ и все строки, имеющие       префикс $$$T$$$ это магические заклинания. У Kaavi также есть       строка $$$S$$$ длины $$$n$$$ и пустая строка $$$A$$$.</p>     <p>Во время гадания, Kaavi нужно применить некоторую       последовательность операций. Есть две различные операции:</p>          <ul>                     <li> Удалить первый символ строки $$$S$$$ и добавить его <span class="tex-font-style-bf">в начало</span> строки $$$A$$$.         </li>       <li> Удалить первый символ строки $$$S$$$ и добавить его <span class="tex-font-style-bf">в конец</span> строки $$$A$$$.         </li></ul>          <p>Kaavi может сделать <span class="tex-font-style-bf">не более,       чем</span> $$$n$$$ операций. Для того, чтобы завершить гадание,       она хочет узнать количество различных последовательностей       операций, для того, чтобы сделать $$$A$$$ магическим заклинанием       (то есть эта строка имеет префикс $$$T$$$). Как ее ассистент,       можете ли вы помочь ей? Поскольку ответ может быть очень большим,       Kaavi хочет знать его остаток при делении на $$$998\,244\,353$$$.</p>     <p>Две последовательности операций считаются различными, если они       различаются по длине или существует такое $$$i$$$, что их       $$$i$$$-е операции различаются.</p>     <p>Подстрокой называется некоторая последовательность       последовательных символов строки. Префиксом строки $$$S$$$       называется подстрока $$$S$$$, которая начинается в начале строки $$$S$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке находится строка $$$S$$$ длины $$$n$$$ ($$$1 \leq       n \leq 3000$$$).</p>     <p>Во второй строке находится строка $$$T$$$ длины $$$m$$$ ($$$1       \leq m \leq n$$$).</p>     <p>Обе строки состоят только из строчных латинских символов.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите единственное целое число  — ответ на задачу по модулю $$$998\,244\,353$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
abab
ba
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
12</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
defineintlonglong
signedmain
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
rotator
rotator
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
4</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
cacdcdbbbb
bdcaccdbbb
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
24</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом тесте:</p>     <p>       <img class="tex-graphics" src="https://espresso.codeforces.com/59b1aeccd6c5b78703012f04c99eb547b718f003.png" style="max-width: 100.0%;max-height: 100.0%;"/></p>     <p>Красные строки это магические заклинания. В первой операции,       Kaavi может добавить символ «<span class="tex-font-style-tt">a</span>» в начало или в конец $$$A$$$.       Хотя в обоих случаях результат будет одинаковым, это две разные       операции. Поэтому ответ $$$6\times2=12$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1336/problem/C' title='Codeforces Round 635 (Div. 1)'>1336C - Kaavi and Magic Spell</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>We can use DP to solve this problem.</p>     <p>Let $$$f_{i,j}$$$ be the answer when $$$S[0..i-1]$$$ has already       been used and the current $$$A[0..\min(i-1,m-1-j)]$$$ will be in       the position $$$[j..\min(i+j-1,m-1)]$$$ after all operations are       finished. Specially, $$$f_{i,m}$$$ means that all characters in       the current $$$A$$$ won't be in the position       $$$[j..\min(i+j-1,m-1)]$$$ after all operations are finished.</p>     <p>By definition, $$$f_{n,0}=1$$$ and $$$f_{n, j}=0 (j\ge 1)$$$.</p>     <p>The state transition:</p>          <ul>                     <li> $$$j=0$$$         <p>If $$$i\ge m$$$, $$$A$$$ has already had the prefix $$$T$$$,           so you can stop performing operations at any position, there           are $$$n-i+1$$$ positions in total.</p>         <p>Otherwise, only when $$$S[i]=T[i]$$$, you can add $$$S[i]$$$           at the back of $$$A$$$, there are $$$f_{i+1,0}$$$ different           operation sequences in this situation.</p>         </li>       <li> $$$1\le j \le m-1$$$         <p>If $$$i+j\ge m$$$ or $$$S[i]=T[i+j]$$$, you can add           $$$S[i]$$$ at the back of $$$A$$$, there are $$$f_{i+1,j}$$$           different operation sequences in this situation.</p>         <p>If $$$S[i]=T[j-1]$$$, you can add $$$S[i]$$$ at the front of           $$$A$$$, there are $$$f_{i+1,j-1}$$$ different operation           sequences in this situation.</p>         </li>       <li> $$$j=m$$$         <p>You can always add $$$S[i]$$$ at the front/back of $$$A$$$ in           this situation ($$$2f_{i+1,m}$$$ different operation           sequences). However, if $$$S[i]=T[m-1]$$$, you can let           $$$S[i]$$$ to match $$$T[m-1]$$$ ($$$f_{i+1,m-1}$$$ different           operation sequences).</p>         <p>So, if $$$S[i]=T[m-1]$$$,           $$$f_{i,m}=2f_{i+1,m}+f_{i+1,m-1}$$$. Otherwise, $$$f_{i,m}=2f_{i+1,m}$$$.</p>         </li></ul>          <p>The answer is $$$2(f_{1,m}+\sum\limits_{T[i]=S[0]}f_{1,i})$$$.</p></div></div></div>

           
            <pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

const int mod = 998244353;

int main()
{
	string s, t;
	
	cin &gt;&gt; s &gt;&gt; t;
	int n = s.size();
	int m = t.size();
	
	vector&lt;vector&lt;int&gt; &gt; f(n + 1, vector&lt;int&gt;(m + 1));
	
	f[n][0] = 1;
	
	for (int i = n - 1; i &gt;= 1; --i)
	{
		for (int j = 0; j &lt;= m; ++j)
		{
			if (j == 0)
			{
				if (i &gt;= m) f[i][0] = n - i + 1;
				else if (s[i] == t[i]) f[i][0] = f[i + 1][0];
			}
			else if (j == m)
			{
				f[i][m] = 2 * f[i + 1][m] % mod;
				if (s[i] == t[m - 1]) f[i][m] = (f[i][m] + f[i + 1][m - 1]) % mod;
			}
			else
			{
				if (i + j &gt;= m || s[i] == t[i + j]) f[i][j] = f[i + 1][j];
				if (s[i] == t[j - 1]) f[i][j] = (f[i][j] + f[i + 1][j - 1]) % mod;
			}
		}
	}
	
	int ans = f[1][m];
	for (int i = 0; i &lt; m; ++i) if (t[i] == s[0]) ans = (ans + f[1][i]) % mod;
	ans = ans * 2 % mod;
	
	cout &lt;&lt; ans;
	
	return 0;
}
</code></pre>
           
            <pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

using namespace std;

const int mod = 998244353;

int main()
{
	string s, t;
	
	cin &gt;&gt; s &gt;&gt; t;
	int n = s.size();
	int m = t.size();
	
	vector&lt;vector&lt;int&gt; &gt; f(n + 1, vector&lt;int&gt;(m + 1));
	
	f[n][0] = 1;
	
	for (int i = n - 1; i &gt;= 1; --i)
	{
		for (int j = 0; j &lt;= m; ++j)
		{
			if (j == 0)
			{
				if (i &gt;= m) f[i][0] = n - i + 1;
				else if (s[i] == t[i]) f[i][0] = f[i + 1][0];
			}
			else if (j == m)
			{
				f[i][m] = 2 * f[i + 1][m] % mod;
				if (s[i] == t[m - 1]) f[i][m] = (f[i][m] + f[i + 1][m - 1]) % mod;
			}
			else
			{
				if (i + j &gt;= m || s[i] == t[i + j]) f[i][j] = f[i + 1][j];
				if (s[i] == t[j - 1]) f[i][j] = (f[i][j] + f[i + 1][j - 1]) % mod;
			}
		}
	}
	
	int ans = f[1][m];
	for (int i = 0; i &lt; m; ++i) if (t[i] == s[0]) ans = (ans + f[1][i]) % mod;
	ans = ans * 2 % mod;
	
	cout &lt;&lt; ans;
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #635 (Div. 1)
    1336D
    Yui и маджонг </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Yui и маджонг</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>       <span class="tex-font-style-bf">Это интерактивная задача.</span></p>     <p>Yui девочка, которая очень любит играть в маджонг.</p>          <center>       <img class="tex-graphics" src="https://espresso.codeforces.com/52d3020384f00426f2e00e8e88039c5fc29bbdd8.png" style="max-width: 100.0%;max-height: 100.0%;"/></center>      <p>У нее есть таинственный набор, который состоит из нескольких       плиток (этот набор может быть пустым). Каждая плитка содержит       целое число от $$$1$$$ до $$$n$$$ и <span class="tex-font-style-bf">не больше, чем $$$n$$$ плиток</span> в       множестве имеют одинаковое значение. Таким образом, в множество       содержит не больше, чем $$$n^2$$$ плиток.</p>     <p>Вы хотите узнать, какие числа написаны на плитках в множестве.       Для этого Yui хочет сыграть с вами в игру.</p>     <p>Давайте назовем множество, состоящее из <span class="tex-font-style-bf">трех</span> плиток <span class="tex-font-style-it">равной тройкой</span>, если значения       на плитках одинаковые. Например, $$$\{2,\,2,\,2\}$$$ это равная       тройка, а $$$\{2,\,3,\,3\}$$$ нет.</p>     <p>Давайте назовем множество, состоящее из <span class="tex-font-style-bf">трех</span> плиток <span class="tex-font-style-it">последовательной тройкой</span>, если       значения на плитках последовательные целые числа. Например,       $$$\{2,\,3,\,4\}$$$ это последовательная тройка, а       $$$\{1,\,3,\,5\}$$$ нет.</p>     <p>Сначала, Yui называет вам количество подмножеств плиток, которые       являются равными тройками и количество подмножеств плиток, которые       являются последовательными тройками в ее множестве плиток. После       этого, вы можете добавить плитку с целым числом от $$$1$$$ до       $$$n$$$ в множество <span class="tex-font-style-bf">не более, чем         $$$n$$$ раз</span>. Каждый раз добавляя плитку, в ответ вы       получите количество подмножеств плиток в текущем множестве плиток,       которые являются равными тройками и количество подмножеств плиток       в текущем множестве плиток, которые являются последовательными тройками.</p>     <p>Обратите внимание, что любые две различные плитки с одинаковым       значением считаются различными. Другими словами, в множестве       $$$\{1,\,1,\,2,\,2,\,3\}$$$ вы можете найти $$$4$$$ подмножества $$$\{1,\,2,\,3\}$$$.</p>     <p>Угадайте количество плиток в изначальном множестве с числом       $$$i$$$ для всех целых чисел $$$i$$$ от $$$1$$$ до $$$n$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке находится единственное целое число $$$n$$$ ($$$4       \le n \le 100$$$).</p>     <p>Во второй строке находится два целых числа, равные количеству       подмножеств плиток, которые являются равными тройками и количеству       подмножеств плиток, которые являются последовательными тройками в       изначальном множестве плиток.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Когда ваша программа будет готова ответить, выведите строку в       формате «<span class="tex-font-style-tt">! $$$a_1$$$ $$$a_2$$$         $$$\ldots$$$ $$$a_n$$$</span>» ($$$0 \le a_i \le n$$$), где       $$$a_i$$$ будет равно количеству плиток в изначальном множестве с       числом $$$i$$$.</p></div>         <div>     <div class="section-title">Протокол взаимодействия</div>          <p>Для того, чтобы добавить плитку в множество, выведите строку в       формате «<span class="tex-font-style-tt">+ $$$x$$$</span>» ($$$1       \le x \le n$$$), где $$$x$$$ равно числу, которое будет на плитке,       которую вы добавляете. В ответ вы должны считать два целых числа,       равных количеству подмножеств плиток, которые являются равными       тройками и количеству подмножеств плиток, которые являются       последовательными тройками в текущем множестве плиток.</p>     <p>После вывода строки с запросом добавления плитки или строки с       ответом не забывайте сбрасывать буфер вывода. Иначе ваше решение       получит вердикт <span class="tex-font-style-tt">Idleness limit exceeded</span>.</p>     <p>Для того, чтобы сделать это, используйте:</p>          <ul> <li> <span class="tex-font-style-tt">fflush(stdout)</span> или           <span class="tex-font-style-tt">cout.flush()</span> в C++; </li>       <li> <span class="tex-font-style-tt">System.out.flush()</span> в         Java; </li>       <li> <span class="tex-font-style-tt">flush(output)</span> в         Pascall; </li>       <li> <span class="tex-font-style-tt">stdout.flush()</span> в         Python; </li>       <li> обратитесь к документации для остальных языков. </li></ul>          <p>Вы получите вердикт <span class="tex-font-style-tt">Wrong       answer</span>, если вы добавите больше, чем $$$n$$$ плиток в множество.</p>     <p>       <span class="tex-font-style-bf">Взломы</span></p>     <p>Для того, чтобы сделать взлом, вы должны предоставить тест в       следующем формате:</p>     <p>В первой строке находится единственное целое число $$$n$$$ ($$$4       \le n \le 100$$$).</p>     <p>Во второй строке находится $$$n$$$ целых чисел       $$$a_1,a_2,\ldots,a_n$$$ ($$$0 \le a_i \le n$$$)  — $$$a_i$$$       равно количеству плиток с числом $$$i$$$ в множестве.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
1 6
2 9
5 12
5 24
6 24
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
+ 1
+ 1
+ 2
+ 5
! 2 1 3 0 2
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом тесте, изначальное множество плиток $$$\{1, 1, 2, 3, 3,       3, 5, 5\}$$$. Оно содержит одну равную тройку $$$\{3, 3, 3\}$$$ и       шесть последовательных троек, которые все равны $$$\{1, 2, 3\}$$$.       После добавления в множество плитки со значением $$$1$$$ множество       плиток станет $$$\{1, 1, 1, 2, 3, 3, 3, 5, 5\}$$$ и будет       содержать две равные тройки $$$\{1, 1, 1\}$$$, $$$\{3, 3, 3\}$$$ и       девять последовательных троек, которые все равны $$$\{1, 2, 3\}$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1336/problem/D' title='Codeforces Round 635 (Div. 1)'>1336D - Yui and Mahjong Set</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Suppose $$$c_i$$$ equals to the number of tiles in the current       set with value $$$i$$$ (before making a query).</p>     <p>If you insert a tile with value $$$x$$$:</p>          <ul> <li> The delta of triplet subsets is $$$\dbinom{c_x}{2}$$$.         Once you're sure that $$$c_x \neq 0$$$ holds, you can determine         the exact value of $$$c_x$$$. </li>       <li> The delta of straight subsets is         $$$c_{x-2}c_{x-1}+c_{x-1}c_{x+1}+c_{x+1}c_{x+2}$$$. Once you've         known the values of $$$c_{1} \ldots c_{x+1}$$$ and you're sure         that $$$c_{x+1} \neq 0$$$, you can determine the exact value of         $$$c_{x+2}$$$. </li></ul>          <p>Let's insert tiles with following values in order: $$$n-1$$$,       $$$n-2$$$, $$$\ldots$$$, $$$3$$$, $$$1$$$, $$$2$$$, $$$1$$$.</p>     <p>We can easily get $$$a_1$$$ by the delta of triplet subsets since       we insert tiles with value $$$1$$$ twice.</p>     <p>Consider the delta of straight subsets when you insert the tile       with value $$$1$$$. It equals to $$$a_2(a_3+1)$$$ for the first       time and $$$(a_2+1)(a_3+1)$$$ for the second time. Use subtraction       to get $$$a_3$$$, then use division to get $$$a_2$$$. (The divisor       is $$$a_3+1$$$, which is non-zero)</p>     <p>Finally, let do the following for each $$$x$$$ from $$$2$$$ to       $$$n-2$$$. We've known the values of $$$a_{1} \ldots a_{x+1}$$$.       Since we've inserted a tile with value $$$x+1$$$ before inserting       $$$x$$$, we can use division to get $$$a_{x+2}$$$ by the delta of       straight subsets and avoid dividing zero.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int n, s1, s2, t1, t2, d1[105], d2[105], a[105];

int main() {
    cin &gt;&gt; n &gt;&gt; s1 &gt;&gt; s2;
    for (int i = n - 1; i &gt;= 0; i--) {
        cout &lt;&lt; &#34;+ &#34; &lt;&lt; (i &gt; 2 ? i : i % 2 + 1) &lt;&lt; endl;
        t1 = s1; t2 = s2; cin &gt;&gt; s1 &gt;&gt; s2;
        d1[i] = s1 - t1; d2[i] = s2 - t2;
    }
    a[1] = sqrt(d1[0] * 2);
    a[3] = d2[0] - d2[2] - 1;
    a[2] = d2[2] / (a[3] + 1);
    a[4] = d2[1] / (a[3] + 1) - a[1] - 2;
    for (int i = 5; i &lt;= n; i++) {
        a[i] = (d2[i - 2] - a[i - 4] * a[i - 3]) / (a[i - 1] + 1) - a[i - 3] - 1;
    }
    cout &lt;&lt; &#34;!&#34;; a[n]++;
    for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; &#34; &#34; &lt;&lt; a[i]; }
    cout &lt;&lt; endl;
    return 0;
}
</code></pre>
           
            <pre><code>#include &lt;cstdio&gt;

const int MN = 105;

int N, lstv1, lstv2, v1, v2;
int dv1[MN], dv2[MN], Tag[MN], Ans[MN];

int main() {
	scanf(&#34;%d&#34;, &amp;N);
	scanf(&#34;%d%d&#34;, &amp;lstv1, &amp;lstv2);
	for (int i = 1; i &lt; N; ++i) {
		printf(&#34;+ %d\n&#34;, i), fflush(stdout);
		scanf(&#34;%d%d&#34;, &amp;v1, &amp;v2);
		dv1[i] = v1 - lstv1, dv2[i] = v2 - lstv2;
		if (dv1[i] &gt; 0)
			for (int x = 2; x &lt;= N; ++x)
				if (x * (x - 1) / 2 == dv1[i]) {
					Tag[i] = x; break;
				}
		lstv1 = v1, lstv2 = v2;
	}
	printf(&#34;+ 1\n&#34;), fflush(stdout);
	scanf(&#34;%d%d&#34;, &amp;v1, &amp;v2);
	int ndv1 = v1 - lstv1, ndv2 = v2 - lstv2;
	for (int x = 0; x &lt;= N; ++x)
		if (x * (x + 1) / 2 == ndv1) {
			Ans[1] = x; break;
		}
	int delta = ndv2 - dv2[1] - 1; // delta = a[2] + a[3]
	if (Tag[2] &gt;= 2) Ans[2] = Tag[2], Ans[3] = delta - Ans[2];
	else if (Tag[3] &gt;= 2) Ans[3] = Tag[3], Ans[2] = delta - Ans[3];
	else if (delta == 0) Ans[3] = Ans[2] = 0;
	else if (delta == 2) Ans[3] = Ans[2] = 1;
	else if (dv2[2] &gt; 0) Ans[2] = 0, Ans[3] = 1;
	else Ans[2] = 1, Ans[3] = 0;
	for (int i = 3; i &lt;= N - 2; ++i) {
		if (Tag[i + 1] &gt;= 2) {
			Ans[i + 1] = Tag[i + 1];
			continue;
		}
		if ((Ans[i - 2] + 1) * (Ans[i - 1] + 1) == dv2[i]) Ans[i + 1] = 0;
		else Ans[i + 1] = 1;
	}
	Ans[N] = (dv2[N - 1] - (Ans[N - 3] + 1) * (Ans[N - 2] + 1)) / (Ans[N - 2] + 1);
	printf(&#34;!&#34;);
	for (int i = 1; i &lt;= N; ++i) printf(&#34; %d&#34;, Ans[i]);
	puts(&#34;&#34;), fflush(stdout);
	return 0;
}
</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int n, s1, s2, t1, t2, d1[105], d2[105], a[105];

int main() {
    cin &gt;&gt; n &gt;&gt; s1 &gt;&gt; s2;
    for (int i = n - 1; i &gt;= 0; i--) {
        cout &lt;&lt; &#34;+ &#34; &lt;&lt; (i &gt; 2 ? i : i % 2 + 1) &lt;&lt; endl;
        t1 = s1; t2 = s2; cin &gt;&gt; s1 &gt;&gt; s2;
        d1[i] = s1 - t1; d2[i] = s2 - t2;
    }
    a[1] = sqrt(d1[0] * 2);
    a[3] = d2[0] - d2[2] - 1;
    a[2] = d2[2] / (a[3] + 1);
    a[4] = d2[1] / (a[3] + 1) - a[1] - 2;
    for (int i = 5; i &lt;= n; i++) {
        a[i] = (d2[i - 2] - a[i - 4] * a[i - 3]) / (a[i - 1] + 1) - a[i - 3] - 1;
    }
    cout &lt;&lt; &#34;!&#34;; a[n]++;
    for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; &#34; &#34; &lt;&lt; a[i]; }
    cout &lt;&lt; endl;
    return 0;
}
</code></pre>
           
            <pre><code>#include &lt;cstdio&gt;

const int MN = 105;

int N, lstv1, lstv2, v1, v2;
int dv1[MN], dv2[MN], Tag[MN], Ans[MN];

int main() {
	scanf(&#34;%d&#34;, &amp;N);
	scanf(&#34;%d%d&#34;, &amp;lstv1, &amp;lstv2);
	for (int i = 1; i &lt; N; ++i) {
		printf(&#34;+ %d\n&#34;, i), fflush(stdout);
		scanf(&#34;%d%d&#34;, &amp;v1, &amp;v2);
		dv1[i] = v1 - lstv1, dv2[i] = v2 - lstv2;
		if (dv1[i] &gt; 0)
			for (int x = 2; x &lt;= N; ++x)
				if (x * (x - 1) / 2 == dv1[i]) {
					Tag[i] = x; break;
				}
		lstv1 = v1, lstv2 = v2;
	}
	printf(&#34;+ 1\n&#34;), fflush(stdout);
	scanf(&#34;%d%d&#34;, &amp;v1, &amp;v2);
	int ndv1 = v1 - lstv1, ndv2 = v2 - lstv2;
	for (int x = 0; x &lt;= N; ++x)
		if (x * (x + 1) / 2 == ndv1) {
			Ans[1] = x; break;
		}
	int delta = ndv2 - dv2[1] - 1; // delta = a[2] + a[3]
	if (Tag[2] &gt;= 2) Ans[2] = Tag[2], Ans[3] = delta - Ans[2];
	else if (Tag[3] &gt;= 2) Ans[3] = Tag[3], Ans[2] = delta - Ans[3];
	else if (delta == 0) Ans[3] = Ans[2] = 0;
	else if (delta == 2) Ans[3] = Ans[2] = 1;
	else if (dv2[2] &gt; 0) Ans[2] = 0, Ans[3] = 1;
	else Ans[2] = 1, Ans[3] = 0;
	for (int i = 3; i &lt;= N - 2; ++i) {
		if (Tag[i + 1] &gt;= 2) {
			Ans[i + 1] = Tag[i + 1];
			continue;
		}
		if ((Ans[i - 2] + 1) * (Ans[i - 1] + 1) == dv2[i]) Ans[i + 1] = 0;
		else Ans[i + 1] = 1;
	}
	Ans[N] = (dv2[N - 1] - (Ans[N - 3] + 1) * (Ans[N - 2] + 1)) / (Ans[N - 2] + 1);
	printf(&#34;!&#34;);
	for (int i = 1; i &lt;= N; ++i) printf(&#34; %d&#34;, Ans[i]);
	puts(&#34;&#34;), fflush(stdout);
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #635 (Div. 1)
    1336F
    Путешествия </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Путешествия</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>4 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на       тест</div>1024 мегабайта</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Где-то в дебрях, далеко-далеко находится святая земля, которая       имеет форму дерева  — связного неориентированного графа,       состоящего из $$$n$$$ вершин и $$$n-1$$$ ребра. Вершины       пронумерованы целыми числами от $$$1$$$ до $$$n$$$.</p>     <p>Всего есть $$$m$$$ путешественников, привлеченных красотой и       процветанием этой земли. Каждый из них отправился в путешествие по       ней. $$$i$$$-й путешественник проехал вдоль кратчайшего пути из       $$$s_i$$$ в $$$t_i$$$. Во время этого путешествия, он прошел через       все ребра, лежащие на кратчайшем пути из $$$s_i$$$ в $$$t_i$$$,       который, как известно, единственный в дереве.</p>     <p>Во время своих путешествий, некоторые путешественники       познакомились с остальными. Некоторые из путешественников станут       друзьями. Более точно, $$$i$$$-й и $$$j$$$-й путешественники       станут друзьями, тогда и только тогда, когда было <span class="tex-font-style-bf">хотя бы</span> $$$k$$$ ребер, по       которым прошли и $$$i$$$-й и $$$j$$$-й путешественники.</p>     <p>Ваша задача состоит в том, чтобы найти количество пар       путешественников $$$(i, j)$$$, удовлетворяющих следующим условиям:</p>          <ul> <li> $$$1 \leq i &lt; j \leq m$$$. </li>       <li> $$$i$$$-й и $$$j$$$-й путешественники станут друзьями. </li></ul></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке находится три целых числа $$$n$$$, $$$m$$$ и       $$$k$$$ ($$$2 \le n, m \le 1.5 \cdot 10^5$$$, $$$1\le k\le n$$$).</p>     <p>Каждая из следующих $$$n-1$$$ строк содержит два целых числа       $$$u$$$ и $$$v$$$ ($$$1 \le u,v \le n$$$), обозначающих, что       существует ребро между $$$u$$$ и $$$v$$$.</p>     <p>$$$i$$$-я из следующих $$$m$$$ строк содержит два целых числа       $$$s_i$$$ и $$$t_i$$$ ($$$1\le s_i,t_i\le n$$$, $$$s_i \neq       t_i$$$), обозначающие начальную и конечную вершины $$$i$$$-го путешественника.</p>     <p>Гарантируется, что данные ребра образуют дерево.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одно целое число  — количество пар путешественников,       удовлетворяющих описанным условиям.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
8 4 1
1 7
1 2
2 5
4 6
6 3
6 2
6 8
7 8
3 8
2 6
4 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
4</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
10 4 2
3 10
9 3
4 9
4 6
8 2
1 7
2 1
4 5
6 7
7 1
8 7
9 2
10 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
13 8 3
7 6
9 11
5 6
11 3
9 7
2 12
4 3
1 2
5 8
6 13
5 10
3 1
10 4
10 11
8 11
4 9
2 5
3 5
7 3
8 10
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
14</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>       <img class="tex-graphics" src="https://espresso.codeforces.com/238216da68c34b418571920cacddd6194f408878.png" style="max-width: 100.0%;max-height: 100.0%;"/></p>     <p>В первом тесте существует $$$4$$$ пары, удовлетворяющие описанным       условиям: $$$(1,2)$$$, $$$(1,3)$$$, $$$(1,4)$$$, $$$(3,4)$$$.</p>          <ul>                     <li> $$$1$$$-й путешественник и $$$2$$$-й путешественник оба         пройдут по ребру $$$6-8$$$.          </li>       <li> $$$1$$$-й путешественник и $$$3$$$-й путешественник оба         пройдут по ребру $$$2-6$$$.          </li>       <li> $$$1$$$-й путешественник и $$$4$$$-й путешественник оба         пройдут по ребрам $$$1-2$$$ и $$$2-6$$$.          </li>       <li> $$$3$$$-й путешественник и $$$4$$$-й путешественник оба         пройдут по ребру $$$2-6$$$.          </li></ul></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1336/problem/F' title='Codeforces Round 635 (Div. 1)'>1336F - Journey</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>First, let's choose an arbitrary root for the tree. Then for all       pairs of paths, their LCA (lowest common ancestor) can be either       different or the same.</p>     <p>Then, let's calculate the answer of pairs with different LCAs. In       this case, if the intersection is not empty, it will be a vertical       path as in the graph below.</p>     <p>       <img class="tex-graphics" src="https://espresso.codeforces.com/c481cb5d71045bb8df5e50f28f218970c663b576.png" style="max-width: 100.0%;max-height: 100.0%;" /></p>     <p>Here path $$$G-H$$$ and path $$$E-F$$$ intersects at path $$$B-G$$$.</p>     <p>We can process all paths in decreasing order of the depth of       their LCA. When processing a path $$$p$$$ we calculate the number       of paths $$$q$$$, where $$$q$$$ is processed before $$$p$$$, and       the edge-intersection of $$$p$$$ and $$$q$$$ is at least $$$k$$$.       To do this we can plus one to the subtree of the nodes on the path       $$$k$$$ edges away from the LCA (node $$$C$$$ and $$$D$$$ for path       $$$G-H$$$ in the graph above), then we can query the value at the       endpoints of the path (node $$$E$$$ and $$$F$$$ for path       $$$E-F$$$). We can maintain this easily with BIT (binary indexed       tree, or Fenwick tree).</p>     <p>Next, we calculate pairs with the same LCA. This case is harder.</p>     <p>For each node $$$u$$$ we calculate the number of pairs with the       LCA $$$u$$$. </p>     <p>       <img class="tex-graphics" src="https://espresso.codeforces.com/ffea39d208b93e345c7b45c5c06e3d7930d9acec.png" style="max-width: 100.0%;max-height: 100.0%;" /></p>     <p>For a pair of path $$$(x_1,y_1)$$$ and $$$(x_2, y_2)$$$, there       are still two cases we need to handle.</p>     <p>In the first case (the left one in the graph above), where the       intervals $$$[dfn_{x_1},dfn_{y_1}]$$$ ($$$dfn_x$$$ is the index of       $$$x$$$ in the DFS order) and $$$[dfn_{x_2},dfn_{y_2}]$$$ have no       intersection. In this case the intersection of two paths is a       vertical path where $$$(y_1,u)$$$ and $$$(x_2,u)$$$ intersects.       This can be solved similarly to the case of different LCAs.</p>     <p>In the next case (the right one in the graph above), an       intersection of the two intervals exists. The intersection of two       paths may cross over node $$$u$$$.</p>     <p>For all paths $$$(x,y)$$$ (assume that $$$dfn_x$$$ &lt;       $$$dfn_y$$$) with the LCA $$$u$$$. We can build a virtual-tree       over all $$$x$$$ of the paths, and on node $$$x$$$ we store the       value of $$$y$$$. Let's do a dfs on the virtual-tree. On each node       $$$a$$$ we calculate pairs $$$(x_1,y_1)$$$,$$$(x_2,y_2)$$$ that       $$$\operatorname{LCA}(x_1,x_2) = a$$$. For $$$x_1$$$ , let's go       from $$$a$$$ to $$$y_1$$$ for $$$k$$$ edges, assume the node we       reached is $$$b$$$, all legal $$$y_2$$$ should be in the subtree       of $$$b$$$.</p>     <p>We can use a segment tree on the DFS-order to maintain all       $$$y$$$s in the subtree and merge them with the small-to-large       trick, meanwhile, iterate over all $$$x_1$$$ in the smaller       segment tree, count the valid $$$y_2$$$'s in the larger segment tree.</p>     <p>In fact, you can use HLD (heavy-light decomposition) instead of       virtual-tree, which seems to be easier to implement.</p>     <p>The overall complexity of this solution is $$$O(m \log^2 m +       n\log n)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;
#define maxn 200005
int n,m,k,u[maxn],v[maxn],ch[maxn&lt;&lt;6][2]={0},sum[maxn&lt;&lt;6]={0},pt[maxn],head[maxn]={0},tail=0,cnt=0,root[maxn]={0},
anc[maxn][19]={0},son[maxn]={0},depth[maxn]={0},dfn[maxn],size[maxn],idx=0;
long long ans=0;
std::vector&lt;int&gt;in[maxn],vec[maxn];
struct edge {
	int v,next;
}edges[maxn&lt;&lt;1];
void add_edge(int u,int v){
	edges[++tail].v=v;
	edges[tail].next=head[u];
	head[u]=tail;
}
namespace BIT {
	int sum[maxn&lt;&lt;2]={0};
	void add(int p,int x) {if (p==0) return;while (p&lt;=n) {sum[p]+=x;p+=p&amp;-p;}}
	int query(int p) {int ans=0;while (p&gt;0) {ans+=sum[p];p-=p&amp;-p;}return ans;}
	void Add(int l,int r){add(l,1);add(r+1,-1);}
}
void update(int x){sum[x]=sum[ch[x][0]]+sum[ch[x][1]];}
int insert(int rt,int l,int r,int p){
	if (!rt) rt=++cnt;
	if (l==r) {sum[rt]++;return rt;}
	int mid=(l+r)&gt;&gt;1;
	if (p&lt;=mid) ch[rt][0]=insert(ch[rt][0],l,mid,p);
	else ch[rt][1]=insert(ch[rt][1],mid+1,r,p);
	update(rt);
	return rt;
} int merge(int u,int v){
	if (!u||!v)return u+v;
	ch[u][0]=merge(ch[u][0],ch[v][0]);
	ch[u][1]=merge(ch[u][1],ch[v][1]);
	sum[u]=sum[u]+sum[v];return u;
} int query(int rt,int L,int R,int l,int r){
	if (l&gt;R||r&lt;L)return 0;
	if (l&lt;=L&amp;&amp;R&lt;=r){return sum[rt];}
	return query(ch[rt][0],L,(L+R)&gt;&gt;1,l,r)+query(ch[rt][1],((L+R)&gt;&gt;1)+1,R,l,r);
}

void dfs1(int u,int f){
	anc[u][0]=f;depth[u]=depth[f]+1;size[u]=1;
	for (int i=1;i&lt;=18;++i)anc[u][i]=anc[anc[u][i-1]][i-1];
	for (int i=head[u];i;i=edges[i].next){
		int v=edges[i].v;
		if (v==f) continue;
		dfs1(v,u);size[u]+=size[v];
		if (size[v]&gt;size[son[u]])son[u]=v;
	}
} void dfsn(int u){
	dfn[u]=++idx;
	for (int i=head[u];i;i=edges[i].next){
		int v=edges[i].v;
		if (v==son[u]||v==anc[u][0])continue;
		dfsn(v);
	}if (son[u]) dfsn(son[u]);
}

int lift(int u,int x){
	for (int i=18;i&gt;=0;i--)if (x&gt;=(1&lt;&lt;i)) {u=anc[u][i];x-=(1&lt;&lt;i);}
	return u;
}

int lca(int u,int v){
	if (depth[u]&lt;depth[v])std::swap(u,v);
	for (int i=18;i&gt;=0;i--)if (depth[anc[u][i]]&gt;=depth[v])u=anc[u][i];
	if (u==v)return u;
	for (int i=18;i&gt;=0;i--)if (anc[u][i]!=anc[v][i]){u=anc[u][i];v=anc[v][i];}
	return anc[u][0];
} 

void dfs3(int x,int rt){
	pt[x]=x;root[x]=0;
	for (int i=0;i&lt;in[x].size();++i) {
		int d=in[x][i];
		int rd=std::max(0,k-(depth[u[d]]-depth[rt]));
		if (depth[v[d]]-depth[rt]&gt;=rd){
			int l=lift(v[d],depth[v[d]]-depth[rt]-rd);
			ans+=query(root[x],1,n,dfn[l],dfn[l]+size[l]-1);
		}root[x]=insert(root[x],1,n,dfn[v[d]]);
	}for (int i=head[x];i;i=edges[i].next){
		int t=edges[i].v;
		if (t==anc[x][0]||(rt==x&amp;&amp;t==son[x])) continue;
		dfs3(t,rt);
		if (in[pt[x]].size()&lt;in[pt[t]].size()){
			std::swap(pt[x],pt[t]);
			std::swap(root[x],root[t]);
		}while (!in[pt[t]].empty()){
			int d=in[pt[t]][in[pt[t]].size()-1];in[pt[t]].pop_back();
			int rd=std::max(0,k-(depth[x]-depth[rt]));
			if (depth[v[d]]-depth[rt]&gt;=rd) {
				int l=lift(v[d],(depth[v[d]]-depth[rt]-rd));
				ans+=query(root[x],1,n,dfn[l],dfn[l]+size[l]-1);
			}in[pt[x]].push_back(d);
		}root[x]=merge(root[x],root[t]);
	}
}

void dfs2(int x){
	int len=vec[x].size();
	for (int i=head[x];i;i=edges[i].next)if (edges[i].v!=anc[x][0])dfs2(edges[i].v);
	for (int i=0;i&lt;len;++i)ans+=BIT::query(dfn[v[vec[x][i]]]);
	for (int i=0;i&lt;len;++i){
		int j=vec[x][i];
		if (depth[v[j]]-depth[x]&gt;=k) {
			int l=lift(v[j],depth[v[j]]-depth[x]-k);
			BIT::Add(dfn[l],dfn[l]+size[l]-1);
		}
	}for (int i=0;i&lt;len;++i){ans+=BIT::query(dfn[u[vec[x][i]]]);in[u[vec[x][i]]].push_back(vec[x][i]);}
	dfs3(x,x);
	while (!in[pt[x]].empty())in[pt[x]].pop_back();
	for (int i=0;i&lt;len;++i){
		int j=vec[x][i];
		if (depth[u[j]]-depth[x]&gt;=k) {
			int l=lift(u[j],depth[u[j]]-depth[x]-k);
			BIT::Add(dfn[l],dfn[l]+size[l]-1);
		}
	}
}
	
int main(){
	scanf(&#34;%d%d%d&#34;,&amp;n,&amp;m,&amp;k);
	for(int i=1;i&lt;n;++i){
		int u,v;
		scanf(&#34;%d%d&#34;,&amp;u,&amp;v);
		add_edge(u,v);
		add_edge(v,u);
	}dfs1(1,0);dfsn(1);
	for (int i=1;i&lt;=m;++i){
		scanf(&#34;%d%d&#34;,&amp;u[i],&amp;v[i]);
		if (dfn[u[i]]&gt;dfn[v[i]]) std::swap(u[i],v[i]);
		int l=lca(u[i],v[i]);
		vec[l].push_back(i);
	} dfs2(1);
	std::cout&lt;&lt;ans;
	return 0;
}
</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;
#define maxn 200005
int n,m,k,u[maxn],v[maxn],ch[maxn&lt;&lt;6][2]={0},sum[maxn&lt;&lt;6]={0},pt[maxn],head[maxn]={0},tail=0,cnt=0,root[maxn]={0},
anc[maxn][19]={0},son[maxn]={0},depth[maxn]={0},dfn[maxn],size[maxn],idx=0;
long long ans=0;
std::vector&lt;int&gt;in[maxn],vec[maxn];
struct edge {
	int v,next;
}edges[maxn&lt;&lt;1];
void add_edge(int u,int v){
	edges[++tail].v=v;
	edges[tail].next=head[u];
	head[u]=tail;
}
namespace BIT {
	int sum[maxn&lt;&lt;2]={0};
	void add(int p,int x) {if (p==0) return;while (p&lt;=n) {sum[p]+=x;p+=p&amp;-p;}}
	int query(int p) {int ans=0;while (p&gt;0) {ans+=sum[p];p-=p&amp;-p;}return ans;}
	void Add(int l,int r){add(l,1);add(r+1,-1);}
}
void update(int x){sum[x]=sum[ch[x][0]]+sum[ch[x][1]];}
int insert(int rt,int l,int r,int p){
	if (!rt) rt=++cnt;
	if (l==r) {sum[rt]++;return rt;}
	int mid=(l+r)&gt;&gt;1;
	if (p&lt;=mid) ch[rt][0]=insert(ch[rt][0],l,mid,p);
	else ch[rt][1]=insert(ch[rt][1],mid+1,r,p);
	update(rt);
	return rt;
} int merge(int u,int v){
	if (!u||!v)return u+v;
	ch[u][0]=merge(ch[u][0],ch[v][0]);
	ch[u][1]=merge(ch[u][1],ch[v][1]);
	sum[u]=sum[u]+sum[v];return u;
} int query(int rt,int L,int R,int l,int r){
	if (l&gt;R||r&lt;L)return 0;
	if (l&lt;=L&amp;&amp;R&lt;=r){return sum[rt];}
	return query(ch[rt][0],L,(L+R)&gt;&gt;1,l,r)+query(ch[rt][1],((L+R)&gt;&gt;1)+1,R,l,r);
}

void dfs1(int u,int f){
	anc[u][0]=f;depth[u]=depth[f]+1;size[u]=1;
	for (int i=1;i&lt;=18;++i)anc[u][i]=anc[anc[u][i-1]][i-1];
	for (int i=head[u];i;i=edges[i].next){
		int v=edges[i].v;
		if (v==f) continue;
		dfs1(v,u);size[u]+=size[v];
		if (size[v]&gt;size[son[u]])son[u]=v;
	}
} void dfsn(int u){
	dfn[u]=++idx;
	for (int i=head[u];i;i=edges[i].next){
		int v=edges[i].v;
		if (v==son[u]||v==anc[u][0])continue;
		dfsn(v);
	}if (son[u]) dfsn(son[u]);
}

int lift(int u,int x){
	for (int i=18;i&gt;=0;i--)if (x&gt;=(1&lt;&lt;i)) {u=anc[u][i];x-=(1&lt;&lt;i);}
	return u;
}

int lca(int u,int v){
	if (depth[u]&lt;depth[v])std::swap(u,v);
	for (int i=18;i&gt;=0;i--)if (depth[anc[u][i]]&gt;=depth[v])u=anc[u][i];
	if (u==v)return u;
	for (int i=18;i&gt;=0;i--)if (anc[u][i]!=anc[v][i]){u=anc[u][i];v=anc[v][i];}
	return anc[u][0];
} 

void dfs3(int x,int rt){
	pt[x]=x;root[x]=0;
	for (int i=0;i&lt;in[x].size();++i) {
		int d=in[x][i];
		int rd=std::max(0,k-(depth[u[d]]-depth[rt]));
		if (depth[v[d]]-depth[rt]&gt;=rd){
			int l=lift(v[d],depth[v[d]]-depth[rt]-rd);
			ans+=query(root[x],1,n,dfn[l],dfn[l]+size[l]-1);
		}root[x]=insert(root[x],1,n,dfn[v[d]]);
	}for (int i=head[x];i;i=edges[i].next){
		int t=edges[i].v;
		if (t==anc[x][0]||(rt==x&amp;&amp;t==son[x])) continue;
		dfs3(t,rt);
		if (in[pt[x]].size()&lt;in[pt[t]].size()){
			std::swap(pt[x],pt[t]);
			std::swap(root[x],root[t]);
		}while (!in[pt[t]].empty()){
			int d=in[pt[t]][in[pt[t]].size()-1];in[pt[t]].pop_back();
			int rd=std::max(0,k-(depth[x]-depth[rt]));
			if (depth[v[d]]-depth[rt]&gt;=rd) {
				int l=lift(v[d],(depth[v[d]]-depth[rt]-rd));
				ans+=query(root[x],1,n,dfn[l],dfn[l]+size[l]-1);
			}in[pt[x]].push_back(d);
		}root[x]=merge(root[x],root[t]);
	}
}

void dfs2(int x){
	int len=vec[x].size();
	for (int i=head[x];i;i=edges[i].next)if (edges[i].v!=anc[x][0])dfs2(edges[i].v);
	for (int i=0;i&lt;len;++i)ans+=BIT::query(dfn[v[vec[x][i]]]);
	for (int i=0;i&lt;len;++i){
		int j=vec[x][i];
		if (depth[v[j]]-depth[x]&gt;=k) {
			int l=lift(v[j],depth[v[j]]-depth[x]-k);
			BIT::Add(dfn[l],dfn[l]+size[l]-1);
		}
	}for (int i=0;i&lt;len;++i){ans+=BIT::query(dfn[u[vec[x][i]]]);in[u[vec[x][i]]].push_back(vec[x][i]);}
	dfs3(x,x);
	while (!in[pt[x]].empty())in[pt[x]].pop_back();
	for (int i=0;i&lt;len;++i){
		int j=vec[x][i];
		if (depth[u[j]]-depth[x]&gt;=k) {
			int l=lift(u[j],depth[u[j]]-depth[x]-k);
			BIT::Add(dfn[l],dfn[l]+size[l]-1);
		}
	}
}
	
int main(){
	scanf(&#34;%d%d%d&#34;,&amp;n,&amp;m,&amp;k);
	for(int i=1;i&lt;n;++i){
		int u,v;
		scanf(&#34;%d%d&#34;,&amp;u,&amp;v);
		add_edge(u,v);
		add_edge(v,u);
	}dfs1(1,0);dfsn(1);
	for (int i=1;i&lt;=m;++i){
		scanf(&#34;%d%d&#34;,&amp;u[i],&amp;v[i]);
		if (dfn[u[i]]&gt;dfn[v[i]]) std::swap(u[i],v[i]);
		int l=lca(u[i],v[i]);
		vec[l].push_back(i);
	} dfs2(1);
	std::cout&lt;&lt;ans;
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #635 (Div. 2)
    1337A
    Ichihime и треугольник </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Ichihime и треугольник</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Ichihime нынешняя жрица храма души Маджонга. Она утверждает, что       она человек, несмотря на свои кошачьи ушки.</p>     <p>Сейчас в храме проводится соревнование по математике. Обычно       Ichihime не проявляет интереса к подобным вещам, но в этот раз       призом является ее любимое печенье, поэтому она решила принять       участие. Сейчас она решает следующую задачу.</p>          <center>       <img class="tex-graphics" src="https://espresso.codeforces.com/460965cc95e110488641a549ff72e6b554689699.png" style="max-width: 100.0%;max-height: 100.0%;"/></center>      <p>Вам даны четыре положительных целых числа $$$a$$$, $$$b$$$,       $$$c$$$, $$$d$$$, такие что $$$a \leq b \leq c \leq d$$$. </p>     <p>Вам нужно найти три целых числа $$$x$$$, $$$y$$$, $$$z$$$,       удовлетворяющие следующим условиям:</p>          <ul>                     <li> $$$a \leq x \leq b$$$.         </li>       <li> $$$b \leq y \leq c$$$.         </li>       <li> $$$c \leq z \leq d$$$.         </li>       <li> Существует треугольник положительной площади, длины сторон         которого равны $$$x$$$, $$$y$$$ и $$$z$$$.         </li></ul>          <p>Ichihime хочет получить печенье, но эта задачка очень трудная для       нее. Можете ли вы помочь ей?</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке находится единственное целое число $$$t$$$ ($$$1       \leq t \leq 1000$$$)  — количество тестовых случаев.</p>     <p>Следующие $$$t$$$ строк содержат описания тестовых случаев.       Каждая строка описания тестового случая содержит четыре       положительных целых числа $$$a$$$, $$$b$$$, $$$c$$$, $$$d$$$ ($$$1       \leq a \leq b \leq c \leq d \leq 10^9$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого тестового случая выведите три целых числа $$$x$$$,       $$$y$$$, $$$z$$$ — три числа, которые вы нашли, удовлетворяющие       описанным требованиям.</p>     <p>Гарантируется, что ответ всегда существует. Если существует       несколько возможных ответов, выведите любой.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
1 3 5 7
1 5 5 7
100000 200000 300000 400000
1 1 977539810 977539810
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3 4 5
5 5 5
182690 214748 300999
1 977539810 977539810
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Одно из возможных решений для первого тестового случая:</p>     <p>       <img class="tex-graphics" src="https://espresso.codeforces.com/18f634d31f7ba8b732b09cf7534c10b3f2e3afc4.png" style="max-width: 100.0%;max-height: 100.0%;"/></p>          <p>Одно из возможных решений для второго тестового случая:</p>     <p>       <img class="tex-graphics" src="https://espresso.codeforces.com/264e51bb6d26b7a1119d7e9e96133e5ffda65898.png" style="max-width: 100.0%;max-height: 100.0%;"/></p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1337/problem/A' title='Codeforces Round 635 (Div. 2)'>1337A - Ichihime and Triangle</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>There are many possible solutions, one of them is to always       output $$$b$$$, $$$c$$$, $$$c$$$. You can easily prove that       $$$b$$$, $$$c$$$, $$$c$$$ always satisfies the requirements.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int t, a, b, c, d;

int main() {
    for (cin &gt;&gt; t; t; t--) {
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
        cout &lt;&lt; b &lt;&lt; &#34; &#34; &lt;&lt; c &lt;&lt; &#34; &#34; &lt;&lt; c &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int t, a, b, c, d;

int main() {
    for (cin &gt;&gt; t; t; t--) {
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
        cout &lt;&lt; b &lt;&lt; &#34; &#34; &lt;&lt; c &lt;&lt; &#34; &#34; &lt;&lt; c &lt;&lt; endl;
    }
    return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #635 (Div. 2)
    1337B
    Kana и игра Dragon Quest </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Kana и игра Dragon Quest</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Кana была обыкновенной старшекласницей, пока ее не обнаружил       разведчик талантов. Теперь она стала идолом. Но, в отличие от       стереотипа, она обожает играть в игры.</p>     <p>Однажды Kana заинтересовалась новой игрой, которая называется         <span class="tex-font-style-it">Dragon Quest</span>. В этой игре       она должна победить дракона.</p>          <center>       <img class="tex-graphics" src="https://espresso.codeforces.com/c7715ea18024283ae27dcab024db999e77f34037.png" style="max-width: 100.0%;max-height: 100.0%;"/></center>      <p>У дракона есть некоторое количество <span class="tex-font-style-it">очков здоровья</span>, которое       изначально равно $$$x$$$. Когда количество его <span class="tex-font-style-it">очков здоровья</span> становится       равным $$$0$$$ или меньше $$$0$$$, он погибает. Для того, чтобы       победить дракона Kana может использовать два типа заклинаний.</p>          <ul>                     <li> <span class="tex-font-style-tt">Поглощение пустотой</span>          <p>Предположим, что текущее количество <span class="tex-font-style-it">очков здоровья</span> дракона           равно $$$h$$$, после <span class="tex-font-style-it">применения</span> этого заклинания           количество <span class="tex-font-style-it">очков           здоровья</span> станет равным $$$\left\lfloor \frac{h}{2}           \right\rfloor + 10$$$. Здесь за $$$\left\lfloor \frac{h}{2}           \right\rfloor$$$ мы обозначаем число $$$h$$$, разделенное на           два с округлением вниз.</p>         </li>       <li> <span class="tex-font-style-tt">Удар молнии</span>                  <p>Это заклинание уменьшает количество <span class="tex-font-style-it">очков здоровья</span> на $$$10$$$.           Предположим, что текущее количество <span class="tex-font-style-it">очков здоровья</span> дракона           равно $$$h$$$, после <span class="tex-font-style-it">применения</span> этого заклинания,           количество <span class="tex-font-style-it">очков           здоровья</span> уменьшится до $$$h-10$$$.</p>         </li></ul>          <p>По некоторым причинам, Kana может <span class="tex-font-style-it">применить</span> <span class="tex-font-style-bf">не больше чем</span> $$$n$$$ <span class="tex-font-style-tt">Поглощений пустотой</span> и $$$m$$$         <span class="tex-font-style-tt">Ударов молнии</span>. Она может       применять заклинания в любом порядке и <span class="tex-font-style-bf">не обязана</span> применить все эти       заклинания. Kana не очень хороша в математике, поэтому она просит       вас помочь ей определить, сможет ли она победить дракона.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит одно целое число $$$t$$$ ($$$1 \leq t \leq       1000$$$)  — количество тестовых случаев.</p>     <p>Следующие $$$t$$$ строк содержат описания тестовых случаев.       Каждая строка описания тестового случая содержит три целых числа       $$$x$$$, $$$n$$$, $$$m$$$ ($$$1\le x \le 10^5$$$, $$$0\le       n,m\le30$$$)  — изначальное количество <span class="tex-font-style-it">очков здоровья</span> дракона,       максимальное количество <span class="tex-font-style-tt">Поглощений       пустотой</span> и <span class="tex-font-style-tt">Ударов       молнии</span>, которое Kana может <span class="tex-font-style-it">применить</span>, соответственно.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Если возможно победить дракона, выведите «<span class="tex-font-style-tt">YES</span>» (без кавычек). Иначе,       выведите «<span class="tex-font-style-tt">NO</span>» (без кавычек).</p>     <p>Вы можете выводить каждый символ в любом регистре (в верхнем или нижнем).</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
7
100 3 4
189 3 4
64 2 3
63 2 3
30 27 7
10 9 1
69117 21 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
YES
NO
NO
YES
YES
YES
YES
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Одна из возможных последовательностей применения заклинаний в       первом тестовом случае такая:</p>          <ul>                     <li> <span class="tex-font-style-tt">Поглощение пустотой</span>         $$$\left\lfloor \frac{100}{2} \right\rfloor + 10=60$$$.         </li>       <li> <span class="tex-font-style-tt">Удар молнии</span> $$$60-10=50$$$.         </li>       <li> <span class="tex-font-style-tt">Поглощение пустотой</span>         $$$\left\lfloor \frac{50}{2} \right\rfloor + 10=35$$$.         </li>       <li> <span class="tex-font-style-tt">Поглощение пустотой</span>         $$$\left\lfloor \frac{35}{2} \right\rfloor + 10=27$$$.         </li>       <li> <span class="tex-font-style-tt">Удар молнии</span> $$$27-10=17$$$.         </li>       <li> <span class="tex-font-style-tt">Удар молнии</span> $$$17-10=7$$$.         </li>       <li> <span class="tex-font-style-tt">Удар молнии</span> $$$7-10=-3$$$.         </li></ul></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1337/problem/B' title='Codeforces Round 635 (Div. 2)'>1337B - Kana and Dragon Quest game</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>First, it's better not to cast <span class="tex-font-style-tt">Void Absorptions</span> after a <span class="tex-font-style-tt">Lightning Strike</span>.</p>     <p>Otherwise, there will be a <span class="tex-font-style-tt">Void       Absorption</span> right after a <span class="tex-font-style-tt">Lightning Strike</span>. Supposing the       hit point was $$$x$$$ before casting these two spells, if you cast         <span class="tex-font-style-tt">Lightning Strike</span> first,       after these two spells the hit point will be $$$\left\lfloor       \frac{x-10}{2} \right\rfloor +10 = \left\lfloor \frac{x}{2}       \right\rfloor + 5$$$, but if you cast <span class="tex-font-style-tt">Void Absorption</span> first, after       these two spells the hit point will be $$$\left\lfloor \frac{x}{2}       \right\rfloor$$$, which is smaller.</p>     <p>So the solution is to cast <span class="tex-font-style-tt">Void       Absorptions</span> until the dragon's hit point won't decrease       with more casts or you can't cast more <span class="tex-font-style-tt">Void Absorptions</span>, then cast all         <span class="tex-font-style-tt">Lightning Strikes</span> you have.</p>     <p>We can also use DP to solve this problem. Let $$$f_{i,j,k} =       0/1$$$ be possibility of defeating the dragon when the dragon's       hit point is at $$$i$$$, you can cast $$$j$$$ more <span class="tex-font-style-tt">Void Absorptions</span> and $$$k$$$       more <span class="tex-font-style-tt">Lightning Strikes</span>.       This is a slow solution but is enough to get accepted. You may       have to use boolean arrays instead of integer arrays to save memory.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;
int x,n,m,t;
void solve(){
	scanf(&#34;%d%d%d&#34;,&amp;x,&amp;n,&amp;m);
	while (x&gt;0&amp;&amp;n&amp;&amp;x/2+10&lt;x){n--;x=x/2+10;}
	if (x&lt;=m*10)printf(&#34;YES\n&#34;);
	else printf(&#34;NO\n&#34;); 
}
int main(){
	scanf(&#34;%d&#34;,&amp;t);
	while(t--)solve();
	return 0;
}
</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;
int x,n,m,t;
void solve(){
	scanf(&#34;%d%d%d&#34;,&amp;x,&amp;n,&amp;m);
	while (x&gt;0&amp;&amp;n&amp;&amp;x/2+10&lt;x){n--;x=x/2+10;}
	if (x&lt;=m*10)printf(&#34;YES\n&#34;);
	else printf(&#34;NO\n&#34;); 
}
int main(){
	scanf(&#34;%d&#34;,&amp;t);
	while(t--)solve();
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #633 (Div. 1)
    1338A
    Прибавление степеней </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Прибавление степеней</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У вас есть массив $$$a$$$ длины $$$n$$$. Для каждого       положительного числа $$$x$$$ в течение $$$x$$$-й секунды вы       собираетесь выполнить следующую операцию:</p>          <ul> <li> Выберите несколько различных индексов $$$i_{1}, i_{2},         \ldots, i_{k}$$$, которые находятся в диапазоне от $$$1$$$ до         $$$n$$$ включительно, и добавьте $$$2^{x-1}$$$ к каждой         соответствующей позиции в $$$a$$$. Формально $$$a_{i_{j}} :=         a_{i_{j}} + 2^{x-1}$$$ для $$$j = 1, 2, \ldots, k$$$. <span class="tex-font-style-bf">Обратите внимание, что вы можете           также не выбрать ни одного индекса.</span> </li></ul>          <p>Вы должны сделать $$$a$$$ неубывающим как можно быстрее. Найдите       наименьшее число $$$T$$$ такое, что вы можете сделать массив       неубывающим не позднее, чем через $$$T$$$ секунд.</p>     <p>Массив $$$a$$$ называется неубывающим, если и только если       $$$a_{1} \le a_{2} \le \ldots \le a_{n}$$$.</p>     <p>Вы должны ответить на $$$t$$$ независимых тестовых случаев.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит одно целое число $$$t$$$ ($$$1 \le t \le       10^{4}$$$)  — количество тестовых случаев.</p>     <p>Первая строка каждого тестового случая содержит одно целое число       $$$n$$$ ($$$1 \le n \le 10^{5}$$$)  — длину массива $$$a$$$.       Гарантируется, что сумма значений $$$n$$$ по всем тестовым случаям       не превышает $$$10^{5}$$$.</p>     <p>Вторая строка каждого теста содержит $$$n$$$ целых чисел       $$$a_{1}, a_{2}, \ldots, a_{n}$$$ ($$$-10^{9} \le a_{i} \le 10^{9}$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого тестового примера выведите минимальное количество       секунд, за которое вы можете сделать $$$a$$$ неубывающим.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
4
1 7 6 5
5
1 2 3 4 5
2
0 -4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
0
3
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом тестовом случае, если вы выберете индексы $$$3, 4$$$ на       $$$1$$$-й секунде и $$$4$$$ на $$$2$$$-й секунде, то $$$a$$$       станет равным $$$[1, 7, 7, 8]$$$. Есть и другие способы сделать       $$$a$$$ неубывающим за $$$2$$$ секунды, но вы не сделать его       неубывающим быстрее.</p>     <p>Во втором тестовом случае $$$a$$$ уже неубывающий, поэтому ответ       равен $$$0$$$.</p>     <p>В третьем тестовом случае, если вы ничего не сделаете в первые       $$$2$$$ секунды и в течение $$$3$$$-й секунды выберете индекс       $$$2$$$, $$$a$$$ станет равным $$$[0, 0]$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1338/problem/A' title='Codeforces Round 633 (Div. 1)'>1338A - Powered Addition</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>First, let's define $$$b$$$ as ideal destination of $$$a$$$, when       we used operations.</p>     <p>       <span class="tex-font-style-bf">Observation 1</span>. Whatever you       select any $$$b$$$, there is only one way to make it, because       there is no more than single way to make specific amount of       addition. That means we just have to select optimal destination of $$$a$$$.</p>     <p>For example, if you want to make $$$a_{1}$$$ from 10 to 21, then       you must do $$$10 \to 11 \to 13 \to 21$$$. There is no other way       to make $$$10$$$ to $$$21$$$ using given operations.</p>     <p>So now we have to minimize $$$max(b_{1} - a_{1}, b_{2} - a_{2},       \ldots, b_{n} - a_{n})$$$, as smaller differences leads to use       shorter time to make $$$a$$$ nondecreasing.</p>     <p>       <span class="tex-font-style-bf">Observation 2</span>. $$$b$$$ is       optimal when $$$b_{i}$$$ is the maximum value among $$$b_{1},       b_{2}, \ldots, b_{i-1}$$$ and $$$a_{i}$$$.</p>     <p>Because for each position $$$i$$$, we have to make $$$b_{i} -       a_{i}$$$ as smallest possible. Since $$$b_{i}$$$ should be not       smaller than previous $$$b$$$ values and also $$$a_{i}$$$, we       derived such formula.</p>     <p>So from position $$$1, 2, \ldots, n$$$, greedily find a       $$$b_{i}$$$, and check how many seconds needed to convert       $$$a_{i}$$$ to $$$b_{i}$$$. The answer is maximum needed seconds       among all positions.</p>     <p>Time complexity is $$$O(n)$$$, but you can do $$$O(n \log n)$$$       with &quot;<span class="tex-font-style-tt">std::set</span>&quot;       or whatever.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #633 (Div. 1)
    1338B
    Назначение весов ребрам </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Назначение весов ребрам</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У вас есть невзвешенное дерево на $$$n$$$ вершинах. Вы должны       назначить <span class="tex-font-style-bf">положительный</span> вес       каждому ребру, чтобы выполнялось следующее условие:</p>          <ul> <li> Для каждых двух разных листов $$$v_{1}$$$ и $$$v_{2}$$$         этого дерева, <a href="https://ru.wikipedia.org/wiki/Битовая_операция#Исключающее_ИЛИ">побитовое           исключающее ИЛИ</a> весов всех ребер на простом пути между         $$$v_{1}$$$ и $$$v_{2}$$$ должно быть равно $$$0$$$. </li></ul>          <p>Обратите внимание, что вы можете назначать <span class="tex-font-style-bf">очень большие</span> натуральные числа       (такие как $$$10^{(10^{10})}$$$).</p>     <p>Гарантируется, что такое назначение всегда существует при данных       ограничениях. Теперь определим $$$f$$$ как <span class="tex-font-style-bf">количество различных весов</span>       среди назначенных весов.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/822324016e7a6837336849481ecbe0190b03dfa3.png" style="max-width: 100.0%;max-height: 100.0%;"/>       В этом примере назначение верно, потому что побитовое исключающее       ИЛИ всех весов ребер между каждой парой листьев равно $$$0$$$.       Значение $$$f$$$ здесь равно $$$2$$$, потому что есть $$$2$$$       различных веса ребер ($$$4$$$ и $$$5$$$).       <p>         <img class="tex-graphics" src="https://espresso.codeforces.com/82d52d5070be134d11729e65fab0a8709aae6b3f.png" style="max-width: 100.0%;max-height: 100.0%;"/>         В этом примере назначение не удовлетворяет условию, поскольку         побитовое исключающее ИЛИ всех весов ребер между вершинами         $$$1$$$ и $$$6$$$ ($$$3, 4, 5, 4$$$) не равно $$$0$$$. </p></center>          <p>Чему равны минимальное и максимальное возможные значения $$$f$$$       для данного дерева? Найдите и выведите оба.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит целое число $$$n$$$ ($$$3 \le n \le       10^{5}$$$)  — количество вершин в данном дереве.</p>     <p>$$$i$$$-я из следующих $$$n-1$$$ строк содержит два целых числа       $$$a_{i}$$$ и $$$b_{i}$$$ ($$$1 \le a_{i} \lt b_{i} \le n$$$)  —       это означает, что существует ребро между $$$a_{i}$$$ и       $$$b_{i}$$$. Гарантируется, что данный граф образует дерево из       $$$n$$$ вершин.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите два целых числа  — минимальное и максимальное возможное       значения $$$f$$$, которые могут быть получены из правильного       назначения данного дерева. Обратите внимание, что такое назначение       всегда существует при данных ограничениях.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
1 3
2 3
3 4
4 5
5 6
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1 4
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
1 3
2 3
3 4
4 5
4 6
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3 3
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
7
1 2
2 7
3 4
4 7
5 6
6 7
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1 6
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере возможные назначения для минимума и максимума       показаны на рисунке ниже. Конечно, есть и другие назначения. </p>     <center> <img class="tex-graphics" src="https://espresso.codeforces.com/e7bf97f0144ccdc05c3ef43ccaa89a3d0c9ce1dc.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>Во втором примере возможные назначения для минимума и максимума       показаны на рисунке ниже. Значение $$$f$$$ для правильного       назначения этого дерева всегда равно $$$3$$$. </p>     <center> <img class="tex-graphics" src="https://espresso.codeforces.com/f98bbf02e8b21aed9fd5a82be44c2dcd71808c3c.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>В третьем примере возможные назначения для минимума и максимума       показаны на рисунке ниже. Конечно, есть и другие назначения. </p>     <center> <img class="tex-graphics" src="https://espresso.codeforces.com/0a99edbccedea10ea506d2c7bd3d027a4bdf17ce.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1338/problem/B' title='Codeforces Round 633 (Div. 1)'>1338B - Edge Weight Assignment</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's make an easy and good construction which can solve actual       problem. Now reroot this tree at any leaf like picture below;</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/628a7910673a58df94156e47a2e234c949c64297.png" style="max-width: 100.0%;max-height: 100.0%;" /> </center>          <p>Our goal in this construction is, we are trying to make       $$$xor(path(l_{1}, lca(l_{1}, l_{2}))) = xor(path(l_{2},       lca(l_{1}, l_{2}))) = xor(path(root, lca(l_{1}, l_{2})))$$$ for       all two leaves $$$l_{1}$$$ and $$$l_{2}$$$ to satisfy       $$$xor(path(l_{1}, l_{2})) = 0$$$.</p>     <p>First, let's solve about minimum $$$f$$$ value. </p>     <p>       <span class="tex-font-style-bf">Observation 1</span>. You can       prove that minimum value of $$$f$$$ is at most $$$3$$$, by       following construction;</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/c033147934116eb679ddae1edfb14c83099b0823.png" style="max-width: 100.0%;max-height: 100.0%;" />       Since we pick any leaf as root, root is not at the top in this       picture. </center>          <p>Weight of edges are only determined by degree of two vertices and       whether that edge is connected to leaf or not. So answer for       minimum value is at most $$$3$$$.</p>     <p>       <span class="tex-font-style-bf">Observation 2</span>. If there is       any construction such that $$$f = 2$$$, then it is always possible       to have construction of $$$f = 1$$$. Because if $$$f = 2$$$ then       there should be even number of edges for each weight, and you can       simply change all weights them to single value without violating       validity of edge weight assignment.</p>     <p>If you want to check validity of $$$f = 1$$$ assignment, then you       can simply check if all leaves have same parity of distance from       root. Because distances between all nodes should be even.</p>     <p>Now let's solve about maximum value. </p>     <p>       <span class="tex-font-style-bf">Observation 3</span>. You can       solve maximum value of $$$f$$$ by following construction;</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/90c9d90bbf253b2f62cf5c85b3142de59f8f5cde.png" style="max-width: 100.0%;max-height: 100.0%;" /> </center>          <p>So for each non-root vertex $$$i$$$, assign weight to edge       between $$$i$$$ and $$$p_{i}$$$ by followings ($$$p_{i}$$$ is       parent of vertex $$$i$$$); </p>     <ul> <li> If $$$i$$$ is not leaf, then assign $$$2^{i}$$$ as weight. </li>       <li> Otherwise, assign $$$xor(path(root, p_{i}))$$$ as weight. </li></ul>          <p>This will differentize all edges' weights except for multiple       leaves's edges which are connected to single vertex, because every       non-leaf vertex have different weights of edge to its parent.</p>     <p>So the answer for maximum value is $$$e - l + m$$$, where </p>     <ul> <li> $$$e$$$ is number of edges in this tree. </li>       <li> $$$l$$$ is number of leaves in this tree. </li>       <li> $$$m$$$ is number of non-leaves which has at least one leaf         as its neighbor. </li></ul>          <p>Time complexity is $$$O(n)$$$.</p>     <p>——————</p>     <p>(Update) There is an another way to approach, provided by       Darooha. </p>     <p>If you label vertices instead of edges where all leaves have same       label and none of neighbors have same label, then you can consider       edge weight as xor of two vertices' labels, so this is basically       equivalent to original problem.</p>     <p>Now for minimum, you can see that labelling $$$0$$$ to leaves,       and $$$1, 2$$$ to non-leaves are enough, so you can prove minimum       value of $$$f$$$ is at most $$$3$$$. In same manner, you can try       parity checking to check if $$$f$$$ value can be $$$1$$$ or not.</p>     <p>For maximum, assign $$$0$$$ to all leaves and assign all       different values($$$2^{1}, 2^{2}, \ldots$$$) to non-leaf vertices,       then you can see all edge weights(except leaves connected to same       vertex) are different.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #633 (Div. 1)
    1338C
    Прекрасные тройки </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Прекрасные тройки</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Рассмотрим бесконечную последовательность $$$s$$$ натуральных       чисел, построенную повторением следующих шагов:</p>          <ol> <li> Найдите лексикографически наименьшую тройку натуральных         чисел $$$(a, b, c)$$$ такую, ​​что <ul> <li> $$$a \oplus b             \oplus c = 0$$$, где $$$\oplus$$$ обозначает <a href="https://ru.wikipedia.org/wiki/Битовая_операция#Исключающее_ИЛИ">побитовое               исключающее ИЛИ</a>. </li>           <li> $$$a$$$, $$$b$$$, $$$c$$$ не находятся в $$$s$$$.         </li></ul> Здесь тройка целых чисел $$$(a_1, b_1, c_1)$$$         считается лексикографически меньше тройки $$$(a_2, b_2, c_2)$$$,         если последовательность $$$[a_1, b_1, c_1]$$$ лексикографически         меньше последовательности $$$[a_2, b_2, c_2]$$$ </li>       <li> Добавьте $$$a$$$, $$$b$$$, $$$c$$$ в конец $$$s$$$ в этом         порядке. </li>       <li> Вернитесь к первому шагу. </li></ol>          <p>У вас есть целое число $$$n$$$. Найдите $$$n$$$-й элемент $$$s$$$.</p>     <p>Вы должны ответить на $$$t$$$ независимых тестовых случаев.</p>     <p>Последовательность $$$a$$$ лексикографически меньше       последовательности $$$b$$$, если в первой позиции, где $$$a$$$ и       $$$b$$$ различны, в последовательности $$$a$$$ элемент меньше, чем       соответствующий элемент в $$$b$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит одно целое число $$$t$$$ ($$$1 \le t \le       10^5$$$)  — количество тестовых случаев.</p>     <p>Каждая из следующих $$$t$$$ строк содержит одно целое число       $$$n$$$ ($$$1\le n \le 10^{16}$$$)  — позицию элемента, который вы       хотите узнать.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>В каждой из строк $$$t$$$ выведите ответ на соответствующий       тестовый случай.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
9
1
2
3
4
5
6
7
8
9
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
2
3
4
8
12
5
10
15
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Первые несколько элементов $$$s$$$ это $$$1, 2, 3, 4, 8, 12, 5,       10, 15, \dots $$$</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1338/problem/C' title='Codeforces Round 633 (Div. 1)'>1338C - Perfect Triples</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's try mathematical induction.</p>     <p>First, suppose you have fully used numbers only between $$$1$$$       and $$$4^{n} - 1$$$ inclusive. Now we are going to use all numbers       between $$$4^{n}$$$ and $$$4^{n+1} - 1$$$ inclusive by following       methods. Following picture is description of $$$a$$$, $$$b$$$ and       $$$c$$$ in bitwise manner;</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/5f0a24543aeade78709e77fee5a18b0e88206748.png" style="max-width: 100.0%;max-height: 100.0%;" />       First row means we have already used all numbers until $$$4^{n} -       1$$$. Other $$$3$$$ rows mean $$$a$$$, $$$b$$$ and $$$c$$$. </center>          <p>Keep in mind that $$$a$$$, $$$b$$$, and $$$c$$$ are the       lexicographically smallest triple, so $$$a \oplus b = c$$$ and       $$$a &lt; b &lt; c$$$ should be satisfied at the same time.</p>     <p>       <span class="tex-font-style-bf">Observation 1</span>. $$$a_{2n} =       1$$$, $$$a_{2n+1} = 0$$$, $$$b_{2n} = 0$$$, $$$b_{2n+1} = 1$$$,       $$$c_{2n} = c_{2n+1} = 1$$$. Otherwise, $$$a &lt; b &lt; c$$$       condition won't be satisfied, because top two digits of $$$a$$$,       $$$b$$$, $$$c$$$ are either $$$01$$$, $$$10$$$, and $$$11$$$.</p>     <p>Then we have more freedom in lower digits, because since the       highest $$$2$$$ digits are all different, then we can fill lower       digits of three numbers independently. Now look at picture below;</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/0c185d1a6606a7421cc262cc66f2ecdc6d0ada9f.png" style="max-width: 100.0%;max-height: 100.0%;" />       This table shows you how to fill each $$$2$$$ digits of $$$a$$$,       $$$b$$$ and $$$c$$$. </center>          <p>       <span class="tex-font-style-bf">Observation 2</span>. For each       $$$2$$$ digits, $$$a$$$, $$$b$$$ and $$$c$$$ should have form like       this. Of course, you can use mathematical induction again here;       Try to prove this in only $$$2$$$ digits at the first, then expand       this lemma to $$$4$$$ digits, $$$6$$$ digits, ..., $$$2n$$$ digits.</p>     <p>Now you know the pattern of digits of $$$a$$$, $$$b$$$, and       $$$c$$$. Apply this pattern for each test case. Time complexity is       $$$O(\log n)$$$.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #633 (Div. 1)
    1338D
    Вложенные резинки </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Вложенные резинки</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У вас есть дерево из $$$n$$$ вершин. Вы собираетесь преобразовать       это дерево в $$$n$$$ резинок на бесконечной плоскости. Должно       выполняться следующее;</p>          <ul> <li> Для каждой пары вершин $$$a$$$ и $$$b$$$, резинки $$$a$$$         и $$$b$$$ должны пересекаться тогда и только тогда, когда между         $$$a$$$ и $$$b$$$ в дереве существует ребро. </li>       <li> Форма резинки должна быть простой петлей. Другими словами,         резинка  — это замкнутая кривая без самопересечений. </li></ul>          <p>Теперь давайте дадим следующие определения: </p>     <ul> <li> Резинка $$$a$$$ <span class="tex-font-style-bf">включает</span> резинку $$$b$$$, если         и только если резинка $$$b$$$ находится полностью внутри резинки         $$$a$$$, и они не пересекаются. </li>       <li> Последовательность резинок $$$a_{1}, a_{2}, \ldots, a_{k}$$$         ($$$k \ge 2$$$) называется <span class="tex-font-style-bf">вложенной</span>, если и только если         для всех $$$i$$$ ($$$2 \le i \le k$$$), $$$a_{i-1}$$$ включает в         себя $$$a_{i}$$$. </li></ul>               <center> <img class="tex-graphics" src="https://espresso.codeforces.com/344702cbc9dc910c7e10b4dad5c287cabc28d27e.png" style="max-width: 100.0%;max-height: 100.0%;"/>       Это пример преобразования. Обратите внимание, что резинки $$$5$$$       и $$$6$$$ являются вложенными. </center>          <p>Можно доказать, что при заданных ограничениях существует       преобразование и последовательность вложенных резинок.</p>     <p>Какую максимальную длину последовательности вложенных резинок       можно получить из данного дерева? Найдите и выведите ее.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит целое число $$$n$$$ ($$$3 \le n \le       10^{5}$$$)  — количество вершин в данном дереве.</p>     <p>$$$i$$$-я из следующих $$$n-1$$$ строк содержит два целых числа       $$$a_{i}$$$ и $$$b_{i}$$$ ($$$1 \le a_{i} \lt b_{i} \le n$$$)  —       это означает, что существует ребро между $$$a_{i}$$$ и       $$$b_{i}$$$. Гарантируется, что данный граф образует дерево из       $$$n$$$ вершин.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите ответ.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
1 3
2 3
3 4
4 5
4 6
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
4
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
1 2
2 3
3 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере можно получить вложенную последовательность из       $$$4$$$ резинок ($$$1$$$, $$$2$$$, $$$5$$$ и $$$6$$$) с помощью       следующего преобразования, приведенного ниже. Конечно, существуют       и другие преобразования для создания вложенной последовательности       длины $$$4$$$. Однако вы не можете сделать последовательность из       $$$5$$$ или более вложенных резинок для данного дерева.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/29a3ee35372e45c994d87155adf2795c5b4600f0.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>Одно из возможных преобразований для второго примера приведено ниже.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/e8f3a00073f8ac4ef88a3a152423d97d7d9565d7.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1338/problem/D' title='Codeforces Round 633 (Div. 1)'>1338D - Nested Rubber Bands</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>       <span class="tex-font-style-bf">Observation 1</span>. You have to       generate optimal sequence which is subsequence of path between       some two vertices. Neighbors of vertices in optimal sequence will       be used as nested rubber bands.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/bf9b765c99b4bd284593421ba5099b40108969de.png" style="max-width: 100.0%;max-height: 100.0%;" />       This is an example of conversion. Red vertices are picked       sequence, and blue vertices are neighbor of red vertices which are       used as nested rubber bands. </center>          <p>The reason why black vertices can't be used as nested rubber       bands is, basically you have to make a tunnel between any two blue       lines, but it's impossible, because in each tunnel there is at       least one red vertex which blocks complete connection on tunnel.</p>     <p>Also, this can be described as finding maximum independent set on       subtree, which consists of vertices which has at most $$$1$$$       distance from the optimal path connection of red vertices. Now       your goal is to maximize number of blue vertices.</p>     <p>       <span class="tex-font-style-bf">Observation 2</span>. The       distances between two adjacent red vertices are at most $$$2$$$.       Adjacent in this sentence means adjacent elements in generated       optimal sequence. Because if there is some unused</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/b131a7fcbd2beac850977e85ee384b3f0dda29ac.png" style="max-width: 100.0%;max-height: 100.0%;" />       It is always optimal to take more red vertices than abandoning       black vertices. </center>          <p>Note that if there are two black vertices between two red       vertices, then we cannot use both of them as blue vertices.</p>     <p>From those two observations, construct tree DP and run for it.       Time complexity is $$$O(n)$$$.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #633 (Div. 1)
    1338E
    JYPнация </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. JYPнация</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на       тест</div>1024 мегабайта</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>       <span class="tex-font-style-it">Благодаря успеху TWICE, JYP         Entertainment заработала бесчисленные деньги и стала крупнейшей         развлекательной компанией по рыночной капитализации. Поэтому         начальник JYP решил создать новую нацию и назначил вас         предоставить схему проектирования.</span></p>     <p>Новая нация состоит из $$$n$$$ городов и нескольких дорог между       ними. JYP дал некоторые ограничения:</p>          <ul>   <li> Чтобы гарантировать эффективность, избегая хаоса, <span class="tex-font-style-bf">для любых $$$2$$$ разных городов           $$$A$$$ и $$$B$$$, между ними существует ровно одна дорога, и           она является однонаправленной. Нет дорог, соединяющих город с           самим собой</span>.         <p>  </p></li>       <li> Логотип конкурирующих компаний не должен появляться в плане,         а именно: <span class="tex-font-style-bf">там не         существует</span> $$$4$$$ <span class="tex-font-style-bf">различных городов</span> $$$A$$$,         $$$B$$$, $$$C$$$, $$$D$$$ <span class="tex-font-style-bf">таких,           что выполняется следующая конфигурация.</span> </li></ul>               <center> <img class="tex-graphics" src="https://espresso.codeforces.com/71de29128b9f668c25d8435d4348a186584b2b34.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>JYP дал критерии для вашей диаграммы. Для двух городов $$$A$$$,       $$$B$$$, через $$$dis(A,B)$$$ обозначим наименьшее число дорог,       которое вам нужно пройти, чтобы пройти от $$$A$$$ до $$$B$$$. Если       невозможно пройти от $$$A$$$ к $$$B$$$, $$$dis(A,B) = 614n$$$.       Затем значение эффективности определяется как сумма $$$dis(A,B)$$$       по всем упорядоченным парам различных городов $$$(A,B)$$$.</p>     <p>       <span class="tex-font-style-bf">Обратите внимание, что         $$$dis(A,B)$$$ не обязательно должно быть равно $$$dis(B,A)$$$</span>.</p>     <p>Вы нарисовали схему проекта, которая удовлетворяет ограничениям       JYP. Найдите сумму $$$dis(A,B)$$$ по всем упорядоченным парам       городов $$$(A,B)$$$ с $$$A\neq B$$$.</p>     <p>       <span class="tex-font-style-bf">Обратите внимание, что ввод дается         в сжатом виде. Но даже хотя он сжат, лучше используйте быстрое считывание.</span></p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит одно целое число $$$n$$$ ($$$4 \le n \le       8000$$$, $$$n \equiv 0 \pmod{4}$$$)  — количество городов.</p>     <p>Далее следует описание матрицы. В каждой из $$$n$$$ следующих       строк следуют по $$$\frac{n}{4}$$$ однозначных чисел       шестнадцатеричной системы счисления (то есть, эти числа могут       задаваться либо как цифры от $$$0$$$ до $$$9$$$, либо как       прописные латинские буквы от $$$A$$$ до $$$F$$$). Двоичная запись       каждого из этих чисел задаёт очередные $$$4$$$ элемента матрицы в       текущей строке. Например, если число равно $$$B$$$, то очередные       четыре элемента матрицы равны $$$1011$$$, а если число равно       $$$5$$$, то очередные четыре элемента матрицы равны $$$0101$$$.</p>     <p>После того, как вы получите расшифрованную двоичную матрицу,       $$$j$$$-й символ $$$i$$$-й строки будет равен $$$1$$$, если       односторонняя дорога между городами $$$i$$$ и $$$j$$$ направлена       от $$$i$$$ к $$$j$$$, и $$$0$$$ в противном случае. Гарантируется,       что граф удовлетворяет ограничениям, указанным выше.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одно целое число, равное сумме $$$dis(A,B)$$$ по всем       упорядоченным парам городов $$$(A,B)$$$ с $$$A\neq B$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
7
2
1
4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
7380
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
8
7F
3F
1F
0C
06
03
11
18
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
88464
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Первый пример соответствует матрице:</p>     <p>$$$\begin{matrix} 0111 \\ 0010 \\ 0001 \\ 0100 \\ \end{matrix}$$$</p>     <p>Которая соответствует следующему графу:</p>     <p>       <img class="tex-graphics" src="https://espresso.codeforces.com/464ea5f1e69cf670271c368e51106b6e813ae987.png" style="max-width: 100.0%;max-height: 100.0%;"/></p>     <p>$$$dis(1,2)=dis(1,3)=dis(1,4)=dis(2,3)=dis(3,4)=dis(4,2)=1$$$</p>     <p>$$$dis(2,4)=dis(4,3)=dis(3,2)=2$$$</p>     <p>$$$dis(2,1)=dis(3,1)=dis(4,1)=2456$$$</p>     <p>Поэтому ответ на диаграмму составляет $$$7380$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1338/problem/E' title='Codeforces Round 633 (Div. 1)'>1338E - JYPnation</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>The solution contains several tricky observations, but its not       hard to prove each of them seperately, so I will mention only the       key points of the solution and proof.</p>     <p>Firstly, we should repeatedly remove points that have no       in-degree. We can calculate their contribution easily.</p>     <p>For a node $$$x$$$, define $$$in(x)$$$ to be the set of nodes       $$$u$$$ that $$$u \rightarrow x$$$ exists. </p>     <p>       <span class="tex-font-style-bf">Lemma 1:</span> $$$in(x) \cup       {x}$$$ has no cycles for any node $$$x$$$.</p>     <p>Let's pick $$$X$$$ to be the node with maximum in-degree.</p>     <p>Let $$$P$$$ = $$$in(X) \cup {X}$$$, and let $$$Q$$$ = $$$Z       \setminus P$$$, where $$$Z$$$ is the set of all vertices.</p>     <p>       <span class="tex-font-style-bf">Lemma 2:</span> There exist nodes       $$$U \in Q$$$,$$$V \in P$$$, such that $$$U \rightarrow V$$$ exists.</p>     <p>Let $$$R$$$ = $$$in(V) \cap Q$$$, and let $$$S$$$ = $$$Q       \setminus R$$$</p>     <p>       <span class="tex-font-style-bf">Lemma 3:</span> For all nodes $$$A       \in S$$$,$$$B \in R$$$, $$$A \rightarrow B$$$ exists.</p>     <p>       <span class="tex-font-style-bf">Lemma 4:</span> $$$S$$$ has no       cycles, $$$R$$$ has no cycles.</p>     <p>       <span class="tex-font-style-bf">Lemma 5:</span> $$$P$$$ has no       cycles, $$$Q$$$ has no cycles. </p>     <p>That means we have partitioned the graph into two sets of nodes,       where each set is completely ordered.</p>     <p>Lets label the nodes in $$$P$$$ by $$$P_i$$$ where $$$i$$$ is an       integer from $$$1$$$ to $$$|P|$$$, such that for two nodes       $$$P_i$$$ and $$$P_j$$$, $$$P_j \rightarrow P_i$$$ exists iff $$$j&gt;i$$$.</p>     <p>Label nodes in $$$Q$$$ by $$$Q_i$$$ in similar manner. </p>     <p>Define $$$inP(x)$$$ to be the set of nodes $$$u \in P$$$ that       $$$u \rightarrow x$$$ exists. </p>     <p>Define $$$inQ(x)$$$ to be the set of nodes $$$u \in Q$$$ that       $$$u \rightarrow x$$$ exists. </p>     <p>       <span class="tex-font-style-bf">Lemma 6a:</span> If $$$|inQ(P_i)|       = |inQ(P_j)|$$$ then $$$inQ(P_i) = inQ(P_j)$$$. </p>     <p>       <span class="tex-font-style-bf">Lemma 6b:</span> If $$$|inP(Q_i)|       = |inP(Q_j)|$$$ then $$$inP(Q_i) = inP(Q_j)$$$. </p>     <p>       <span class="tex-font-style-bf">Final observations:</span></p>          <ul>                     <li> $$$dis(P_i,P_j)=1$$$ iff $$$i&gt;j$$$         </li>       <li> $$$dis(P_i,P_j)=2$$$ iff $$$i&lt;j$$$ and $$$|inQ(P_i)| \neq |inQ(P_j)|$$$         </li>       <li> $$$dis(P_i,P_j)=3$$$ iff $$$i&lt;j$$$ and $$$|inQ(P_i)| = |inQ(P_j)|$$$         </li>       <li> $$$dis(Q_i,Q_j)=1$$$ iff $$$i&gt;j$$$         </li>       <li> $$$dis(Q_i,Q_j)=2$$$ iff $$$i&lt;j$$$ and $$$|inP(Q_i)| \neq |inP(Q_j)|$$$         </li>       <li> $$$dis(Q_i,Q_j)=3$$$ iff $$$i&lt;j$$$ and $$$|inP(Q_i)| = |inP(Q_j)|$$$         </li>       <li> $$$dis(P_i,Q_j)+dis(Q_j,P_i)=3$$$         </li></ul>          <p>Finally, we can count the answer in $$$O(N^2)$$$ by the above observations.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #633 (Div. 2)
    1339A
    Заполнение ромбами </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Заполнение ромбами</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У вас есть целое число $$$n$$$. Сколькими способами можно       полностью покрыть поясоподобную область, состоящую из $$$4n-2$$$       треугольников, ромбами?</p>     <p>Ромб состоит из двух треугольников. Вы можете перемещать, вращать       или переворачивать ромб, но вы не можете масштабировать его.</p>     <p>$$$2$$$ покрытия называются различными, если некоторые $$$2$$$       треугольника покрыты одним и тем же ромбом в одном из них, и       различными в другом.</p>     <p>Пожалуйста, посмотрите на иллюстрации ниже для лучшего понимания.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/fe1ad8b85bef7134b3bba5bc2c576643aef558dc.png" style="max-width: 100.0%;max-height: 100.0%;"/>       Слева изображен ромб, которым вы будете заполнять область, а       справа  — область, которую вы хотите заполнить.       <p>         <img class="tex-graphics" src="https://espresso.codeforces.com/253cb03aef62ea2260f28f431e7e51c962b79f23.png" style="max-width: 100.0%;max-height: 100.0%;"/>         Выше приведены области, для $$$n = 1, 2, 3, 4$$$. </p></center>          <p>Вы должны ответить на $$$t$$$ независимых тестовых случаев.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит одно целое число $$$t$$$ ($$$1 \le t \le       10^{4}$$$)  — количество тестовых случаев.</p>     <p>Каждая из следующих $$$t$$$ строк содержит одно целое число       $$$n$$$ ($$$1 \le n \le 10^{9}$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого теста выведите количество способов полностью покрыть       поясоподобную область, состоящую из $$$4n-2$$$ треугольников,       ромбами. Можно показать, что при данных ограничениях это       количество не превышает $$$10^{18}$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
2
1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
1
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом тестовом примере, есть следующие $$$2$$$ способа       заполнить область:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/e72f8c635d8dc8aff12edac5df922a9410645cbb.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>Во втором тестовом примере, существует единственный способ       заполнить область:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/076644b16c11b7a034b789a88ccaf85e52dd0102.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1339/problem/A' title='Codeforces Round 633 (Div. 2)'>1339A - Filling Diamonds</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>The key observation of this problem is, wherever you put vertical       diamond at some point, all other places are uniquely placed by       horizontal diamonds like picture below.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/d05132e8bf3b64a20000115b46600a3302c69a9c.png" style="max-width: 100.0%;max-height: 100.0%;" /> </center>          <p>There are $$$n$$$ places you can put vertical diamond, so answer       is $$$n$$$ for each test case.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #633 (Div. 2)
    1339B
    Отсортированные разности соседних </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Отсортированные разности соседних</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У вас есть массив из $$$n$$$ чисел $$$a_{1}, a_{2}, \ldots, a_{n}$$$.</p>     <p>Переставьте эти числа так, чтобы они удовлетворяли $$$|a_{1} -       a_{2}| \le |a_{2} - a_{3}| \le \ldots \le |a_{n-1} - a_{n}|$$$,       где $$$|x|$$$ обозначает абсолютное значение $$$x$$$.       Гарантируется, что для данных ограничений всегда можно найти такую перестановку.</p>     <p>Обратите внимание, что элементы в $$$a$$$ не обязательно попарно       различны. Другими словами, некоторые элементы $$$a$$$ могут быть одинаковыми.</p>     <p>Вы должны ответить на $$$t$$$ независимых тестовых случаев.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит одно целое число $$$t$$$ ($$$1 \le t \le       10^{4}$$$)  — количество тестовых случаев.</p>     <p>Первая строка каждого тестового случая содержит одно целое число       $$$n$$$ ($$$3 \le n \le 10^{5}$$$)  — длину массива $$$a$$$.       Гарантируется, что сумма значений $$$n$$$ по всем тестовых случаях       не превышает $$$10^{5}$$$.</p>     <p>Вторая строка каждого тестового случая содержит $$$n$$$ целых       чисел $$$a_{1}, a_{2}, \ldots, a_{n}$$$ ($$$-10^{9} \le a_{i} \le 10^{9}$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого тестового случая выведите перестановку массива       $$$a$$$, которая удовлетворяет данному условию. Если существует       несколько допустимых перестановок, выведите любую из них.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
6
5 -2 4 8 6 5
4
8 1 4 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
5 5 4 6 8 -2
1 2 4 8
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом тестовом случае, для данной перестановки, мы имеем       $$$|a_{1} - a_{2}| = 0 \le |a_{2} - a_{3}| = 1 \le |a_{3} - a_{4}|       = 2 \le |a_{4} - a_{5}| = 2 \le |a_{5} - a_{6}| = 10$$$.       Существуют также другие ответы, к примеру "<span class="tex-font-style-tt">5 4 5 6 -2 8</span>".</p>     <p>Во втором тестовом случае, для данной перестановки, мы имеем       $$$|a_{1} - a_{2}| = 1 \le |a_{2} - a_{3}| = 2 \le |a_{3} - a_{4}|       = 4$$$. Существуют также другие ответы, к примеру "<span class="tex-font-style-tt">2 4 8 1</span>".</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1339/problem/B' title='Codeforces Round 633 (Div. 2)'>1339B - Sorted Adjacent Differences</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Sort the list, and make an oscillation centered on middle element       like picture below.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/789052e1f8c8408dbe8ed8a9a628b6d6aebb1b11.png" style="max-width: 100.0%;max-height: 100.0%;" /> </center>          <p>In this way, you will always achieve to make $$$|a_{i} - a_{i+1}|       \le |a_{i+1} - a_{i+2}|$$$ for all $$$i$$$. Time complexity is       $$$O(n \log n)$$$.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #637 (Div. 1) - Thanks, Ivan Belonogov!
    1340A
    Настя и странный генератор </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Настя и странный генератор</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>       <span class="tex-font-style-it">Расстроившись после такого         отношения Насти, Денис был очень грустным. Ничего не могло         развеселить отвергнутого парня. Чтобы хоть как-то развеселиться         он решил побродить по подворотням. И, как ни странно, ему         улыбнулась удача! Зайдя в первый двор, он встретил странного         человека, который чем-то торговал. </span></p>     <p>Оглядевшись вокруг, Денис подошел к незнакомцу и купил загадочный       товар. Им оказался... Генератор случайных перестановок! Именно это       мальчик так давно искал!</p>     <p>Придя домой он стал изучать, как работает его генератор и узнал       алгоритм. Процесс генерации перестановки состоит из $$$n$$$ шагов.       На $$$i$$$-м шаге выбирается позиция (индекс) для значения $$$i$$$       $$$(1 \leq i \leq n)$$$. Позиция для значения $$$i$$$ определяется       следующим образом:</p>          <ul> <li> Для всех $$$j$$$ от $$$1$$$ до $$$n$$$ посчитаем $$$r_j$$$          — минимальный такой индекс, что $$$j \leq r_j \leq n$$$, a         позиция $$$r_j$$$ еще не занята в перестановке. Если таких         позиций нет, то будем считать, что значение $$$r_j$$$ не         определено. </li>       <li> Для всех $$$t$$$ от $$$1$$$ до $$$n$$$ посчитаем         $$$count_t$$$  — количество таких позиций $$$1 \leq j \leq n$$$,         что значение $$$r_j$$$ определено и $$$r_j = t$$$. </li>       <li> Рассмотрим все еще не занятые позиции перестановки и среди         таких рассмотрим позиции, для которых значение в массиве         $$$count$$$ максимально. </li>       <li> Генератор выбирает одну из таких позиций для значения         $$$i$$$. Генератор может выбрать <span class="tex-font-style-bf">любую</span> позицию. </li></ul>          <p>Рассмотрим работу алгоритма на следующем примере:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/15abb96c35071a49b2b1acdf0082b04b54f18bd6.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>Пусть $$$n = 5$$$ и алгоритм уже расставил значения $$$1, 2, 3$$$       в перестановке. Рассмотрим, как генератор будет выбирать позицию       для значения $$$4$$$:</p>          <ul> <li> Значения $$$r$$$ будут $$$r = [3, 3, 3, 4, \times]$$$, где         $$$\times$$$ означает неопределенное значение. </li>       <li> Тогда значения $$$count$$$ будут $$$count = [0, 0, 3, 1,         0]$$$. </li>       <li> Есть только две не занятые позиции в перестановке: $$$3$$$ и         $$$4$$$. Значение в массиве $$$count$$$ для позиции $$$3$$$         равно $$$3$$$, для позиции $$$4$$$ равно $$$1$$$. </li>       <li> Максимальное значение достигается только для позиции $$$3$$$,         поэтому алгоритм однозначно выберет эту позицию для значения         $$$4$$$. </li></ul>          <p>Довольный своим приобретением Денис пошел домой. Несколько дней       без перерыва он генерировал перестановки и решил, что       преисполнился в осознании процесса генерации. Он считает, что       может придумывать случайные перестановки не хуже генератора. </p>     <p>После этого он выписал первую пришедшую на ум перестановку       $$$p_1, p_2, \ldots, p_n$$$ и решил узнать, могла ли она получится       в результате работы генератора.</p>     <p>К сожалению, эта задача оказалась слишком сложна для него, и он       обратился за помощью к вам. Нужно определить, могла ли получиться       выписанная перестановка применением описанного алгоритма, если       генератор всегда выбирает нужную Денису позицию.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано целое число $$$t$$$ $$$(1 \leq t \leq       10^5)$$$  — количество наборов входных данных в тесте. Далее       содержатся сами описания наборов.</p>     <p>В первой строке каждого набора находится единственное целое число       $$$n$$$ $$$(1 \leq n \leq 10^5)$$$  — длина перестановки.</p>     <p>Во второй строке набора находится $$$n$$$ различных целых чисел       $$$p_1, p_2, \ldots, p_n$$$ ($$$1 \leq p_i \leq n$$$)  —       выписанная Денисом перестановка.</p>     <p>Гарантируется, что сумма значений $$$n$$$ по всем входным данным       не превосходит $$$10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите «<span class="tex-font-style-tt">Yes</span>», если эта       перестановка могла быть получена в результате работы генератора. В       противном случае выведите «<span class="tex-font-style-tt">No</span>».</p>     <p>Все буквы можно выводить в любом регистре.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
5
2 3 4 5 1
1
1
3
1 3 2
4
4 2 3 1
5
1 5 2 4 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
Yes
Yes
No
Yes
No
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Промоделируем работу генератора на первом тесте.</p>     <p>На $$$1$$$ шаге $$$r = [1, 2, 3, 4, 5], count = [1, 1, 1, 1,       1]$$$. Максимальное значение достигается в любой свободной       позиции, поэтому генератор может выбрать случайную позицию от       $$$1$$$ до $$$5$$$. В нашем примере он выбрал $$$5$$$.</p>     <p>На $$$2$$$ шаге $$$r = [1, 2, 3, 4, \times], count = [1, 1, 1, 1,       0]$$$. Максимальное значение достигается в позициях от $$$1$$$ до       $$$4$$$, поэтому генератор может выбрать случайную позицию среди       них. В нашем примере он выбрал $$$1$$$.</p>     <p>На $$$3$$$ шаге $$$r = [2, 2, 3, 4, \times], count = [0, 2, 1, 1,       0]$$$. Максимальное значение равно $$$2$$$ и достигается только в       позиции $$$2$$$, поэтому генератор выберет эту позицию.</p>     <p>На $$$4$$$ шаге $$$r = [3, 3, 3, 4, \times], count = [0, 0, 3, 1,       0]$$$. Максимальное значение равно $$$3$$$ и достигается только в       позиции $$$3$$$, поэтому генератор выберет эту позицию.</p>     <p>На $$$5$$$ шаге $$$r = [4, 4, 4, 4, \times], count = [0, 0, 0, 4,       0]$$$. Максимальное значение равно $$$4$$$ и достигается только в       позиции $$$4$$$, поэтому генератор выберет эту позицию.</p>     <p>Итого мы получили перестановку $$$2, 3, 4, 5, 1$$$, то есть       генератор мог её сгенерировать.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1340/problem/A' title='Codeforces Round 637 (Div. 1) - Thanks, Ivan Belonogov!'>1340A - Nastya and Strange Generator</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Consider the initial moment of time. Note that the array is $$$ r       = [1, 2, \ldots, n]$$$, $$$count = [1, 1, \ldots, 1] $$$. So the       generator will choose a random position from the entire array –       let it be the position $$$ i_1 $$$. In the next step, $$$r = [1,       2, \ldots i_1 + 1, i_1 + 1, i + 2, \ldots, n]$$$, $$$count = [1,       1, \ldots, 0, 2, 1, \ldots, 1] $$$. That is, now there is only one       maximum and it is reached at the position $$$ i_1 + 1 $$$. Thus,       we will fill in the entire suffix starting at position $$$ i_1       $$$: $$$ a = [\times, \ldots, \times, 1, \ldots, i_1] $$$. After       this, this procedure will be repeated for some $$$i_2$$$ ($$$ 1       \leq i_2 &lt; i_1 $$$) and the array will become $$$ a = [\times,       \ldots, \times, i_1 + 1, \ldots, i_1 + i_2, 1, \ldots, i_1] $$$ .       That is, we need to check that the array consists of several       ascending sequences.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #637 (Div. 1) - Thanks, Ivan Belonogov!
    1340B
    Настя и табло </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Настя и табло</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>       <span class="tex-font-style-it"> Денис, справившийся с покупкой         цветов и конфет (об этой истории вы узнаете в следующей задаче),         поехал на встречу с Настей, чтобы предложить ей стать парой. </span></p>     <p>       <span class="tex-font-style-it"> И вот, они сидят вместе в кафе,         болтают. Решительный Денис наконец-то предлагает быть им вместе,         но... Но Настя не даёт никакого ответа. </span></p>     <p>Как же сильно расстроился бедный парень. Так сильно, что он пнул       какое-то табло с цифрами. Цифры отображаются таким же образом, как       на электронных часах: каждая позиция для цифры состоит из $$$7$$$       сегментов, которые могут быть включены или выключены, чтобы       отображать различные цифры. На картинке показано, как изображаются       все $$$10$$$ десятичных цифр: </p>     <center> <img class="tex-graphics" src="https://espresso.codeforces.com/19e4ae06aceef4b9326d2ef6bca3339f5c84ed91.png" style="max-width: 100.0%;max-height: 100.0%;"/>     </center> После пинка некоторые палочки перестали работать, то есть     некоторые палочки могли перестать гореть, если горели раньше. Но     Денис запомнил, сколько палочек горело и сколько горит сейчас. Пусть     сломалось <span class="tex-font-style-bf">ровно</span> $$$k$$$     палочек и известно, какие палочки горят сейчас. Денис задался     вопросом: какое максимальное число может гореть на табло, если     включить ровно $$$k$$$ палочек (из тех которые сейчас выключены)?      <p>       <span class="tex-font-style-bf">Разрешается</span>, чтобы в числе       были лидирующие нули.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке дано число $$$n$$$ $$$(1 \leq n \leq 2000)$$$  —       количество цифр на табло и $$$k$$$ $$$(0 \leq k \leq 2000)$$$  —       количество сломанных палочек.</p>     <p>В следующих $$$n$$$ строках находится по одной бинарной строке       длины $$$7$$$, $$$i$$$-я из которых кодирует $$$i$$$-ю цифру табло.</p>     <p>Каждая цифра на табло состоит из $$$7$$$ палочек. Пронумеруем их,       как на картинке ниже, и пусть на $$$i$$$-м месте бинарной строки       будет $$$0$$$, если $$$i$$$-я палочка не горит и $$$1$$$, если       горит. Тогда бинарная строка длины $$$7$$$ будет задавать то,       какие палочки горят.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/bed1234ad2f319542a635519d6e40510e65f641b.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>Таким образом, последовательности «1110111», «0010010»,       «1011101», «1011011», «0111010», «1101011», «1101111», «1010010»,       «1111111», «1111011» кодируют по порядку все цифры от $$$0$$$ до       $$$9$$$ включительно.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите единственное число, состоящее из $$$n$$$ разрядов –       максимальное число, которое можно получить, если включить ровно       $$$k$$$ палочек или $$$-1$$$, если невозможно так включить ровно       $$$k$$$ палочек, чтобы на табло получилась какая-то       последовательность цифр.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
1 7
0000000
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
8</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
2 5
0010010
0010010
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
97</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
3 5
0100001
1001001
1010011
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
-1</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом тесте мы обязаны включить все $$$7$$$ палочек и получить       на табло одну цифру $$$8$$$.</p>     <p>Во втором тесте у нас включены палочки таким образом, что       образуются единицы. За $$$5$$$ дополнительно включённых палочек       можно получить числа $$$07$$$, $$$18$$$, $$$34$$$, $$$43$$$,       $$$70$$$, $$$79$$$, $$$81$$$ и $$$97$$$, из них выбираем       максимальное  — $$$97$$$.</p>     <p>В третьем тесте невозможно так включить ровно $$$5$$$ палочек,       чтобы на табло получилась какая-то последовательность цифр.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1340/problem/B' title='Codeforces Round 637 (Div. 1) - Thanks, Ivan Belonogov!'>1340B - Nastya and Scoreboard</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let $$$dp[i][j] = true$$$, if at the suffix $$$i \ldots n$$$ you       can turn on exactly $$$j$$$ sticks and get the correct sequence of       digits and $$$false$$$ otherwise. It is easy to recalculate this       dynamics: we will make transitions to all possible digits (the       mask at position $$$ i $$$ should be a submask of the digit).</p>     <p>Asymptotic calculate of the dynamics $$$O(10nd)$$$.</p>     <p>Now let's go in order from $$$1$$$ to $$$n$$$ and will try to       eagerly set the maximum possible figure using our dynamics. It is       easy to understand that in this way we get the maximum possible       number of $$$n$$$ digits.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #637 (Div. 1) - Thanks, Ivan Belonogov!
    1340C
    Настя и неожиданный гость </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Настя и неожиданный гость</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>       <span class="tex-font-style-it">Если девушка не идет к Денису, то         Денис идет к девушке. Руководствуясь таким принципом, молодой         человек вышел из дома, купил цветы и направился к Насте.</span></p>     <p>По пути от его дома до дома его возлюбленной есть дорога из       $$$n$$$ полос, перейти которую за один зеленый свет не всегда       возможно. Предвидя это, добрый мэр распорядился поставить в       некоторых точках этой дороги островки безопасности. Каждый       островок расположен после какой-то полосы, а также в начале и в       конце дороги. На них пешеходы могут отдохнуть, набраться сил и       дождаться зеленого света.</p>     <p>Денис подошел к левому краю дороги ровно в тот момент, когда       загорелся зеленый свет. Мальчик знает, что светофор сначала горит       $$$g$$$ секунд зеленым, а потом $$$r$$$ секунд красным, потом       опять $$$g$$$ секунд зеленым и так далее.</p>     <p>Формально, дорогу можно представить как отрезок $$$[0, n]$$$.       Изначально Денис стоит в точке $$$0$$$. Его задача - попасть в       точку $$$n$$$ за минимальное возможное время.</p>     <p>Oн знает множество различных целых чисел $$$d_1, d_2, \ldots,       d_m$$$, где $$$0 \leq d_i \leq n$$$  — координаты точек, в которых       расположены островки безопасности. Только в одной из этих точек       мальчик может находиться в момент, когда горит красный свет.</p>     <p>К сожалению, из-за волнения Денис не всегда может контролировать       себя, поэтому сейчас на его передвижения наложены некоторые ограничения:</p>          <ul> <li> Он обязан двигаться всегда, пока горит зеленый, ведь         сложно стоять, когда тебя ждет такая девушка. Денис за $$$1$$$         секунду может изменить свое положение на $$$\pm 1$$$. При этом         он должен всегда оставаться внутри отрезка $$$[0, n]$$$. </li>       <li> Он может менять направление движения только на островках         безопасности (ведь это безопасно). Это означает, что если за         предыдущую секунду мальчик изменил свое положение на $$$+1$$$,         то если он находится на островке безопасности, он может изменить         свое положение на $$$\pm 1$$$, иначе он может изменить свое         положение вновь только на $$$+1$$$. Аналогично, если за         предыдущую секунду он изменил свое положение на $$$-1$$$, на         островке безопасности он может изменить свое положение на $$$\pm         1$$$, а в любой другой точке вновь только на $$$-1$$$. </li>       <li> В момент, когда загорается красный, мальчик должен оказаться         на каком-то островке безопасности. Он сможет продолжить движение         в любом направлении, когда вновь загорится зеленый. </li></ul>          <p>Считается, что Денис перешел дорогу как только его координата       станет равна $$$n$$$.</p>     <p>Эта задача оказалась не так проста, ведь возможно, таким способом       даже невозможно перейти дорогу. Так как у Дениса все мысли о       любви, он не справился решить ее и попросил нас помочь ему в этом.       Найдите минимальное возможное время, за которое он сможет перейти       дорогу по таким правилам, либо установите, что это сделать невозможно.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке находится два целых числа $$$n$$$ и $$$m$$$ $$$(1       \leq n \leq 10^6, 2 \leq m \leq min(n + 1, 10^4))$$$  — ширина       дороги и количество островков безопасности.</p>     <p>Во второй строке находится $$$m$$$ различных целых чисел $$$d_1,       d_2, \ldots, d_m$$$ $$$(0 \leq d_i \leq n)$$$  — точки, в которых       расположены островки безопасности. Гарантируется, что среди них       есть $$$0$$$ и $$$n$$$.</p>     <p>В третьей строке находится два целых числа $$$g, r$$$ $$$(1 \leq       g, r \leq 1000)$$$  — время, которое на светофоре горит зеленый       свет и время, которое на светофоре горит красный свет.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одно целое число  — минимальное время, за которое Денис       может перейти дорогу по всем правилам. </p>     <p>Если перейти дорогу по всем правилам невозможно выведите $$$-1$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
15 5
0 3 7 14 15
11 11
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
45</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
13 4
0 3 7 13
9 9
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
-1</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом тесте оптимальный маршрут такой: </p>     <ul> <li> за первый зеленый свет дойти до $$$7$$$ и вернуться на         $$$3$$$. В этом случае, мы сменим направление движения в точке         $$$7$$$, что разрешено, поскольку в этой точке есть островок         безопасности. В конце мы окажемся в точке $$$3$$$, где также         есть островок безопасности. Следующие $$$11$$$ секунд мы должны         подождать красный свет. </li>       <li> за второй зеленый свет дойти до $$$14$$$. Снова подождать         красный свет. </li>       <li> за $$$1$$$ секунду перейти в $$$15$$$. В итоге Денис         оказывается в конце дороги. </li></ul>          <p>Всего получается $$$45$$$ секунд.</p>     <p>Во втором тесте невозможно перейти дорогу по всем правилам.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1340/problem/C' title='Codeforces Round 637 (Div. 1) - Thanks, Ivan Belonogov!'>1340C - Nastya and Unexpected Guest</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Notice the fact: if we somehow came to safety island and time       $$$i \bmod g$$$ ($$$\bmod$$$ - is a remainder after dividing       $$$i$$$ by $$$g$$$), we don't need anymore to come to this island       at time $$$j$$$ where $$$i&lt;j$$$ and $$$i\bmod g = j\bmod g$$$,       because this will form a cycle.</p>     <p>So that we can rephrase our task like this: we have some       vertices, which are denoted as a pair $$$(i, t)$$$, $$$i$$$ - is       island index, $$$t$$$ is a remainder after dividing the time we       came to $$$i$$$ by $$$g$$$. So it will be enough to use only edges       between vertices $$$(i, t) \to (i + 1, (t + a[i + 1] - a[i])\bmod       g)$$$ and $$$(i, t)\to (i - 1, (t + a[i] - a[i - 1])\bmod g)$$$,       because all remaining edges can be expressed through these ones.       Now lets notice that edges, which make time $$$t + a &gt; g$$$       can't be used due to restriction of walking on red. But vertices       with $$$t + a = g$$$ are good for us. So we can say, that while       green light is on, Denis can walk without restrictions, and when       $$$t + a = g$$$ we add $$$g + r$$$ to time. So we can use       $$$01$$$-BFS to solve this task and at the end check find vertex       and position from which we can go to our final destination.</p>     <p>Time complexity will be $$$O(g * m)$$$.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #637 (Div. 1) - Thanks, Ivan Belonogov!
    1340D
    Настя и машина времени </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Настя и машина времени</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>       <span class="tex-font-style-it">Придя к Насте, Денис обнаружил,         что она ему не рада... Но у молодого человека есть последняя         надежда. Он хочет купить все вещи, что нравятся Насте. Тогда-то         она уж точно согласится с ним общаться.</span></p>     <p>Карта города, в котором живут наши герои, представляет собой       множество площадей, некоторые из которых соединены дорогами. От       любой площади можно добраться до любой другой ровно одним       способом, используя эти дороги и не посещая одну и ту же площадь       дважды. Получается, что граф города  — это дерево.</p>     <p>Денис находится в вершине $$$1$$$ в момент времени $$$0$$$. Он       хочет хоть раз побывать в каждой вершине и вернуться назад как       можно раньше.</p>     <p>Денис может проходить вдоль любой дороги за $$$1$$$ времени. Увы,       город столь велик, что сделать это быстро никак не выйдет. Поэтому       Денис пошел на отчаянный шаг. Он достал свою карманную машину       времени, которую он собрал у себя в подвале. С ее помощью Денис       может стоя на месте сменить время на любое неотрицательное время,       которое меньше текущего. </p>     <p>Но у машины времени есть один нюанс. Если герой окажется в одном       месте и в одно и то же время дважды, произойдет взрыв вселенских       масштабов и не получится порадовать Настю. Поэтому Денис просит       вас проложить ему маршрут с использованием машины времени такой,       что он обойдет все площади и вернется на первую и при этом       максимальное время в котором он побывал будет минимально.</p>     <p>Формально, маршрут Дениса можно представить как       последовательность пар $$$\{v_1, t_1\}, \{v_2, t_2\}, \{v_3,       t_3\}, \ldots, \{v_k, t_k\}$$$, где $$$v_i$$$ — номер площади, а       $$$t_i$$$  — время, в котором сейчас находится мальчик.</p>     <p>Должны быть выполнены следующие условия:</p>          <ul> <li> Маршрут начинается на площади $$$1$$$ в момент времени         $$$0$$$, то есть $$$v_1 = 1, t_1 = 0$$$ и заканчивается на         площади $$$1$$$, то есть $$$v_k = 1$$$. </li>       <li> Все переходы делятся на два типа: <ol> <li> Стоя на площади             сменить время: $$$\{ v_i, t_i \} \to \{ v_{i+1}, t_{i+1} \}             : v_{i+1} = v_i, 0 \leq t_{i+1} &lt; t_i$$$. </li>           <li> Пройти по одной из дорог: $$$\{ v_i, t_i \} \to \{             v_{i+1}, t_{i+1} \}$$$. При этом $$$v_i$$$ и $$$v_{i+1}$$$             соединены дорогой и $$$t_{i+1} = t_i + 1$$$. </li></ol> </li>       <li> Все пары $$$\{ v_i, t_i \}$$$ должны быть различны. </li>       <li> Среди $$$v_1, v_2, \ldots, v_k$$$ встречаются все площади. </li></ul>          <p>Вам нужно найти маршрут такой, что максимальное время, в котором       побывает Денис будет минимальным, то есть маршрут, для которого       $$$\max{(t_1, t_2, \ldots, t_k)}$$$ будет минимально возможным.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке находится единственное целое число $$$n$$$ $$$(1       \leq n \leq 10^5)$$$  — количество площадей в городе.</p>     <p>В следующих $$$n - 1$$$ строках находится по два целых числа       $$$u$$$ и $$$v$$$ $$$(1 \leq v, u \leq n, u \neq v)$$$  — номера       площадей, соединенных дорогой.</p>     <p>Гарантируется, что заданный граф является деревом.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>В первой строке выведите целое число $$$k$$$ $$$(1 \leq k \leq       10^6)$$$  — длина пути Дениса.</p>     <p>В следующих $$$k$$$ строках выведите пары $$$v_i, t_i$$$  — пары,       описывающие маршрут Дениса (как в условии).</p>     <p>Все требования к маршруту, описанные в условии должны быть выполнены.</p>     <p>Гарантируется, что при заданных ограничениях существует хотя бы       один маршрут и ответ, длина которого не превосходит $$$10^6$$$.       Если возможных ответов несколько, выведите любой.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
1 2
2 3
2 4
4 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
13
1 0
2 1
3 2
3 1
2 2
4 3
4 1
5 2
5 1
4 2
2 3
2 0
1 1
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1340/problem/D' title='Codeforces Round 637 (Div. 1) - Thanks, Ivan Belonogov!'>1340D - Nastya and Time Machine</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Lemma: The maximum time that Denis will visit will be at least       $$$\max\limits_{v = 1}^{n} \deg v = T$$$</p>     <p>Proof: consider an arbitrary vertex $$$ v $$$. We will visit her       $$$ \deg v - 1$$$ times when we will bypass all her neighbors and       another $$$ 1 $$$ when we return to her ancestor. But we can't go       to vertex at 0 time. So, we need $$$\deg v$$$ moments more than 0.</p>     <p>We construct a graph traversal with a maximum time equal to       $$$T$$$. Let us now stand at $$$ v $$$ at a time $$$ t $$$ and $$$       v $$$ has an un visited son $$$ u $$$. We want to go to $$$ u $$$,       go around its entire subtree and return to $$$ v $$$ at time $$$ t       + 1 $$$. That is, the route will be something like this: $$$ (v,       t) \to (u, t + 1) \to \ldots \to (u, t) \to (v, t + 1) $$$.</p>     <p>Let $$$ k = \deg u - 1 $$$, for $$$ w_i $$$ we denote the $$$ i       $$$ th son of $$$ u $$$. If $$$ t + 1 \leq T - k $$$, then there       are no problems, we will move back in time at the very end of the       route: $$$(v, t)$$$ $$$\to$$$ $$$(u, t + 1)$$$ $$$\to$$$ $$$(w_1,       t + 2)$$$ $$$\to$$$ $$$\ldots$$$ $$$\to$$$ $$$(u, t + 2)$$$       $$$\to$$$ $$$\ldots$$$ $$$\to$$$ $$$(w_k, t + k + 1)$$$ $$$\to$$$       $$$\ldots$$$ $$$\to$$$ $$$(u, t + k)$$$ $$$\to$$$ $$$(u, t)$$$       $$$\to$$$ $$$(v, t + 1)$$$.</p>     <p>Otherwise, you have to go back in time in the middle of the route       (exactly when we get to T) so that after the last visit we will be       in $$$ (v, t + 1) $$$, that is: $$$(v, t)$$$ $$$\to$$$ $$$(u, t +       1)$$$ $$$\to$$$ $$$(w_1, t + 2)$$$ $$$\to$$$ $$$\ldots$$$       $$$\to$$$ $$$(u, t + 2)$$$ $$$\to$$$ $$$\ldots$$$ $$$\to$$$ $$$(u,       T)$$$ $$$\to$$$ $$$(u, t')$$$ $$$\to$$$ $$$\ldots$$$ $$$(w_k, t +       k + 1)$$$ $$$\to$$$ $$$\ldots$$$ $$$\to$$$ $$$(u, t + k)$$$       $$$\to$$$ $$$(u, t)$$$ $$$\to$$$ $$$(v, t + 1)$$$ , where $$$       t'$$$ can be easily calculated by the number of not visited sons.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #637 (Div. 1) - Thanks, Ivan Belonogov!
    1340E
    Настя и пчёлы </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. Настя и пчёлы</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>       <span class="tex-font-style-bf">К сожалению, была найдена ошибка в         доказательстве авторского решения этой задачи. На данный момент         нам неизвестно абсолютно верное решение. Тем не менее, вы можете         сдавать эту задачу, но в случае, если ваше решение пройдет все         тесты, оно не будет гарантированно верным. Если ваше решение         прошло все тесты и вы уверены в доказательстве его корректности,         вы можете написать одному из авторов соревнования об этом.</span></p>     <p>       <span class="tex-font-style-it"> Наверняка вы все читали книгу         «Алиса в стране чудес». В этой задаче Настя оказалась в стране         Трёх странных Пчёл. Пчёлы странные, потому что их соты         пятиугольные. Настя пробралась туда незаконно, поэтому она         хочет, чтобы вы её не поймали. Помогите пчёлам наказать         нарушительницу! </span></p>     <p>       <span class="tex-font-style-bf"> Это интерактивная задача. </span></p>     <p>Пчелиный улей представляет собой связный неориентированный граф,       по ребрам которого могут перемещаться пчелы и Настя. Граф       удовлетворяет двум свойствам:</p>          <ul> <li> Степень любой его вершины не больше чем $$$3$$$. </li>       <li> Для каждого ребра существует цикл длины не больше чем         $$$5$$$, проходящий через это ребро. </li></ul>      <p>Есть три пчелы и Настя. Вы играете за пчел. Сначала вы выбираете       вершины, в которые поставите пчел. Затем Настя выбирает вершину, в       которой она изначально окажется. Один ход представляет из себя       перемещения сначала пчел, потом Насти, по очереди: </p>     <ol> <li> Для каждой из ваших пчел, вы можете либо переместить         каждую ее по какому-нибудь ребру графа, выходящему из вершины,         где находится эта пчела или оставить ее на месте. </li>       <li> Затем Настя <span class="tex-font-style-bf">обязательно</span> перемещается по         какому-нибудь ребру графа, выходящему из вершины, в которой она         сейчас находится. </li></ol>          <p>Вы побеждаете, если хотя бы одна из пчел и Настя оказываются в       одной вершине в любой момент игры.</p>     <p>Если после $$$n$$$ ходов такая ситуация не происходит, то вы проигрываете.</p>     <p>       <span class="tex-font-style-bf">Несколько пчел могут находиться в         одной и той же вершине.</span></p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке даны два целых числа $$$n$$$ $$$(4 \leq n \leq       5000)$$$ и $$$m$$$ $$$(n \leq m \leq 3n)$$$  — количество вершин и       рёбер в графе.</p>     <p>Каждая из следующих $$$m$$$ строк содержит по два целых числа       $$$v$$$ и $$$u$$$ $$$(1 \leq v, u \leq n)$$$, которые означают,       что между вершинами $$$v$$$ и $$$u$$$ есть ребро. Гарантируется,       что граф связен, не содержит петель, что степень любой вершины не       превосходит $$$3$$$ и через каждое ребро проходит цикл длины не       больше чем $$$5$$$. Обратите внимание, граф <span class="tex-font-style-bf">может</span> содержать кратные рёбра.</p></div>         <div>     <div class="section-title">Протокол взаимодействия</div>          <p>На каждом ходу вы должны выводить ровно по три вершины $$$a, b,       c$$$ $$$(1 \leq a, b, c \leq n)$$$. В первый раз выведенные       $$$3$$$ вершины будут означать, в какие вершины вы изначально       поставили пчел. В ответ вы получите вершину, в которую жюри       расположило Настю. Каждые следующие $$$3$$$ вершины будут       означать, где оказываются $$$3$$$ пчелы после вашего хода. Каждая       из пчел может независимо от других пчел как остаться в текущей       вершине, так и переместиться по ребру. После очередного вывода       $$$3$$$ вершин, в ответ вы получаете номер новой вершины, в       которую пошла Настя.</p>     <p>Как только одна из пчёл оказалась в одной вершине с Настей или вы       достигли лимита на количество ходов, ваша программа должна       завершить работу. То есть, если вы сделали ход, и одна из пчел       оказалась в одной вершине с Настей, ваша программа должна       завершить работу, либо если Настя сделала ход и оказалась в одной       вершине с одной из пчел, вы не должны делать свой ход и программа       должна завершить работу.</p>     <p>При превышении лимита на количество ходов (то есть количество       ваших ходов превысило $$$n$$$, где $$$n$$$  — количество вершин в       графе) будет ваша программа получит вердикт неправильный ответ, в       случае немедленного завершения.</p>     <p>Ваше решение может получить вердикт <span class="tex-font-style-it">Решение «зависло»</span>, если вы       ничего не выведете или забудете сбросить буфер вывода.</p>     <p>Чтобы сбросить буфер вывода вам нужно сделать следующее сразу       после вывода запроса и символа конца строки:</p>          <ul> <li> fflush(stdout) или cout.flush() в C++; </li>       <li> System.out.flush() в Java; </li>       <li> flush(output) в Pascal; </li>       <li> stdout.flush() в Python; </li>       <li> см. документацию других языков. </li></ul>          <p>В этой задаче интерактор адаптивный. Это означает, что в       зависимости от всех ваших предыдущих ходов поведение Насти может       изменяться. </p>     <p>       <span class="tex-font-style-bf">Взломы</span> недоступны для этой задачи.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5 5
1 2
2 3
3 4
4 5
5 1
4
5</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1 1 2
1 5 3</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
8 9
1 2
2 3
3 4
4 5
5 1
5 6
6 7
7 8
8 4
1
5</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
7 3 3
6 2 2
5 3 1</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Пусть Настя - это зелёная фишка, а три пронумерованных красных -       это три пчелы.</p>     <p>В первом тесте перемещение героев выглядит так.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/c272d9bbf84f7af62b88946b85e60969ac5d84bd.png" style="max-width: 100.0%;max-height: 100.0%;"/>         <span class="tex-font-size-small">После выбора стартовых       вершин.</span> </center>               <center> <img class="tex-graphics" src="https://espresso.codeforces.com/602ed1429a012600b037447f89797ed7ccc4ca52.png" style="max-width: 100.0%;max-height: 100.0%;"/>         <span class="tex-font-size-small">Первых ход после перемещения       пчёл.</span> </center>               <center> <img class="tex-graphics" src="https://espresso.codeforces.com/399639c28c29178e8f3d5f023ba30360b8609f64.png" style="max-width: 100.0%;max-height: 100.0%;"/>         <span class="tex-font-size-small">Первых ход после перемещения         Насти.   Настя поймана пчелой 1.</span> </center>          <p>Во втором тесте перемещение героев выглядит так.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/e43d3c0e18e637ca84771ad4811899ba911880d2.png" style="max-width: 100.0%;max-height: 100.0%;"/>         <span class="tex-font-size-small">После выбора стартовых       вершин.</span> </center>               <center> <img class="tex-graphics" src="https://espresso.codeforces.com/255504d0e8872e4df03360a993ca349cd9741db4.png" style="max-width: 100.0%;max-height: 100.0%;"/>         <span class="tex-font-size-small">Первых ход после перемещения       пчёл.</span> </center>               <center> <img class="tex-graphics" src="https://espresso.codeforces.com/7f663d0e3901604481c18a3e97e6861480c1468c.png" style="max-width: 100.0%;max-height: 100.0%;"/>         <span class="tex-font-size-small">Первых ход после перемещения       Насти.</span> </center>               <center> <img class="tex-graphics" src="https://espresso.codeforces.com/af912445c35da0b5852dbe46dd84137c5267aa14.png" style="max-width: 100.0%;max-height: 100.0%;"/>         <span class="tex-font-size-small">Второй ход после перемещения         пчёл. Настя поймана пчелой 1.</span> </center></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #637 (Div. 1) - Thanks, Ivan Belonogov!
    1340F
    Настя и ПСП </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Настя и ПСП</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>4 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p> <span class="tex-font-style-it"> Настя, как и вы  — олимпиадный         программист, но она только учится. Недавно Денис ей рассказал о         способе проверки строки на то, что она является правильной         скобочной последовательностью. После этого неожиданно Настя         придумала более сложную задачу, которую Денис не смог решить, а         сможете ли Вы? </span></p>     <p>Дана строка $$$s$$$, состоящая из $$$k$$$ видов пар скобок.       Каждая скобка имеет вид $$$t$$$ — целое число, такое что $$$1 \leq       |t| \leq k$$$. Если скобка имеет вид $$$t$$$, то:</p>          <ul> <li> Если $$$t &gt; 0$$$, то это открывающая скобка типа         $$$t$$$. </li>       <li> Если $$$t &lt; 0$$$, то это закрывающая скобка типа $$$-t$$$. </li></ul>          <p>Таким образом, всего существует $$$k$$$ типов пар скобок.</p>     <p>Требуется отвечать на следующие запросы: </p>          <ol> <li> Заменить скобку на позиции $$$i$$$ на скобку вида $$$t$$$. </li>       <li> Проверить, является ли подстрока с $$$l$$$-й по $$$r$$$-ю         позиции, включительно, правильной скобочной последовательностью. </li></ol>          <p>Напомним определение правильной скобочной последовательности:</p>          <ul> <li> Пустая последовательность является правильной. </li>       <li> Если $$$A$$$ и $$$B$$$ - две правильные скобочные         последовательности, то их конкатенация «$$$A$$$ $$$B$$$» тоже         является правильной скобочной последовательностью. </li>       <li> Если $$$A$$$ - правильная скобочная последовательность,         $$$c$$$ $$$(1 \leq c \leq k)$$$  — некоторый тип скобок, то         последовательность «$$$c$$$ $$$A$$$ $$$-c$$$» тоже является         правильной. </li></ul></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке дано $$$n$$$ $$$(1 \leq n \leq 10^5)$$$  — длина       строки и число $$$k$$$ $$$(1 \leq k \leq n)$$$  — количество типов скобок.</p>     <p>Во второй строке дана строка $$$s$$$ длиной $$$n$$$ символов  —       $$$n$$$ целых чисел $$$s_1, s_2, \ldots, s_n$$$ $$$(1 \leq |s_i|       \leq k)$$$.</p>     <p>В третьей строке дано число $$$q$$$ $$$(1 \leq q \leq 10^5)$$$  —       количество запросов.</p>     <p>Каждая из следующих $$$q$$$ строк описывает запросы: </p>     <ul> <li> $$$1$$$ $$$i$$$ $$$t$$$ - запрос $$$1$$$-го типа $$$(1         \leq i \leq n, 1 \leq |t| \leq k)$$$. </li>       <li> $$$2$$$ $$$l$$$ $$$r$$$ - запрос $$$2$$$-го типа $$$(1 \leq l         \leq r \leq n)$$$. </li></ul></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого запроса $$$2$$$ типа выведите «<span class="tex-font-style-tt">Yes</span>», если подстрока из запроса       является правильной скобочной последовательностью и «<span class="tex-font-style-tt">No</span>», иначе.</p>     <p>Вы можете выводить буквы в любом регистре.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2 1
1 -1
1
2 1 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
Yes
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
2 2
1 -2
1
2 1 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
No
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
6 2
1 2 -2 -1 1 -1
3
2 1 6
2 1 4
2 2 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
Yes
Yes
No
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
2 2
-1 1
4
2 1 2
1 1 1
1 2 -1
2 1 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
No
Yes
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В четвёртом тесте изначально строка не является правильной       скобочной последовательностью, значит ответ на первый вопрос         «<span class="tex-font-style-tt">No</span>». После двух       изменений она имеет вид «<span class="tex-font-style-tt">$$$1$$$       $$$-1$$$</span>», значит она стала правильной скобочной       последовательностью и ответ на четвёртый запрос «<span class="tex-font-style-tt">Yes</span>».</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1340/problem/F' title='Codeforces Round 637 (Div. 1) - Thanks, Ivan Belonogov!'>1340F - Nastya and CBS</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>We will call the string exactly the wrong bracket sequence if we       go through it with a stack and it will not be of the form $$$close       + open$$$, where $$$ close $$$ is the sequence of closing       brackets, and $$$ open $$$ is opening.</p>     <p>Claim: if $$$ s = a + b $$$ and $$$ a $$$ is exactly not CBS or       $$$ b $$$ is exactly not CBS, then $$$ s $$$ is also exactly not CBS.</p>     <p>At the top of the Segment Tree, we will keep the line after going       through it with the stack in the form $$$ close + open $$$ or       marking that it is exactly not CBS. How to merge $$$ 2 $$$       segments of the form $$$ \{close_1 + open_1 \} $$$ and $$$       \{close_2 + open_2 \} $$$? Note that $$$ 3 $$$ cases are possible:</p>          <ol>     <li> The suffix $$$ open_1 $$$ is $$$ close_2 $$$, then the         result is $$$ close_1 + (close_2 - \text {prefix}) + open_2 $$$.     </li>       <li> The prefix $$$ close_1 $$$ is equal to $$$ open_2 $$$,         similarly.     </li>       <li> The result is exectly not CBS. </li></ol>          <p>How can we quickly consider this? Let's build a segment tree,       which contains treaps (which contain hashes) in each node, then we       need to check for equality some prefixes, glue some strings and       save all versions in order to update the ST.</p>     <p>The resulting asymptotics of $$$ O (n \log^2 n) $$$.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/6c3225037850009ad2491e68af9540d6f981a9c8.png" style="max-width: 100.0%;max-height: 100.0%;" /> </center></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

#define fi first
#define se second
#define ll long long

using namespace std;

mt19937 rnd(13&#39;06&#39;2019);

const int N = 4e5 + 1;
const int LN = 2e6 + 1;
const int mod = 1e9 + 7;
const long long div1 = 100&#39;001;

struct dek {
    int l, r, sz, key;
    long long hesh;
};

int top = 0;
dek m[LN];
long long t[N];
int lft[N], righ[N], a[N];
bool open[N], bad[N];
bool use[LN];

int get_next() {
    while (use[top])
        ++top;
    use[top] = 1;
    return top;
}

void recalc(int u) {
    m[u].sz = m[m[u].l].sz + m[m[u].r].sz + 1;
    m[u].hesh = (m[m[u].l].hesh * t[m[m[u].r].sz + 1] + t[m[m[u].r].sz] * m[u].key + m[m[u].r].hesh) % mod;
}

void copy_vert(int from, int to) {
    m[to] = m[from];
}

int merg(int a, int b) {
    if (a == 0)
        return b;
    if (b == 0)
        return a;
    int u = get_next();
    if (rnd() % (m[a].sz + m[b].sz) &lt; m[a].sz) {
        copy_vert(a, u);
        m[u].r = merg(m[a].r, b);
    } else {
        copy_vert(b, u);
        m[u].l = merg(a, m[b].l);
    }
    recalc(u);
    return u;
}


void split(int root, int &amp;a, int &amp;b, int x) {
    if (root == 0) {
        a = 0;
        b = 0;
        return;
    }
    int u = get_next();
    copy_vert(root, u);
    if (m[m[root].l].sz &gt;= x) {
        split(m[root].l, a, m[u].l, x);
        b = u;
    } else {
        split(m[root].r, m[u].r, b, x - m[m[root].l].sz - 1);
        a = u;
    }
    recalc(u);
}

int newv(int key) {
    int u = get_next();
    m[u].key = key;
    m[u].l = m[u].r = 0;
    m[u].sz = 1;
    m[u].hesh = key;
    return u;
}

void recalc_do(int v) {
    if (bad[2*v + 1] || bad[2*v + 2])
        bad[v] = 1;
    else {
        if (m[righ[2*v + 1]].sz &gt;= m[lft[2*v + 2]].sz) {
            int a, b;
            split(righ[2*v + 1], a, b, m[righ[2*v + 1]].sz - m[lft[2*v + 2]].sz);
            if (m[b].hesh != m[lft[2*v + 2]].hesh)
                bad[v] = 1;
            else {
                lft[v] = lft[2*v + 1];
                righ[v] = merg(a, righ[2*v + 2]);
                bad[v] = 0;
            }
        } else {
            int a, b;
            split(lft[2*v + 2], a, b, m[lft[2*v + 2]].sz - m[righ[2*v + 1]].sz);
            if (m[b].hesh != m[righ[2*v + 1]].hesh)
                bad[v] = 1;
            else {
                lft[v] = merg(a, lft[2*v + 1]);
                righ[v] = righ[2*v + 2];
                bad[v] = 0;
            }
        }
    }
}

void build_do(int v, int vl, int vr) {
    if (vr - vl == 1) {
        righ[v] = 0;
        lft[v] = 0;
        if (open[vl] == 1)
            righ[v] = newv(a[vl]);
        else
            lft[v] = newv(a[vl]);
        bad[v] = 0;
    } else {
        build_do(2*v + 1, vl, (vl + vr) / 2);
        build_do(2*v + 2, (vl + vr) / 2, vr);
        recalc_do(v);
    }
}

void als(int v, int vl, int vr, int l, int x, bool op) {
    if (vr - vl == 1) {
        a[vl] = x;
        open[vl] = op;
        build_do(v, vl, vr);
    } else {
        if (l &lt; (vl + vr) / 2)
            als(2*v + 1, vl, (vl + vr) / 2, l, x, op);
        else
            als(2*v + 2, (vl + vr) / 2, vr, l, x, op);
        recalc_do(v);
    }
}

bool zpr(int v, int vl, int vr, int l, int r, int &amp;lefq, int &amp;rigq) {
    if (l &lt;= vl &amp;&amp; vr &lt;= r) {
        lefq = lft[v];
        rigq = righ[v];
        return bad[v];
    } else if (l &gt;= vr || vl &gt;= r) {
        lefq = 0;
        rigq = 0;
        return 0;
    } else {
        bool b1, b2;
        int l1, r1, l2, r2;
        b1 = zpr(2*v + 1, vl, (vl + vr) / 2, l, r, l1, r1);
        b2 = zpr(2*v + 2, (vl + vr) / 2, vr, l, r, l2, r2);
        if (b1 || b2)
            return true;
        if (m[r1].sz &gt;= m[l2].sz) {
            int a, b;
            split(r1, a, b, m[r1].sz - m[l2].sz);
            if (m[b].hesh != m[l2].hesh)
                return true;
            rigq = merg(a, r2);
            lefq = l1;
        } else {
            int a, b;
            split(l2, a, b, m[l2].sz - m[r1].sz);
            if (m[b].hesh != m[r1].hesh)
                return true;
            rigq = r2;
            lefq = merg(a, l1);
        }
        return false;
    }
}

void dfs(int u) {
    if (use[u])
        return;
    use[u] = 1;
    dfs(m[u].l);
    dfs(m[u].r);
}

int main() {
    int i, j, k, n, p, x, q, type;
    //freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    
    use[0] = 1;
    cin &gt;&gt; n &gt;&gt; k;
    t[0] = 1;
    for (i = 1; i &lt;= n; ++i)
        t[i] = (t[i - 1] * div1) % mod;
    for (i = 1; i &lt;= n; ++i) {
        cin &gt;&gt; a[i];
        if (a[i] &gt; 0)
            open[i] = 1;
        else {
            a[i] = -a[i];
            open[i] = 0;
        }
    }
    build_do(0, 1, n + 1);
    cin &gt;&gt; q;
    for (i = 0; i &lt; q; ++i) {
        cin &gt;&gt; type;
        if (type == 1) {
            cin &gt;&gt; p &gt;&gt; x;
            bool op;
            if (x &gt; 0)
                op = 1;
            else {
                x = -x;
                op = 0;
            }
            als(0, 1, n + 1, p, x, op);
        } else {
            int l, r, lft, right;
            cin &gt;&gt; l &gt;&gt; r;
            bool bad = zpr(0, 1, n + 1, l, r + 1, lft, right);
            if (bad || lft != 0 || right != 0)
                cout &lt;&lt; &#34;No\n&#34;;
            else
                cout &lt;&lt; &#34;Yes\n&#34;;
        }
        if (top &gt; LN - 1e4) {
            memset(use, 0, sizeof(use));
            for (j = 0; j &lt; N; ++j) {
                dfs(lft[j]);
                dfs(righ[j]);
            }
            top = 0;
        }
    }
}</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;

#define fi first
#define se second
#define ll long long

using namespace std;

mt19937 rnd(13&#39;06&#39;2019);

const int N = 4e5 + 1;
const int LN = 2e6 + 1;
const int mod = 1e9 + 7;
const long long div1 = 100&#39;001;

struct dek {
    int l, r, sz, key;
    long long hesh;
};

int top = 0;
dek m[LN];
long long t[N];
int lft[N], righ[N], a[N];
bool open[N], bad[N];
bool use[LN];

int get_next() {
    while (use[top])
        ++top;
    use[top] = 1;
    return top;
}

void recalc(int u) {
    m[u].sz = m[m[u].l].sz + m[m[u].r].sz + 1;
    m[u].hesh = (m[m[u].l].hesh * t[m[m[u].r].sz + 1] + t[m[m[u].r].sz] * m[u].key + m[m[u].r].hesh) % mod;
}

void copy_vert(int from, int to) {
    m[to] = m[from];
}

int merg(int a, int b) {
    if (a == 0)
        return b;
    if (b == 0)
        return a;
    int u = get_next();
    if (rnd() % (m[a].sz + m[b].sz) &lt; m[a].sz) {
        copy_vert(a, u);
        m[u].r = merg(m[a].r, b);
    } else {
        copy_vert(b, u);
        m[u].l = merg(a, m[b].l);
    }
    recalc(u);
    return u;
}


void split(int root, int &amp;a, int &amp;b, int x) {
    if (root == 0) {
        a = 0;
        b = 0;
        return;
    }
    int u = get_next();
    copy_vert(root, u);
    if (m[m[root].l].sz &gt;= x) {
        split(m[root].l, a, m[u].l, x);
        b = u;
    } else {
        split(m[root].r, m[u].r, b, x - m[m[root].l].sz - 1);
        a = u;
    }
    recalc(u);
}

int newv(int key) {
    int u = get_next();
    m[u].key = key;
    m[u].l = m[u].r = 0;
    m[u].sz = 1;
    m[u].hesh = key;
    return u;
}

void recalc_do(int v) {
    if (bad[2*v + 1] || bad[2*v + 2])
        bad[v] = 1;
    else {
        if (m[righ[2*v + 1]].sz &gt;= m[lft[2*v + 2]].sz) {
            int a, b;
            split(righ[2*v + 1], a, b, m[righ[2*v + 1]].sz - m[lft[2*v + 2]].sz);
            if (m[b].hesh != m[lft[2*v + 2]].hesh)
                bad[v] = 1;
            else {
                lft[v] = lft[2*v + 1];
                righ[v] = merg(a, righ[2*v + 2]);
                bad[v] = 0;
            }
        } else {
            int a, b;
            split(lft[2*v + 2], a, b, m[lft[2*v + 2]].sz - m[righ[2*v + 1]].sz);
            if (m[b].hesh != m[righ[2*v + 1]].hesh)
                bad[v] = 1;
            else {
                lft[v] = merg(a, lft[2*v + 1]);
                righ[v] = righ[2*v + 2];
                bad[v] = 0;
            }
        }
    }
}

void build_do(int v, int vl, int vr) {
    if (vr - vl == 1) {
        righ[v] = 0;
        lft[v] = 0;
        if (open[vl] == 1)
            righ[v] = newv(a[vl]);
        else
            lft[v] = newv(a[vl]);
        bad[v] = 0;
    } else {
        build_do(2*v + 1, vl, (vl + vr) / 2);
        build_do(2*v + 2, (vl + vr) / 2, vr);
        recalc_do(v);
    }
}

void als(int v, int vl, int vr, int l, int x, bool op) {
    if (vr - vl == 1) {
        a[vl] = x;
        open[vl] = op;
        build_do(v, vl, vr);
    } else {
        if (l &lt; (vl + vr) / 2)
            als(2*v + 1, vl, (vl + vr) / 2, l, x, op);
        else
            als(2*v + 2, (vl + vr) / 2, vr, l, x, op);
        recalc_do(v);
    }
}

bool zpr(int v, int vl, int vr, int l, int r, int &amp;lefq, int &amp;rigq) {
    if (l &lt;= vl &amp;&amp; vr &lt;= r) {
        lefq = lft[v];
        rigq = righ[v];
        return bad[v];
    } else if (l &gt;= vr || vl &gt;= r) {
        lefq = 0;
        rigq = 0;
        return 0;
    } else {
        bool b1, b2;
        int l1, r1, l2, r2;
        b1 = zpr(2*v + 1, vl, (vl + vr) / 2, l, r, l1, r1);
        b2 = zpr(2*v + 2, (vl + vr) / 2, vr, l, r, l2, r2);
        if (b1 || b2)
            return true;
        if (m[r1].sz &gt;= m[l2].sz) {
            int a, b;
            split(r1, a, b, m[r1].sz - m[l2].sz);
            if (m[b].hesh != m[l2].hesh)
                return true;
            rigq = merg(a, r2);
            lefq = l1;
        } else {
            int a, b;
            split(l2, a, b, m[l2].sz - m[r1].sz);
            if (m[b].hesh != m[r1].hesh)
                return true;
            rigq = r2;
            lefq = merg(a, l1);
        }
        return false;
    }
}

void dfs(int u) {
    if (use[u])
        return;
    use[u] = 1;
    dfs(m[u].l);
    dfs(m[u].r);
}

int main() {
    int i, j, k, n, p, x, q, type;
    //freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    
    use[0] = 1;
    cin &gt;&gt; n &gt;&gt; k;
    t[0] = 1;
    for (i = 1; i &lt;= n; ++i)
        t[i] = (t[i - 1] * div1) % mod;
    for (i = 1; i &lt;= n; ++i) {
        cin &gt;&gt; a[i];
        if (a[i] &gt; 0)
            open[i] = 1;
        else {
            a[i] = -a[i];
            open[i] = 0;
        }
    }
    build_do(0, 1, n + 1);
    cin &gt;&gt; q;
    for (i = 0; i &lt; q; ++i) {
        cin &gt;&gt; type;
        if (type == 1) {
            cin &gt;&gt; p &gt;&gt; x;
            bool op;
            if (x &gt; 0)
                op = 1;
            else {
                x = -x;
                op = 0;
            }
            als(0, 1, n + 1, p, x, op);
        } else {
            int l, r, lft, right;
            cin &gt;&gt; l &gt;&gt; r;
            bool bad = zpr(0, 1, n + 1, l, r + 1, lft, right);
            if (bad || lft != 0 || right != 0)
                cout &lt;&lt; &#34;No\n&#34;;
            else
                cout &lt;&lt; &#34;Yes\n&#34;;
        }
        if (top &gt; LN - 1e4) {
            memset(use, 0, sizeof(use));
            for (j = 0; j &lt; N; ++j) {
                dfs(lft[j]);
                dfs(righ[j]);
            }
            top = 0;
        }
    }
}</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #637 (Div. 2) - Thanks, Ivan Belonogov!
    1341A
    Настя и рис </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Настя и рис</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Только что Настя совершила огромную ошибку и рассыпала целую       упаковку риса на пол. Скоро придёт мама. Если она это увидит, то       Настю накажут и поставят в угол.</p>     <p>Всего Настя просыпала $$$n$$$ зёрен. Настя прочла, что каждое       зерно весит некоторое целое число грамм от $$$a - b$$$ до $$$a +       b$$$ грамм включительно (числа $$$a$$$ и $$$b$$$ известны), а вся       упаковка из $$$n$$$ зёрен весит от $$$c - d$$$ до $$$c + d$$$       грамм, включительно (числа $$$c$$$ и $$$d$$$ известны). Вес       упаковки  — это сумма весов всех $$$n$$$ зёрен в ней.</p>     <p>Помогите понять Насте, может ли прочитанная информация быть       верной. Иными словами, проверьте, может ли у каждого зерна быть       такая масса, что $$$i$$$-е зерно весит некоторое целое число грамм       $$$x_i$$$ $$$(a - b \leq x_i \leq a + b)$$$, а в сумме они весят       от $$$c - d$$$ до $$$c + d$$$, включительно (то есть $$$c - d \leq       \sum\limits_{i=1}^{n}{x_i} \leq c + d$$$).</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Входные данные содержат несколько наборов входных данных. В       первой строке задано единственное число $$$t$$$ $$$(1 \leq t \leq       1000)$$$ — количество наборов входных данных. </p>     <p>Следующие $$$t$$$ строк содержат описания наборов входных данных,       каждая строка содержит по $$$5$$$ целых чисел: $$$n$$$ $$$(1 \leq       n \leq 1000)$$$  — количество зерен, которое насчитала Настя и       $$$a, b, c, d$$$ $$$(0 \leq b &lt; a \leq 1000, 0 \leq d &lt; c       \leq 1000)$$$  — числа, определяющие возможный вес одного зерна       риса (от $$$a - b$$$ до $$$a + b$$$) и возможный суммарный вес       упаковки (от $$$c - d$$$ до $$$c + d$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите «<span class="tex-font-style-tt">Yes</span>», если информация о весах не       противоречива, и «<span class="tex-font-style-tt">No</span>», если       $$$n$$$ зёрен массами от $$$a - b$$$ до $$$a + b$$$ не могут       составить упаковку суммарной массой от $$$c - d$$$ до $$$c + d$$$.</p>     <p>Вы можете выводить буквы в любом регистре (верхнем или нижнем).</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
7 20 3 101 18
11 11 10 234 2
8 9 7 250 122
19 41 21 321 10
3 10 8 6 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
Yes
No
Yes
No
Yes
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом тесте можно предположить, что каждое зерно весит по       $$$17$$$ грамм, а пачка $$$119$$$ грамм, тогда действительно Настя       могла собрать всю пачку.</p>     <p>Во третьем тесте можно предположить, что каждое зерно весит по       $$$16$$$ грамм, а пачка $$$128$$$ грамм, тогда действительно Настя       могла собрать всю пачку.</p>     <p>Во пятом тесте можно предположить, что $$$3$$$ зерна риса весят       $$$2$$$, $$$2$$$ и $$$3$$$ грамма, а пачка $$$7$$$ грамм, тогда       действительно Настя могла собрать всю пачку.</p>     <p>Во втором и в четвёртом тестах можно доказать, что нельзя       определить корректные веса всех зёрен риса и вес пачки так, чтобы       вес пачки оказался равен суммарному весу всех собранных зерен.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1341/problem/A' title='Codeforces Round 637 (Div. 2) - Thanks, Ivan Belonogov!'>1341A - Nastya and Rice</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>We can get any weight of all grains from $$$n(a - b)$$$ to $$$n(a       + b)$$$, so we need to check that the segments $$$[n(a - b); n(a +       b)]$$$ and $$$[c - d; c + d]$$$ intersect.</p></div></div></div>

           
            <pre><code>#include &lt;iostream&gt;
 
using namespace std;
 
int main() {
	int q;
	cin &gt;&gt; q;
	while (q--) {
		int n, a, b, c, d;
		cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
		int L = n * (a - b), R = n * (a + b);
		if (R &lt; c - d || c + d &lt; L)
		    cout &lt;&lt; &#34;No\n&#34;;
		else
		    cout &lt;&lt; &#34;Yes\n&#34;;
	}
}</code></pre>
           
            <pre><code>#include &lt;iostream&gt;
 
using namespace std;
 
int main() {
	int q;
	cin &gt;&gt; q;
	while (q--) {
		int n, a, b, c, d;
		cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
		int L = n * (a - b), R = n * (a + b);
		if (R &lt; c - d || c + d &lt; L)
		    cout &lt;&lt; &#34;No\n&#34;;
		else
		    cout &lt;&lt; &#34;Yes\n&#34;;
	}
}</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #637 (Div. 2) - Thanks, Ivan Belonogov!
    1341B
    Настя и дверь </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Настя и дверь</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>На 14 февраля Денис решил подарить валентинку Насте и не придумал       ничего лучше чем нарисовать на двери длины $$$k$$$ ($$$k \ge 3$$$)       огромное красное сердечко. Настю такой подарок очень смутил,       поэтому она решила сломать дверь, сбросив её на горы.</p>     <p>Горы описываются последовательностью высот $$$a_1, a_2, \dots,       a_n$$$ в порядке слева направо ($$$k \le n$$$). Гарантируется, что       соседние высоты не равны друг другу (то есть $$$a_i \ne a_{i+1}$$$       для всех $$$i$$$ от $$$1$$$ до $$$n-1$$$).</p>     <p>Пиками гор на отрезке $$$[l,r]$$$ (от $$$l$$$ до $$$r$$$)       называются такие индексы $$$i$$$, что $$$l &lt; i &lt; r$$$,       $$$a_{i - 1} &lt; a_i$$$ и $$$a_i &gt; a_{i + 1}$$$. Стоит       отметить, что граничные для отрезка индексы $$$l$$$ и $$$r$$$       пиками <span class="tex-font-style-bf">не являются</span>.       Например, если $$$n=8$$$ и $$$a=[3,1,4,1,5,9,2,6]$$$, то на       отрезке $$$[1,8]$$$ всего два пика (с индексами $$$3$$$ и       $$$6$$$), а на отрезке $$$[3, 6]$$$ — пиков нет.</p>     <p>Чтобы сломать дверь, Настя сбрасывает ее на некоторый отрезок       $$$[l,l+k-1]$$$ подряд идущих гор длины $$$k$$$ ($$$1 \le l \le       n-k+1$$$). Когда дверь касается пиков гор, она разламывается на       две части, после этого эти части продолжат падать в разных       половинах и также ломаться на части при касании пиков гор и так       далее. Формально, количество частей, на которое разобьется дверь,       будет равно $$$p+1$$$, где $$$p$$$ — количество пиков на отрезке $$$[l,l+k-1]$$$.</p>     <p>Настя хочет сломать ее на максимальное количество кусочков.       Помогите ей выбрать такой отрезок гор $$$[l, l+k-1]$$$, что       количество пиков на нём — максимально. Если существует несколько       оптимальных отрезков, Настя желает найти такой, для которого       значение $$$l$$$ — минимально.</p>     <p>Формально, то вам нужно выбрать такой отрезок гор $$$[l,       l+k-1]$$$, на котором количество пиков максимально. Среди всех       таких отрезков, вам нужно найти отрезок, имеющий минимальное       значение $$$l$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано целое число $$$t$$$ ($$$1 \leq t \leq       10^4$$$) — количество наборов входных данных в тесте. Далее       содержатся сами описания наборов.</p>     <p>В первой строке набора находятся два целых числа $$$n$$$ и       $$$k$$$ ($$$3 \leq k \leq n \leq 2 \cdot 10^5$$$)  — количество       гор и длина Настиной двери.</p>     <p>Вторая строка набора входных данных содержит $$$n$$$ целых чисел       $$$a_1, a_2, \dots, a_n$$$ ($$$0 \leq a_i \leq 10 ^ 9$$$, $$$a_i       \neq a_{i + 1}$$$), задающие высоты гор.</p>     <p>Гарантируется, что сумма значений $$$n$$$ по всем наборам входных       данных не превосходит $$$2 \cdot 10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите два целых числа       $$$t$$$ и $$$l$$$  — максимальное количество частей, на которое       может разбиться дверь, и левую границу отрезка длины $$$k$$$, на       который надо сбросить дверь.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
8 6
1 2 4 1 2 4 1 2
5 3
3 2 3 2 1
10 4
4 3 4 3 2 3 2 1 0 1
15 7
3 7 4 8 2 3 4 5 21 2 3 4 2 1 3
7 5
1 2 3 4 5 6 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3 2
2 2
2 1
3 1
2 3
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере нужно выбрать отрезок гор со $$$2$$$ по $$$7$$$,       на этом отрезке индексы $$$3$$$ и $$$6$$$ являются пиками, поэтому       ответ равен $$$3$$$ (всего $$$2$$$ пика, значит дверь разломится       на $$$3$$$ части). Не трудно заметить, что отрезки гор $$$[1,       6]$$$ и $$$[3, 8]$$$ не подойдут, так как на них всего $$$1$$$ пик       (для первого отрезка индекс $$$6$$$ не является пиком, а для       второго отрезка индекс $$$3$$$ не является пиком). </p>     <p>Во втором примере нужно выбрать отрезок гор со $$$2$$$ по       $$$4$$$, на этом отрезке индекс $$$3$$$ является пиком, поэтому       ответ равен $$$2$$$ (всего $$$1$$$ пик, значит дверь разломится на       $$$2$$$ части).</p>     <p>В третьем примере нужно выбрать отрезок гор с $$$1$$$ по $$$4$$$,       на этом отрезке индекс $$$3$$$ является пиком, поэтому ответ равен       $$$2$$$ (всего $$$1$$$ пик, значит дверь разломится на $$$2$$$       части). Можно заметить, что на отрезках $$$[2, 5]$$$, $$$[4, 7]$$$       и $$$[5, 8]$$$ количество пиков также равно $$$1$$$, но у этих       отрезков левая граница больше, чем у отрезка $$$[1, 4]$$$, поэтому       они не являются правильным ответом.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1341/problem/B' title='Codeforces Round 637 (Div. 2) - Thanks, Ivan Belonogov!'>1341B - Nastya and Door</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's make an array consisting of $$$0$$$ and $$$1$$$, such that       it shows whether the position $$$i$$$ is a peak on the whole       segment. To do this, we will go through the indices from $$$2$$$       to $$$n - 1$$$, and if the conditions $$$a_{i - 1} &lt; a_i$$$ and       $$$a_i &gt; a_{i + 1}$$$ are true, then we write $$$1$$$ in a new       array at position $$$i$$$. After that, we calculate the prefix sum       in the new array $$$pref$$$. Now the number of peaks in the       segment $$$[l, l + k - 1]$$$ is calculated as $$$pref[l + k - 2] -       pref[l]$$$, so we find out how many peaks in the desired segment,       not including the boundaries of the segment. It remains only to go       through all $$$l$$$ from $$$1$$$ to $$$n - k + 1$$$ and find the       leftmost $$$l$$$, such that $$$pref[l + k - 2] - pref[l]$$$ as       much as possible.</p></div></div></div>

           
            <pre><code>#define _CRT_SECURE_NO_WARNINGS
#define _USE_MATH_DEFINES

#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;fstream&gt;
#include &lt;iomanip&gt;
#include &lt;bitset&gt;
#include &lt;random&gt;
#include &lt;queue&gt;
#include &lt;cstring&gt;
#include &lt;cassert&gt;

using namespace std;

#define X first
#define Y second
#define mp make_pair
#define all(x) x.begin(), x.end()
#define all_(x) x.rbegin(), x.rend()
#define multi_test 1

typedef long long ll;
typedef long long lint;
typedef unsigned long long ull;
typedef long double ld;
typedef pair&lt;int, int&gt; pii;
typedef pair&lt;ll, ll&gt; pll;
typedef pair&lt;ld, ld&gt; pld;

const ll INF = 1e9 + 9;
const ll INF1 = 1e18 + 19;
const ll MAXN = 1e6 + 7;
const ll MAXN1 = 300;
const ll MAXN2 = (1 &lt;&lt; 24) + 7;
const ll MOD = 1e9 + 7;
const ll PW = 31;
const ll BLOCK = 317;

void solve();
mt19937_64 mt(1e9 + 7);

signed main() {
    srand(&#39;a&#39; + &#39;l&#39; + &#39;e&#39; + &#39;x&#39; + &#39;X&#39; + &#39;5&#39; + &#39;1&#39; + &#39;2&#39;);
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
#ifdef _DEBUG
#define MAXN 5000
    freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
    freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
    int q = 1;
    if (multi_test) cin &gt;&gt; q;
    while (q--)  {
        solve();
    }
}

/*-----------------------------------------------------------------------------------------------------------------------------*/

bool pick(int i, vector&lt;int&gt;&amp; v, int l, int r) {
    if (i == l || i == r) return 0;
    return v[i - 1] &lt; v[i] &amp;&amp; v[i] &gt; v[i + 1];
}

void solve() {
    int n, k;
    cin &gt;&gt; n &gt;&gt; k;
    vector&lt;int&gt; v(n);
    for (auto &amp;i : v) cin &gt;&gt; i;
    int ans = -1, l = -1, r = -1, now = 0;
    for (int i = 1; i + 1 &lt; k; ++i) {
        if (pick(i, v, 0, k - 1)) ++now;
    }
    ans = now + 1, l = 0, r = k - 1;
    for (int i = k; i &lt; n; ++i) {
        if (pick(i - k + 1, v, i - k, i - 1)) --now;
        if (pick(i - 1, v, i - k + 1, i)) ++now;
        if (now + 1 &gt; ans) {
            ans = now + 1;
            l = i - k + 1;
            r = i;
        }
    }
    cout &lt;&lt; ans &lt;&lt; &#34; &#34; &lt;&lt; l + 1 &lt;&lt; &#34;\n&#34;;
}
</code></pre>
           
            <pre><code>#define _CRT_SECURE_NO_WARNINGS
#define _USE_MATH_DEFINES

#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;fstream&gt;
#include &lt;iomanip&gt;
#include &lt;bitset&gt;
#include &lt;random&gt;
#include &lt;queue&gt;
#include &lt;cstring&gt;
#include &lt;cassert&gt;

using namespace std;

#define X first
#define Y second
#define mp make_pair
#define all(x) x.begin(), x.end()
#define all_(x) x.rbegin(), x.rend()
#define multi_test 1

typedef long long ll;
typedef long long lint;
typedef unsigned long long ull;
typedef long double ld;
typedef pair&lt;int, int&gt; pii;
typedef pair&lt;ll, ll&gt; pll;
typedef pair&lt;ld, ld&gt; pld;

const ll INF = 1e9 + 9;
const ll INF1 = 1e18 + 19;
const ll MAXN = 1e6 + 7;
const ll MAXN1 = 300;
const ll MAXN2 = (1 &lt;&lt; 24) + 7;
const ll MOD = 1e9 + 7;
const ll PW = 31;
const ll BLOCK = 317;

void solve();
mt19937_64 mt(1e9 + 7);

signed main() {
    srand(&#39;a&#39; + &#39;l&#39; + &#39;e&#39; + &#39;x&#39; + &#39;X&#39; + &#39;5&#39; + &#39;1&#39; + &#39;2&#39;);
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
#ifdef _DEBUG
#define MAXN 5000
    freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
    freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
    int q = 1;
    if (multi_test) cin &gt;&gt; q;
    while (q--)  {
        solve();
    }
}

/*-----------------------------------------------------------------------------------------------------------------------------*/

bool pick(int i, vector&lt;int&gt;&amp; v, int l, int r) {
    if (i == l || i == r) return 0;
    return v[i - 1] &lt; v[i] &amp;&amp; v[i] &gt; v[i + 1];
}

void solve() {
    int n, k;
    cin &gt;&gt; n &gt;&gt; k;
    vector&lt;int&gt; v(n);
    for (auto &amp;i : v) cin &gt;&gt; i;
    int ans = -1, l = -1, r = -1, now = 0;
    for (int i = 1; i + 1 &lt; k; ++i) {
        if (pick(i, v, 0, k - 1)) ++now;
    }
    ans = now + 1, l = 0, r = k - 1;
    for (int i = k; i &lt; n; ++i) {
        if (pick(i - k + 1, v, i - k, i - 1)) --now;
        if (pick(i - 1, v, i - k + 1, i)) ++now;
        if (now + 1 &gt; ans) {
            ans = now + 1;
            l = i - k + 1;
            r = i;
        }
    }
    cout &lt;&lt; ans &lt;&lt; &#34; &#34; &lt;&lt; l + 1 &lt;&lt; &#34;\n&#34;;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 86 (рейтинговый для Див. 2)
    1342A
    Получи два нуля </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Получи два нуля</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам заданы два числа $$$x$$$ и $$$y$$$. Вы можете выполнять       операции двух типов: </p>     <ol> <li> Заплатить $$$a$$$ долларов и увеличить либо уменьшить         любое из чисел на $$$1$$$. Например, если $$$x = 0$$$ и $$$y =         7$$$ возможны четыре варианта после такой операции: <ul> <li>             $$$x = 0$$$, $$$y = 6$$$; </li>           <li> $$$x = 0$$$, $$$y = 8$$$; </li>           <li> $$$x = -1$$$, $$$y = 7$$$; </li>           <li> $$$x = 1$$$, $$$y = 7$$$. </li></ul>                  <p> </p></li>       <li> Заплатить $$$b$$$ долларов и увеличить либо уменьшить оба         числа на $$$1$$$. Например, если $$$x = 0$$$ и $$$y = 7$$$         возможны два варианта после такой операции: <ul> <li> $$$x =             -1$$$, $$$y = 6$$$; </li>           <li> $$$x = 1$$$, $$$y = 8$$$. </li></ul> </li></ol>          <p>Ваша задача сделать оба числа равными нулю одновременно, т.е.       достичь состояния $$$x = y = 0$$$. Других каких-либо требований       нет. В частности, переход из $$$x=1$$$, $$$y=0$$$ в $$$x=y=0$$$ допустим.</p>     <p>Посчитайте минимально количество долларов, которое вам нужно       потратить для этого.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит целое число $$$t$$$ ($$$1 \le t \le       100$$$) — количество наборов входных данных.</p>     <p>Первая строка каждого набора входных данных содержит два числа       $$$x$$$ и $$$y$$$ ($$$0 \le x, y \le 10^9$$$).</p>     <p>Вторая строка каждого набора входных данных содержит два числа       $$$a$$$ и $$$b$$$ ($$$1 \le a, b \le 10^9$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>На каждый набор входных данных выведите ответ — минимальное       количество долларов, которое придется потратить.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
1 3
391 555
0 0
9 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1337
0
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных вы можете применить следующие       операции: первую, вторую и первую. Таким образом, вы потратите       $$$391 + 555 + 391 = 1337$$$ долларов.</p>     <p>Во втором наборе входных данных оба числа равны нулю изначально,       а значит вам не нужно ничего тратить.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1342/problem/A' title='Educational Codeforces Round 86 (Rated for Div. 2)'>1342A - Road To Zero</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's presume that $$$x \ge y$$$. Then there are two cases in the       problem: </p>     <ol> <li> If $$$a + a \le b$$$ then we have to $$$x + y$$$ times         perform the first operation. So the answer is $$$(x + y) \cdot         a$$$; </li>       <li> If $$$a + a &gt; b$$$ then we have to $$$y$$$ times perform         the second operation and pass the remaining distance by         performing the first operation. So the answer is $$$y \cdot b +         (x - y) \cdot a$$$. </li></ol></div></div></div>

           
            <pre><code>for _ in range(int(input())):
    x, y = map(int, input().split())
    a, b = map(int, input().split())
    b = min(b, a + a)
    if x &lt; y:
        x, y= y, x
    print(y * b + (x - y) * a)
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 86 (рейтинговый для Див. 2)
    1342B
    Двоичный период </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Двоичный период</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Скажем, что строка $$$s$$$ имеет период $$$k$$$, если $$$s_i =       s_{i + k}$$$ для всех $$$i$$$ от $$$1$$$ по $$$|s| - k$$$       ($$$|s|$$$ — это длина строки $$$s$$$), и $$$k$$$ — минимальное       положительное целое число с этим свойством.</p>     <p>Несколько примеров вычисления периода: для $$$s$$$=«<span class="tex-font-style-tt">0101</span>» период равен $$$k=2$$$, для         $$$s$$$=«<span class="tex-font-style-tt">0000</span>» период       равен $$$k=1$$$, для $$$s$$$=«<span class="tex-font-style-tt">010</span>» период равен $$$k=2$$$, для         $$$s$$$=«<span class="tex-font-style-tt">0011</span>» период       равен $$$k=4$$$. </p>     <p>Вам задана строка $$$t$$$, состоящая только из <span class="tex-font-style-tt">0</span> и <span class="tex-font-style-tt">1</span>, и вам нужно найти такую строку       $$$s$$$, что:</p>          <ol> <li> Строка $$$s$$$ состоит только из <span class="tex-font-style-tt">0</span> и <span class="tex-font-style-tt">1</span>; </li>       <li> Длина $$$s$$$ не превосходит $$$2 \cdot |t|$$$; </li>       <li> Строка $$$t$$$ является подпоследовательностью строки         $$$s$$$; </li>       <li> Строка $$$s$$$ имеет минимальный возможный период среди всех         строк, удовлетворяющих условиям 1—3. </li></ol>          <p>Напомним, что $$$t$$$ является подпоследовательностью $$$s$$$,       если $$$t$$$ можно получить из $$$s$$$ путем удаления нуля или       более элементов (любых) и не меняя порядок оставшихся элементов.       Например, $$$t$$$=«<span class="tex-font-style-tt">011</span>» —       это подпоследовательность строки $$$s$$$=«<span class="tex-font-style-tt">10101</span>».</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке задано единственное целое число $$$T$$$ ($$$1 \le       T \le 100$$$) — количество наборов входных данных.</p>     <p>В следующих $$$T$$$ строках заданы сами наборы — по одному на       строку. В каждой строке задана строка $$$t$$$ ($$$1 \le |t| \le       100$$$), состоящая только из <span class="tex-font-style-tt">0</span> и <span class="tex-font-style-tt">1</span>.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите по одной строке на каждый набор входных данных — строку       $$$s$$$, которую вам надо найти. Если существует несколько решений       — выведите любое из них.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
00
01
111
110
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
00
01
11111
1010</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом и втором наборе $$$s = t$$$, так как это уже одни из       оптимальных решений. Периоды ответов равны $$$1$$$ и $$$2$$$, соответственно.</p>     <p>В третьем наборе, есть и другие более короткие ответы, но все в       порядке, потому что не требуется минимизировать ответ $$$s$$$.       Строка $$$s$$$ имеет период $$$1$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1342/problem/B' title='Educational Codeforces Round 86 (Rated for Div. 2)'>1342B - Binary Period</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's see how strings with periods $$$k = 1$$$ and $$$k = 2$$$       look. There are two types of strings with a period equal to       $$$1$$$: <span class="tex-font-style-tt">0000...</span> and <span class="tex-font-style-tt">1111...</span>. And there are two types       of strings with a period equal to $$$2$$$: <span class="tex-font-style-tt">01010...</span> and <span class="tex-font-style-tt">10101...</span>.</p>     <p>It's easy to see if $$$t$$$ consists only of <span class="tex-font-style-tt">0</span>'s (<span class="tex-font-style-tt">1</span>'s) then the string itself is an       answer since it has period equal to $$$1$$$. Otherwise, it's also       quite obvious that any string $$$t$$$ is a subsequence of <span class="tex-font-style-tt">0101...01</span> (<span class="tex-font-style-tt">1010...10</span>) of $$$2|t|$$$ length.</p></div></div></div>

           
            <pre><code>fun main() {
    val T = readLine()!!.toInt()
    for (tc in 1..T) {
        val t = readLine()!!

        val s = t.toCharArray().distinct().joinToString(&#34;&#34;).repeat(t.length)
        println(s)
    }
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 86 (рейтинговый для Див. 2)
    1342C
    Очередная задача на подсчет </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Очередная задача на подсчет</div>     <div class="time-limit"><div class="property-title">ограничение по времени на       тест</div>3.5 секунд</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам даны два числа $$$a$$$ и $$$b$$$, а также $$$q$$$ запросов.       $$$i$$$-й запрос состоит из двух чисел $$$l_i$$$ и $$$r_i$$$, и       ответ на него — количество таких целых чисел $$$x$$$, что $$$l_i       \le x \le r_i$$$ и $$$((x \bmod a) \bmod b) \ne ((x \bmod b) \bmod       a)$$$. Вычислите ответ на каждый запрос.</p>     <p>Напоминаем, что $$$y \bmod z$$$ — остаток от деления $$$y$$$       на $$$z$$$. Например, $$$5 \bmod 3 = 2$$$, $$$7 \bmod 8 = 7$$$,       $$$9 \bmod 4 = 1$$$, $$$9 \bmod 9 = 0$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке задано одно целое число $$$t$$$ ($$$1 \le t \le       100$$$) — количество наборов входных данных. Затем следуют сами наборы.</p>     <p>Первая строка каждого набора содержит три целых числа $$$a$$$,       $$$b$$$ и $$$q$$$ ($$$1 \le a, b \le 200$$$; $$$1 \le q \le 500$$$).</p>     <p>Затем следуют $$$q$$$ строк, каждая из которых содержит два числа       $$$l_i$$$ и $$$r_i$$$ ($$$1 \le l_i \le r_i \le 10^{18}$$$) для       очередного запроса.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите $$$q$$$ целых чисел —       ответы на запросы в том порядке, в котором они задаются.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
4 6 5
1 1
1 3
1 5
1 7
1 9
7 10 2
7 8
100 200
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0 0 0 2 4 
0 91 
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1342/problem/C' title='Educational Codeforces Round 86 (Rated for Div. 2)'>1342C - Yet Another Counting Problem</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>It's quite easy to see that $$$((ab + x) \bmod a) \bmod b = (x       \bmod a) \bmod b$$$. What does it mean? The property given in the       statement holds for $$$x$$$ if and only if it holds for $$$x \bmod       ab$$$. It allows us to answer each testcase in $$$O(ab + q)$$$ as       follows: for each number from $$$0$$$ to $$$ab - 1$$$, we may       check the given property before processing the queries, and build       an array of prefix sums on it to efficiently count the number of       integers satisfying the property from the segment $$$[0, y]$$$,       where $$$y &lt; ab$$$. Then each query $$$[l, r]$$$ can be divided       into two prefix-queries $$$[0, l - 1]$$$ and $$$[0, r]$$$. To       answer a prefix query $$$[0, p]$$$ in $$$O(1)$$$, we can calculate       the number of &quot;full segments&quot; of length $$$ab$$$ inside       this prefix (that is $$$\lfloor \frac{p}{ab} \rfloor$$$) and the       length of the last segment of numbers that don't belong into a       full segment (that is $$$p \bmod ab$$$). To handle full segments,       we multiply the number of integers satisfying the property on one       segment by the number of such segments, and to handle the last       part of segment, we use prefix sums.</p></div></div></div>

           
            <pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;

const int N = 40043;

int len;
int p[N];

void build(int a, int b)
{
	len = a * b;
	p[0] = 0;
	for(int i = 1; i &lt;= len; i++)
	{
		p[i] = p[i - 1];
		if((i % a) % b != (i % b) % a)
			p[i]++;
	}
}

long long query(long long l)
{
	long long cnt = l / len;
	int rem = l % len;
	return p[len] * 1ll * cnt + p[rem]; 
}

long long query(long long l, long long r)
{
	return query(r) - query(l - 1);
}

int main()
{
	int t;
	cin &gt;&gt; t;
	for(int i = 0; i &lt; t; i++)
	{
		int a, b, q;
		cin &gt;&gt; a &gt;&gt; b &gt;&gt; q;
		build(a, b);
		long long l, r;
		for(int j = 0; j &lt; q; j++)
		{
			cin &gt;&gt; l &gt;&gt; r;
			cout &lt;&lt; query(l, r) &lt;&lt; &#34; &#34;;
		}
		cout &lt;&lt; endl;
	}
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 86 (рейтинговый для Див. 2)
    1342D
    Наборы входных данных </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Наборы входных данных</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Итак, вы решили провести свой раунд на Codeforces. Приготовили       задачи: условия, решения, чекеры, валидаторы, тесты... И тут       внезапно ваш координатор просит вас заменить все ваши тесты в       самой простой задачи на наборы входных данных!</p>     <p>Изначально каждый тест в данной задаче — это просто массив.       Максимальный размер массива равен $$$k$$$. Для простоты будем       считать, что содержимое массива не важно. У вас есть $$$n$$$       тестов; $$$i$$$-й тест — это массив размера $$$m_i$$$ ($$$1 \le       m_i \le k$$$).</p>     <p>Ваш координатор просит вас распределить все ваши массивы по       нескольким наборам входных данных. Каждый набор может включать в       себя несколько массивов. Однако, в каждом наборе входных данных       должно быть не больше $$$c_1$$$ массивов размера <span class="tex-font-style-bf">больше или равного $$$1$$$</span>       ($$$\ge 1$$$), не больше $$$c_2$$$ массивов размера <span class="tex-font-style-bf">больше или равного $$$2$$$</span>,       $$$\dots$$$, не больше $$$c_k$$$ массивов размера <span class="tex-font-style-bf">больше или равного $$$k$$$</span>.       Также $$$c_1 \ge c_2 \ge \dots \ge c_k$$$.</p>     <p>Теперь ваша задача — составить новые наборы входных данных так,       чтобы: </p>     <ul> <li> каждый из изначальных массивов встречается <span class="tex-font-style-bf">ровно в одном</span> наборе входных         данных; </li>       <li> для каждого набора тестовых данных выполняются приведенные         условия; </li>       <li> количество наборов тестовых данных минимально возможно. </li></ul>          <p>Выведите минимальное количество наборов тестовых данных, которое       можно достичь, а также размеры массивов в каждом наборе входных данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записаны два целых числа $$$n$$$ и $$$k$$$ ($$$1       \le n, k \le 2 \cdot 10^5$$$) — изначальное количество тестов и       ограничение на размер каждого массива.</p>     <p>Во второй строке записаны $$$n$$$ целых чисел $$$m_1, m_2, \dots,       m_n$$$ ($$$1 \le m_i \le k$$$) — размеры массивов в изначальных тестах.</p>     <p>В третьей строке записаны $$$k$$$ целых чисел $$$c_1, c_2, \dots,       c_k$$$ ($$$n \ge c_1 \ge c_2 \ge \dots \ge c_k \ge 1$$$);       $$$c_i$$$ — это максимальное количество массивов размера больше       или равного $$$i$$$, которые могут быть внутри одного набора       входных данных.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>В первой строке выведите одно целое число $$$ans$$$ ($$$1 \le ans       \le n$$$) — минимальное количество наборов входных данных, которое       можно достичь.</p>     <p>Каждая из следующих $$$ans$$$ строк должна содержать описание       набора входных данных в следующем формате:</p>     <p>$$$t$$$ $$$a_1$$$ $$$a_2$$$ $$$\dots$$$ $$$a_{t}$$$ ($$$1 \le       t\le n$$$) — в наборе входных данных содержится $$$t$$$ массивов,       $$$a_i$$$ — это размер $$$i$$$-го массива в этом наборе входных данных.</p>     <p>Каждый из изначальных массивов должен содержаться в <span class="tex-font-style-bf">ровно одном</span> наборе входных       данных. В частности, это подразумевает, что сумма всех значений       $$$t$$$ по всем $$$ans$$$ наборам входных данных должна быть равна $$$n$$$.</p>     <p>Обратите внимание, что ответ существует всегда, потому что $$$c_k       \ge 1$$$ (а следовательно $$$c_1 \ge 1$$$).</p>     <p>Если существует несколько решений, выведите любое из них.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4 3
1 2 2 3
4 1 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
1 2
2 1 3
1 2
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
6 10
5 8 1 10 8 7
6 6 4 4 3 2 2 2 1 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
3 8 5 7
3 10 8 1
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5 1
1 1 1 1 1
5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
5 1 1 1 1 1
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5 1
1 1 1 1 1
1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
5
1 1
1 1
1 1
1 1
1 1
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере не существует способа распределить все тесты по       меньше, чем $$$3$$$, наборам входных данных. Данный ответ       удовлетворяет всем условиям: в каждом наборе входных данных не       больше $$$4$$$ массивов размера больше или равного $$$1$$$ и не       больше $$$1$$$ массива размера больше или равного $$$2$$$ и $$$3$$$.</p>     <p>Обратите внимание, что существует несколько правильных ответов на       данный тест. Например, наборы входных данных с размерами $$$[[2],       [1, 2], [3]]$$$ тоже будут правильными.</p>     <p>Однако, наборы тестовых данных с размерами $$$[[1, 2], [2, 3]]$$$       будут неправильными, потому что во втором наборе входных данных       есть $$$2$$$ массива размера больше или равного $$$2$$$.</p>     <p>Обратите внимание на разницу между третьим и четвертым примером.       В третьем примере можно собрать до $$$5$$$ массивов размера больше       или равного $$$1$$$ в набор входных данных, поэтому одного набора       достаточно. А в четвертом примере можно иметь не больше $$$1$$$       массива. Поэтому каждый массив приходится выделять в отдельный       набор входных данных.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1342/problem/D' title='Educational Codeforces Round 86 (Rated for Div. 2)'>1342D - Multiple Testcases</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's estimate the smallest possible achievable answer. Let the       number of the arrays of size greater than or equal to $$$i$$$ be       $$$g_i$$$. The answer is maximum $$$\lceil \frac{g_i}{c_i}       \rceil$$$ over all $$$i$$$ from $$$1$$$ to $$$k$$$. You can prove       that you can't fit $$$g_i$$$ arrays in less than $$$\lceil       \frac{g_i}{c_i} \rceil$$$ testcases with the pigeonhole principle.       Let that be called $$$ans$$$.</p>     <p>Ok, let's now construct the solution for that estimate. Sort       arrays in the increasing or decreasing order and assign the       $$$i$$$-th array ($$$0$$$-indexed) in that order to the       $$$i~mod~ans$$$ testcase. It's easy to see that for any $$$i$$$       the number of arrays of size greater than or equal to $$$i$$$ is       always restricted by $$$\lceil \frac{g_i}{c_i} \rceil$$$.</p>     <p>Overall complexity: $$$O(n \log n + k)$$$ or $$$O(n + k)$$$ if       you care enough to do counting sort.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

#define forn(i, n) for (int i = 0; i &lt; int(n); i++)

using namespace std;


int main() {
	int n, k;
	scanf(&#34;%d%d&#34;, &amp;n, &amp;k);
	vector&lt;int&gt; a(n);
	forn(i, n) scanf(&#34;%d&#34;, &amp;a[i]);
	vector&lt;int&gt; c(k + 1);
	forn(i, k) scanf(&#34;%d&#34;, &amp;c[i + 1]);
	
	sort(a.begin(), a.end(), greater&lt;int&gt;());
	int ans = 0;
	for (int i = k, g = 0; i &gt;= 1; --i){
		while (g &lt; n &amp;&amp; a[g] == i) ++g;
		ans = max(ans, (g + c[i] - 1) / c[i]);
	}
	vector&lt;vector&lt;int&gt;&gt; res(ans);
	forn(i, n) res[i % ans].push_back(a[i]);
	
	printf(&#34;%d\n&#34;, ans);
	forn(i, ans){
		printf(&#34;%d&#34;, int(res[i].size()));
		for (auto it : res[i])
			printf(&#34; %d&#34;, it);
		puts(&#34;&#34;);
	}
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 86 (рейтинговый для Див. 2)
    1342E
    Расстановка ладей </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. Расстановка ладей</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Посчитайте количество способов расставить $$$n$$$ ладей на доске       $$$n \times n$$$ так, что выполняются оба следующих условия:</p>          <ul> <li> все пустые клетки атакованы; </li>       <li> ровно $$$k$$$ пар ладей атакуют друг друга. </li></ul>          <p>Пустая клетка считается атакованной, если хотя бы одна ладья       находится в той же строке или в том же столбце. Две ладьи атакуют       друг друга, если они находятся в одной и той же строке или в одном       и том же столбце, <span class="tex-font-style-it">и между ними нет         других ладей</span>. Например, на следующей картинке можно найти       только две пары ладей, атакующих друг друга:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/39e963e792c25d833bed0b97bbe92cc970fe9f67.png" style="max-width: 100.0%;max-height: 100.0%;"/>         <span class="tex-font-size-small">Один из способов расставить         ладьи при $$$n = 3$$$ и $$$k = 2$$$</span> </center>          <p>Два способа считаются различными, если существует хотя бы одна       клетка, которая свободна в одном из способов и занята ладьей в       другом способе.</p>     <p>Ответ может быть очень большим, поэтому выведите его по модулю $$$998244353$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Единственная строка входных данных содержит два целых числа       $$$n$$$ и $$$k$$$ ($$$1 \le n \le 200000$$$; $$$0 \le k \le       \frac{n(n - 1)}{2}$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одно число — количество способов расставить ладьи,       взятое по модулю $$$998244353$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
6
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
3 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
4 0
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
24
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
1337 42
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
807905441
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1342/problem/E' title='Educational Codeforces Round 86 (Rated for Div. 2)'>1342E - Placing Rooks</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>If we want to place $$$n$$$ rooks on an $$$n \times n$$$       chessboard so all empty cells are under attack, then either each       row or each column should contain at least one rook. Let's suppose       that each row contains at least one rook, and multiply the answer       by $$$2$$$ in the end.</p>     <p>How to ensure that there are exactly $$$k$$$ pairs of rooks       attacking each other? Since each row contains exactly one rook,       only the rooks in the same column attack each other — moreover, if       there are $$$x$$$ rooks in a non-empty column, they create $$$(x -       1)$$$ pairs. So our goal is to distribute $$$n$$$ rooks to $$$n -       k$$$ columns so that each column contains at least one rook.</p>     <p>How to calculate the number of ways to distribute the rooks into       $$$c$$$ columns? One of the options is to choose the columns we       use (the number of ways to do this is $$${n}\choose{c}$$$), and       then use inclusion-exclusion to ensure that we are counting only       the ways where each column contains at least one rook. The formula       we will get is something like $$$\sum \limits_{i = 0}^{c} (-1)^i       {{c}\choose{i}} (c-i)^n$$$: we want to fix the number of columns       that will not contain rooks (that is $$$i$$$), which are these       columns (that is $$${c}\choose{i}$$$), and how many are there ways       to distribute the rooks among remaining columns (that is $$$(c-i)^n$$$).</p>     <p>Are we done? Almost. We wanted to multiply the answer by $$$2$$$       to count the ways where each column contains at least one rook,       but we should not do it if $$$k = 0$$$, because in this case each       placement of the rooks has exactly one rook in each row and       exactly one rook in each column.</p></div></div></div>

           
            <pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;

const int MOD = 998244353;
const int N = 200043;

int add(int x, int y)
{
	return (x + y) % MOD;
}

int sub(int x, int y)
{
	return add(x, MOD - y);
}

int mul(int x, int y)
{
	return (x * 1ll * y) % MOD;
}

int binpow(int x, int y)
{
	int z = 1;
	while(y &gt; 0)
	{
		if(y % 2 == 1)
			z = mul(z, x);
		x = mul(x, x);
		y /= 2;
	}
	return z;
}

int inv(int x)
{
	return binpow(x, MOD - 2);
}

int fact[N];

int C(int n, int k)
{
	return mul(fact[n], inv(mul(fact[k], fact[n - k])));
}

int main()
{
	int n, k;
	cin &gt;&gt; n &gt;&gt; k;
	
	if(k &gt; n - 1)
	{
		cout &lt;&lt; 0 &lt;&lt; endl;
		return 0;
	}
	
	fact[0] = 1;
	for(int i = 1; i &lt;= n; i++)
		fact[i] = mul(i, fact[i - 1]);
	int ans = 0;
	int c = n - k;
	for(int i = c; i &gt;= 0; i--)
		if(i % 2 == c % 2)
			ans = add(ans, mul(binpow(i, n), C(c, i)));
		else
			ans = sub(ans, mul(binpow(i, n), C(c, i)));
	ans = mul(ans, C(n, c));
	if(k &gt; 0)
		ans = mul(ans, 2);
	cout &lt;&lt; ans &lt;&lt; endl;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 86 (рейтинговый для Див. 2)
    1342F
    Сделай возрастающим </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Сделай возрастающим</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>7 секунд</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Дан массив $$$a$$$, состоящий из $$$n$$$ целых чисел. Вы можете       применить несколько операций к этому массиву (возможно, ни одной).</p>     <p>Во время каждой операции вы выбираете два индекса $$$i$$$ и       $$$j$$$ ($$$1 \le i, j \le n$$$; $$$i \ne j$$$), увеличиваете       $$$a_j$$$ на $$$a_i$$$, а затем удаляете $$$i$$$-й элемент из       массива (при этом индексы всех элементов правее удаляемого       уменьшаются на $$$1$$$, и размер массива $$$n$$$ также уменьшается       на $$$1$$$).</p>     <p>Ваша цель — сделать массив $$$a$$$ строго возрастающим, то есть       должно выполняться условие $$$a_1 &lt; a_2 &lt; \dots &lt; a_n$$$       (где $$$n$$$ — итоговый размер массива).</p>     <p>Посчитайте минимальное количество операций, которое требуется,       чтобы массив стал возрастающим.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке задано одно целое число $$$T$$$ ($$$1 \le T \le       10000$$$) — количество наборов входных данных.</p>     <p>Каждый набор входных данных состоит из двух строк. Первая строка       содержит одно целое число $$$n$$$ ($$$1 \le n \le 15$$$) —       количество элементов в исходном массиве $$$a$$$.</p>     <p>Вторая строка содержит $$$n$$$ целых чисел $$$a_1$$$, $$$a_2$$$,       ..., $$$a_n$$$ ($$$1 \le a_i \le 10^6$$$).</p>     <p>Гарантируется, что: </p>     <ul> <li> количество наборов тестовых данных, в которых $$$n \ge         5$$$, не превосходит $$$5000$$$; </li>       <li> количество наборов тестовых данных, в которых $$$n \ge 8$$$,         не превосходит $$$500$$$; </li>       <li> количество наборов тестовых данных, в которых $$$n \ge 10$$$,         не превосходит $$$100$$$; </li>       <li> количество наборов тестовых данных, в которых $$$n \ge 11$$$,         не превосходит $$$50$$$; </li>       <li> количество наборов тестовых данных, в которых $$$n \ge 12$$$,         не превосходит $$$25$$$; </li>       <li> количество наборов тестовых данных, в которых $$$n \ge 13$$$,         не превосходит $$$10$$$; </li>       <li> количество наборов тестовых данных, в которых $$$n \ge 14$$$,         не превосходит $$$3$$$; </li>       <li> количество наборов тестовых данных, в которых $$$n \ge 15$$$,         не превосходит $$$1$$$. </li></ul></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>На каждый набор тестовых данных выведите ответ следующим образом:</p>     <p>Сначала выведите $$$k$$$ — минимальное количество операций,       которые вы должны сделать. Затем выведите $$$k$$$ строк, каждая из       которых содержит два индекса $$$i$$$ и $$$j$$$ для соответствующей       операции. Обратите внимание, что нумерация элементов меняется       после удаления элемента из массива. Если существует несколько       оптимальных последовательностей операций, выведите любую из них.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
8
2 1 3 5 1 2 4 5
15
16384 8192 4096 2048 1024 512 256 128 64 32 16 8 4 2 1
2
3 3
14
1 2 3 4 5 6 7 8 9 10 11 12 13 14
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
6 8
1 6
4 1
7
1 15
1 13
1 11
1 9
1 7
1 5
1 3
1
2 1
0
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе тестовых данных $$$a$$$ меняется следующим образом:</p>     <p>$$$[2, 1, 3, 5, 1, 2, 4, 5] \rightarrow [2, 1, 3, 5, 1, 4, 7]       \rightarrow [1, 3, 5, 1, 6, 7] \rightarrow [2, 3, 5, 6, 7]$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1342/problem/F' title='Educational Codeforces Round 86 (Rated for Div. 2)'>1342F - Make It Ascending</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Suppose we don't have any constraints on the order of elements,       the resulting array just should not contain any duplicates. Let's       build the result one element after another in ascending order, so       each element we create is strictly greater than the previous. To       create an element, just use some subset of elements and merge them       into new element. This process can be efficiently modeled with the       following dynamic programming: $$$dp_{cnt, mask}$$$ is the minimum       value of the last element, if we merged all the elements from       $$$mask$$$ into $$$cnt$$$ ascending numbers. To model transitions,       we simply iterate on the mask of elements that will be merged into       a new one, and check if its sum is greater than the last element       we created. This runs in $$$O(n3^n)$$$, if we use an efficient way       to iterate on all masks that don't intersect with the given mask.</p>     <p>Okay, how about maintaining the order? When we create an element       by merging some elements of the original array, let's choose some       position of an element we use in merging and state that all other       elements are added to it. Then, to ensure that the result is       ascending, the position of this element should be greater than the       position of the element we chose while building the previous       number. We can add the position we have chosen for the last       element to the states of our dynamic programming, so it becomes       $$$dp_{cnt, mask, pos}$$$ — the minimum value of the last element,       if we merged the $$$mask$$$ of elements into $$$cnt$$$ numbers,       and the last element originally had index $$$pos$$$ in the array.</p>     <p>Using some greedy optimizations (for example, we should not       iterate on the position we are choosing to merge — it can be       chosen greedily as the leftmost position after the position of       previous element we are taking into consideration), we can make it       $$$O(n^2 3^n)$$$, yet with a small constant factor. To restore the       answer, we can maintain the previous values of $$$mask$$$ and       $$$pos$$$ in each state, since $$$cnt$$$ just increases by $$$1$$$       with each transition.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

#define x first
#define y second
#define mp make_pair
#define pb push_back
#define sz(a) int((a).size())
#define forn(i, n) for (int i = 0; i &lt; int(n); ++i)

typedef pair&lt;int, int&gt; pt;

const int INF = 1e9;
const int N = 15;

int n;
int a[N];
int sum[1 &lt;&lt; N];
int dp[N + 1][1 &lt;&lt; N][N + 1];
pt p[N + 1][1 &lt;&lt; N][N + 1];

void solve() {
	scanf(&#34;%d&#34;, &amp;n);
	forn(i, n) scanf(&#34;%d&#34;, &amp;a[i]);
	
	forn(mask, 1 &lt;&lt; n) {
		sum[mask] = 0;
		forn(i, n) if (mask &amp; (1 &lt;&lt; i))
			sum[mask] += a[i];
	}	
	
	forn(cnt, n + 1) forn(mask, 1 &lt;&lt; n) forn(pos, n + 1)
		dp[cnt][mask][pos] = INF;
	
	dp[0][0][0] = 0;
	forn(cnt, n) forn(mask, 1 &lt;&lt; n) forn(pos, n) if (dp[cnt][mask][pos] &lt; INF) {
		int rmask = mask ^ ((1 &lt;&lt; n) - 1);
		for (int nmask = rmask; nmask; nmask = (nmask - 1) &amp; rmask) {
			if (sum[nmask] &lt;= dp[cnt][mask][pos])
				continue;
			if ((nmask &gt;&gt; pos) == 0)
				continue;
			int npos = pos + __builtin_ctz(nmask &gt;&gt; pos) + 1;
			if (dp[cnt + 1][mask | nmask][npos] &gt; sum[nmask]) {
				dp[cnt + 1][mask | nmask][npos] = sum[nmask];
				p[cnt + 1][mask | nmask][npos] = mp(mask, pos);
			}
		}
	}
	
	int acnt = 0, apos = 0;
	forn(cnt, n + 1) forn(pos, n + 1) if (dp[cnt][(1 &lt;&lt; n) - 1][pos] &lt; INF)
		acnt = cnt, apos = pos;
		
	vector&lt;pt&gt; ans;
	
	int mask = (1 &lt;&lt; n) - 1, pos = apos;
	for (int cnt = acnt; cnt &gt; 0; --cnt) {
		int nmask = p[cnt][mask][pos].x;
		int npos = p[cnt][mask][pos].y;
		forn(i, n) if ((nmask ^ mask) &amp; (1 &lt;&lt; i))
			if (i != pos - 1) ans.pb(mp(i, pos - 1));
		mask = nmask, pos = npos;
	}
	
	
	printf(&#34;%d\n&#34;, sz(ans));
	forn(i, sz(ans)) {
		int from = ans[i].x;
		forn(j, i) from -= ans[j].x &lt; ans[i].x;
		int to = ans[i].y;
		forn(j, i) to -= ans[j].x &lt; ans[i].y;
		printf(&#34;%d %d\n&#34;, from + 1, to + 1);
	}
}	

int main() {
	int tc;
	scanf(&#34;%d&#34;, &amp;tc);
	forn(i, tc) solve();
		
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #636 (Div. 3)
    1343A
    Конфеты </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Конфеты</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Недавно Вова нашел $$$n$$$ фантиков от конфет. Он помнит, что он       покупал $$$x$$$ конфет в первый день, $$$2x$$$ конфет во второй       день, $$$4x$$$ конфет в третий день, $$$\dots$$$, $$$2^{k-1} x$$$       конфет в $$$k$$$-й день. Но есть проблема: Вова не помнит ни       $$$x$$$, ни $$$k$$$, но он уверен, что $$$x$$$ и $$$k$$$ —       положительные целые числа и $$$k &gt; 1$$$.</p>     <p>Вова будет удовлетворен, если вы назовете ему <span class="tex-font-style-bf">любое положительное</span> целое число       $$$x$$$ такое, что существует целое число $$$k&gt;1$$$, при       котором $$$x + 2x + 4x + \dots + 2^{k-1} x = n$$$. Гарантируется,       что существует как минимум одно решение. <span class="tex-font-style-bf">Обратите внимание: $$$k &gt; 1$$$</span>.</p>     <p>Вам нужно ответить на $$$t$$$ независимых наборов тестовых данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка теста содержит одно целое число $$$t$$$ ($$$1 \le t       \le 10^4$$$) — количество наборов тестовых данных. Затем следуют       $$$t$$$ наборов тестовых данных.</p>     <p>Единственная строка набора тестовых данных содержит одно целое       число $$$n$$$ ($$$3 \le n \le 10^9$$$) — количество конфетных       фантиков, которые нашел Вова. Гарантируется, что существуют       некоторые положительные целые числа $$$x$$$ и $$$k&gt;1$$$ такие,       что $$$x + 2x + 4x + \dots + 2^{k-1} x = n$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одно целое число — <span class="tex-font-style-bf">любое       положительное</span> целое значение $$$x$$$ такое, что существует       целое число $$$k&gt;1$$$, при котором $$$x + 2x + 4x + \dots +       2^{k-1} x = n$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
7
3
6
7
21
28
999999999
999999984
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
2
1
7
4
333333333
333333328
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе тестовых данных примера одним из возможных       ответов является $$$x=1, k=2$$$. Тогда $$$1 \cdot 1 + 2 \cdot 1$$$       равняется $$$n=3$$$.</p>     <p>Во втором наборе тестовых данных примера одним из возможных       ответов является $$$x=2, k=2$$$. Тогда $$$1 \cdot 2 + 2 \cdot 2$$$       равняется $$$n=6$$$.</p>     <p>В третьем наборе тестовых данных примера одним из возможных       ответов является $$$x=1, k=3$$$. Тогда $$$1 \cdot 1 + 2 \cdot 1 +       4 \cdot 1$$$ равняется $$$n=7$$$.</p>     <p>В четвертом наборе тестовых данных примера одним из возможных       ответов является $$$x=7, k=2$$$. Тогда $$$1 \cdot 7 + 2 \cdot 7$$$       равняется $$$n=21$$$.</p>     <p>В пятом наборе тестовых данных примера одним из возможных ответов       является $$$x=4, k=3$$$. Тогда $$$1 \cdot 4 + 2 \cdot 4 + 4 \cdot       4$$$ равняется $$$n=28$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1343/problem/A' title='Codeforces Round 636 (Div. 3)'>1343A - Candies</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Notice that $$$\sum\limits_{i=0}^{k-1} 2^i = 2^k - 1$$$. Thus we       can replace the initial equation with the following: $$$(2^k - 1)       x = n$$$. So we can iterate over all possible $$$k$$$ in range       $$$[2; 29]$$$ (because $$$2^{30} - 1 &gt; 10^9$$$) and check if       $$$n$$$ is divisible by $$$2^k-1$$$. If it is then we can print       $$$x = \frac{n}{2^k-1}$$$.</p>     <p>P.S. I know that so many participants found the formula       $$$\sum\limits_{i=0}^{k-1} 2^i = 2^k - 1$$$ using geometric       progression sum but there is the other way to understand this and       it is a way more intuitive for me. Just take a look at the binary       representation of numbers: we can notice that $$$2^0 = 1, 2^1 =       10, 2^2 = 100$$$ and so on. Thus $$$2^0 = 1, 2^0+2^1=11,       2^0+2^1+2^2=111$$$ and so on. And if we add one to this number       consisting of $$$k$$$ ones then we get $$$2^k$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
	
	int t;
	cin &gt;&gt; t;
	while (t--) {
		int n;
		cin &gt;&gt; n;
		for (int pw = 2; pw &lt; 30; ++pw) {
			int val = (1 &lt;&lt; pw) - 1;
			if (n % val == 0) {
				cerr &lt;&lt; val &lt;&lt; endl;
				cout &lt;&lt; n / val &lt;&lt; endl;
				break;
			}
		}
	}
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #636 (Div. 3)
    1343B
    Сбалансированный массив </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Сбалансированный массив</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам задано положительное целое число $$$n$$$, гарантируется, что       $$$n$$$ четное (то есть делится на $$$2$$$).</p>     <p>Вы хотите построить такой массив $$$a$$$ длины $$$n$$$, что: </p>     <ul> <li> Первые $$$\frac{n}{2}$$$ элементов $$$a$$$ четные (делятся         на $$$2$$$); </li>       <li> вторые $$$\frac{n}{2}$$$ элементов $$$a$$$ нечетные (не         делятся на $$$2$$$); </li>       <li> <span class="tex-font-style-bf">все элементы в $$$a$$$           различны и положительны</span>; </li>       <li> сумма элементов первой половины равна сумме элементов второй         половины ($$$\sum\limits_{i=1}^{\frac{n}{2}} a_i =         \sum\limits_{i=\frac{n}{2} + 1}^{n} a_i$$$). </li></ul>          <p>Если есть несколько ответов, вы можете вывести любой. <span class="tex-font-style-bf">Не гарантируется</span>, что ответ существует.</p>     <p>Вам нужно ответить на $$$t$$$ независимых наборов тестовых данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка теста содержит одно целое число $$$t$$$ ($$$1 \le t       \le 10^4$$$) — количество наборов тестовых данных. Затем следуют       $$$t$$$ наборов тестовых данных.</p>     <p>Единственная строка набора тестовых данных содержит одно целое       число $$$n$$$ ($$$2 \le n \le 2 \cdot 10^5$$$) — длину массива.       Гарантируется, что $$$n$$$ четное (то есть делится на $$$2$$$).</p>     <p>Гарантируется, что сумма чисел $$$n$$$ по всем наборам тестовых       данных не превосходит $$$2 \cdot 10^5$$$ ($$$\sum n \le 2 \cdot 10^5$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите ответ на него —         «<span class="tex-font-style-tt">NO</span>» (без кавычек), если       не существует подходящего ответа для заданного набора, или «<span class="tex-font-style-tt">YES</span>» первой строкой и <span class="tex-font-style-bf">любой</span> подходящий массив $$$a_1,       a_2, \dots, a_n$$$ ($$$1 \le a_i \le 10^9$$$), удовлетворяющий       условиям из условия задачи, второй строкой.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
2
4
6
8
10
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
NO
YES
2 4 1 5
NO
YES
2 4 6 8 1 3 5 11
NO
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1343/problem/B' title='Codeforces Round 636 (Div. 3)'>1343B - Balanced Array</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Firstly, if $$$n$$$ is not divisible by $$$4$$$ then the answer       is &quot;<span class="tex-font-style-tt">NO</span>&quot; because       the parities of halves won't match. Otherwise, the answer is       always &quot;<span class="tex-font-style-tt">YES</span>&quot;.       Let's construct it as follows: firstly, let's create the array       $$$[2, 4, 6, \dots, n, 1, 3, 5, \dots, n - 1]$$$. This array is       almost good except one thing: the sum in the right half is exactly       $$$\frac{n}{2}$$$ less than the sum in the left half. So we can       fix it easily: just add $$$\frac{n}{2}$$$ to the last element.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
	
	int t;
	cin &gt;&gt; t;
	while (t--) {
		int n;
		cin &gt;&gt; n;
		n /= 2;
		if (n &amp; 1) {
			cout &lt;&lt; &#34;NO&#34; &lt;&lt; endl;
			continue;
		}
		cout &lt;&lt; &#34;YES&#34; &lt;&lt; endl;
		for (int i = 1; i &lt;= n; ++i) {
			cout &lt;&lt; i * 2 &lt;&lt; &#34; &#34;;
		}
		for (int i = 1; i &lt; n; ++i) {
			cout &lt;&lt; i * 2 - 1 &lt;&lt; &#34; &#34;;
		}
		cout &lt;&lt; 3 * n - 1 &lt;&lt; endl;
	}
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #636 (Div. 3)
    1343C
    Чередующаяся подпоследовательность </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Чередующаяся подпоследовательность</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Напомним, что последовательность $$$b$$$ является       подпоследовательностью последовательности $$$a$$$, если $$$b$$$       может быть получена из $$$a$$$ путем удаления нуля или более       элементов без изменения порядка оставшихся элементов. Например,       если $$$a=[1, 2, 1, 3, 1, 2, 1]$$$, то возможные       подпоследовательности: $$$[1, 1, 1, 1]$$$, $$$[3]$$$ и $$$[1, 2,       1, 3, 1, 2, 1]$$$, но не $$$[3, 2, 3]$$$ и $$$[1, 1, 1, 1, 2]$$$.</p>     <p>Вам задана последовательность $$$a$$$, состоящая из $$$n$$$       положительных и отрицательных элементов (в последовательности нет нулей).</p>     <p>Ваша задача выбрать <span class="tex-font-style-bf">максимальную         по размеру</span> (длине) <span class="tex-font-style-it">чередующуюся</span>       подпоследовательность заданной последовательности (то есть знак       каждого следующего элемента противоположен знаку текущего       элемента, например, положительный-отрицательный-положительный и       так далее или отрицательный-положительный-отрицательный и так       далее). Из всех таких подпоследовательностей вам нужно выбрать ту,       которая имеет <span class="tex-font-style-bf">максимальную       сумму</span> элементов.</p>     <p>Другими словами, если максимальная длина <span class="tex-font-style-it">чередующейся</span>       подпоследовательности равна $$$k$$$, то ваша задача — найти <span class="tex-font-style-bf">максимальную сумму</span> элементов       какой-то <span class="tex-font-style-it">чередующейся</span>       подпоследовательности длины $$$k$$$.</p>     <p>Вам нужно ответить на $$$t$$$ независимых наборов тестовых данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка теста содержит одно целое число $$$t$$$ ($$$1 \le t       \le 10^4$$$) — количество наборов тестовых данных. Затем следуют       $$$t$$$ наборов тестовых данных.</p>     <p>Первая строка набора тестовых данных содержит одно целое число       $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — количество элементов в       $$$a$$$. Вторая строка набора входных данных содержит $$$n$$$       целых чисел $$$a_1, a_2, \dots, a_n$$$ ($$$-10^9 \le a_i \le 10^9,       a_i \ne 0$$$), где $$$a_i$$$ — $$$i$$$-й элемент в $$$a$$$.</p>     <p>Гарантируется, что сумма чисел $$$n$$$ по всем наборам тестовых       данных не превосходит $$$2 \cdot 10^5$$$ ($$$\sum n \le 2 \cdot 10^5$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите ответ на него — <span class="tex-font-style-bf">максимальную сумму</span> <span class="tex-font-style-bf">максимальной по размеру</span> (длине)         <span class="tex-font-style-it">чередующейся</span>       подпоследовательности $$$a$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
5
1 2 3 -1 -2
4
-1 -2 -1 -3
10
-2 8 3 8 -4 -15 5 -2 -3 1
6
1 -1000000000 1 -1000000000 1 -1000000000
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
-1
6
-2999999997
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе тестовых данных примера одним из возможных       ответов является $$$[1, 2, \underline{3}, \underline{-1}, -2]$$$.</p>     <p>Во втором наборе тестовых данных примера одним из возможных       ответов является $$$[-1, -2, \underline{-1}, -3]$$$.</p>     <p>В третьем наборе тестовых данных примера одним из возможных       ответов является $$$[\underline{-2}, 8, 3, \underline{8},       \underline{-4}, -15, \underline{5}, \underline{-2}, -3, \underline{1}]$$$.</p>     <p>В четвертом наборе тестовых данных примера одним из возможных       ответов является $$$[\underline{1}, \underline{-1000000000},       \underline{1}, \underline{-1000000000}, \underline{1}, \underline{-1000000000}]$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1343/problem/C' title='Codeforces Round 636 (Div. 3)'>1343C - Alternating Subsequence</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Firstly, let's extract maximum by inclusion segments of the array       that consists of the numbers with the same sign. For example, if       the array is $$$[1, 1, 2, -1, -5, 2, 1, -3]$$$ then these segments       are $$$[1, 1, 2]$$$, $$$[-1, -5]$$$, $$$[2, 1]$$$ and $$$[-3]$$$.       We can do it with any &quot;two pointers&quot;-like algorithm. The       number of these segments is the maximum possible length of the       alternating subsequence because we can take only one element from       each block. And as we want to maximize the sum, we need to take       the maximum element from each block.</p>     <p>Time complexity: $$$O(n)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
	
	auto sgn = [&amp;](int x) {
		if (x &gt; 0) return 1;
		else return -1;
	};

	int t;
	cin &gt;&gt; t;
	while (t--) {
		int n;
		cin &gt;&gt; n;
		vector&lt;int&gt; a(n);
		for (auto &amp;it : a) cin &gt;&gt; it;
		long long sum = 0;
		for (int i = 0; i &lt; n; ++i) {
			int cur = a[i];
			int j = i;
			while (j &lt; n &amp;&amp; sgn(a[i]) == sgn(a[j])) {
				cur = max(cur, a[j]);
				++j;
			}
			sum += cur;
			i = j - 1;
		}
		cout &lt;&lt; sum &lt;&lt; endl;
	}
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #636 (Div. 3)
    1343D
    Одинаковая палиндромная сумма </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Одинаковая палиндромная сумма</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам задан массив $$$a$$$, состоящий из $$$n$$$ целых чисел       (гарантируется, что $$$n$$$ четное, то есть делится на $$$2$$$).       Все $$$a_i$$$ не превосходят некоторое число $$$k$$$.</p>     <p>Ваша задача — заменить <span class="tex-font-style-bf">минимальное</span> количество элементов       (под заменой понимается следующая операция: выбрать некоторый       индекс $$$i$$$ от $$$1$$$ до $$$n$$$ и заменить $$$a_i$$$ на       некоторое целое число в отрезке $$$[1; k]$$$) так, чтобы       удовлетворялись следующие условия:</p>          <ul> <li> после всех замен все $$$a_i$$$ — положительные целые         числа, не превосходящие $$$k$$$; </li>       <li> для всех $$$i$$$ от $$$1$$$ до $$$\frac{n}{2}$$$ верно         следующее равенство: $$$a_i + a_{n - i + 1} = x$$$, где $$$x$$$         должен быть <span class="tex-font-style-bf">одинаковым</span>         для всех $$$\frac{n}{2}$$$ пар элементов. </li></ul>          <p>Вам нужно ответить на $$$t$$$ независимых наборов тестовых данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка теста содержит одно целое число $$$t$$$ ($$$1 \le t       \le 10^4$$$) — количество наборов тестовых данных. Затем следуют       $$$t$$$ наборов тестовых данных.</p>     <p>Первая строка набора тестовых данных содержит два целых числа       $$$n$$$ и $$$k$$$ ($$$2 \le n \le 2 \cdot 10^5, 1 \le k \le 2       \cdot 10^5$$$) — длину $$$a$$$ и максимально возможное значение       $$$a_i$$$ соответственно. Гарантируется, что $$$n$$$ четное (то       есть делится на $$$2$$$). Вторая строка набора содержит $$$n$$$       целых чисел $$$a_1, a_2, \dots, a_n$$$ ($$$1 \le a_i \le k$$$),       где $$$a_i$$$ — $$$i$$$-й элемент в $$$a$$$.</p>     <p>Гарантируется, что сумма чисел $$$n$$$ (так же, как и сумма чисел       $$$k$$$) по всем наборам тестовых данных не превосходит $$$2 \cdot       10^5$$$ ($$$\sum n \le 2 \cdot 10^5$$$, $$$\sum k \le 2 \cdot 10^5$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите в ответ на него —         <span class="tex-font-style-bf">минимальное</span> количество       элементов, которое нужно заменить в $$$a$$$, чтобы удовлетворить       все условия задачи.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
4 2
1 2 1 2
4 3
1 2 2 1
8 7
6 1 1 7 6 3 4 6
6 6
5 2 6 1 3 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
1
4
2
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1343/problem/D' title='Codeforces Round 636 (Div. 3)'>1343D - Constant Palindrome Sum</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>It is obvious that if we fix the value of $$$x$$$ then there are       three cases for the pair of elements:</p>          <ol> <li> We don't need to change anything in this pair; </li>       <li> we can replace one element to fix this pair; </li>       <li> we need to replace both elements to fix this pair. </li></ol>          <p>The first part can be calculated easily in $$$O(n+k)$$$, we just       need to create the array of frequencies $$$cnt$$$, where       $$$cnt_x$$$ is the number of such pairs $$$(a_i, a_{n-i+1})$$$       that $$$a_i + a_{n-i+1} = x$$$.</p>     <p>The second part is a bit tricky but still doable in $$$O(n+k)$$$.       For each pair, let's understand the minimum and the maximum sum we       can obtain using at most one replacement. For the $$$i$$$-th pair,       all such sums belong to the segment $$$[min(a_i, a_{n-i+1})+1;       max(a_i, a_{n-i+1})+k]$$$. Let's make $$$+1$$$ on this segment       using prefix sums (make $$$+1$$$ in the left border, $$$-1$$$ in       the right border plus one and then just compute prefix sums on       this array). Let this array be $$$pref$$$. Then the value       $$$pref_x$$$ tells the number of such pairs that we need to       replace <span class="tex-font-style-bf">at most one</span> element       in this pair to make it sum equals $$$x$$$.</p>     <p>And the last part can be calculated as $$$\frac{n}{2} -       pref_x$$$. So, for the sum $$$x$$$ the answer is $$$(pref_x -       cnt_x) + (\frac{n}{2} - pref_x) \cdot 2$$$. We just need to take       the minimum such value among all possible sums from $$$2$$$ to $$$2k$$$.</p>     <p>There is another one solution that uses scanline, not depends on       $$$k$$$ and works in $$$O(n \log n)$$$ but it has no cool ideas to       explain it here (anyway the main idea is almost the same as in the       solution above).</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
	
	int t;
	cin &gt;&gt; t;
	while (t--) {
		int n, k;
		cin &gt;&gt; n &gt;&gt; k;
		vector&lt;int&gt; a(n);
		for (auto &amp;it : a) cin &gt;&gt; it;
		vector&lt;int&gt; cnt(2 * k + 1);
		for (int i = 0; i &lt; n / 2; ++i) {
			++cnt[a[i] + a[n - i - 1]];
		}
		vector&lt;int&gt; pref(2 * k + 2);
		for (int i = 0; i &lt; n / 2; ++i) {
			int l1 = 1 + a[i], r1 = k + a[i];
			int l2 = 1 + a[n - i - 1], r2 = k + a[n - i - 1];
			assert(max(l1, l2) &lt;= min(r1, r2));
			++pref[min(l1, l2)];
			--pref[max(r1, r2) + 1];
		}
		for (int i = 1; i &lt;= 2 * k + 1; ++i) {
			pref[i] += pref[i - 1];
		}
		int ans = 1e9;
		for (int sum = 2; sum &lt;= 2 * k; ++sum) {
			ans = min(ans, (pref[sum] - cnt[sum]) + (n / 2 - pref[sum]) * 2);
		}
		cout &lt;&lt; ans &lt;&lt; endl;
	}
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #636 (Div. 3)
    1343E
    Распределение весов </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. Распределение весов</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам задан неориентированный невзвешенный граф, состоящий из       $$$n$$$ вершин и $$$m$$$ ребер (который представляет карту       Бертауна), а также массив цен $$$p$$$ длины $$$m$$$.       Гарантируется, что между каждой парой вершин (районов) существует путь.</p>     <p>Майк планирует совершить путешествие из вершины (района) $$$a$$$       в вершину (район) $$$b$$$, а затем из вершины (района) $$$b$$$ в       вершину (район) $$$c$$$. Он может посещать один и тот же район       дважды или даже большее число раз. Но есть небольшая проблема:       власти города хотят ввести цену за использование дорог, таким       образом, что если кто-то проходит по ней, то он должен заплатить       цену, соответствующую этой дороге (<span class="tex-font-style-bf">он платит каждый раз, когда проходит         по дороге</span>). Список используемых цен $$$p$$$ готов и они       просто хотят распределить его между всеми дорогами в городе таким       образом, что каждая цена из массива соответствует ровно одной дороге.</p>     <p>Вы являетесь хорошим другом Майка (и, внезапно, мэром Бертауна) и       хотите помочь сделать его путешествие настолько дешевым, насколько       это возможно. Таким образом, ваша задача заключается в том, чтобы       распределить цены между дорогами таким образом, что если Майк       выберет оптимальный путь, то цена его путешествия будет <span class="tex-font-style-bf">минимально</span> возможной. <span class="tex-font-style-bf">Заметьте, что вы не можете         перераспределять цены после после начала путешествия</span>.</p>     <p>Вам необходимо ответить на $$$t$$$ независимых наборов тестовых данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка входных данных содержит одно целое число $$$t$$$       ($$$1 \le t \le 10^4$$$) — количество наборов тестовых данных.       Затем следуют $$$t$$$ наборов тестовых данных.</p>     <p>Первая строка набора тестовых данных содержит пять целых чисел       $$$n, m, a, b$$$ и $$$c$$$ ($$$2 \le n \le 2 \cdot 10^5$$$, $$$n-1       \le m \le min(\frac{n(n-1)}{2}, 2 \cdot 10^5)$$$, $$$1 \le a, b, c       \le n$$$) — количество вершин, количество ребер и районы в       путешествии Майка.</p>     <p>Вторая строка набора тестовых данных содержит $$$m$$$ целых чисел       $$$p_1, p_2, \dots, p_m$$$ ($$$1 \le p_i \le 10^9$$$), где       $$$p_i$$$ равно $$$i$$$-й цене из массива.</p>     <p>Следующие $$$m$$$ строк набора тестовых данных описывают ребра:       ребро $$$i$$$ предствалено парой целых чисел $$$v_i$$$, $$$u_i$$$       ($$$1 \le v_i, u_i \le n$$$, $$$u_i \ne v_i$$$), которые означают       индексы вершин, соединенных ребром. Гарантируется, что в графе не       существует петель и кратных ребер, то есть для каждой пары       ($$$v_i, u_i$$$) в списке ребер не существует других пар ($$$v_i,       u_i$$$) или ($$$u_i, v_i$$$), а также для каждой пары $$$(v_i,       u_i)$$$ выполняется условие $$$v_i \ne u_i$$$. Гарантируется, что       заданный граф является связным.</p>     <p>Гарантируется, что сумма $$$n$$$ (также как и сумма $$$m$$$) не       превосходит $$$2 \cdot 10^5$$$ ($$$\sum n \le 2 \cdot 10^5$$$,       $$$\sum m \le 2 \cdot 10^5$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите ответ на каждый набор тестовых данных — <span class="tex-font-style-bf">минимально</span> возможную цену       путешествия Майка, если вы распределите цены между ребрами оптимально.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
4 3 2 3 4
1 2 3
1 2
1 3
1 4
7 9 1 5 7
2 10 4 8 5 6 7 3 3
1 2
1 3
1 4
3 2
3 5
4 2
5 6
1 7
6 7
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
7
12
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Одно из возможных решение первого набора тестовых данных из примера:</p>     <p>       <img class="tex-graphics" src="https://espresso.codeforces.com/bcd57e84c44bc22ccce7e5005c98f3f1d0fadebf.png" style="max-width: 100.0%;max-height: 100.0%;"/></p>     <p>Одно из возможных решение второго набора тестовых данных из примера:</p>     <p>       <img class="tex-graphics" src="https://espresso.codeforces.com/f1d0f51cf563c458a58154af19f523d4cb7bafc0.png" style="max-width: 100.0%;max-height: 100.0%;"/></p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1343/problem/E' title='Codeforces Round 636 (Div. 3)'>1343E - Weights Distributing</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>If we distribute costs optimally, then this pair of paths ($$$a       \rightarrow b$$$ and $$$b \rightarrow c$$$) can look like just a       straight path that doesn't visit the same vertex twice or like       three straight paths with one intersection point $$$x$$$. The       first case is basically a subcase of the second one (with the       intersection point $$$a, b$$$ or $$$c$$$). So, if we fix the       intersection point $$$x$$$ then these two paths ($$$a \rightarrow       b$$$ and $$$b \rightarrow c$$$) become four paths ($$$a       \rightarrow x$$$, $$$x \rightarrow b$$$, $$$b \rightarrow x$$$ and       $$$x \rightarrow c$$$). We can notice that each path we denoted       should be the shortest possible because if it isn't the shortest       one then we used some prices that we couldn't use.</p>     <p>Let the length of the shortest path from $$$u$$$ to $$$v$$$ be       $$$dist(u, v)$$$. Then it is obvious that for the fixed       intersection point $$$x$$$ we don't need to use more than       $$$dist(a, x) + dist(b, x) + dist(c, x)$$$ smallest costs. Now we       want to distribute these costs between these three paths somehow.       We can see that the path from $$$b$$$ to $$$x$$$ is used twice so       it is more optimally to distribute the smallest costs along this       part. So, let $$$pref_i$$$ be the sum of the first $$$i$$$       smallest costs (just prefix sums on the sorted array $$$p$$$).       Then for the intersection point $$$x$$$ the answer is       $$$pref_{dist(b, x)} + pref_{dist(a, x) + dist(b, x) + dist(c,       x)}$$$ (if $$$dist(a, x) + dist(b, x) + dist(c, x) \le m$$$). We       can calculate distances from $$$a$$$, $$$b$$$ and $$$c$$$ to each       vertex with three runs of bfs.</p>     <p>Time complexity: $$$O(m \log m)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

const int INF = 1e9;

vector&lt;vector&lt;int&gt;&gt; g;

void bfs(int s, vector&lt;int&gt; &amp;d) {
	d[s] = 0;
	queue&lt;int&gt; q;
	q.push(s);
	while (!q.empty()) {
		int v = q.front();
		q.pop();
		for (auto to : g[v]) {
			if (d[to] == INF) {
				d[to] = d[v] + 1;
				q.push(to);
			}
		}
	}
}

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
	
	int t;
	cin &gt;&gt; t;
	while (t--) {
		int n, m, a, b, c;
		cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b &gt;&gt; c;
		--a, --b, --c;
		
		vector&lt;int&gt; p(m);
		for (auto &amp;it : p) cin &gt;&gt; it;
		sort(p.begin(), p.end());
		vector&lt;long long&gt; pref(m + 1);
		for (int i = 0; i &lt; m; ++i) {
			pref[i + 1] = pref[i] + p[i];
		}
		
		g = vector&lt;vector&lt;int&gt;&gt;(n);
		for (int i = 0; i &lt; m; ++i) {
			int x, y;
			cin &gt;&gt; x &gt;&gt; y;
			--x, --y;
			g[x].push_back(y);
			g[y].push_back(x);
		}
		
		vector&lt;int&gt; da(n, INF), db(n, INF), dc(n, INF);
		bfs(a, da);
		bfs(b, db);
		bfs(c, dc);
		
		long long ans = 1e18;
		for (int i = 0; i &lt; n; ++i) {
			if (da[i] + db[i] + dc[i] &gt; m) continue;
			ans = min(ans, pref[db[i]] + pref[da[i] + db[i] + dc[i]]);
		}
		cout &lt;&lt; ans &lt;&lt; endl;
	}
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #636 (Div. 3)
    1343F
    Восстановить перестановку по отсортированным отрезкам </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Восстановить перестановку по отсортированным отрезкам</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Мы загадали перестановку $$$p$$$, состоящую из $$$n$$$ целых       чисел. Перестановкой длины $$$n$$$ называется массив длины       $$$n$$$, где каждый элемент от $$$1$$$ до $$$n$$$ встречается       ровно один раз. Эта перестановка вам неизвестна.</p>     <p>Для каждой позиции $$$r$$$ от $$$2$$$ до $$$n$$$ мы выбрали       некоторый другой индекс $$$l$$$ ($$$l &lt; r$$$) и дали вам       отрезок $$$p_l, p_{l + 1}, \dots, p_r$$$ в <span class="tex-font-style-bf">отсортированном</span> порядке (то есть       мы переставили элементы на этом отрезке так, что элементы на этом       отрезке оказались отсортированными). Таким образом, вам задан       ровно $$$n-1$$$ отрезок первоначальной перестановки, но элементы       внутри каждого отрезка отсортированы. Отрезки даны вам в случайном порядке.</p>     <p>Например, если загаданная перестановка — $$$p=[3, 1, 4, 6, 2,       5]$$$, то возможное заданное множество отрезков:</p>          <ul> <li> $$$[2, 5, 6]$$$ </li>       <li> $$$[4, 6]$$$ </li>       <li> $$$[1, 3, 4]$$$ </li>       <li> $$$[1, 3]$$$ </li>       <li> $$$[1, 2, 4, 6]$$$ </li></ul>          <p>Ваша задача — найти <span class="tex-font-style-bf">любую</span>       подходящую перестановку (то есть любую перестановку,       соответствующую входным данным). Гарантируется, что входные данные       соответствуют некоторой перестановке (то есть перестановка существует).</p>     <p>Вам нужно ответить на $$$t$$$ независимых наборов тестовых данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка теста содержит одно целое число $$$t$$$ ($$$1 \le t       \le 100$$$) — количество наборов тестовых данных. Затем следуют       $$$t$$$ наборов тестовых данных.</p>     <p>Первая строка набора тестовых данных содержит одно целое число       $$$n$$$ ($$$2 \le n \le 200$$$) — длину перестановки.</p>     <p>Следующая $$$n-1$$$ строка описывает заданные отрезки.</p>     <p>$$$i$$$-я строка содержит описание $$$i$$$-го отрезка. Строка       начинается с числа $$$k_i$$$ ($$$2 \le k_i \le n$$$) — длины       $$$i$$$-го отрезка. Затем следуют $$$k_i$$$ целых чисел. Все числа       в строке различны, отсортированы по возрастанию, между $$$1$$$ и       $$$n$$$, включительно.</p>     <p>Гарантируется, что искомая перестановка $$$p$$$ существует для       каждого набора тестовых данных.</p>     <p>Также гарантируется, что сумма чисел $$$n$$$ по всем наборам       тестовых данных не превосходит $$$200$$$ ($$$\sum n \le 200$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите ответ: $$$n$$$ целых       чисел $$$p_1, p_2, \dots, p_n$$$ ($$$1 \le p_i \le n$$$, все       $$$p_i$$$ должны быть различны) — <span class="tex-font-style-bf">любую</span> подходящую перестановку (то       есть любую перестановку, удовлетворяющую входным данным набора       тестовых данных).</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
6
3 2 5 6
2 4 6
3 1 3 4
2 1 3
4 1 2 4 6
5
2 2 3
2 1 2
2 1 4
2 4 5
7
3 1 2 6
4 1 3 5 6
2 1 2
3 4 5 7
6 1 2 3 4 5 6
3 1 3 6
2
2 1 2
5
2 2 5
3 2 3 5
4 2 3 4 5
5 1 2 3 4 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3 1 4 6 2 5 
3 2 1 4 5 
2 1 6 3 5 4 7 
1 2 
2 5 3 4 1 
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1343/problem/F' title='Codeforces Round 636 (Div. 3)'>1343F - Restore the Permutation by Sorted Segments</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's fix the first element and then try to restore permutation       using this information. One interesting fact: if such permutation       exists (with this first element) then it can be restored uniquely.       Let's remove the first element from all segments containing it (we       can use some logarithmic data structure for it). Then we just have       a smaller problem but with one important condition: there is a       segment consisting of one element (again, if such permutation       exists). So, if the number of segments of length $$$1$$$ is zero       or more than one by some reason then there is no answer for this       first element. Otherwise, let's place this segment (a single       element) in second place, remove it from all segments containing       it and just solve a smaller problem again.</p>     <p>If we succeed with restoring the permutation then we need to       check if this permutation really satisfies the given input       segments (see the first test case of the example to understand why       this case appears). Let's just iterate over all $$$i$$$ from       $$$2$$$ to $$$n$$$ and then over all $$$j$$$ from $$$i-1$$$ to       $$$1$$$. If the segment $$$a_j, a_{j+1}, \dots, a_i$$$ is in the       list, remove it and go to the next $$$i$$$. If we can't find the       segment for some $$$i$$$ then this permutation is wrong.</p>     <p>Time complexity: $$$O(n^3 \log n)$$$ (or less, maybe?)</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
	
	int t;
	cin &gt;&gt; t;
	while (t--) {
		int n;
		cin &gt;&gt; n;
		vector&lt;set&lt;int&gt;&gt; segs;
		for (int i = 0; i &lt; n - 1; ++i) {
			set&lt;int&gt; cur;
			int k;
			cin &gt;&gt; k;
			for (int j = 0; j &lt; k; ++j) {
				int x;
				cin &gt;&gt; x;
				cur.insert(x);
			}
			segs.push_back(cur);
		}
		for (int fst = 1; fst &lt;= n; ++fst) {
			vector&lt;int&gt; ans;
			bool ok = true;
			vector&lt;set&lt;int&gt;&gt; cur = segs;
			for (auto &amp;it : cur) if (it.count(fst)) it.erase(fst);
			ans.push_back(fst);
			for (int i = 1; i &lt; n; ++i) {
				int cnt1 = 0;
				int nxt = -1;
				for (auto  &amp;it : cur) if (it.size() == 1) {
					++cnt1;
					nxt = *it.begin();
				}
				if (cnt1 != 1) {
					ok = false;
					break;
				}
				for (auto &amp;it : cur) if (it.count(nxt)) it.erase(nxt);
				ans.push_back(nxt);
			}
			if (ok) {
				set&lt;set&lt;int&gt;&gt; all(segs.begin(), segs.end());
				for (int i = 1; i &lt; n; ++i) {
					set&lt;int&gt; seg;
					seg.insert(ans[i]);
					bool found = false;
					for (int j = i - 1; j &gt;= 0; --j) {
						seg.insert(ans[j]);
						if (all.count(seg)) {
							found = true;
							all.erase(seg);
							break;
						}
					}
					if (!found) ok = false;
				}
			}
			if (ok) {
				for (auto it : ans) cout &lt;&lt; it &lt;&lt; &#34; &#34;;
				cout &lt;&lt; endl;
				break;
			}
		}
	}
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #639 (Div. 1)
    1344A
    Отель Гильберта </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Отель Гильберта</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Отель Гильберта это очень необычный отель, потому что количество       комнат в нем бесконечно! Для каждого целого числа существует ровно       одна комната с таким номером, <span class="tex-font-style-bf">включая ноль и отрицательные       числа</span>. Не менее странно то, что сейчас отель полностью       заполнен, что означает, что в каждой комнате находится ровно один       гость. Менеджер отеля, сам Давид Гильберт, решил переместить       гостей, потому что у него есть предположение, что за счет этого       образуются свободные места.</p>     <p>Для любого целого числа $$$k$$$ и положительного целого числа       $$$n$$$ обозначим за $$$k\bmod n$$$ остаток при делении числа       $$$k$$$ на число $$$n$$$. Более формально, $$$r=k\bmod n$$$ это       наименьшее неотрицательное целое число такое, что $$$k-r$$$       делится на $$$n$$$. Всегда выполнено, что $$$0\le k\bmod n\le       n-1$$$. Например, $$$100\bmod 12=4$$$ и $$$(-1337)\bmod 3=1$$$.</p>     <p>Процесс перемещения гостей выглядит следующим образом: есть       массив, состоящий из $$$n$$$ целых чисел       $$$a_0,a_1,\ldots,a_{n-1}$$$. Тогда для всех целых чисел $$$k$$$       гость из комнаты с номером $$$k$$$ перемещается в комнату с       номером $$$k+a_{k\bmod n}$$$.</p>     <p>Определите, верно ли, что после этого процесса перемещения в       каждой комнате по-прежнему находится ровно один гость. Это       означает, что нет пустых комнат и комнат, в которых больше одного гостя.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Каждый тест состоит из нескольких тестовых случаев. Первая строка       содержит единственное целое число $$$t$$$ ($$$1\le t\le 10^4$$$) —       количество тестовых случаев. Следующие $$$2t$$$ строк содержат       описания тестовых случаев.</p>     <p>В первой строке описания каждого тестового случая находится       единственное целое число $$$n$$$ ($$$1\le n\le 2\cdot 10^5$$$) —       длина массива.</p>     <p>Во второй строке описания каждого тестового случая находятся       $$$n$$$ целых чисел $$$a_0,a_1,\ldots,a_{n-1}$$$ ($$$-10^9\le       a_i\le 10^9$$$).</p>     <p>Гарантируется, что сумма $$$n$$$ по всем тестовым случаям не       превосходит $$$2\cdot 10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого тестового случая выведите единственную строку,       содержащую «<span class="tex-font-style-tt">YES</span>», если в       каждой комнате после перемещения находится ровно один гость, и         «<span class="tex-font-style-tt">NO</span>» иначе. Вы можете       выводить каждый символ в любом регистре.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
1
14
2
1 -1
4
5 5 5 1
3
3 2 1
2
0 1
5
-239 -2 -100 -3 -11
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
YES
YES
YES
NO
NO
YES
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом тестовом случае номер комнаты каждого гостя увеличился       на $$$14$$$, поэтому по-прежнему в каждой комнате находится ровно       один гость.</p>     <p>Во втором тестовом случае гости в комнатах с четными номерами       перемещаются в комнату с номером, на $$$1$$$ большим исходного;       гости в комнатах с нечетными номерами перемещаются в комнату с       номером, на $$$1$$$ меньшим исходного. Можно показать, что       по-прежнему в каждой комнате находится ровно один гость.</p>     <p>В третьем тестовом случае каждый четвертый гость перемещается в       комнату с номером, на $$$1$$$ большим исходного, а остальные гости       перемещаются в комнату с номером, на $$$5$$$ большим. Можно       показать, что по-прежнему в каждой комнате находится ровно один гость.</p>     <p>В четвертом тестовом случае гости, исходно находящиеся в комнатах       $$$0$$$ и $$$1$$$, перемещаются в комнату с номером $$$3$$$.</p>     <p>В пятом тестовом случае гости, находящиеся в комнатах $$$1$$$ и       $$$2$$$, перемещаются в комнату с номером $$$2$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1344/problem/A' title='Codeforces Round 639 (Div. 1)'>1344A - Отель Гильберта</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Suppose that $$$i+a_i\equiv j+a_j\pmod{n}$$$ for some $$$0\le       i&lt;j&lt;n$$$. Then $$$i+a_i=j+a_j+kn$$$ for some integer       $$$k$$$, so the guest in room $$$i$$$ is assigned the same room as       guest $$$j+kn$$$.</p>     <p>Similarly, suppose that two different guests $$$k$$$ and $$$m$$$       are assigned the same room. Then we have $$$i+a_i\equiv       j+a_j\pmod{n}$$$ for $$$i=k\bmod n$$$ and $$$j=m\bmod n$$$.</p>     <p>This proves there is a collision if and only if all $$$i+a_i$$$       are not distinct $$$\pmod n$$$. That is, $$$\{(0+a_0)\bmod       n,(1+a_1)\bmod n,\ldots,(n-1+a_{n-1})\bmod       n\}=\{0,1,\ldots,n-1\}$$$. This is simply checked with a boolean       array to make sure each number from $$$0$$$ to $$$n-1$$$ is included.</p>     <p>Note that there are also no vacancies if this condition holds:       Let $$$k$$$ be some room. Then $$$k\bmod n$$$ must appear in the       array, so there is some $$$i$$$ with $$$i+a_i\equiv k\pmod n$$$.       Then there is an integer $$$m$$$ with $$$i+mn+a_i=k$$$, meaning       guest $$$i+mn$$$ is moved to room $$$k$$$.</p>     <p>Complexity is $$$O(n)$$$.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #639 (Div. 1)
    1344B
    Однополюсные магниты </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Однополюсные магниты</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Однополюсный магнит — это магнит, у которого ровно один полюс:       либо северный, либо южный. Они не существуют в природе, потому что       настоящие магниты имеют два полюса, но это задача по       программированию, поэтому будем считать, что такие магниты существуют.</p>     <p>У вас есть таблица размером $$$n\times m$$$. Изначально вы можете       поставить несколько магнитов с северным полюсом и несколько       магнитов с южным полюсом в некоторые клетки этой таблицы. Вам       разрешено расставлять сколько угодно магнитов, в том числе       несколько в одну клетку.</p>     <p>Можно выполнять следующую операцию: выбрать один магнит с       северным полюсом и один магнит с южным полюсом для активации. Если       они находятся в одной строке или в одном столбце, но занимают       разные клетки, то магнит с северным полюсом переместится на одну       клетку ближе к магниту с южным полюсом. Иначе, если они занимают       одинаковые клетки или не находятся в одной строке или в одном       столбце, то ничего не произойдет. Обратите внимание, что магниты с       южным полюсом неподвижны.</p>     <p>Каждая клетка таблицы покрашена в черный или белый цвет. Будем       рассматривать расстановки магнитов в таблице, для которых       следующие условия будут выполнены.</p>          <ol> <li> В каждой строке и каждом столбце таблицы находится хотя бы         один магнит с южным полюсом. </li>       <li> Если клетка таблицы черная, тогда можно переместить         какой-нибудь магнит с северным полюсом в эту клетку с помощью         некоторой последовательности операций <span class="tex-font-style-bf">из начального расположения         магнитов</span>. </li>       <li> Если клетка таблицы белая, тогда никакой магнит с северным         полюсом невозможно переместить в эту клетку с помощью некоторой         последовательности операций <span class="tex-font-style-bf">из           начального расположения магнитов</span>. </li></ol>          <p>Определите, можно ли расположить магниты в таблице так, что все       условия будут выполнены. Если это возможно, найдите минимальное       количество магнитов с северным полюсом, которое для этого       требуется (минимизировать количество магнитов с южным полюсом не нужно).</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке находятся два целых числа $$$n$$$ и $$$m$$$       ($$$1\le n,m\le 1000$$$)  — количество строк и столбцов в таблице, соответственно.</p>     <p>Следующие $$$n$$$ строк описывают раскраску таблицы: $$$i$$$-я из       этих строк содержит строку длины $$$m$$$, в которой $$$j$$$-й       символ обозначает цвет клетки таблицы, находящейся в строке       $$$i$$$ и столбце $$$j$$$. Символы «<span class="tex-font-style-tt">#</span>» и «<span class="tex-font-style-tt">.</span>» обозначают черный и белый       цвета соответственно. Гарантируется, что строка не содержит других символов.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите единственное целое число, которое равно минимальному       количеству магнитов с северным полюсом, которое требуется.</p>     <p>Если не существует способа расставить магниты, который будет       удовлетворять всем условиям, выведите единственное целое число $$$-1$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3 3
.#.
###
##.
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
4 2
##
.#
.#
##
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
-1
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
4 5
....#
####.
.###.
.#...
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
2 1
.
#
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
-1
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
3 5
.....
.....
.....
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом тесте возможно расположить магниты следующим образом:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/f89d8c7a378384a96c7e162b53499c211fbb21cd.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>Во втором тесте можно показать, что не существует необходимых       расположений магнитов. На следующей картинке показаны три примера       расположений, которые удовлетворяют не всем условиям. Первый       пример нарушает правило $$$3$$$, потому что мы можем переместить       магнит с северным полюсом вниз на белую клетку. Второй пример       нарушает правило $$$2$$$, потому что мы не можем переместить       магнит с северным полюсом в левую нижнюю черную клетку никакой       последовательностью операций. Третий пример нарушает правило       $$$1$$$, потому что нет ни одного магнита с южным полюсом в первом столбце.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/4bf25d94e49a452e00895f940f4e76d26d8cde35.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>Следующая картинка показывает пример возможного расположения       магнитов в третьем тесте. Можно показать, что не существует       необходимых расположений магнитов с меньшим количеством магнитов с       северным полюсом.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/730abcba1dab5abea574d5f479fe54cdf3f528ae.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>Во четвертом тесте можно показать, что не существует необходимых       расположений магнитов. На следующей картинке два примера       расположений, которые удовлетворяют не всем условиям. Первый       пример нарушает правило $$$1$$$, потому что нет ни одного магнита       с южным полюсом в первой строке. Второй пример нарушает правила       $$$1$$$ и $$$3$$$, потому что нет ни одного магнита с южным       полюсом во второй строке, а кроме того, мы можем переместить       магнит с северным полюсом на одну клетку вверх, и он попадет на       белую клетку.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/c719c90077972d8befc8234a02d55b35d7736299.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>В пятом тесте мы можем поставить магниты с южным полюсом во все       клетки и не использовать ни одного магнита с северным полюсом.       Поскольку нет ни одной черной клетки, это будет корректной       расстановкой магнитов.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1344/problem/B' title='Codeforces Round 639 (Div. 1)'>1344B - Однополюсные магниты</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Suppose two cells $$$A$$$ and $$$B$$$ are colored black in the       same row. Since there must be a south magnet in every row, there       are segments of black cells from $$$A$$$ and $$$B$$$ to the cell       with the south magnet. The same result holds for columns.       Therefore, for a solution to exist, every row and every column has       exactly one segment of black cells or is all-white.</p>     <p>Suppose there is an all-white row, but not an all-white column.       (Or similarly, an all-white column but not an all-white row.) Then       wherever we place a south magnet in this row, its column will have       a black cell. But then the south magnet would be reachable,       contradicting the fact that the row is all-white. Therefore, there       should be an all-white row if and only if there is an all-white       column, or no solution exists.</p>     <p>Now that we have excluded these cases where no solution exists,       let's construct a solution. Place a south magnet in a cell if: </p>     <ol> <li> The cell is colored black, or </li>       <li> Its row and column are both all-white. </li></ol>          <p>Then place one north magnet in each connected component of black       cells. A north magnet cannot travel between components, so this is optimal.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #639 (Div. 1)
    1344C
    Задача про кванторы </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Задача про кванторы</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Логические кванторы — это очень хороший инструмент для создания       некоторых утверждений о множестве. В этой задаче мы будем       рассматривать множество вещественных чисел. <span class="tex-font-style-bf">Множество вещественных чисел содержит         ноль и отрицательные числа.</span> Есть два вида кванторов:       всеобщности ($$$\forall$$$) и существования ($$$\exists$$$). Вы       можете прочитать больше про них <a href="https://ru.wikipedia.org/wiki/Квантор">здесь</a>.</p>     <p>Квантор всеобщности используется, чтобы сказать, что утверждение       выполнено <span class="tex-font-style-it">для всех вещественных       чисел</span>. Например:</p>          <ul> <li> $$$\forall x,x&lt;100$$$ читается как: для всех         вещественных чисел $$$x$$$ число $$$x$$$ меньше, чем $$$100$$$.         Это утверждение ложно. </li>       <li> $$$\forall x,x&gt;x-1$$$ читается как: для всех вещественных         чисел $$$x$$$ число $$$x$$$ больше, чем $$$x-1$$$. Это         утверждение верно. </li></ul>          <p>Квантор существования используется, чтобы сказать, что <span class="tex-font-style-it">существует некоторое вещественное       число</span>, для которого утверждение выполнено. Например:</p>          <ul> <li> $$$\exists x,x&lt;100$$$ читается как: существует         вещественное число $$$x$$$ такое, что $$$x$$$ меньше, чем         $$$100$$$. Это утверждение верно. </li>       <li> $$$\exists x,x&gt;x-1$$$ читается как: существует         вещественное число $$$x$$$ такое, что $$$x$$$ больше, чем         $$$x-1$$$. Это утверждение верно. </li></ul>          <p>Кроме того, эти кванторы могут быть вложенными. Например:</p>          <ul> <li> $$$\forall x,\exists y,x&lt;y$$$ читается так: для всех         вещественных чисел $$$x$$$ существует вещественное число $$$y$$$         такое, что $$$x$$$ меньше, чем $$$y$$$. Это утверждение верно         для всех $$$x$$$, потому что существует $$$y=x+1$$$. </li>       <li> $$$\exists y,\forall x,x&lt;y$$$ читается так: существует         вещественное число $$$y$$$ такое, что для всех вещественных         чисел $$$x$$$ число $$$x$$$ меньше, чем $$$y$$$. Это утверждение         ложно, потому что оно утверждает, что существует максимальное         вещественное число: число $$$y$$$ больше, чем любое $$$x$$$. </li></ul>          <p>       <span class="tex-font-style-bf">Обратите внимание, что порядок         переменных и кванторов важен для значения и верности утверждения.</span></p>     <p>Всего есть $$$n$$$ переменных $$$x_1,x_2,\ldots,x_n$$$, и вам       дана формула вида $$$$$$       f(x_1,\dots,x_n):=(x_{j_1}&lt;x_{k_1})\land       (x_{j_2}&lt;x_{k_2})\land \cdots\land (x_{j_m}&lt;x_{k_m}), $$$$$$</p>     <p>где $$$\land$$$ обозначает логическое И. Это означает, что       $$$f(x_1,\ldots, x_n)$$$ истинно, если каждое неравенство       $$$x_{j_i}&lt;x_{k_i}$$$ выполнено. Иначе, если хотя бы одно       неравенство не выполнено, то $$$f(x_1,\ldots,x_n)$$$ ложно.</p>     <p>Ваша задача — выбрать значения каждого из кванторов       $$$Q_1,\ldots,Q_n$$$ либо квантором всеобщности ($$$\forall$$$),       либо квантором существования ($$$\exists$$$) так, что утверждение       $$$$$$ Q_1 x_1, Q_2 x_2, \ldots, Q_n x_n, f(x_1,\ldots, x_n) $$$$$$</p>     <p>будет верно и <span class="tex-font-style-bf">количество         кванторов всеобщности максимально возможное</span>, или       определить, что утверждение ложно для всех возможных выборов кванторов.</p>     <p>       <span class="tex-font-style-bf">Обратите внимание, что порядок         переменных, в котором они идут в утверждении фиксирован.</span>       Например, если $$$f(x_1,x_2):=(x_1&lt;x_2)$$$, то вам не разрешено       сделать переменную $$$x_2$$$ идущей первой, и получить утверждение       $$$\forall x_2,\exists x_1, x_1&lt;x_2$$$. Если вы выберете       $$$Q_1=\exists$$$ и $$$Q_2=\forall$$$ получившееся утверждение       будет <span class="tex-font-style-bf">однозначно</span> равно       $$$\exists x_1,\forall x_2,x_1&lt;x_2$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке находятся два целых числа $$$n$$$ и $$$m$$$       ($$$2\le n\le 2\cdot 10^5$$$; $$$1\le m\le 2\cdot 10^5$$$) —       количество переменных и неравенств в формуле, соответственно.</p>     <p>Следующие $$$m$$$ строк описывают формулу. $$$i$$$-я из этих       строк содержит два целых числа $$$j_i$$$, $$$k_i$$$ ($$$1\le       j_i,k_i\le n$$$, $$$j_i\ne k_i$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Если ни одной расстановки кванторов такой, что утверждение будет       верно, не существует, выведите единственное целое число $$$-1$$$.</p>     <p>Иначе на первой строке выведите максимальное возможное количество       кванторов всеобщности.</p>     <p>На следующей строке выведите строку длины $$$n$$$, в которой       $$$i$$$-й символ это «<span class="tex-font-style-tt">A</span>»,       если $$$Q_i$$$ должен быть квантором всеобщности ($$$\forall$$$),       или «<span class="tex-font-style-tt">E</span>», если $$$Q_i$$$       должен быть квантором существования ($$$\exists$$$). Все символы       должны быть в верхнем регистре. Если существует несколько       возможных решений, в которых количество кванторов всеобщности       максимально возможное, выведите любое.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2 1
1 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
AE
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
4 3
1 2
2 3
3 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
-1
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
3 2
1 3
2 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
AAE
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом тесте утверждение $$$\forall x_1, \exists x_2,       x_1&lt;x_2$$$ верно. Ответы «<span class="tex-font-style-tt">EA</span>» и «<span class="tex-font-style-tt">AA</span>» дают ложные утверждения.       Ответ «<span class="tex-font-style-tt">EE</span>» дает верное       утверждение, но количество кванторов всеобщности будет меньше, чем       в нашем ответе.</p>     <p>Для второго теста можно показать, что ни одной расстановки       кванторов такой, что утверждение будет верно, не существует.</p>     <p>В третьем тесте утверждение $$$\forall x_1, \forall x_2, \exists       x_3, (x_1&lt;x_3)\land (x_2&lt;x_3)$$$ верно: мы можем выбрать $$$x_3=\max\{x_1,x_2\}+1$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1344/problem/C' title='Codeforces Round 639 (Div. 1)'>1344C - Задача про кванторы</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Build a directed graph of variables, where an edge $$$x_i\to       x_j$$$ corresponds to an inequality $$$x_i&lt;x_j.$$$ Say that two       variables are comparable if there is a directed path from one       variable to the other.</p>     <p>Suppose $$$x_i$$$ and $$$x_j$$$ are comparable with $$$i&lt;j$$$.       Then $$$x_j$$$ cannot be universal since $$$x_i$$$ is determined       before $$$x_j$$$ in the order and their comparability restricts       the value of $$$x_j$$$. So, a requirement for universality is that       the variable is only comparable with larger-indexed variables.</p>     <p>If there is a cycle of inequalities, then there is no solution       since the formula is contradictory. Otherwise, the graph is       acyclic, so we can find a topological order. For each variable, we       can find the minimum index of a node comparable to it by doing DP       in forward and reverse topological order. Then for every variable       not comparable to a smaller indexed variable, let it be universal.       All other variables must be existential. Our requirement of       universality proves this is optimal.</p>     <p>Let's prove this assignment gives a true statement (other than       proof by AC). First, we can decrease the index of existential       variables, which only strengthens the statement. So let's decrease       the index of each existential variable to appear just after its       largest-indexed comparable universal variable.</p>     <p>An existential variable $$$x_i$$$ may be comparable to many       universal variables, but $$$x_i$$$ must be either greater than       them all or less than them all. (Otherwise, we would have two       comparable universals.) Without loss of generality, say $$$x_i$$$       is greater than its comparable universals. And suppose $$$x_i$$$       is less than another existential variable $$$x_j$$$. Then       $$$x_j$$$ is comparable to the same universals as $$$x_i$$$, so we       can determine the value of $$$x_j$$$ later such that it depends on       $$$x_i$$$. Therefore, each existential variable is only restricted       by a lower bound or an upper bound of smaller-indexed variables.       We can properly assign values to them, satisfying all inequalities.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #639 (Div. 1)
    1344D
    Составление резюме </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Составление резюме</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>4 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>       <span class="tex-font-style-it">О нет! Скоро закончится время,         когда еще можно подать заявку на стажировку в IT компанию, а вы         медлили, участвуя в контестах вместо этого! (Давайте пока         притворимся, что в наше неопределенное время можно будет найти работу.)</span></p>     <p>Вы сделали много проектов по программированию. Существует ровно       $$$n$$$ типов проектов и вы сделали $$$a_i$$$ проектов типа       $$$i$$$. Ваше резюме имеет ограниченный размер, но вы хотите       аккуратно выбрать проекты, чтобы максимизировать шанс того, что       вас возьмут на работу.</p>     <p>Вы хотите включить несколько проектов одного типа, чтобы       подчеркнуть вашу компетентность, но вы также не хотите включать их       так много, что среди них начнут появляться некачественные проекты.       Поэтому, вы придумали следующую формулу, которая является хорошим       индикатором того, что вас возьмут на работу:</p>     <p>$$$$$$ f(b_1,\ldots,b_n)=\sum\limits_{i=1}^n b_i(a_i-b_i^2). $$$$$$</p>     <p>Здесь $$$b_i$$$ обозначает количество проектов типа $$$i$$$,       которое вы включите в ваше резюме. Конечно, вы не можете включить       в резюме больше проектов, чем вы сделали, поэтому для всех $$$i$$$       должно быть выполнено $$$0\le b_i \le a_i$$$.</p>     <p>В вашем резюме хватает места для $$$k$$$ проектов, и вы абсолютно       точно не будете приняты на работу, если в вашем резюме будет       пустая строчка. Поэтому вы хотите, чтобы было выполнено       $$$\sum\limits_{i=1}^n b_i=k$$$.</p>     <p>Найдите значения $$$b_1,\ldots, b_n$$$, которые максимизируют       значение $$$f(b_1,\ldots,b_n)$$$ при том, что все описанные       условия выполнены.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке находятся два целых числа $$$n$$$ и $$$k$$$       ($$$1\le n\le 10^5$$$, $$$1\le k\le \sum\limits_{i=1}^n a_i$$$) —       количество типов проектов и размер резюме, соответственно.</p>     <p>В следующей строке находятся $$$n$$$ целых чисел       $$$a_1,\ldots,a_n$$$ ($$$1\le a_i\le 10^9$$$), $$$a_i$$$ равно       количеству сделанных проектов типа $$$i$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>В единственной строке выведите $$$n$$$ целых чисел $$$b_1,\ldots,       b_n$$$, для которых достигается максимальное значение       $$$f(b_1,\ldots,b_n)$$$ в условиях ограничений $$$0\le b_i\le       a_i$$$ и $$$\sum\limits_{i=1}^n b_i=k$$$. Если существует       несколько возможных решений, выведите любое.</p>     <p>       <span class="tex-font-style-bf">Обратите внимание, что вы не         должны выводить само значение $$$f(b_1,\ldots,b_n)$$$.</span></p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
10 32
1 2 3 4 5 5 5 5 5 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1 2 3 3 3 4 4 4 4 4 
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5 8
4 4 8 2 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2 2 2 1 1 
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом тесте оптимальный ответ это $$$f=-269$$$. Обратите       внимание, что большее значение $$$f$$$ возможно, только если мы       уберем ограничение $$$\sum\limits_{i=1}^n b_i=k$$$.</p>     <p>Во втором тесте оптимальный ответ $$$f=9$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1344/problem/D' title='Codeforces Round 639 (Div. 1)'>1344D - Составление резюме</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>If we increment some $$$b_i$$$ to $$$x$$$, the value of $$$f$$$       changes by $$$$$$\Delta_i (x):=\left[x(a_i-x^2)\right]-\left[(x-1)(a_i-(x-1)^2)\right]=a_i-3x^2+3x-1,$$$$$$</p>     <p>which decreases for $$$x\ge 1.$$$ If we initially set all       $$$b_i$$$ to $$$0$$$, then greedily incrementing the best index       gives an optimal solution. Since $$$k$$$ is large, we cannot       afford to do this one increment at a time. However, we can observe       that this process increments the values as long as $$$\Delta_i       (x)\ge A$$$ for some constant $$$A$$$. Simply binary search on the       value of $$$A$$$ so that we increment exactly $$$k$$$ times.</p>     <p>To compute the cutoffs for the $$$x$$$ values, we can either use       the quadratic formula or do another binary search.</p>     <p>There may be ties for the $$$\Delta_i(x)$$$ values, but this can       be handled without too much trouble.</p>     <p>Let $$$A=\max_{i=1,\ldots,n}\{a_i\}$$$. Complexity is       $$$O(n\log(A))$$$ with the quadratic formula, or       $$$O(n\log^2(A))$$$ with another binary search.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #639 (Div. 1)
    1344E
    Железнодорожные пути </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. Железнодорожные пути</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>5 секунд</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>       <span class="tex-font-style-it">Все верно. Я студент университета         Пердью и безо всякого стыда придумал задачу про поезда.</span></p>     <p>Есть $$$n$$$ станций и $$$m$$$ поездов. Станции соединяются       $$$n-1$$$ однонаправленной железной дорогой так, что они образуют       корневое дерево с корнем в станции $$$1$$$. Все железные дороги       имеют направлены вдоль путей от корневой станции $$$1$$$ к       листьям. Каждая железная дорога ведет от станции $$$u$$$ к станции       $$$v$$$ и имеет расстояние $$$d$$$, обозначающее, что требуется       $$$d$$$ единиц времени, чтобы доехать от станции $$$u$$$ к станции       $$$v$$$. Каждая станция, из которой выходит хотя бы одна железная       дорога, имеет переключатель, который определяет станцию, в которую       затем поедет любой поезд, приехавший на эту станцию. Например, это       может выглядеть следующим образом:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/a8bd088972a0dd07d182e1561fc0906f02f5b734.png" style="max-width: 100.0%;max-height: 100.0%;"/>       Здесь станции $$$1$$$ и $$$3$$$ имеют переключатели, направляющие       к станциям $$$2$$$ и $$$4$$$, соответственно. </center>          <p>Изначально ни на одной станции нет поезда. Поезд $$$i$$$ появится       на станции $$$1$$$ в момент времени $$$t_i$$$. В каждый момент       времени, начиная с $$$1$$$, будут происходить следующие два шага:</p>          <ol> <li> Вы можете переключить переключатель не более одной станции         на другую дорогу, выходящую из этой станции. Переключение         происходит до шага $$$2$$$. </li>       <li> Любой поезд, который находится на станции $$$u$$$,         направляется к станции $$$v$$$, в которую указывает         переключатель станции $$$u$$$. Если железная дорога от станции         $$$u$$$ к станции $$$v$$$ имела расстояние $$$d$$$, поезд         прибудет на станцию $$$v$$$ через $$$d$$$ единиц времени от         настоящего момента. </li></ol>          <p>У каждого поезда есть станция прибытия $$$s_i$$$. Когда он       прибывает на станцию $$$s_i$$$, он останавливается там навсегда.       Если в какой-то момент времени поезд поедет в неверном       направлении, то есть он никогда уже не сможет достичь станции       $$$s_i$$$ независимо от состояния переключателей, он тут же взорвется.</p>     <p>Найдите <span class="tex-font-style-bf">наибольшее возможное         время первого взрыва</span>, если вы будете переключать       переключатели оптимально или определите, что вы можете направить       каждый поезд к своей станции прибытия так, что ни одного взрыва не       произойдет. Также найдите <span class="tex-font-style-bf">минимальное количество       переключений</span>, которое требуется, чтобы достичь этого.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке находятся два целых числа $$$n$$$ и $$$m$$$       ($$$1\le n,m\le 10^5$$$) — количество станций и поездов, соответственно.</p>     <p>Следующие $$$n-1$$$ строк описывают железные дороги. $$$i$$$-я из       этих строк содержит три целых числа $$$u,v,d$$$ ($$$1\le u,v\le       n$$$, $$$1\le d\le 10^9$$$), обозначающие железную дорогу от       станции $$$u$$$ к станции $$$v$$$, имеющую расстояние $$$d$$$.       Гарантируется, что железные дороги формируют корневое дерево с       корнем в станции $$$1$$$. <span class="tex-font-style-bf">Переключатель в станции $$$u$$$         изначально направлен вдоль последней в данном порядке железной         дороги, выходящей из станции $$$u$$$.</span></p>     <p>Следующие $$$m$$$ строк описывают поезда. $$$i$$$-я из этих строк       содержит два целых числа $$$s_i,t_i$$$ ($$$1\le s_i\le n$$$,       $$$1\le t_1&lt;t_2&lt;\cdots&lt;t_m\le 10^9$$$) — станция       назначения и время, в которое $$$i$$$-й поезд прибудет на станцию       $$$1$$$, соответственно.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите два целых числа: наибольшее возможное время первого       взрыва (или $$$-1$$$, если можно предотвратить взрывы) и       минимальное количество переключений, необходимое, чтобы достичь этого.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5 4
1 2 1
1 3 2
3 4 1
3 5 3
2 1
4 2
2 6
5 10
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
-1 6
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5 4
1 2 1
1 3 2
3 4 1
3 5 3
5 1
4 2
4 3
2 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
4 0
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
11 6
1 2 1
1 3 2
3 4 1
3 5 2
5 6 1
5 7 2
7 8 1
7 9 2
9 10 1
9 11 1
2 1
8 3
6 5
10 7
4 9
2 11
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
11 4
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом тесте один из возможных примеров того, как все будет       происходить, описан ниже. </p>     <ul> <li> В момент времени $$$1$$$ поезд $$$1$$$ прибывает на         станцию $$$1$$$. Переключатель станции $$$1$$$ направлен к         станции $$$2$$$. Поезд $$$1$$$ отправляется к станции $$$2$$$. </li>       <li> В момент времени $$$2$$$ поезд $$$2$$$ прибывает на станцию         $$$1$$$ и поезд $$$1$$$ прибывает на станцию $$$2$$$, где         останавливается навсегда. Мы переключаем переключатель в станции         $$$1$$$ к станции $$$3$$$. Поезд $$$2$$$ направляется к станции         $$$3$$$. </li>       <li> В момент времени $$$4$$$ поезд $$$2$$$ прибывает на станцию         $$$3$$$. Мы переключаем переключатель в станции $$$3$$$ к         станции $$$4$$$. Поезд $$$2$$$ направляется к станции $$$4$$$. </li>       <li> В момент времени $$$5$$$ поезд $$$2$$$ прибывает на станцию         $$$4$$$, где останавливается навсегда. </li>       <li> В момент времени $$$6$$$ поезд $$$3$$$ прибывает на станцию         $$$1$$$. Мы переключаем переключатель станции $$$1$$$ к станции         $$$2$$$. Поезд $$$3$$$ направляется к станции $$$2$$$. </li>       <li> В момент времени $$$7$$$ поезд $$$3$$$ прибывает на станцию         $$$2$$$, где останавливается навсегда. Мы переключаем         переключатель станции $$$3$$$ к станции $$$5$$$. </li>       <li> В момент времени $$$10$$$ поезд $$$4$$$ прибывает на станцию         $$$1$$$. Мы переключаем переключатель станции $$$1$$$ к станции         $$$3$$$. Поезд $$$4$$$ направляется к станции $$$3$$$. </li>       <li> В момент времени $$$12$$$ поезд $$$4$$$ прибывает на станцию         $$$3$$$. Поезд $$$4$$$ направляется к станции $$$5$$$. </li>       <li> В момент времени $$$15$$$ поезд $$$4$$$ прибывает на станцию         $$$5$$$, где останавливается навсегда. </li></ul>          <p>Во втором тесте мы не переключаем ничего. В момент времени       $$$4$$$ поезд $$$2$$$ направляется к станции $$$5$$$, и поезд       $$$4$$$ направляется к станции $$$3$$$. Они оба взрываются.       Невозможно предотвратить взрывы поездов к моменту времени $$$4$$$.</p>     <p>В третьем тесте давайте будем обозначать переключение       переключателя как $$$(u\to v,t)$$$, если мы переключаем       переключатель станции $$$u$$$ к станции $$$v$$$ в момент времени       $$$t$$$. Одним из решений является сделать следующие $$$4$$$       переключения: $$$(1\to 2,1)$$$, $$$(1\to 3,2)$$$, $$$(7\to       8,5)$$$, $$$(5\to 6,8)$$$. В момент времени $$$11$$$ поезда       $$$4$$$, $$$5$$$ и $$$6$$$ взорвутся. Невозможно предотвратить       взрывы поездов к моменту времени $$$11$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1344/problem/E' title='Codeforces Round 639 (Div. 1)'>1344E - Train Tracks</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>First, observe that a train can never pass one that enters       earlier. So let's consider the trains independently. For a train       $$$i$$$, look at the path from $$$1$$$ to $$$s_i$$$. We may need       to change the switches of several stations on this path. We must       make each switch within a time interval $$$(L, R]$$$, where       $$$L$$$ is the most recent time some other train was directed the       other way, and $$$R$$$ is the time train $$$i$$$ will enter the       station. Let's mark all of these switches as changed before       processing the next train.</p>     <p>Suppose the total number of switch changes is $$$k$$$, and for       each station, we know its time intervals. We can manage all events       in a priority queue of size $$$n$$$, always changing the switch       with the earliest deadline that we can. Keep doing this until we       are too late for a deadline, in which case an explosion happens,       or until we have successfully made every switch change. This part       will take $$$O(k\log n)$$$ time.</p>     <p>Let's find a nice upper bound on $$$k$$$. Note that the switches       decompose the tree into a set of disjoint paths. When we process a       train $$$i$$$, we are changing the switches to make a path from       the root to $$$s_i$$$. It turns out this is exactly the same as an       access operation on a link/cut tree! Because link/cut trees have       $$$O(\log n)$$$ amortized time per operation, we can guarantee       that the total number of switch changes is $$$k=O(n+m\log n)$$$.</p>     <p>Now let's consider the problem of finding all time intervals. We       could use a link/cut tree, but everyone hates those, so let's       discuss other methods. One strategy is to maintain a list of       trains that go through a station, for every station. We start at       the leaves and merge the lists going up. We can merge the lists       efficiently by inserting elements from the smaller list to the       larger list. Then a switch only needs to be changed when       consecutive trains go to different children.</p>     <p>Unlike some of the testers, I wasn't smart enough to come up with       the elegant small-to-large merging idea. So let's discuss an       alternate solution using segment trees. When processing a train       $$$i$$$, we want to do the following:</p>          <ol> <li> Find the top node $$$x$$$ of the path leading to         $$$s_i$$$. </li>       <li> If $$$x$$$ is not the root, make the parent of $$$x$$$ point         to $$$x$$$, and record the time interval we must make this         switch. Repeat from step $$$1$$$ until $$$x$$$ is the root. </li></ol>          <p>The queries we want to support are thus: </p>     <ol> <li> Find the time the most recent train passed through a node         $$$x$$$ (ignoring trains with $$$s_i=x,$$$ where it only stops         at $$$x$$$). </li>       <li> Find the top node of the path containing node $$$x$$$. </li></ol>          <p>Let's handle queries of type $$$1$$$ with a segment tree. After       processing train $$$i$$$, update the value at index $$$s_i$$$ to       $$$i$$$. To answer a query, find the maximum value in the range       corresponding to the relevant subtree.</p>     <p>Let's also handle queries of type $$$2$$$ with a segment tree. At       a segment tree node, store the minimum value on its range. To       answer a query, check the range $$$[x,x]$$$. Support lazy updates       of the form &quot;On a range $$$[l, r]$$$, replace all values       $$$X$$$ with value $$$Y$$$, with the precondition that $$$X$$$ is       currently the minimum value in $$$[l,r]$$$ and $$$Y$$$ will remain       the minimum value after the update&quot;. To make a switch change,       we only need to do two lazy updates.</p>     <p>Therefore, finding all the time intervals will take       $$$O((m+k)\log n)$$$ time.</p>     <p>The overall complexity is $$$O(n\log n+m\log^2 n)$$$.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #639 (Div. 1)
    1344F
    Палитра Пита Мондриана </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Палитра Пита Мондриана</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>       <span class="tex-font-style-it">Пит Мондриан — художник, наиболее         известный своими минималистскими работами, состоящими только из         четырех цветов: красного, желтого, синего и белого. Большинство         людей объясняют это его стилем, но правда заключается в том, что         смешивание двух его основных цветов лишь создает другой основной цвет!</span></p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/3af3793868336bdf970c98194b7c689683d0dd31.png" style="max-width: 100.0%;max-height: 100.0%;"/>         <span class="tex-font-style-it">Менее известное произведение,         названное «Претенциозные прямоугольники»</span> </center>          <p>Последовательность из нескольких основных цветов (красного,       желтого и синего) смешивается следующим образом: пока есть хотя бы       два цвета, посмотрим на первые два. Если они разные, заменим их на       недостающий в этой паре цвет. Если они одинаковые, удалим их из       последовательности. В конце, если в последовательности есть один       цвет, этот цвет будет результатом смешивания. Иначе, если       последовательность пустая, результатом смешивания будет белый.       Рассмотрим два примера смешивания последовательности цветов:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/948530fff451cb13e7e5c7a247351601acf3142e.png" style="max-width: 100.0%;max-height: 100.0%;"/>     </center>   <center> <img class="tex-graphics" src="https://espresso.codeforces.com/bca3db1e6223b5454e68e2faab650409a69b97bc.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>У Пита есть цветная палитра, состоящая из нескольких клеток,       пронумерованых от $$$1$$$ до $$$n$$$. Каждая клетка пустая или       содержит один из основных цветов. Пит очень секретный и не покажет       вам свою палитру, поэтому вы не знаете, какие цвета находятся в       каждой клетке.</p>     <p>Несмотря на это, художник выполнил $$$k$$$ операций. Всего есть       четыре вида операций: </p>     <ol> <li> Операция <span class="tex-font-style-bf">mix</span>: Пит         выбирает подмножество клеток и смешивает цвета в выбранных         клетках в некотором порядке (не обязательно по возрастанию         индексов). Он записывает получившийся цвет. Пустые клетки не         влияют на процесс смешивания и игнорируются. Смешивание не         влияет на цвета в клетках палитры. </li>       <li> Операция <span class="tex-font-style-bf">RY</span>: Пит         выбирает подмножество клеток. Каждая красная клетка в этом         подмножестве становится желтой, и каждая желтая клетка в этом         подмножестве становится красной. Синие и пустые клетки не меняют         свой цвет. </li>       <li> Операция <span class="tex-font-style-bf">RB</span>: Пит         выбирает подмножество клеток. Каждая красная клетка в этом         подмножестве становится синей, и каждая синяя клетка в этом         подмножестве становится красной. Желтые и пустые клетки не         меняют свой цвет. </li>       <li> Операция <span class="tex-font-style-bf">YB</span>: Пит         выбирает подмножество клеток. Каждая желтая клетка в этом         подмножестве становится синей, и каждая синяя клетка в этом         подмножестве становится желтой. Красные и пустые клетки не         меняют свой цвет. </li></ol>          <p>Пит сказал вам список операций, которые он выполнил, в       хронологическом порядке, с соответствующими индексами и       результатами каждой операции <span class="tex-font-style-tt">mix</span>. Имея эту информацию,       определите цвет каждой клетки в изначальной палитре. Вы должны       найти одно из возможных состояний изначальной палитры (до       применения операций) или сказать, что описанная ситуация невозможна.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке находятся два целых числа $$$n$$$ и $$$k$$$       ($$$1\le n,k\le 1000$$$) — количество клеток в палитре и       количество операций соответственно.</p>     <p>Следующие $$$k$$$ строк описывают операции. $$$i$$$-я из этих       строк начинается с названия $$$i$$$-й операции и целого числа       $$$m$$$ ($$$1\le m\le n$$$) — количества использованных в операции       индексов. Затем следуют $$$m$$$ целых чисел $$$j_1,\ldots,j_m$$$       ($$$1\le j_i\le n$$$) — индексы клеток, выбранных в операции.       Гарантируется, что в каждой операции все $$$j_i$$$ различны. Если       это операция <span class="tex-font-style-tt">mix</span>, индексы       перечисляются в том порядке, в котором цвета смешиваются, и в       конце строки также дается один символ, означающий получившийся в       результате смешивания цвет: «<span class="tex-font-style-tt">R</span>» для красного, «<span class="tex-font-style-tt">Y</span>» для желтого, «<span class="tex-font-style-tt">B</span>» для синего и «<span class="tex-font-style-tt">W</span>» для белого.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>В первой строке выведите «<span class="tex-font-style-tt">YES</span>», если решение существует, и         «<span class="tex-font-style-tt">NO</span>» иначе. Вы можете       выводить каждый символ в любом регистре (верхнем или нижнем).</p>     <p>Если ответ «<span class="tex-font-style-tt">YES</span>», в       следующей строке выведите строку длины $$$n$$$, состоящую из       символов «<span class="tex-font-style-tt">R</span>», «<span class="tex-font-style-tt">Y</span>», «<span class="tex-font-style-tt">B</span>» или «<span class="tex-font-style-tt">.</span>», задающую цвета $$$n$$$ клеток       на изначальной палитре (красный, желтый, синий цвета и пустая       клетка соответственно). Если есть несколько возможных изначальных       палитр, выведите любую. Вы можете выводить каждый символ в любом       регистре (верхнем или нижнем).</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3 2
mix 2 2 1 R
mix 2 1 3 Y
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
YES
YB.
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
2 3
mix 1 2 Y
RB 1 2
mix 1 2 W
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
NO
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
1 3
RY 1 1
YB 1 1
mix 1 1 B
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
YES
R
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
3 8
mix 2 1 2 R
mix 2 1 3 Y
RY 2 2 3
RB 3 1 2 3
YB 3 1 2 3
mix 1 1 W
mix 1 2 B
mix 1 3 Y
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
YES
.RY
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом тесте ответ «<span class="tex-font-style-tt">YB.</span>»       не противоречит обоим смешиваниям. При первом смешивании       последовательности цветов «<span class="tex-font-style-tt">BY</span>» получится красный цвет, при       втором смешивании последовательности цветов «<span class="tex-font-style-tt">Y</span>» получится желтый цвет (пустые       клетки игнорируются). Некоторые другие возможные ответы: «<span class="tex-font-style-tt">BYR</span>» и «<span class="tex-font-style-tt">.RY</span>».</p>     <p>Во втором тесте можно показать, что не существует ни одной не       противоречивой расстановки цветов на изначальной палитре.</p>     <p>В третьем тесте ответ «<span class="tex-font-style-tt">R</span>»       не противоречит никаким операциям. В первой операции палитра       меняется на «<span class="tex-font-style-tt">Y</span>», затем на         «<span class="tex-font-style-tt">B</span>». В последней операции       при смешивании последовательности цветов «<span class="tex-font-style-tt">B</span>» получается синий цвет.</p>     <p>В четвертом тесте ответ «<span class="tex-font-style-tt">.RY</span>» не противоречит никаким       операциям. В первых двух смешиваниях последовательности цветов         «<span class="tex-font-style-tt">R</span>» и «<span class="tex-font-style-tt">Y</span>» смешиваются в красный и желтый       цвета соответственно. В следующих трех операциях палитра       изменяется на «<span class="tex-font-style-tt">.YR</span>», затем       на «<span class="tex-font-style-tt">.YB</span>», затем на «<span class="tex-font-style-tt">.BY</span>». Последние три смешивания       согласуются с получившейся палитрой.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1344/problem/F' title='Codeforces Round 639 (Div. 1)'>1344F - Piet's Palette</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Equate an empty cell with the color white, and let's represent       the colors as 0/1 vectors:       $$$$$$W=\begin{bmatrix}0\\0\end{bmatrix},\       R=\begin{bmatrix}1\\0\end{bmatrix},\       Y=\begin{bmatrix}0\\1\end{bmatrix},\ B=\begin{bmatrix}1\\1\end{bmatrix}.$$$$$$</p>     <p>Under this representation, mixing becomes addition       $$$\pmod{2}$$$. And the operations $$$\mathrm{RY}$$$,       $$$\mathrm{RB}$$$, $$$\mathrm{YB}$$$ are linear transformations of       the colors. That is, each of these operations is equivalent to       multiplying the corresponding matrix by a cell's vector:       $$$$$$\mathrm{RY}=\begin{bmatrix}0&amp;1\\1&amp;0\end{bmatrix},\       \mathrm{RB}=\begin{bmatrix}1&amp;0\\1&amp;1\end{bmatrix},\ \mathrm{YB}=\begin{bmatrix}1&amp;1\\0&amp;1\end{bmatrix}.$$$$$$</p>     <p>We simply have a system of $$$2k$$$ linear equations on $$$2n$$$       unknowns, which we can solve with Gaussian elimination using bitsets.</p>     <p>Complexity is $$$O((2k)^2 (2n) / 64).$$$</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #639 (Div. 2)
    1345A
    Сборка пазла </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Сборка пазла</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам дается специальный пазл, состоящий из $$$n\cdot m$$$       одинаковых деталей. Каждая деталь имеет три выступа и одну выемку,       как показано на рисунке.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/12bd9722a46824150283fab59ae3dad3c2926ed9.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>Пазл считается собранным, если следующие условия выполнены:</p>          <ol> <li> Детали расположены в виде прямоугольника с $$$n$$$         строками и $$$m$$$ столбцами. </li>       <li> Любые две детали, которые имеют общую сторону в         прямоугольнике, идеально соединяются с помощью выступа одной         детали и выемки другой. </li></ol>          <p>Определите, можно ли собрать пазл, вращая и перемещая детали как угодно.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Каждый тест содержит несколько тестовых случаев. В первой строке       находится единственное целое число $$$t$$$ ($$$1\le t\le       1000$$$) — количество тестовых случаев. В следующих $$$t$$$       строках следует описание тестовых случаев.</p>     <p>Единственная строка описания каждого тестового случая содержит       два целых числа $$$n$$$ и $$$m$$$ ($$$1 \le n,m \le 10^5$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого тестового случая выведите единственную строку,       содержащую «<span class="tex-font-style-tt">YES</span>», если       возможно собрать пазл и «<span class="tex-font-style-tt">NO</span>», иначе. Вы можете выводить       каждый символ в любом регистре.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
1 3
100000 100000
2 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
YES
NO
YES
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом тестовом случае один из возможных примеров решения пазла:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/03f246790d1b31b27745f0ae94fc105e94373d46.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>Для второго тестового случая можно показать, что пазл собрать невозможно.</p>     <p>В третьем тестовом случае один из возможных примеров решения пазла:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/b09e8310c88f18ac6bfa5ec4b17f92aa50d890bb.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1345/problem/A' title='Codeforces Round 639 (Div. 2)'>1345A - Puzzle Pieces</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>If $$$n=1$$$ or $$$m=1$$$, then we can chain the pieces together       to form a solution. If $$$n=m=2$$$, we can make the following solution:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/b09e8310c88f18ac6bfa5ec4b17f92aa50d890bb.png" style="max-width: 100.0%;max-height: 100.0%;" /> </center>          <p>Any other potential solution would contain a $$$2\times 3$$$ or a       $$$3\times 2$$$ solution, which we can show is impossible.</p>     <p>A $$$2\times 3$$$ grid has $$$7$$$ shared edges between the       pieces, and each shared edge must have a blank. But there are only       $$$6$$$ blanks available as there are $$$6$$$ pieces.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #639 (Div. 2)
    1345B
    Карточные пирамиды </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Карточные пирамиды</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Карточная пирамида высоты $$$1$$$ может быть построена с помощью       двух карт, приставленных друг к другу. Для $$$h&gt;1$$$ карточная       пирамида высоты $$$h$$$ может быть построена расположением       карточной пирамиды высоты $$$h-1$$$ на базе. База состоит из       $$$h$$$ пирамидок высоты $$$1$$$, поставленных в ряд, и $$$h-1$$$       карты, лежащей сверху на них. Например, карточные пирамиды с       высотами $$$1$$$, $$$2$$$ и $$$3$$$ выглядят следующим образом:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/03d27fa5105a849bb8363e064d735c2d4240187a.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>Изначально у вас есть $$$n$$$ карт и вы строите как можно более       высокую пирамиду из этих карт. Если остались лишние карты, вы       снова строите как можно более высокую пирамиду из оставшихся карт.       Вы продолжаете этот процесс до тих пор, пока не станет невозможно       построить какую-нибудь пирамиду. Сколько карточных пирамид вы построите?</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Каждый тест состоит из нескольких тестовых случаев. Первая строка       содержит единственное целое число $$$t$$$ ($$$1\le t\le 1000$$$) —       количество тестовых случаев. Следующие $$$t$$$ строк содержат       описания тестовых случаев.</p>     <p>Единственная строка описания каждого тестового случая содержит       единственное целое число $$$n$$$ ($$$1\le n\le 10^9$$$) —       количество карт.</p>     <p>Гарантируется, что сумма значений $$$n$$$ по всем тестовым       случаям не превосходит $$$10^9$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого тестового случая выведите единственное целое число —       количество карточных пирамид, которое вы построите в конце процесса.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
3
14
15
24
1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
2
1
3
0
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом тестовом случае вы построите карточную пирамиду высоты       $$$1$$$ из $$$2$$$-x карт. Останется $$$1$$$ карта, которой       недостаточно, чтобы построить какую-нибудь пирамиду.</p>     <p>Во втором тестовом случае вы построите две пирамиды, каждая       высоты $$$2$$$, и в конце процесса не останется карт.</p>     <p>В третьем тестовом случае вы построите одну пирамиду высоты       $$$3$$$, и ни одной карты не останется.</p>     <p>В четвертом тестовом случае вы сначала построите одну пирамиду       высоты $$$3$$$, и $$$9$$$ карт останется. Затем вы построите       пирамиду высоты $$$2$$$, и $$$2$$$ карты останется. Наконец, вы       построите последнюю пирамиду высоты $$$1$$$, и не останется ни       одной карты.</p>     <p>В пятом тестовом случае одной карты недостаточно, чтобы построить       какую-нибудь пирамиду.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1345/problem/B' title='Codeforces Round 639 (Div. 2)'>1345B - Card Constructions</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's count the number of cards in a pyramid of height $$$h$$$.       There are $$$2(1+2+3+\cdots+h)$$$ cards standing up, and there are       $$$0+1+2+\cdots+(h-1)$$$ horizontal cards. So, there are       $$$2\frac{h(h+1)}{2}+\frac{(h-1)h}{2}=\frac{3}{2}h^2+\frac12 h$$$       cards total. Using this formula, we can quickly find the largest       height $$$h$$$ that uses at most $$$n$$$ cards.</p>     <p>The quadratic formula or binary search can be used here, but are       unnecessary. Simply iterating through all $$$h$$$ values works in       $$$O(\sqrt n)$$$ time per test.</p>     <p>It's enough to see that this takes $$$O(t\sqrt N)$$$ time       overall, where $$$N$$$ is the sum of $$$n$$$ across all test       cases. But interestingly, we can argue for a tighter bound of       $$$O(\sqrt{tN})$$$ due to the Cauchy-Schwarz Inequality:</p>     <p>$$$$$$\sum_{i=1}^t \left(1\cdot \sqrt{n_i}\right)\le       \sqrt{\left(\sum_{i=1}^t1^2\right)\left(\sum_{i=1}^t\left(\sqrt n_i\right)^2\right)}=\sqrt{tN}$$$$$$</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #638 (Div. 2)
    1348A
    Феникс и баланс </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Феникс и баланс</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У Феникса есть $$$n$$$ монет с весами $$$2^1, 2^2, \dots, 2^n$$$.       Он знает, что $$$n$$$ — четное.</p>     <p>Он хочет сложить монеты в две кучки так, что в каждой кучке будет       ровно $$$\frac{n}{2}$$$ монет и разница суммарных весов между       кучками будет <span class="tex-font-style-bf">минимальна</span>.       Формально, обозначим за $$$a$$$ сумму весов в первой кучке, а за       $$$b$$$ — сумму весов во второй. Помогите Фениксу минимизировать       $$$|a-b|$$$, то есть модуль числа $$$a-b$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Входные данные состоят из нескольких наборов. В первой строке       задано целое число $$$t$$$ ($$$1 \le t \le 100$$$) — количество       наборов входных данных.</p>     <p>В единственной строке каждого набора задано целое число $$$n$$$       ($$$2 \le n \le 30$$$; $$$n$$$ — четное) — количество монет в       распоряжении Феникса. </p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите единственное целое       число — минимально возможную разницу весов между двумя кучками.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
2
4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
6
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных, у Феникса есть две монеты с       весами $$$2$$$ и $$$4$$$. Как бы он ни разделил монеты, разница       будет равна $$$4-2=2$$$.</p>     <p>Во втором наборе входных данных, у Феникса есть четыре монеты с       весами $$$2$$$, $$$4$$$, $$$8$$$ и $$$16$$$. Фениксу выгодно       положить монеты с весами $$$2$$$ и $$$16$$$ в одну кучку, а монеты       с весами $$$4$$$ и $$$8$$$ — в другую. Разница будет равна $$$(2+16)-(4+8)=6$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1348/problem/A' title='Codeforces Round 638 (Div. 2)'>1348A - Phoenix and Balance</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>We observe that the coin with the weight $$$2^n$$$ is greater       than the sum of all the other weights combined. This is true       because $$$\sum\limits_{i = 1}^{n-1}2^i=2^n-2$$$. Therefore, the       pile that has the heaviest coin will always weigh more. To       minimize the weight differences, we put the $$$n/2-1$$$ lightest       coins into the pile with the heaviest coin. The answer will be       $$$(2^n+\sum\limits_{i = 1}^{n/2-1}2^i)-\sum\limits_{i = n/2}^{n-1}2^i$$$.</p>     <p>Time complexity for each test case: $$$O(n)$$$</p>     <p>You can also solve the problem in $$$O(1)$$$ by simplifying the       mathematical expression.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

void solve(){
  int N;
  cin&gt;&gt;N;
  //note: 1&lt;&lt;X means 2^X
  //we put largest coin in first pile
  int sum1=(1&lt;&lt;N), sum2=0;
  //we put n/2-1 smallest coins in first pile
  for (int i=1;i&lt;N/2;i++)
    sum1+=(1&lt;&lt;i);
  //we put remaining n/2 coins in second pile
  for (int i=N/2;i&lt;N;i++)
    sum2+=(1&lt;&lt;i);
  cout&lt;&lt;sum1-sum2&lt;&lt;endl;
}

int main(){
  int t; cin&gt;&gt;t;
  while (t--)
    solve();
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #638 (Div. 2)
    1348B
    Феникс и красота </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Феникс и красота</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Феникс любит красивые массивы. Он считает массив красивым, если       все его подмассивы длины $$$k$$$ имеют равную сумму. Подмассив       массива — это последовательность подряд идущих элементов массива.</p>     <p>У Феникса есть массив $$$a$$$ длины $$$n$$$. Он хочет вставить       несколько (возможно, ноль) целых чисел в свой массив, чтобы он       стал красивым. Вставляемые числа должны иметь значения от $$$1$$$       по $$$n$$$ включительно. Числа можно вставлять куда угодно (даже       перед первым или после последнего элемента). Феникс <span class="tex-font-style-bf">не пытается</span> минимизировать       количество вставленных чисел.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Входные данные состоят из нескольких наборов. В первой строке       задано целое число $$$t$$$ ($$$1 \le t \le 50$$$) — количество       наборов входных данных.</p>     <p>В первой строке каждого набора входных данных задано два целых       числа $$$n$$$ и $$$k$$$ ($$$1 \le k \le n \le 100$$$).</p>     <p>Во второй строке каждого набора задано $$$n$$$ целых чисел через       пробел ($$$1 \le a_i \le n$$$) — первоначальный массив Феникса.       Массив уже может быть красивым, а может и не быть.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных, если невозможно получить       крассивый массив, выведите <span class="tex-font-style-tt">-1</span>. Иначе, выведите две строки.</p>     <p>В первой строке выведите длину красивого массива $$$m$$$ ($$$n       \le m \le 10^4$$$). Вам не нужно минимизировать $$$m$$$.</p>     <p>Во второй строке выведите $$$m$$$ целых чисел через пробел ($$$1       \le b_i \le n$$$) — красивый массив, который Феникс сможет       получить вставляя несколько (возможно, ноль) целых чисел в свой       массив $$$a$$$. Вы можете выводить числа, которых не было в       массиве $$$a$$$ первоначально.</p>     <p>Если существует несколько решений, выведите любое. Гарантируется,       что если мы можем сделать массив $$$a$$$ красивым, то мы всегда       сможем добиться этого при итоговой длине не более $$$10^4$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
4 2
1 2 2 1
4 3
1 2 2 1
3 2
1 2 3
4 4
4 3 4 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
5
1 2 1 2 1
4
1 2 2 1
-1
7
4 3 2 1 4 3 2</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных, мы можем сделать массив $$$a$$$       красивым, если вставим число $$$1$$$ в позицию $$$3$$$ (между       двумя числами $$$2$$$). Теперь все подмассивы длины $$$k=2$$$       будут иметь одинаковую сумму $$$3$$$. Существует много других       возможных решений, например: </p>     <ul> <li> $$$2, 1, 2, 1, 2, 1$$$ </li>       <li> $$$1, 2, 1, 2, 1, 2$$$ </li></ul>          <p>Во втором наборе, массив уже красивый: все подмассивы длины       $$$k=3$$$ имеют одинаковую сумму $$$5$$$.</p>     <p>В третьем наборе, можно показать, что невозможно вставить числа       так, чтобы сделать массив $$$a$$$ красивым.</p>     <p>В четвертом наборе, предложенный массив $$$b$$$ является       красивым — все его подмассивы длины $$$k=4$$$ имеют равную сумму       $$$10$$$. Также существуют и другие решения.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1348/problem/B' title='Codeforces Round 638 (Div. 2)'>1348B - Phoenix and Beauty</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>For an array to be beautiful for some $$$k$$$, the array must be       periodic with period $$$k$$$. If there exists more than $$$k$$$       distinct numbers in the array $$$a$$$, there is no answer and we       print <span class="tex-font-style-tt">-1</span> (because the array       cannot be periodic with period $$$k$$$). Otherwise, we propose the       following construction.</p>     <p>Consider a list of all the distinct numbers in array $$$a$$$. If       there are less than $$$k$$$ of them, we will append some $$$1$$$s       (or any other number) until the list has size $$$k$$$. We can just       print this list $$$n$$$ times. The length of our array $$$b$$$ is       $$$nk$$$, which never exceeds $$$10^4$$$. Array $$$b$$$ can always       be constructed by inserting some numbers into array $$$a$$$       because every number in $$$a$$$ corresponds to one list.</p>     <p>Time complexity for each test case: $$$O(n \log{n}+nk)$$$</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

void solve(){
  int N,K;
  cin&gt;&gt;N&gt;&gt;K;
  set&lt;int&gt;s;
  for (int i=0;i&lt;N;i++){
    int a;
    cin&gt;&gt;a;
    s.insert(a);
  }
  //if more than K distinct numbers, print -1
  if (s.size()&gt;K){
    cout&lt;&lt;-1&lt;&lt;endl;
    return;
  }
  cout&lt;&lt;N*K&lt;&lt;endl;
  for (int i=0;i&lt;N;i++){
    //print the distinct numbers
    for (int b:s)
      cout&lt;&lt;b&lt;&lt;&#39; &#39;;
    //print the extra 1s
    for (int j=0;j&lt;K-(int)s.size();j++)
      cout&lt;&lt;1&lt;&lt;&#39; &#39;;
  }
  cout&lt;&lt;endl;
}

int main(){
  int t; cin&gt;&gt;t;
  while (t--)
    solve();
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #638 (Div. 2)
    1348C
    Феникс и распределение </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Феникс и распределение</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У Феникса есть строка $$$s$$$, состоящая из строчных букв       латинского алфавита. Он хочет распределить все буквы своей строки       по $$$k$$$ <span class="tex-font-style-bf">непустым</span> строкам       $$$a_1, a_2, \dots, a_k$$$ так, что каждая буква из $$$s$$$       попадет ровно в одну из строк $$$a_i$$$. Строки $$$a_i$$$ <span class="tex-font-style-bf">не обязаны</span> быть подстроками       $$$s$$$. Феникс может распределить буквы $$$s$$$ и переупорядочить       их внутри каждой строки $$$a_i$$$ так как захочет.</p>     <p>Например, если $$$s = $$$ <span class="tex-font-style-tt">baba</span> и $$$k=2$$$, Феникс может       распределить буквы своей строки множеством способов, в том числе: </p>     <ul> <li> <span class="tex-font-style-tt">ba</span> и <span class="tex-font-style-tt">ba</span> </li>       <li> <span class="tex-font-style-tt">a</span> и <span class="tex-font-style-tt">abb</span> </li>       <li> <span class="tex-font-style-tt">ab</span> и <span class="tex-font-style-tt">ab</span> </li>       <li> <span class="tex-font-style-tt">bb</span> и <span class="tex-font-style-tt">aa</span> </li></ul>          <p>Однако получить такие варианты он не может: </p>     <ul> <li> <span class="tex-font-style-tt">baa</span> и <span class="tex-font-style-tt">ba</span> </li>       <li> <span class="tex-font-style-tt">b</span> и <span class="tex-font-style-tt">ba</span> </li>       <li> <span class="tex-font-style-tt">baba</span> и пустая строка         ($$$a_i$$$ должны быть непустыми) </li></ul>          <p>Феникс хочет разделить свою строку $$$s$$$ на $$$k$$$ строк       $$$a_1, a_2, \dots, a_k$$$ так, чтобы <span class="tex-font-style-bf">минимизировать</span> лексикографически       максимальную строку среди них, т. е. минимизировать $$$max(a_1,       a_2, \dots, a_k)$$$. Помогите ему найти оптимальное распределение       и выведите минимально возможное значение $$$max(a_1, a_2, \dots, a_k)$$$.</p>     <p>Строка $$$x$$$ лексикографически меньше, чем строка $$$y$$$, если       либо $$$x$$$ является префиксом $$$y$$$ (и $$$x \ne y$$$), либо       существует такой индекс $$$i$$$ ($$$1 \le i \le min(|x|, |y|))$$$,       что $$$x_i$$$ &lt; $$$y_i$$$ и для всех $$$j$$$ $$$(1 \le j &lt;       i)$$$ $$$x_j = y_j$$$. Здесь $$$|x|$$$ обозначает длину строки $$$x$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Входные данные состоят из нескольких наборов. В первой строке       задано целое число $$$t$$$ ($$$1 \le t \le 1000$$$) — количество       наборов входных данных. Каждый набор состоит из двух строк.</p>     <p>В первой строке каждого набора задано два целых числа $$$n$$$ и       $$$k$$$ ($$$1 \le k \le n \le 10^5$$$)  — длина строки $$$s$$$ и       количество не пустых строк, в которые Феникс хочет распределить       буквы $$$s$$$, соответственно.</p>     <p>Во второй строке каждого набора задана строка $$$s$$$ длины       $$$n$$$, состоящая из строчных латинских букв.</p>     <p>Гарантируется, что сумма $$$n$$$ по всем наборам входных данных       $$$\le 10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$t$$$ ответов — по одному на набор входных данных;       $$$i$$$-й ответ — минимально возможный $$$max(a_1, a_2, \dots,       a_k)$$$ в $$$i$$$-м наборе.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
4 2
baba
5 2
baacb
5 3
baacb
5 3
aaaaa
6 4
aaxxzz
7 1
phoenix
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
ab
abbc
b
aa
x
ehinopx
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных, одно из оптимальных решений —       разбить <span class="tex-font-style-tt">baba</span> на <span class="tex-font-style-tt">ab</span> и <span class="tex-font-style-tt">ab</span>. </p>     <p>Во втором наборе входных данных, одно из оптимальных решений —       разбить <span class="tex-font-style-tt">baacb</span> на <span class="tex-font-style-tt">abbc</span> и <span class="tex-font-style-tt">a</span>.</p>     <p>В третьем наборе, одно из оптимальных решений — разбить <span class="tex-font-style-tt">baacb</span> на <span class="tex-font-style-tt">ac</span>, <span class="tex-font-style-tt">ab</span> и <span class="tex-font-style-tt">b</span>.</p>     <p>В четвертом наборе, одно из оптимальных решений — разбить <span class="tex-font-style-tt">aaaaa</span> на <span class="tex-font-style-tt">aa</span>, <span class="tex-font-style-tt">aa</span> и <span class="tex-font-style-tt">a</span>.</p>     <p>В пятом наборе, одно из оптимальных решений — разбить <span class="tex-font-style-tt">aaxxzz</span> на <span class="tex-font-style-tt">az</span>, <span class="tex-font-style-tt">az</span>, <span class="tex-font-style-tt">x</span> и <span class="tex-font-style-tt">x</span>.</p>     <p>В шестом наборе, одно из оптимальных решений — разбить <span class="tex-font-style-tt">phoenix</span> на <span class="tex-font-style-tt">ehinopx</span>.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1348/problem/C' title='Codeforces Round 638 (Div. 2)'>1348C - Phoenix and Distribution</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>We first try to assign one letter to each string $$$a_i$$$. Let's       denote the smallest letter in $$$s$$$ as $$$c$$$. If there exists       at least $$$k$$$ occurrences of $$$c$$$ in $$$s$$$, we will assign       $$$c$$$ as the first letter of each string $$$a_i$$$. Otherwise,       the minimal solution is the $$$k$$$th smallest letter in $$$s$$$.       For example, if $$$s=$$$<span class="tex-font-style-tt">aabbb</span> and $$$k=3$$$, the       $$$3$$$rd smallest letter is $$$b$$$ and that will be the answer. </p>     <p>Otherwise, we consider the letters that are left in $$$s$$$. If       they are all the same letter (or there are no letters left because       $$$n=k$$$), we split the remaining letters as evenly as possible       among $$$a_i$$$. If not, we will show that it is optimal to sort       the remaining letters in $$$s$$$ and append them to arbitrary       $$$a_i$$$. </p>     <p>For example, let's suppose after assigning a letter to each       $$$a_i$$$ that the remaining letters in $$$s$$$ are <span class="tex-font-style-tt">aaabb</span>. We want to assign the       $$$b$$$s as late as possible, so any string $$$a_i$$$ that       receives a $$$b$$$ should have some number of $$$a$$$s before. It       makes sense in fact that the string that receives a $$$b$$$ should       receive <span class="tex-font-style-bf">all</span> the $$$a$$$s,       because if not it will be lexicographically larger. It can then be       shown that all remaining larger letters should be sorted and added       to the same string $$$a_i$$$ to minimize the answer.</p>     <p>Time complexity for each test case: $$$O(n \log{n})$$$ (for       sorting $$$s$$$)</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

void solve(){
  int n,k;
  cin&gt;&gt;n&gt;&gt;k;
  string s;
  cin&gt;&gt;s;
  sort(s.begin(),s.end());
  //if smallest k letters are not all the same, answer is kth smallest letter
  if (s[0]!=s[k-1]){
    cout&lt;&lt;s[k-1]&lt;&lt;endl;
    return;
  }
  cout&lt;&lt;s[0];
  //if remaining letters aren&#39;t the same, we append remaining letters to answer
  if (s[k]!=s[n-1]){
    for (int i=k;i&lt;n;i++)
      cout&lt;&lt;s[i];
  }
  else{
    //remaining letters are the same, so we distribute evenly
    for (int i=0;i&lt;(n-k+k-1)/k;i++)
      cout&lt;&lt;s[n-1];
  }
  cout&lt;&lt;endl;
}

int main(){
  int t; cin&gt;&gt;t;
  while (t--)
    solve();
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #638 (Div. 2)
    1348D
    Феникс и наука </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Феникс и наука</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Феникс решил стать ученым! Сейчас он изучает рост бактерий.</p>     <p>Изначально, в день $$$1$$$, есть одна бактерия массой $$$1$$$.</p>     <p>Каждый день некоторое количество бактерий делятся (возможно, все       или ни одной). Когда бактерия массой $$$m$$$ делится, она       превращается в две бактерии массой $$$\frac{m}{2}$$$ каждая.       Например, бактерия массой $$$3$$$ может разделиться на две       бактерии массой $$$1.5$$$.</p>     <p>Каждую ночь масса каждой бактерии увеличивается на один.</p>     <p>Феникса интересует вопрос: может ли общая масса бактерий стать в       точности равна $$$n$$$. Если может, то его интересует как добиться       такой массы за минимальное количество ночей. Помогите ему стать       самым лучшим ученым!</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Входные данные состоят из нескольких наборов. В первой строке       задано целое число $$$t$$$ ($$$1 \le t \le 1000$$$) — количество       наборов входных данных.</p>     <p>В единственной строке каждого набора задано целое число $$$n$$$       ($$$2 \le n \le 10^9$$$) — суммарная масса бактерий, которой хочет       добиться Феникс.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных, если не существует способа       получить общую массу равную $$$n$$$, выведите <span class="tex-font-style-tt">-1</span>. В противном случае, выведите       две строки.</p>     <p>В первой строке выведите целое число $$$d$$$ — минимальное       необходимое количество ночей.</p>     <p>В следующей строке выведите $$$d$$$ целых чисел, где $$$i$$$-е       число обозначает количество бактерий, которые поделятся в       $$$i$$$-й день.</p>     <p>Если существует несколько решений, выведите любое из них.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
9
11
2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
1 0 2 
3
1 1 2
1
0 </pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе, можно получить общую массу бактерий ровно       $$$9$$$ следующим образом: </p>     <ul> <li> День $$$1$$$: Бактерия с массой $$$1$$$ делится. Получаем         две бактерии с массой $$$0.5$$$. </li>       <li> Ночь $$$1$$$: Все бактерии увеличивают массу на один.         Получаем две бактерии с массой $$$1.5$$$. </li>       <li> День $$$2$$$: Ни одна бактерия не делится. </li>       <li> Ночь $$$2$$$: Получаем две бактерии с массой $$$2.5$$$. </li>       <li> День $$$3$$$: Обе бактерии делятся. Получаем четыре бактерии         с массой $$$1.25$$$. </li>       <li> Ночь $$$3$$$: Получаем четыре бактерии с массой $$$2.25$$$.     </li></ul> Суммарная масса равна $$$2.25+2.25+2.25+2.25=9$$$. Можно     доказать, что $$$3$$$ — минимальное необходимое количество ночей.     Есть и другие способы добиться суммарной массы 9 за 3 ночи.     <p>$$$ $$$</p>     <p>В втором наборе, можно получить общую массу бактерий ровно       $$$11$$$ следующим образом: </p>     <ul> <li> День $$$1$$$: Бактерия с массой $$$1$$$ делится. Получаем         две бактерии с массой $$$0.5$$$. </li>       <li> Ночь $$$1$$$: Получаем две бактерии с массой $$$1.5$$$. </li>       <li> День $$$2$$$: Одна бактерия делится. Получаем три бактерии с         массами $$$0.75$$$, $$$0.75$$$ и $$$1.5$$$. </li>       <li> Ночь $$$2$$$: Получаем три бактерии с массами $$$1.75$$$,         $$$1.75$$$ и $$$2.5$$$. </li>       <li> День $$$3$$$: Бактерия с массой $$$1.75$$$ и бактерия с         массой $$$2.5$$$ делятся. Получаем пять бактерий с массами         $$$0.875$$$, $$$0.875$$$, $$$1.25$$$, $$$1.25$$$ и $$$1.75$$$. </li>       <li> Ночь $$$3$$$: Получаем пять бактерий с массами $$$1.875$$$,         $$$1.875$$$, $$$2.25$$$, $$$2.25$$$ и $$$2.75$$$. </li></ul>     Суммарная масса равна $$$1.875+1.875+2.25+2.25+2.75=11$$$. Можно     доказать, что $$$3$$$ — минимальное необходимое количество ночей.     Есть и другие способы добиться суммарной массы 11 за 3 ночи.     <p>$$$ $$$</p>     <p>Во третьем наборе, бактерия не делится в день $$$1$$$, а потом       увеличивает массу до $$$2$$$ в ночь $$$1$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1348/problem/D' title='Codeforces Round 638 (Div. 2)'>1348D - Phoenix and Science</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>There exists many constructive solutions, here is one I think is       very elegant. We will try to approach the problem by considering       how much the total mass increases every night. If there are       $$$x$$$ bacteria some day before the splitting, that night can       have a mass increase between $$$x$$$ and $$$2x$$$ inclusive       (depending on how many bacteria split that day).</p>     <p>Therefore, we can reword the problem as follows: construct a       sequence $$$a$$$ of minimal length $$$a_0=1, a_1, \dots, a_k$$$       such that $$$a_i \le a_{i+1} \le 2a_i$$$ and the sum of $$$a_i$$$       is $$$n$$$. To minimize the length of sequence $$$a$$$, we will       start building our sequence with $$$1, 2, \dots, 2^x$$$ such that       the total sum $$$s$$$ is less than or equal to $$$n$$$. If the       total sum is $$$n$$$, we are done. Otherwise, we insert $$$n-s$$$       into our sequence and sort. This gives a valid sequence of minimal length.</p>     <p>To transform our sequence $$$a$$$ into the answer, we can just       print the differences $$$a_i-a_{i-1}$$$ because the number of       bacteria that split during the day is equal to how much the mass       increase changes.</p>     <p>Time complexity for each test case: $$$O(\log{n})$$$, if you sort       by insertion</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

void solve(){
  vector&lt;int&gt;inc;   
  int N;
  cin&gt;&gt;N;
  //construct sequence 1, 2, 4, ... while sum &lt;= N
  for (int i=1;i&lt;=N;i*=2){
    inc.push_back(i);
    N-=i;
  }
  //if sum is not N, we insert and sort
  if (N&gt;0){
    inc.push_back(N);
    sort(inc.begin(),inc.end());
  }
  cout&lt;&lt;inc.size()-1&lt;&lt;endl;
  for (int i=1;i&lt;(int)inc.size();i++)
    cout&lt;&lt;inc[i]-inc[i-1]&lt;&lt;&#39; &#39;;
  cout&lt;&lt;endl;
}

int main(){
  int t; cin&gt;&gt;t;
  while (t--)
    solve();
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #638 (Div. 2)
    1348E
    Феникс и ягода </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. Феникс и ягода</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Феникс собирает ягоды у себя на заднем дворе. Там растет $$$n$$$       кустов, и на каждом кусте созрело $$$a_i$$$ красных ягод и       $$$b_i$$$ синих ягод.</p>     <p>Каждая корзина вмещает $$$k$$$ ягод. Но Феникс решил, что в       каждой корзине могут лежать ягоды с одного куста, или же ягоды       одного цвета (красные или синие). Другими словами все ягоды в       одной корзине должны быть с одного куста и/или одного цвета.</p>     <p>Например, если у Феникса растет два куста с $$$5$$$ красными и       $$$2$$$ синими ягодами на первом кусте и $$$2$$$ красными и       $$$1$$$ синей на втором, то он сможет полностью заполнить $$$2$$$       корзины объемом $$$4$$$: </p>     <ul> <li> в первую корзину он положит $$$3$$$ красные и $$$1$$$         синюю ягоду с первого куста; </li>       <li> во вторую корзину — $$$2$$$ оставшиеся красные ягоды с         первого куста и $$$2$$$ красные ягоды со второго. </li></ul>          <p>Помогите Фениксу определить максимальное количество корзин,       которые он сможет <span class="tex-font-style-bf">заполнить полностью</span>!</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке заданы два целых числа $$$n$$$ и $$$k$$$ ($$$       1\le n, k \le 500$$$)  — количество кустов и вместимость корзин, соответственно.</p>     <p>В $$$i$$$-й из следующих $$$n$$$ сток задано два целых числа       $$$a_i$$$ и $$$b_i$$$ ($$$0 \le a_i, b_i \le 10^9$$$)  —       количество красных и синих ягод на $$$i$$$-м кусте, соответственно.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите единственное число  — максимальное количество корзин,       которые Феникс сможет заполнить полностью.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2 4
5 2
2 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
1 5
2 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
2 5
2 1
1 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
1 2
1000000000 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
500000000
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Первый пример описан выше.</p>     <p>Во втором примере, Феникс может полностью заполнить одну корзину,       используя все ягоды с первого (и единственного) куста.</p>     <p>В третьем примере, Феникс не сможет полностью заполнить ни одной       корзины, потому что на каждом кусте меньше $$$5$$$ ягод, всего       красных ягод менее $$$5$$$ и всего синих ягод менее $$$5$$$.</p>     <p>В четвертом примере, Феникс может положить все красные ягоды в       корзины, оставив синюю ягоду нетронутой.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1348/problem/E' title='Codeforces Round 638 (Div. 2)'>1348E - Phoenix and Berries</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>       <span class="tex-font-style-bf">Solution 1:</span></p>     <p>There is no obvious greedy solution, so we will try dynamic       programming. Let $$$dp[i][j]$$$ be a boolean array that denotes       whether we can have $$$j$$$ extra red berries after considering       the first $$$i$$$ shrubs. A berry is extra if it is not placed       into a full basket (of any kind). Note that if we know that there       are $$$j$$$ extra red berries, we can also easily calculate how       many extra blue berries there are. Note that we can choose to       never have more than $$$k-1$$$ extra red berries, because       otherwise we can fill some number of baskets with them.</p>     <p>To transition from shrub $$$i-1$$$ to shrub $$$i$$$, we loop over       all possible values $$$l$$$ from $$$0$$$ to $$$min(k-1, a_i)$$$       and check whether or not we can leave $$$l$$$ extra red berries       from the current shrub $$$i$$$. For some $$$i$$$ and $$$j$$$, we       can leave $$$l$$$ extra red berries and put the remaining red       berries in baskets possibly with blue berries from the same shrub       if $$$(a_i-l)$$$ $$$mod$$$ $$$k+b_i \ge k$$$. The reasoning for       this is as follows:</p>     <p>First of all, we are leaving $$$l$$$ red berries (or at least       trying to). We show that from this shrub, there will be at most       one basket containing both red and blue berries (all from this       shrub). To place the remaining red berries into full baskets, the       more blue berries we have the better. It is optimal to place the       remaining $$$a_i-l$$$ red berries into their own separate baskets       first before merging with the blue berries (this way requires       fewest blue berries to satisfy the condition). Then, if       $$$(a_i-l)$$$ $$$mod$$$ $$$k+b_i$$$ is at least $$$k$$$, we can       fill some basket with the remaining red berries and possibly some       blue berries. Remember that we do not care about how many extra       blue berries we leave because that is uniquely determined by the       number of extra red berries.</p>     <p>Also note that we can always leave $$$a_i$$$ $$$mod$$$ $$$k$$$       extra red berries.</p>     <p>Denote the total number of berries as $$$t$$$. The answer will be       maximum over all $$$(t-j)/k$$$ such that $$$dp[n][j]$$$ is true,       $$$0\le j\le k-1$$$.</p>     <p>Time Complexity: $$$O(nk^2)$$$</p>     <p>       <span class="tex-font-style-bf">Solution 2:</span></p>     <p>We use dynamic programming. Let $$$dp[i][j]$$$ be true if after       considering the first $$$i$$$ shrubs , $$$j$$$ is the number of       red berries in heterogenous baskets modulo $$$k$$$. Heterogenous       baskets contain berries from the same shrub, and homogenous       baskets contain berries of the same type.</p>     <p>Suppose we know the number of red berries in heterogeneous       baskets modulo $$$k$$$. This determines the number of blue berries       in heterogeneous baskets modulo $$$k$$$. Since the number of red       berries in homogeneous baskets is a multiple of $$$k$$$, it also       determines the number of red berries not in any baskets (we can       safely assume this to be less than $$$k$$$ since otherwise we can       form another basket). Similarly, we can determine the number of       blue berries not in any basket, and thus deduce the number of baskets.</p>     <p>To compute the possible numbers of red berries in heterogeneous       baskets modulo $$$k$$$, it suffices to look at each shrub       separately and determine the possible numbers of red berries       modulo $$$k$$$ in heterogeneous baskets for that shrub. If there       is more than one heterogeneous basket for one shrub, we can       rearrange the berries to leave at most one heterogeneous. Now we       have two cases. If there are no heterogeneous baskets, the number       of red berries in those baskets is obviously zero. If there is one       heterogeneous basket, let $$$x$$$ be the number of red berries in       it and $$$k-x$$$ be the number of blue berries in it. Clearly,       $$$0\le x \le a_i$$$ and $$$0 \le k-x \le b_i$$$. Rearranging, we       get $$$max(0,k−b_i)\le x \le min(a_i,k)$$$. These correspond to       the transitions for our DP.</p>     <p>There exists faster solutions (like $$$O(nk)$$$), can you find it?</p></div></div></div>

           
            <pre><code>//Solution 1
#include &lt;bits/stdc++.h&gt;
using namespace std;

int N,K;
int a[505],b[505];
bool dp[505][505];  //number of shrubs considered, &#34;extra&#34; red berries

int main(){
  cin&gt;&gt;N&gt;&gt;K;
  long long totA=0,totB=0;
  for (int i=1;i&lt;=N;i++){
    cin&gt;&gt;a[i]&gt;&gt;b[i];
    totA+=a[i];
    totB+=b[i];
  }
  dp[0][0]=true;
  for (int i=1;i&lt;=N;i++){
    for (int j=0;j&lt;K;j++){
      //leave a[i]%K extra red berries
      dp[i][j]=dp[i-1][(j-a[i]%K+K)%K];
      for (int l=0;l&lt;=min(K-1,a[i]);l++){
	//check if we can leave l extra red berries
	if ((a[i]-l)%K+b[i]&gt;=K)
	  dp[i][j]|=dp[i-1][(j-l+K)%K];
      }
    }
  }
  long long ans=0;
  for (int i=0;i&lt;K;i++){
    if (dp[N][i])
      ans=max(ans,(totA+totB-i)/K);
  }
  cout&lt;&lt;ans&lt;&lt;endl;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #638 (Div. 2)
    1348F
    Феникс и память </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Феникс и память</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Феникс хотел сделать фото своих $$$n$$$ друзей, пронумерованных       $$$1, 2, \dots, n$$$. Друзья стояли в ряд в некотором порядке. И       тут вдруг пришли печенеги с половцами и всех переставили.</p>     <p>Теперь Фениксу нужно восстановить данный порядок, но он почти       ничего не помнит! Все, что Феникс запомнил, — что $$$i$$$-й слева       друг имеет номер от $$$a_i$$$ по $$$b_i$$$ включительно.       Единственным ли является порядок друзей, подходящий под его воспоминания?</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке задано целое число $$$n$$$ ($$$1 \le n \le       2\cdot10^5$$$) — количество друзей.</p>     <p>В $$$i$$$-й из следующих $$$n$$$ строк заданы два целых числа       $$$a_i$$$ и $$$b_i$$$ ($$$1 \le a_i \le b_i \le n$$$) — то, что       запомнил Феникс про $$$i$$$-ю позицию слева.</p>     <p>Гарантируется, что информация, которую запомнил Феникс, не       противоречива, и существует хотя бы один подходящий порядок.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Если существует единственный подходящий порядок друзей, выведите         <span class="tex-font-style-tt">YES</span>, а далее $$$n$$$       целых чисел, где $$$i$$$-е число означает номер $$$i$$$-го слева друга.</p>     <p>В противном случае, выведите <span class="tex-font-style-tt">NO</span>. Далее, <span class="tex-font-style-bf">выведите любые два подходящих       порядка</span> на следующих двух строках. Если существует       несколько ответов, выведите любой.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
4 4
1 3
2 4
3 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
YES
4 1 2 3 
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
1 3
2 4
3 4
2 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
NO
1 3 4 2 
1 2 4 3 
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1348/problem/F' title='Codeforces Round 638 (Div. 2)'>1348F - Phoenix and Memory</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>There are many many many solutions to this problem (which is       cool!). I describe two of them below.</p>     <p>Both solutions first find an arbitrary valid ordering. This can       be done in $$$O(n\log{n})$$$ with a greedy algorithm. We can sort       the intervals $$$(a_i,b_i)$$$ and sweep from left to right. To see       which position that we can assign friend $$$j$$$ to, we process       all intervals with $$$a_i \le j$$$ and insert $$$b_i$$$ into a       multiset (or similar) structure. We match friend $$$j$$$ to the       interval with minimal $$$b_i$$$.</p>     <p>       <span class="tex-font-style-bf">Solution $$$1$$$:</span></p>     <p>We prove that if there exists more than one valid ordering, we       can transform one into another by swapping two friends.</p>     <p>Proof:</p>     <p>In our valid ordering, each friend is assigned a position. We can       think of this as a point being assigned to an interval (Friend -       point, position - interval). We will prove there exists a cycle of       length $$$2$$$ or there exists no cycle at all.</p>     <p>Suppose we have a cycle: each point is on its interval and its       predecessor's interval. Let's take the shortest cycle of length at       least two. Let $$$q$$$ be the leftmost point, $$$p$$$ be $$$q$$$'s       predecessor, and $$$r$$$ be $$$q$$$'s successor.</p>     <p>Case $$$1$$$: $$$q$$$'s interval's right endpoint is to the right       of $$$p$$$. $$$p$$$ and $$$q$$$ form a cycle of length $$$2$$$.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/0bc6efd16d6260064715689190a415e138042a7a.png" style="max-width: 100.0%;max-height: 100.0%;" />   </center>          <p>Case $$$2$$$: $$$q$$$'s interval's right endpoint is to the left       of $$$p$$$. $$$r$$$ must be between $$$q$$$ and $$$p$$$. So, we       can remove $$$q$$$ and get a shorter cycle. This is a contradiction.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/8e7359b74b09b8502d843b83952a9bef58941ec4.png" style="max-width: 100.0%;max-height: 100.0%;" />   </center>          <p>$$$\square$$$</p>     <p>Denote $$$p_i$$$ as the position that friend $$$i$$$ is assigned       to in our arbitrary ordering. Now, we are interested whether or       not there exists a friend $$$i$$$ such that there also exists some       friend $$$j$$$ with $$$p_j$$$ such that $$$p_i &lt; p_j \le       b_{p_i}$$$ and $$$a_{p_j} \le p_i$$$. If there does, we can swap       friends $$$i$$$ and $$$j$$$ to make another valid ordering. This       can be done with a segment tree (build it with values $$$a_i$$$).</p>     <p>Time Complexity: $$$O(n \log n)$$$</p>     <p>       <span class="tex-font-style-bf">Solution $$$2$$$:</span></p>     <p>The problem is equivalent to checking if there is a unique       perfect matching in the following bipartite graph:</p>     <p>The vertices on the left correspond to position. The vertices on       the right correspond to labels of the friends. A directed edge       from a position node to a label node exists iff the friend with       that label can be at that position.</p>     <p>Find a perfect matching (corresponding to finding any valid       assignment) as described above. </p>     <p>The matching is unique iff contracting the edges (merging nodes       connected by edges from our perfect matching into one node) in the       perfect matching creates a DAG. The reasoning is as follows:</p>     <p>Consider a simpler graph, with only nodes representing positions.       We draw a directed edge from node $$$i$$$ to node $$$j$$$ if the       friend currently assigned at position $$$i$$$ (from our greedy)       can also be assigned to position $$$j$$$. So, if there exists any       cycle, we can shift the friends around the cycle to create another       valid ordering. In other words, if our graph is a DAG, the perfect       matching is unique.</p>     <p>Now, returning back to the bipartite graph, we see that it is       essentially the same. By contracting edges, all position nodes are       equivalent to the friend node that is assigned to them (from the       greedy). So, following an edge from the left side (position) to       the right side (friend) puts us back on the left side (position),       and this graph corresponds to the simpler version I explained above.</p>     <p>So, this can be done by DFS in $$$O(n^2)$$$, but this is too       slow. We can speed it up by storing a set of unvisited vertices       and only iterating across those (by binary search on set-like       structure). Binary search works because every position corresponds       to a range of friends.</p>     <p>Time Complexity: $$$O(n \log{n})$$$</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

const int INF=1e9+7;
 
int as[200005], bs[200005];
         
vector&lt;pair&lt;int,int&gt; &gt; start[200005];
int ans[200005];
int where[200005];
int N;
         
void show(){
  for(int i=1;i&lt;=N;i++)
    cout&lt;&lt;ans[i]&lt;&lt;&#39; &#39;;
  cout&lt;&lt;endl;
}
 
pair&lt;int,int&gt; st[400005];
 
int query(int l,int r){
  l--;
  pair&lt;int,int&gt; res{INF,INF};
  for(l+=N,r+=N;l&lt;r;l&gt;&gt;=1,r&gt;&gt;=1){
    if(l&amp;1) res=min(res,st[l++]);
    if(r&amp;1) res=min(res,st[--r]);
  }
  return res.second;
}
         
int main(){
  cin&gt;&gt;N; 
  for(int i=1;i&lt;=N;i++){
    cin&gt;&gt;as[i]&gt;&gt;bs[i];
    start[as[i]].push_back({bs[i],i});
  }
  set&lt;pair&lt;int,int&gt; &gt; active;//(right,index)
  for(int i=1;i&lt;=N;i++){
    active.insert(start[i].begin(),start[i].end());
    ans[active.begin()-&gt;second]=i;
    where[i]=active.begin()-&gt;second;
    active.erase(active.begin());
  }
  for(int i=0;i&lt;N;i++){
    st[i+N]={as[where[i+1]],i+1};
  }
  for(int i=N-1;i&gt;0;i--){
    st[i]=min(st[i&lt;&lt;1],st[i&lt;&lt;1|1]);
  }
  for(int i=1;i&lt;=N;i++){
    int j=query(i+1,bs[where[i]]);
    if(j==INF) continue;
    if(as[where[j]]&lt;=i){
      cout&lt;&lt;&#34;NO&#34;&lt;&lt;endl;
      show();
      swap(ans[where[i]],ans[where[j]]);
      show();
      return 0;
    }
  }
  cout&lt;&lt;&#34;YES&#34;&lt;&lt;endl;
  show();
}
</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int N;
int a[200005],b[200005];
int label[200005]; //the label of the person at i-th position in our perfect matching
int label2[200005]; //which position the i-th person is at

void perfectMatch(){ //finds a perfect matching
  deque&lt;pair&lt;pair&lt;int,int&gt;,int&gt;&gt;v;
  for (int i=1;i&lt;=N;i++)
    v.push_back({{a[i],b[i]},i});
  sort(v.begin(),v.end());
  multiset&lt;pair&lt;int,int&gt;&gt;mst;
  for (int i=1;i&lt;=N;i++){
    while ((int)v.size()&gt;0 &amp;&amp; v[0].first.first&lt;=i){
      mst.insert({v[0].first.second,v[0].second});
      v.pop_front();
    }
    //match person with label to earliest ending interval
    label2[i]=mst.begin()-&gt;second;
    label[mst.begin()-&gt;second]=i;
    mst.erase(mst.find(*mst.begin()));
  }
}

set&lt;int&gt;active;
int vis[200005];
int from[200005];
int ans[200005];

void foundAnother(int node, int nextNode){
  vector&lt;int&gt;v;
  int cur=node;
  //backtracks on cycle to find other ordering
  while (cur!=label2[nextNode]){
    v.push_back(cur);
    cur=from[cur];
  }
  reverse(v.begin(),v.end());
  v.push_back(label2[nextNode]);
  reverse(v.begin(),v.end());
  cout&lt;&lt;&#34;NO&#34;&lt;&lt;endl;
  for (int i=1;i&lt;=N;i++)
    cout&lt;&lt;label[i]&lt;&lt;&#39; &#39;;
  cout&lt;&lt;endl;
  for (int i=1;i&lt;=N;i++)
    ans[i]=label[i];
  int temp=ans[v.back()];
  for (int i=0;i&lt;(int)v.size();i++)
    swap(temp,ans[v[i]]);
  for (int i=1;i&lt;=N;i++)
    cout&lt;&lt;ans[i]&lt;&lt;&#39; &#39;;
  cout&lt;&lt;endl;
  exit(0);
}
  
void dfs(int node){
  //activates node
  vis[node]=1;
  queue&lt;int&gt;toRemove;
  for (;;){
    //binary search for unvisisited neighbor
    auto it=active.lower_bound(a[node]);
    if (it!=active.end() &amp;&amp; *it==label[node]){
      toRemove.push(*it);
      it++;
    }
    if (it==active.end() || *it&gt;b[node])
      break;
    if (vis[label2[*it]]==1) //found cycle (another ordering)
      foundAnother(node,*it);
    toRemove.push(*it);
    if (vis[label2[*it]]==2)
      continue;
    from[label2[*it]]=node;
    dfs(label2[*it]);
  }
  //removes visited nodes from set
  while (!toRemove.empty()){
    if (active.count(toRemove.front()))
      active.erase(toRemove.front());
    toRemove.pop();
  }
  //deactivates and retire node
  vis[node]=2;
}

int main(){
  cin&gt;&gt;N;
  for (int i=1;i&lt;=N;i++)
    cin&gt;&gt;a[i]&gt;&gt;b[i];
  perfectMatch();
  for (int i=1;i&lt;=N;i++)
    active.insert(i);
  for (int i=1;i&lt;=N;i++)
    if (vis[i]==0)
      dfs(i);
  cout&lt;&lt;&#34;YES&#34;&lt;&lt;endl;
  for (int i=1;i&lt;=N;i++)
    cout&lt;&lt;label[i]&lt;&lt;&#39; &#39;;
  cout&lt;&lt;endl;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #641 (Div. 1)
    1349A
    Орак и LCM </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Орак и LCM</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>3 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Для мультимножества натуральных чисел       $$$s=\{s_1,s_2,\dots,s_k\}$$$, определим наименьшее общее кратное         («<span class="tex-font-style-tt">LCM</span>» по-английски) и       наибольший общий делитель («<span class="tex-font-style-tt">GCD</span>» по-английски) $$$s$$$       следующим образом:</p>          <ul>                     <li> $$$\gcd(s)$$$ это максимальное натуральное число $$$x$$$,         такое что все числа из $$$s$$$ делятся на $$$x$$$.         </li>       <li> $$$\textrm{lcm}(s)$$$ это минимальное натуральное число         $$$x$$$, которое делится на все числа из $$$s$$$.         </li></ul>          <p>Например, $$$\gcd(\{8,12\})=4,\gcd(\{12,18,6\})=6$$$ и       $$$\textrm{lcm}(\{4,6\})=12$$$. Обратите внимание, что для любого       натурального числа $$$x$$$, $$$\gcd(\{x\})=\textrm{lcm}(\{x\})=x$$$.</p>     <p>У Орака есть последовательность $$$a$$$ длины $$$n$$$. Он       придумал мультимножество $$$t=\{\textrm{lcm}(\{a_i,a_j\})\ |\       i&lt;j\}$$$ и попросил вас найти $$$\gcd(t)$$$ для него. Иначе       говоря, вам нужно найти НОД НОКов всех пар элементов в данной последовательности.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$n\ (2\le n\le 100\,000)$$$.</p>     <p>Во второй строке записаны $$$n$$$ целых чисел, $$$a_1, a_2,       \ldots, a_n$$$ ($$$1 \leq a_i \leq 200\,000$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одно целое число: $$$\gcd(\{\textrm{lcm}(\{a_i,a_j\})\       |\ i&lt;j\})$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
1 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
10 24 40 80
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
40
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
10
540 648 810 648 720 540 594 864 972 648
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
54
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере $$$t=\{\textrm{lcm}(\{1,1\})\}=\{1\}$$$, и $$$\gcd(t)=1$$$.</p>     <p>Во втором примере $$$t=\{120,40,80,120,240,80\}$$$. Нетрудно       видеть, что $$$\gcd(t)=40$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1349/problem/A' title='Codeforces Round 641 (Div. 1)'>1349A - Orac and LCM</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>In this tutorial $$$p$$$ stands for a prime, $$$v$$$ stands for       the maximum of $$$a_i$$$ and $$$ans$$$ stands for the answer.</p>     <p>       <span class="tex-font-style-bf">Observation.</span> $$$p^k\ \mid\       ans$$$ if and only if there are at least $$$n-1$$$ integers in       $$$a$$$ that $$$\mathrm{s.t. }\ p^k\mid\ a_i$$$.</p>     <p>       <span class="tex-font-style-bf">Proof.</span> if there are at most       $$$n-2$$$ integers in $$$a$$$ that $$$\mathrm{s.t. }\ p^k\mid\       a_i$$$, there exists $$$x\neq y$$$ $$$\mathrm{s.t.}\ p^k\nmid       a_x$$$ $$$\mathrm{and}$$$ $$$p^k\nmid a_y$$$, so $$$p^k \nmid       \textrm{lcm}(\{a_x,a_y\})$$$ and $$$p^k\ \nmid\ ans$$$. On the       contrary, if there are at least $$$n-1$$$ integers in $$$a$$$       $$$\mathrm{s.t. }\ p^k\mid\ a_i$$$, between every two different       $$$a_i$$$ there will be at least one multiple of $$$p^k$$$. So for       every $$$(x,y)$$$, $$$p^k \mid \textrm{lcm}(\{a_x,a_y\})$$$.       Therefore $$$p^k\ \mid\ ans$$$.</p>     <p>       <span class="tex-font-style-bf">Solution 1.</span> Define       $$$d_i$$$ as a set that consists of all the numbers in $$$a$$$       except $$$a_i$$$. So $$$\gcd(d_i)$$$ is divisible by at least       $$$n-1$$$ numbers in $$$a$$$. Also, if at least $$$n-1$$$ integers       in $$$a$$$ $$$\mathrm{s.t. }\ p^k\ \mid\ a_i$$$, we can always       find $$$i$$$ $$$\mathrm{s.t. }\ p^k \mid \gcd(d_i)$$$. According       to the Observation, $$$ans=\textrm{lcm}(\{\gcd(d_1),\gcd(d_2),\gcd(d_3),...,\gcd(d_n)\})$$$.</p>     <p>Now consider how to calculate $$$\gcd(d_i)$$$. For every $$$i$$$,       calculate $$$pre_i=\gcd(\{a_1,a_2,...,a_i\})$$$ and       $$$suf_i=\gcd(\{a_{i},a_{i+1},...,a_n\})$$$. Therefore       $$$\gcd(d_i)=\gcd(\{pre_{i-1},suf_{i+1}\})$$$ and we can get       $$$pre$$$ and $$$suf$$$ in $$$O(n\cdot \log(v))$$$ time.</p>     <p>Time complexity: $$$O(n \log v)$$$</p>     <p>       <span class="tex-font-style-bf">Solution 2.</span> Enumerate every       prime $$$\leq v$$$. For a prime $$$p$$$, enumerate every $$$a_i$$$       and calculate $$$k_i$$$ which stands for the maximum integer that       $$$\mathrm{s.t. }\ p^{k_i} \mid a_i$$$. According to the       Observation, the second smallest $$$k_i$$$ is the maximum integer       $$$k$$$ that $$$\mathrm{s.t. }\ p^k \mid ans$$$. Now let's       optimize this solution. If there has been at least two $$$a_i$$$       not divisible by $$$p$$$, then $$$p \nmid ans$$$, so just stop       enumerate $$$a_i$$$.</p>     <p>Time complexity of the optimized solution is $$$O(v+n \log v)$$$       because every integer can be divided for at most $$$\log v $$$ times.</p></div></div></div>

           
            <pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;

using namespace std;
typedef long long ll;

const int maxn=100005;

int n;
ll a[maxn];

ll pre[maxn],suf[maxn];

ll gcd(ll x, ll y)
{
	if(y==0) return x;
	else return gcd(y,x%y);
}

ll ga,ans;

int main()
{
	scanf(&#34;%d&#34;,&amp;n);
	for(int i=1;i&lt;=n;i++) scanf(&#34;%lld&#34;,&amp;a[i]);
	pre[1]=a[1]; suf[n]=a[n];
	for(int i=2;i&lt;=n;i++)
		pre[i]=gcd(pre[i-1],a[i]);
	for(int i=n-1;i&gt;=1;i--)
		suf[i]=gcd(suf[i+1],a[i]);
	for(int i=0;i&lt;=n-1;i++)
	{
		if(i==0)
			ans=suf[2];
		else if(i==n-1)
			ans=ans*pre[n-1]/gcd(pre[n-1],ans);
		else
			ans=ans*gcd(pre[i],suf[i+2])/gcd(gcd(pre[i],suf[i+2]),ans);
	}
	printf(&#34;%lld\n&#34;,ans);
	return 0;
}

</code></pre>
           
            <pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;

using namespace std;
typedef long long ll;

const int maxn=100005;

int n;
ll a[maxn];

ll pre[maxn],suf[maxn];

ll gcd(ll x, ll y)
{
	if(y==0) return x;
	else return gcd(y,x%y);
}

ll ga,ans;

int main()
{
	scanf(&#34;%d&#34;,&amp;n);
	for(int i=1;i&lt;=n;i++) scanf(&#34;%lld&#34;,&amp;a[i]);
	pre[1]=a[1]; suf[n]=a[n];
	for(int i=2;i&lt;=n;i++)
		pre[i]=gcd(pre[i-1],a[i]);
	for(int i=n-1;i&gt;=1;i--)
		suf[i]=gcd(suf[i+1],a[i]);
	for(int i=0;i&lt;=n-1;i++)
	{
		if(i==0)
			ans=suf[2];
		else if(i==n-1)
			ans=ans*pre[n-1]/gcd(pre[n-1],ans);
		else
			ans=ans*gcd(pre[i],suf[i+2])/gcd(gcd(pre[i],suf[i+2]),ans);
	}
	printf(&#34;%lld\n&#34;,ans);
	return 0;
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #641 (Div. 1)
    1349B
    Орак и медианы </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Орак и медианы</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У Слайма есть последовательность натуральных чисел $$$a_1, a_2,       \ldots, a_n$$$.</p>     <p>За одну операцию Орак может выбрать произвольный отрезок $$$[l       \ldots r]$$$ этой последовательности и заменить все числа $$$a_l,       a_{l + 1}, \ldots, a_r$$$ на значение медианы $$$\{a_l, a_{l + 1},       \ldots, a_r\}$$$.</p>     <p>В этой задаче для мультимножества натуральных чисел $$$s$$$,       медиана $$$s$$$ равна $$$\lfloor \frac{|s|+1}{2}\rfloor$$$-у числу       в порядке возрастания в нем. Например, медиана $$$\{1,4,4,6,5\}$$$       равна $$$4$$$, а медиана $$$\{1,7,5,8\}$$$ равна $$$5$$$.</p>     <p>Слайм хочет, чтобы Орак добился $$$a_1 = a_2 = \ldots = a_n =       k$$$ с помощью этих операций.</p>     <p>Орак думает, что это невозможно, и он не хочет тратить свое       время, поэтому он решил спросить вас, можно ли исполнить желание       Слайма, и он может задавать вам запросы такого вида несколько раз.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$t$$$: количество запросов.</p>     <p>В первой строке каждого запроса записано два целых числа $$$n\       (1\le n\le 100\,000)$$$ и $$$k\ (1\le k\le 10^9)$$$, во второй       строке записаны $$$n$$$ натуральных чисел $$$a_1,a_2,\dots,a_n\       (1\le a_i\le 10^9)$$$</p>     <p>Сумма $$$n$$$ по всем запросам не превосходит $$$100\,000$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Вы должны вывести $$$t$$$ строк. В $$$i$$$-й из них должно быть       записано '<span class="tex-font-style-tt">yes</span>', если       возможно превратить все числа в $$$k$$$ за какое-нибудь число       операций или '<span class="tex-font-style-tt">no</span>', иначе.       Каждая выведенная буква может быть как строчной, так и заглавной.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
5 3
1 5 2 6 1
1 6
6
3 2
1 2 3
4 3
3 1 2 3
10 3
1 2 3 4 5 6 7 8 9 10
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
no
yes
yes
no
yes
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом запросе Орак не может превратить все элементы в $$$3$$$.</p>     <p>Во втором запросе $$$a_1=6$$$ уже выполнено.</p>     <p>В третьем запросе Орак может для операции выбрать весь массив и       превратить его в $$$2$$$.</p>     <p>В четвертом запросе Орак не может превратить все элементы в $$$3$$$.</p>     <p>В пятом запросе Орак может сначала выбрать $$$[1,6]$$$, а затем $$$[2,10]$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1349/problem/B' title='Codeforces Round 641 (Div. 1)'>1349B - Orac and Medians</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let $$$B_i=\left\{\begin{aligned}       0,A_i&lt;k\\1,A_i=k\\2,A_i&gt;k\end{aligned} \right.$$$，then just       consider whether it can be done to make all elements in $$$B$$$       become $$$1$$$ in a finite number of operations. </p>     <p>It can be proved that a solution exists if and only if $$$\exists       1\le i\le n,\mathrm{s.t.}B_i=1$$$ and $$$\exists 1\le i&lt;j\le       n,\mathrm{s.t.}j-i\le2,B_i&gt;0,B_j&gt;0$$$ .</p>     <p>The necessity is obvious: if $$$\forall 1\le i\le n, B_i\neq 1$$$       , no elements in $$$B$$$ can be transformed into $$$1$$$; If there       are at least two zeros between any two positive numbers, then the       median of each interval equals to $$$0$$$, no solution exists. </p>     <p>Consider the sufficiency. If there are two adjacent elements in       $$$B$$$ both equals to $$$1$$$ , just select an interval which       contains at least three elements and exact one element unequal to       $$$1$$$ , and operate once on this interval. After this operation,       there are still two adjacent elements in $$$B$$$ both equals to       $$$1$$$, so we keep doing this until all elements are transformed       into $$$1$$$.</p>     <p>Therefore, if there is a interval $$$[l,r]$$$ which satisfies       $$$r-l+1\ge2$$$ and the median of $$$\{B_l,B_{l+1},\dots,B_r\}$$$       equals to $$$1$$$, just perform an operation on $$$[l,r]$$$ , then       use the above strategy. It can be shown that such an interval can       always be created in several operations with the condition.</p>          <ul>                     <li> If an interval $$$[i,i+2]$$$ satisfies         $$$\{B_i,B_{i+1},B_{i+2}\}=\{0,1,2\}$$$ or $$$\{1,1,2\}$$$ or         $$$\{0,1,1\}$$$ or $$$\{1,1,1\}$$$，just perform an operation on         $$$[i,i+2]$$$ .         </li>       <li> If $$$[i,i+2]$$$ satisfies         $$$\{B_i,B_{i+1},B_{i+2}\}=\{1,2,2\}$$$ , then         $$$\{B_i,B_{i+1}\}=\{1,2\}$$$ or         $$$\{B_{i+1},B_{i+2}\}=\{1,2\}$$$ . Perform an operation on         $$$[i,i+1]$$$ or $$$[i+1,i+2]$$$ .         </li>       <li> If any interval with three elements doesn't satisfy the above         conditions, because $$$\exists 1\le i&lt;j\le         n,\mathrm{s.t.}j-i\le2,B_i&gt;0,B_j&gt;0$$$ ，there is an         interval $$$[i,i+2]$$$ which satisfies         $$$\{B_i,B_{i+1},B_{i+2}\}=\{0,2,2\}$$$ or $$$\{2,2,2\}$$$ .         Take such an interval $$$[i,i+2]$$$ , perform an operation on         $$$[i,i+2]$$$ first, then select an interval which contains at         least three elements and exact one element unequal to $$$2$$$         until two adjacent numbers equals to $$$1$$$ and $$$2$$$         respectively. Perform one operation on these two adjacent         elements.          </li></ul>          <p>Therefore, the sufficiency is proved. So just check whether there       is an element in $$$B$$$ equals to $$$1$$$, and whether there is a       pair of two positive integers $$$(i,j)$$$ which satisfies $$$1\le       j-i\le 2,B_i&gt;0,B_j&gt;0$$$ . The complexity is $$$O(n)$$$. </p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair&lt;int,int&gt; pii;
#define x first
#define y second
#define mp make_pair
#define pb push_back
template &lt;typename TYPE&gt; inline void chkmax(TYPE &amp;x,TYPE y){x&lt;y?x=y:TYPE();}
template &lt;typename TYPE&gt; inline void chkmin(TYPE &amp;x,TYPE y){y&lt;x?x=y:TYPE();}
template &lt;typename TYPE&gt; void readint(TYPE &amp;x)
{
    x=0;int f=1;char c;
    for(c=getchar();!isdigit(c);c=getchar())if(c==&#39;-&#39;)f=-1;
    for(;isdigit(c);c=getchar())x=x*10+c-&#39;0&#39;;
    x*=f;
}
const int MAXN=500005;

int n,k,a[MAXN];
bool solve()
{
	readint(n),readint(k);
	bool flag=0;
	for(int i=1;i&lt;=n;++i)
	{
		readint(a[i]);
		if(a[i]&lt;k)a[i]=0;
		else if(a[i]&gt;k)a[i]=2;
		else a[i]=1;
		if(a[i]==1)flag=1;
	}
	if(!flag)return 0;
	if(n==1)return 1;
	for(int i=1;i&lt;=n;++i)
		for(int j=i+1;j&lt;=n &amp;&amp; j-i&lt;=2;++j)
			if(a[i] &amp;&amp; a[j])return 1;
	return 0;
}

int main()
{
	int T;
	readint(T);
	while(T--)printf(solve()?&#34;yes\n&#34;:&#34;no\n&#34;);
	return 0;
}
</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair&lt;int,int&gt; pii;
#define x first
#define y second
#define mp make_pair
#define pb push_back
template &lt;typename TYPE&gt; inline void chkmax(TYPE &amp;x,TYPE y){x&lt;y?x=y:TYPE();}
template &lt;typename TYPE&gt; inline void chkmin(TYPE &amp;x,TYPE y){y&lt;x?x=y:TYPE();}
template &lt;typename TYPE&gt; void readint(TYPE &amp;x)
{
    x=0;int f=1;char c;
    for(c=getchar();!isdigit(c);c=getchar())if(c==&#39;-&#39;)f=-1;
    for(;isdigit(c);c=getchar())x=x*10+c-&#39;0&#39;;
    x*=f;
}
const int MAXN=500005;

int n,k,a[MAXN];
bool solve()
{
	readint(n),readint(k);
	bool flag=0;
	for(int i=1;i&lt;=n;++i)
	{
		readint(a[i]);
		if(a[i]&lt;k)a[i]=0;
		else if(a[i]&gt;k)a[i]=2;
		else a[i]=1;
		if(a[i]==1)flag=1;
	}
	if(!flag)return 0;
	if(n==1)return 1;
	for(int i=1;i&lt;=n;++i)
		for(int j=i+1;j&lt;=n &amp;&amp; j-i&lt;=2;++j)
			if(a[i] &amp;&amp; a[j])return 1;
	return 0;
}

int main()
{
	int T;
	readint(T);
	while(T--)printf(solve()?&#34;yes\n&#34;:&#34;no\n&#34;);
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #641 (Div. 1)
    1349C
    Орак и Game of Life </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Орак и Game of Life</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>128 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>       <span class="tex-font-style-bf">Обратите внимание на необычное         ограничение по памяти в этой задаче.</span></p>     <p>Орак любит игры. Недавно он придумал новую игру, «<span class="tex-font-style-tt">Game of Life</span>».</p>     <p>Вы должны играть в эту игру на черно-белом клетчатом поле из       $$$n$$$ строк и $$$m$$$ столбцов. Каждая клетка либо белая, либо       черная. </p>     <p>На каждой итерации этой игры (исходная итерация это $$$0$$$) цвет       клетки будет изменяться по следующим правилам:</p>          <ul>                     <li> Если на текущей итерации нет соседних клеток с таким же         цветом, как и эта клетка, ее цвет на следующей итерации         останется прежним.         </li>       <li> Иначе, ее цвет на следующей итерации будет другим.         </li></ul>          <p>Две клетки являются соседними, если у них есть общая сторона.</p>     <p>Орак уже выбрал исходное состояние игры, и он хочет знать для       клетки $$$(i,j)$$$ (в $$$i$$$-й строке и $$$j$$$-м столбце), чему       будет равен ее цвет на итерации $$$p$$$. Он может задавать вам эти       вопросы по несколько раз. </p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано три целых числа $$$n,m,t\ (1\le n,m\le       1000, 1\le t\le 100\,000)$$$, описывающие количество строк и       столбцов, и количество запросов Орака.</p>     <p>Каждая из следующих $$$n$$$ строк содержит бинарную строку длины       $$$m$$$, $$$j$$$-й символ в $$$i$$$-й строке описывает изначальный       цвет клетки $$$(i,j)$$$. '<span class="tex-font-style-tt">0</span>' означает белый, '<span class="tex-font-style-tt">1</span>' означает черный.</p>     <p>Каждая из следующих $$$t$$$ строк содержит три целых числа       $$$i,j,p\ (1\le i\le n, 1\le j\le m, 1\le p\le 10^{18})$$$,       описывающие запрос Орака.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$t$$$ строк, в $$$i$$$-й из которых вы должны вывести       ответ на $$$i$$$-й запрос Орака. Если цвет клетки черный, вы       должны вывести '<span class="tex-font-style-tt">1</span>', иначе,       вы должны вывести '<span class="tex-font-style-tt">0</span>'.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3 3 3
000
111
000
1 1 1
2 2 2
3 3 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
1
1
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5 2 2
01
10
01
10
01
1 1 4
5 1 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
0
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5 5 3
01011
10110
01101
11010
10101
1 1 4
1 2 3
5 5 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
0
1
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
1 1 3
0
1 1 1
1 1 2
1 1 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
0
0
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>               <center> <img class="tex-graphics" src="https://espresso.codeforces.com/eeb42d9bfc2462ba84fcfac9bf8c45511650f63f.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>В первом примере картинка выше описывает исходну ситуацию и цвета       клеток на итерациях $$$1$$$, $$$2$$$, и $$$3$$$. Вы можете       увидеть, что цвет клетки $$$(1,1)$$$ на итерации $$$1$$$ черный,       цвет клетки $$$(2,2)$$$ после итерации $$$2$$$ черный, и цвет       клетки $$$(3,3)$$$ после итерации $$$3$$$ тоже черный.</p>     <p>Во втором примере можно доказать, что клетки никогда не поменяют       свой цвет.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1349/problem/C' title='Codeforces Round 641 (Div. 1)'>1349C - Orac and Game of Life</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>A cell $$$(i,j)$$$ is said to be <span class="tex-font-style-bf">good</span> if and only if there is a       cell $$$(i',j')$$$ adjacent to $$$(i,j)$$$ which has the same       color to $$$(i,j)$$$ . If a cell $$$(i,j)$$$ is not good, it is       said to be <span class="tex-font-style-bf">bad</span>. Therefore,       the color of a cell changes after a turn if and only if the cell       is good.</p>     <p>According to the definition, any cell never changes its color if       every cell is bad. Also, a good cell $$$(i,j)$$$ would never turn       into a bad cell .</p>     <p>For a bad cell $$$(i,j)$$$, if there is a good cell $$$(i',j')$$$       adjacent to $$$(i,j)$$$, $$$(i,j)$$$ will turn into a good cell       after a turn because $$$(i',j')$$$ currently has a different color       from $$$(i,j)$$$ and the color of $$$(i',j')$$$ will change after       a turn but the color of $$$(i,j)$$$ won't change; otherwise, after       a turn, the color of $$$(i,j)$$$ and cells adjacent to $$$(i,j)$$$       stays the same, so $$$(i,j)$$$ is still bad.</p>     <p>For a cell $$$(i,j)$$$, let $$$f_{i,j}$$$ be the number of turns       needed for that $$$(i,j)$$$ becomes a good cell. According to the       paragraph above, $$$f_{i,j}$$$ equals to the minimal Manhattan       distance from $$$(i,j)$$$ to a good cell. Therefore, $$$f_{i,j}$$$       can be figured out by BFS. </p>     <p>Notice that for $$$k \le f_{i,j}$$$ , the color of $$$(i,j)$$$       stays the same after the $$$k$$$-th turn; for $$$k&gt;f_{i,j}$$$ ,       the color of $$$(i,j)$$$ changes after the $$$k$$$-th turn.       Therefore, each query can be processed with $$$O(1)$$$ time       complexity. The total time complexity is $$$O(nm+t)$$$ .</p>     <p>       <span class="tex-font-style-bf">P.S. R.I.P. John Horton Conway,         you are a great mathematician that should be remembered forever.</span></p></div></div></div>

           
            <pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#define pii pair&lt;int,int&gt;
#define mp make_pair
#define fi first
#define se second

using namespace std;
typedef long long ll;
const int MAXN = 1005;
inline ll readint()
{
	ll res = 0, f = 1;
	char c = 0;
	while(!isdigit(c))
	{
		c = getchar();
		if(c==&#39;-&#39;)
			f = -1;
	}
	while(isdigit(c))
		res = res*10+c-&#39;0&#39;, c = getchar();
	return res*f;
}
int n,m,T,a[MAXN][MAXN];
char str[MAXN];
int f[MAXN][MAXN],pos[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};
bool vis[MAXN][MAXN];
inline bool check(int x, int y)
{
	for(int i = 0; i&lt;4; i++)
	{
		int nx = x+pos[i][0], ny = y+pos[i][1];
		if(a[nx][ny]==a[x][y])
			return true;	
	}
	return false;
}
pii q[MAXN*MAXN];
inline void bfs()
{
	int front = 0, rear = 0;
	for(int i = 1; i&lt;=n; i++)
		for(int j = 1; j&lt;=m; j++)
			if(check(i,j))
				f[i][j] = 0, vis[i][j] = true, q[rear++] = mp(i,j);
	while(front&lt;rear)
	{
		pii now = q[front++];
		for(int i = 0; i&lt;4; i++)
		{
			int nx = now.fi+pos[i][0], ny = now.se+pos[i][1];
			if(nx&lt;1||nx&gt;n||ny&lt;1||ny&gt;m||vis[nx][ny])
				continue;
			f[nx][ny] = f[now.fi][now.se]+1;
			vis[nx][ny] = true;
			q[rear++] = mp(nx,ny);
		}
	}
}

int main()
{
	n = readint(), m = readint(), T = readint();
	memset(a,-1,sizeof(a));
	for(int i = 1; i&lt;=n; i++)
	{
		scanf(&#34;%s&#34;,str+1);
		for(int j = 1;	j&lt;=m; j++) 
			a[i][j] = str[j]-&#39;0&#39;;
	}
	bfs();
	int x,y;
	ll t;
	while(T--)
	{
		x = readint(), y = readint(), t = readint();
		if(vis[x][y])
			printf(&#34;%d\n&#34;,a[x][y]^(max(0ll,t-f[x][y])&amp;1)); 
		else
			printf(&#34;%d\n&#34;,a[x][y]);
	}
	return 0;
}

</code></pre>
           
            <pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#define pii pair&lt;int,int&gt;
#define mp make_pair
#define fi first
#define se second

using namespace std;
typedef long long ll;
const int MAXN = 1005;
inline ll readint()
{
	ll res = 0, f = 1;
	char c = 0;
	while(!isdigit(c))
	{
		c = getchar();
		if(c==&#39;-&#39;)
			f = -1;
	}
	while(isdigit(c))
		res = res*10+c-&#39;0&#39;, c = getchar();
	return res*f;
}
int n,m,T,a[MAXN][MAXN];
char str[MAXN];
int f[MAXN][MAXN],pos[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};
bool vis[MAXN][MAXN];
inline bool check(int x, int y)
{
	for(int i = 0; i&lt;4; i++)
	{
		int nx = x+pos[i][0], ny = y+pos[i][1];
		if(a[nx][ny]==a[x][y])
			return true;	
	}
	return false;
}
pii q[MAXN*MAXN];
inline void bfs()
{
	int front = 0, rear = 0;
	for(int i = 1; i&lt;=n; i++)
		for(int j = 1; j&lt;=m; j++)
			if(check(i,j))
				f[i][j] = 0, vis[i][j] = true, q[rear++] = mp(i,j);
	while(front&lt;rear)
	{
		pii now = q[front++];
		for(int i = 0; i&lt;4; i++)
		{
			int nx = now.fi+pos[i][0], ny = now.se+pos[i][1];
			if(nx&lt;1||nx&gt;n||ny&lt;1||ny&gt;m||vis[nx][ny])
				continue;
			f[nx][ny] = f[now.fi][now.se]+1;
			vis[nx][ny] = true;
			q[rear++] = mp(nx,ny);
		}
	}
}

int main()
{
	n = readint(), m = readint(), T = readint();
	memset(a,-1,sizeof(a));
	for(int i = 1; i&lt;=n; i++)
	{
		scanf(&#34;%s&#34;,str+1);
		for(int j = 1;	j&lt;=m; j++) 
			a[i][j] = str[j]-&#39;0&#39;;
	}
	bfs();
	int x,y;
	ll t;
	while(T--)
	{
		x = readint(), y = readint(), t = readint();
		if(vis[x][y])
			printf(&#34;%d\n&#34;,a[x][y]^(max(0ll,t-f[x][y])&amp;1)); 
		else
			printf(&#34;%d\n&#34;,a[x][y]);
	}
	return 0;
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #641 (Div. 1)
    1349D
    Слайм и бисквиты </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Слайм и бисквиты</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Слайм и его $$$n$$$ друзей на вечеринке. Слайм придумал игру для       своих друзей.</p>     <p>В начале игры у $$$i$$$-го игрока есть $$$a_i$$$ бисквитов.       Каждую секунду Слайм выберет один бисквит равновероятно среди       $$$a_1 + a_2 + \ldots + a_n$$$ бисквитов, и владелец этого       бисквита передает его случайному игроку, равновероятно среди       $$$n-1$$$ игроков кроме себя. Игра закончится, когда у одного       игрока будут все бисквиты.</p>     <p>Как хозяин вечеринки, Слайм хочет узнать математическое ожидание       времени, когда игра закончится, чтобы успеть провести следующее мероприятие.</p>     <p>Так как ответ может быть представлен в виде рациональной дроби       $$$\frac{p}{q}$$$ для взаимно простых $$$p$$$ и $$$q$$$, выведите       его в форме $$$(p \cdot q^{-1})\mod 998\,244\,353$$$. Можно       доказать, что $$$q\mod 998\,244\,353 \neq 0$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$n\ (2\le n\le       100\,000)$$$: количество игроков.</p>     <p>Во второй строке записаны $$$n$$$ неотрицательных целых чисел       $$$a_1,a_2,\dots,a_n\ (1\le a_1+a_2+\dots+a_n\le 300\,000)$$$, где       $$$a_i$$$ обозначает количество бисквитов у $$$i$$$-го человека в       начале игры.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одно число: математическое ожидание времени, когда игра       закончится, по модулю $$$998\,244\,353$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
1 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
1 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
0 0 0 0 35
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
8 4 2 0 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
801604029
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере, вероятность, что игрок $$$1$$$ передаст игроку       $$$2$$$ бисквит равна $$$\frac{1}{2}$$$, а вероятность что игрок       $$$2$$$ передаст игроку $$$1$$$ бисквит равна $$$\frac{1}{2}$$$. В       любом случае игра продлится ровно $$$1$$$ секунду, так как все       бисквиты будут у одного игрока спустя $$$1$$$ секунду, поэтому       ответ равен $$$1$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1349/problem/D' title='Codeforces Round 641 (Div. 1)'>1349D - Slime and Biscuits</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let $$$E_x$$$ be the sum of probability times time when the game       end up with all biscuits are owned by the x-th person (At here,       the sum of probability is not 1, though the sum of probability in       all $$$E_x$$$ is 1). So the answer is $$$\sum\limits_{i=1}^nE_i$$$</p>     <p>Let $$$E'_x$$$ be the expectation of time when the game only ends       when the x-th person own all the biscuits.</p>     <p>Let $$$P_x$$$ be the probability that the game end up with all       biscuits are owned by the x-th person. It's easy to find that       $$$\sum\limits_{i=1}^n P_i = 1$$$。</p>     <p>And we let constant $$$C$$$ be the expect time from when all       biscuits are owned by i-th person to when all biscuits are owned       by j-th person (now the end condition is that all biscuits are       owned by j-th person, is the same with $$$E'_x$$$ . And for all       (i, j), the value of $$$C$$$ is the same). So we have a identity:</p>     <p>$$$$$$E_x = E'_x-\sum\limits_{i=1}^n[i\neq x]( P_i\cdot       C+E_i)$$$$$$ </p>     <p>We can get this by consider which people own all the biscuits       when the game ends in all possible situation of $$$E'_x$$$ .</p>     <p>Then we can get:</p>     <p>$$$$$$\sum\limits_{i=1}^n E_i=E'_x-C\cdot       \sum\limits_{i=1}^n[i\neq x]P_i$$$$$$ </p>     <p>Sum it up for $$$x=1,2,\cdots,n$$$ , and we get:</p>      <p>$$$$$$n\sum\limits_{i=1}^nE_i=\sum\limits_{i=1}^nE'_i-C(n-1)\sum\limits_{i=1}^nP_i$$$$$$ </p>     <p>Mention that $$$ans=\sum\limits_{i=1}^nE_i$$$ and       $$$\sum\limits_{i=1}^nP_i=1$$$ , so we find that:</p>     <p>$$$$$$n\cdot ans=\sum\limits_{i=1}^nE'_i-C(n-1)$$$$$$ </p>     <p>When we find the value of $$$E'_x$$$ and $$$C$$$ , we only want       to know whether the biscuit is owned by the person we want or not,       so we can let $$$f_m$$$ represent the expect time the person will       own $$$m+1$$$ biscuits when the person own $$$m$$$ biscuits now.       We can easily get $$$f_0$$$ and equation between $$$f_i$$$ and       $$$f_{i-1}$$$ .</p>     <p>So we can get all $$$f_m$$$ and $$$C$$$ in       $$$O(\sum\limits_{i=1}^na_i \cdot \log\ mod)$$$ time. And we can       get the answer.</p>     <p>The overall complexity is $$$O(\sum\limits_{i=1}^na_i \cdot \log\       mod)$$$ .</p></div></div></div>

           
            <pre><code>#include&lt;bits/stdc++.h&gt;

#define pb push_back
#define mp make_pair
#define fi first
#define se second

using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef pair&lt;int,int&gt; pii;
typedef pair&lt;ll,ll&gt; pll;

template &lt;typename T&gt; bool chkmax(T &amp;x,T y){return x&lt;y?x=y,true:false;}
template &lt;typename T&gt; bool chkmin(T &amp;x,T y){return x&gt;y?x=y,true:false;}

int readint(){
	int x=0,f=1; char ch=getchar();
	while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}
	while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}
	return x*f;
}

const int cys=998244353;
int n,m;
ll a[100005],ans[300005];

ll qpow(ll x,ll p){
	ll ret=1;
	for(;p;p&gt;&gt;=1,x=x*x%cys) if(p&amp;1) ret=ret*x%cys;
	return ret;
}

int main(){
	n=readint();
	for(int i=1;i&lt;=n;i++) a[i]=readint(),m+=a[i];
	ll invm=qpow(m,cys-2),invn1=qpow(n-1,cys-2);
	for(int i=m;i&gt;=1;i--){
		ll k1=i*invm%cys*invn1%cys,k2=(m-i)*invm%cys;
		ans[i]=(k2*ans[i+1]+1)%cys*qpow(k1,cys-2)%cys;
	}
	for(int i=1;i&lt;=m;i++) ans[i]=(ans[i]+ans[i-1])%cys;
	ll res=0;
	for(int i=1;i&lt;=n;i++) res=(res+ans[m-a[i]])%cys;
	res=(res+cys-ans[m]*(n-1)%cys)%cys;
	printf(&#34;%lld\n&#34;,res*qpow(n,cys-2)%cys);
	return 0;
}
</code></pre>
           
            <pre><code>#include&lt;bits/stdc++.h&gt;

#define pb push_back
#define mp make_pair
#define fi first
#define se second

using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef pair&lt;int,int&gt; pii;
typedef pair&lt;ll,ll&gt; pll;

template &lt;typename T&gt; bool chkmax(T &amp;x,T y){return x&lt;y?x=y,true:false;}
template &lt;typename T&gt; bool chkmin(T &amp;x,T y){return x&gt;y?x=y,true:false;}

int readint(){
	int x=0,f=1; char ch=getchar();
	while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;){if(ch==&#39;-&#39;)f=-1;ch=getchar();}
	while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;){x=x*10+ch-&#39;0&#39;;ch=getchar();}
	return x*f;
}

const int cys=998244353;
int n,m;
ll a[100005],ans[300005];

ll qpow(ll x,ll p){
	ll ret=1;
	for(;p;p&gt;&gt;=1,x=x*x%cys) if(p&amp;1) ret=ret*x%cys;
	return ret;
}

int main(){
	n=readint();
	for(int i=1;i&lt;=n;i++) a[i]=readint(),m+=a[i];
	ll invm=qpow(m,cys-2),invn1=qpow(n-1,cys-2);
	for(int i=m;i&gt;=1;i--){
		ll k1=i*invm%cys*invn1%cys,k2=(m-i)*invm%cys;
		ans[i]=(k2*ans[i+1]+1)%cys*qpow(k1,cys-2)%cys;
	}
	for(int i=1;i&lt;=m;i++) ans[i]=(ans[i]+ans[i-1])%cys;
	ll res=0;
	for(int i=1;i&lt;=n;i++) res=(res+ans[m-a[i]])%cys;
	res=(res+cys-ans[m]*(n-1)%cys)%cys;
	printf(&#34;%lld\n&#34;,res*qpow(n,cys-2)%cys);
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #641 (Div. 1)
    1349E
    Слайм и шляпы </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. Слайм и шляпы</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Слайм и Орак проводят пошаговую игру. В большой комнате на       стульях сидят $$$n$$$ человек и смотрят в сторону колонны, у       каждого игрока есть номер: игрок $$$1$$$ сидит перед колонной,       игрок $$$2$$$ сидит прямо за ним; игрок $$$3$$$ сидит прямо за       игроком номер $$$2$$$, и так далее; игрок $$$n$$$ сидит прямо за       игроком $$$n-1$$$. Каждый игрок носит шляпу, которая может быть       белой или черной. Так как все игроки смотрят вперед, игрок $$$i$$$       знает цвет шляпы игрока $$$j$$$ если и только если $$$i$$$ больше       чем $$$j$$$.</p>     <p>В начале каждого хода, Орак скажет, <span class="tex-font-style-bf">есть ли хотя бы один игрок в комнате,         на котором надета черная шляпа</span>.</p>     <p>После речи Орака, если игрок может однозначно определить цвет его       шляпы, он положит его шляпу на стул, встанет, и покинет комнату.       Все игроки умные, так что если возможно понять цвет шляпы,       используя полученную информацию в этом и предыдущих раундах, они поймут.</p>     <p>На каждом ходу все игроки, которые поняли свой цвет, выйдут       одновременно. Это означает, что если игрок понял цвет своей шляпы       после ухода игроков на этом ходу, он сможет покинуть комнату       только на следующем ходу.</p>     <p>Обратите внимание, что когда игрок выходит из комнаты, он       оставлят свою шляпу на стуле, так что игроки перед ним не смогут       узнать цвет его шляпы.</p>     <p>Таким образом, $$$i$$$-й игрок узнает, кто покинул комнату среди       игроков $$$1,2,\ldots,i-1$$$, и сколько игроков среди       $$$i+1,i+2,\ldots,n$$$ покинули комнату.</p>     <p>Слайм стоит за дверью. Он наблюдает за игроками и записывает       номера игроков и время, в которое они покинули комнату. К       сожалению, Слайм такой неряха, что он записал это только про       некоторых игроков и записал он это в формате «<span class="tex-font-style-tt">игрок $$$x$$$ покинул игру в $$$y$$$-м раунде</span>».</p>     <p>Слайм попросил вас найти цвет шляпы каждого игрока. Если есть       несколько возможных решений, вы можете вывести любое.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$n\ (1\le n\le 200\,000)$$$.</p>     <p>Во второй строке записаны $$$n$$$ целых чисел       $$$t_1,t_2,\dots,t_n\ (0\le t_i\le 10^{15})$$$. Если $$$t_i=0$$$,       то неизвестна никакая информация про игрока с номером $$$i$$$;       иначе, игрок $$$i$$$ покинул игру на $$$t_i$$$-м раунде.</p>     <p>Хотя бы одно решение существует для данного ввода.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одну бинарную строку из $$$n$$$ символов. $$$i$$$-й       символ должен быть равен '<span class="tex-font-style-tt">1</span>' если игрок $$$i$$$ носит       черную шляпу, и должен быть равен '<span class="tex-font-style-tt">0</span>' иначе. Если есть несколько       решений, вы можете вывести любое.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
0 1 1 0 0
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
00000</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
0 2 2 0 0
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
00001</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
0 0 0 0 0
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
00000</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
4 4 0 4 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
00100</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере в предложенном решении, все игроки носят белую       шляпу. На первом ходу Орак скажет, что нет игроков с черной       шляпой, так что все игроки поймут, что они носят белые шляпы, и       покинут игру на первом ходу.</p>     <p>Во втором примере игрок $$$5$$$ носит черную шляпу, а остальные       игроки носят белые шляпы. Орак скажет, что существует игрок в       черной шляпе, и игрок $$$5$$$ знает, что все остальные игроки       носят белые шляпы, следовательно он может понять, что он носит       черную шляпу, и покинет игру в первом раунде, а остальные игроки       покинут игру во втором раунде. Обратите внимание, что все игроки       поняли цвет шляпы после того, как игрок $$$5$$$ ушел, но они       должны ждать следующего хода, чтобы уйти.</p>     <p>В третьем примере нет никакой информации об игре, так что любой       ответ корректен.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1349/problem/E' title='Codeforces Round 641 (Div. 1)'>1349E - Slime and Hats</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>First, let's renumber the players for convenience. Number the       player at the front as $$$n$$$ ，the player sitting behind him as       $$$n-1$$$ , and so on. </p>     <p>Let $$$c_i$$$ be the color of player $$$i$$$'s hat. Consider how       to calculate $$${t_i}$$$ if we have already known       $$$c_1,c_2,\dots,c_n$$$. If $$$c_1=c_2=\dots=c_n=0$$$, then       $$$t_1=t_2=\dots=t_n=1$$$. Otherwise, let $$$x$$$ be the maximal       number of a player with a black hat. In the first turn, player       $$$1$$$ knows that someone wears a black hat.</p>          <ul>                     <li> If $$$x=1$$$, player $$$1$$$ finds out that everyone except         him wears a white hat, so he wears a black hat and he leaves. In         the second turn, other players can figure out that         $$$c_2=c_3=\dots=c_n=0$$$. Therefore, $$$t_1=1,t_2=t_3=\dots=t_n=2$$$.         </li>       <li> If $$$x\ge 2$$$, there is a player with a black hat sitting         in front of player $$$1$$$ , so he can't figure out the color of         his own hat and doesn't leave. Other players know that $$$x\ge         2$$$ in the next turn, and the problem is transformed into a         subproblem on player $$$2,3,\dots,n$$$. No one leaves until the         $$$x$$$-th turn, player $$$x$$$ knows that there is at least one         player with a black hat in $$$x,x+1,\dots,n$$$, but player         $$$x,x+1,\dots,n$$$ all wear white hats, so he leaves. In the         next turn, $$$x+1,x+2,\dots,n$$$ leaves.         </li></ul>          <p>According to the above process, player $$$x$$$ leaves in the       $$$x$$$-th turn, player $$$x+1,x+2,\dots,n$$$ leave in the       $$$(x+1)$$$-th turn, and a new process begins. Therefore, we can       figure out the value of $$$t_1,t_2,\dots,t_n$$$. </p>     <p>- If $$$c_i=1$$$ , then $$$t_i=\sum\limits_{j\ge i,c_j=1}j$$$ .       Let $$$b_i=i$$$ . - If $$$c_i=0$$$ , let $$$k$$$ be the maximal       number which satisfies $$$c_k=1$$$ and $$$k&lt;i$$$ , then       $$$t_i=t_k+1$$$ . For convenience, let $$$c_0=1,       t_0=\sum\limits_{c_j=1}j$$$ , so $$$k$$$ always exists. Let $$$b_i=k$$$.</p>     <p>Therefore, we can calculate $$$t_1,t_2,\dots,t_n$$$ using       $$$c_1,c_2,\dots c_n$$$, and $$$t_i=t_{b_i}+(1-c_i)$$$ is       satisfied. </p>     <p>Consider how to solve the original problem. Before using dynamic       programming to solve the problem, we need to do some preparation       for that.</p>     <p>If $$$i\ge j$$$ and $$$c_i=c_j=1$$$ , it is obviously that       $$$t_i\le t_j$$$. Also, if $$$t_i&gt;t_j$$$, $$$b_i\ge b_j$$$.       Therefore, $$$$$$ \forall i&gt;j,       t_i-t_j=t_{b_i}+(1-c_i)-t_{b_j}-(1-c_j)=t_{b_i}-t_{b_j}+(c_j-c_i)\le       c_j-c_i\le 1 $$$$$$ In fact, if $$$i&gt;j$$$ , we have $$$$$$       \left\{ \begin{array}{lcl} t_i-t_j=1,\space\mathrm{if}\space       c_j=1\ \textrm{and}\ \forall i\ge k&gt;j,c_k=0 \\       t_i-t_j=0,\space\mathrm{if}\space \exists       i&gt;k&gt;j,c_k=1,c_1=c_2=\dots=c_{k-1}=c_{k+1}=\dots=c_n=0\       \textrm{or}\ \forall i\ge k\ge j,c_k=0 \\       t_i-t_j&lt;0,\space\mathrm{otherwise} \end{array} \right. $$$$$$       It is not difficult to prove the formula above with some simple       classified discussions.</p>     <p>Define a set of intervals       $$$A=\{[l_1,r_1],[l_2,r_2],\dots,[l_m,r_m]\}$$$ which satisfies       these rules:</p>          <ul>                     <li> $$$1\le l_1\le r_1&lt;l_2\le r_2&lt;\dots&lt;l_m\le r_m\le n$$$         </li>       <li> $$$\forall 1\le k\le m, \exists l_k\le i\le r_k$$$, $$$t_i$$$         is given.         </li>       <li> $$$\forall 1\le i\le n$$$, if $$$t_i$$$ is given, $$$\exists         k, \mathrm{s.t.}\space l_k\le i\le r_k$$$          </li>       <li> For all pairs $$$(i,j)$$$ where $$$i&gt;j$$$ and         $$$t_i,t_j$$$ are both given, $$$i$$$ and $$$j$$$ are in the         same interval if and only if $$$t_i\ge t_j$$$.          </li></ul>          <p>If $$$l_i\neq 1$$$, it can be known that       $$$c_{l_i+1}=c_{l_i+2}=\dots=c_{r_i}=0$$$ and       $$$b_{l_i}=b_{l_i+1}=\dots=b_{r_i}$$$. Let $$$B_i=b_{l_i}$$$.</p>     <p>After the preparatory work, let's work on dp. Let $$$f_{i,j}$$$       be the maximal possible value of $$$B_i$$$ when $$$c_{l_i}=j$$$ .       Consider how to calculate $$$f_{i,j'}$$$ if we know the value of       $$$f_{i+1,0}$$$ and $$$f_{i+1,1}$$$ . For $$$f_{i+1,j}$$$,       enumerate all possible $$$f_{i,j'}$$$ from large to small,       $$$B_i=f_{i,j'}$$$ might be satisfied if $$$$$$       t_{f_{i,j'}}=\sum\limits_{k\ge       f_{i,j'},c_k=1}k=\left(\sum\limits_{k\ge f_{i+1,j},c_k=1}k\right)       + \left(\sum\limits_{f_{i+1,j}&gt;k\ge f_{i,j'},c_k=1}k\right) <br />        <br />=t_{f_{i+1,j}}+f_{i,j'}+\sum\limits_{r_i&lt;k&lt;f_{i+1,j},c_j=1}k       $$$$$$ If can be noticed that       $$$t_{f_{i,j'}},f_{i,j'},t_{f_{i+1,j}}$$$ are already known, so we       just need to check whether there exists some distinct integers in       $$$[r_i+1,f_{i+1,j}-1]$$$ where the sum of them equals to       $$$t_{f_{i,j'}}-f_{i,j'}-t_{f_{i+1,j}}$$$ , which can be easily       solved by binary search.</p>     <p>Besides $$$f_{i,j}$$$, record whether $$$f_{i,j}$$$ is       transformed from $$$f_{i+1,0}$$$ or $$$f_{i+1,1}$$$. Using these       we can easily give a solution.</p>     <p>Notice that when $$$l_1=1$$$, $$$[l_1,r_1]$$$ doesn't satisfy       $$$c_{l_1+1}=c_{l_1+2}=\dots=c_{r_1}=0$$$ . However, there is at       most one $$$i$$$ in $$$[l_1,r_1]$$$ where $$$c_i=1$$$. Just brute       force which $$$c_i$$$ equals to $$$1$$$ is okay. The whole       complexity is $$$O(n\log n)$$$. </p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef pair&lt;int,ll&gt; pii;
#define x first
#define y second
#define pb push_back
const int MAXN=200005;

int n,m,cnt;
pii a[MAXN];
bool avis[MAXN];
struct Range
{
	int l,r,type;
	ll val;
	Range(){}
	Range(int l,int r,int type,ll val):l(l),r(r),type(type),val(val){}
}b[MAXN];

int f[2][MAXN],wh[2][MAXN],res[MAXN];
vector&lt;int&gt; str[2][MAXN];
bool check(ll s,int l,int r)
{
	if(s&lt;=0)return !s &amp;&amp; r-l+1&gt;=0;
	ll L=1,R=r-l+1,mid,ans=0;
	while(L&lt;=R)
	{
		mid=(L+R)&gt;&gt;1;
		if((l+l+mid-1)*mid&lt;=s*2)ans=mid,L=mid+1;
		else R=mid-1;
	}
	return s*2&lt;=(r+r-ans+1)*ans;
}
void modify(ll s,int l,int r,vector&lt;int&gt; &amp;tar,int start)
{
	ll L=1,R=r-l+1,mid,ans=0;
	while(L&lt;=R)
	{
		mid=(L+R)&gt;&gt;1;
		if((l+l+mid-1)*mid&lt;=s*2)ans=mid,L=mid+1;
		else R=mid-1;
	}
	for(int i=l;i&lt;=r;i++)
		if(ans &amp;&amp; (i+i+ans-2)*(ans-1)&lt;=(s-i)*2 &amp;&amp; (s-i)*2&lt;=(r+r-ans+2)*(ans-1))
			{--ans,s-=i;tar.pb(1);}
		else tar.pb(0);
}
void update(int i,int ti,int ti_1,int pos,ll d)
{
	if(pos&lt;=f[ti][i])return;
	str[ti][i].clear();
	f[ti][i]=pos;wh[ti][i]=ti_1;
	str[ti][i].pb(1);
	for(int j=f[ti][i]+1;j&lt;=b[i].r;j++)str[ti][i].pb(0);
	modify(d-f[ti][i],b[i].r+1,f[ti_1][i-1]-1,str[ti][i],f[ti][i]);
}

int main()
{
	#ifndef ONLINE_JUDGE
	//freopen(&#34;code.in&#34;,&#34;r&#34;,stdin);
	//freopen(&#34;code.out&#34;,&#34;w&#34;,stdout);
	#endif
	scanf(&#34;%d&#34;,&amp;n);
	for(int i=1;i&lt;=n;i++)
	{
		ll y;
		scanf(&#34;%lld&#34;,&amp;y);
		if(!y)continue;
		a[++m]=make_pair(n-i+1,y);
		avis[n-i+1]=1;
	}
	if(!m)
	{
		for(int i=1;i&lt;=n;i++)putchar(&#39;0&#39;);
		return 0;
	}
	sort(a+1,a+m+1);
	b[cnt=1]=Range(a[m].x,a[m].x,2,a[m].y);
	for(int i=m-1;i;i--)
	{
		if(a[i].y==a[i+1].y)b[cnt].l=a[i].x,b[cnt].type=0;
		else if(a[i].y==a[i+1].y-1)b[cnt].l=a[i].x,b[cnt].type=1,b[cnt].val--;
		else b[++cnt]=Range(a[i].x,a[i].x,2,a[i].y);
	}
	b[cnt+1]=Range(-1,-1,0,0);
	bool error=0;
	f[0][0]=-1;f[1][0]=n+1;
	for(int i=1;i&lt;=cnt;i++)
	{
		f[0][i]=f[1][i]=-1;
		for(int t=0;t&lt;=1;t++)
			if(f[t][i-1]&gt;b[i].r)
			{
				if(b[i].type==0 || b[i].type==2)
				{
					ll d=(b[i].val-1)-(b[i-1].val-1+t);
					int pos=-1;
					for(int j=min(b[i].l-1ll,d);j&gt;b[i+1].r;--j)
						if(check(d-j,b[i].r+1,f[t][i-1]-1)){pos=j;break;}
					update(i,0,t,pos,d);
				}
				if(b[i].type==1 || b[i].type==2)
				{
					ll d=b[i].val-(b[i-1].val-1+t);
					if(check(d-b[i].l,b[i].r+1,f[t][i-1]-1))
						update(i,1,t,b[i].l,d);
				}
			}
		if(f[0][i]&lt;0 &amp;&amp; f[1][i]&lt;0 &amp;&amp; i==cnt &amp;&amp; !b[i].type)error=1;
	}
	if(error)
	{
		for(int t=0;t&lt;=1;t++)
			if(f[t][cnt-1]&gt;b[cnt].r)
			{
				ll d=(b[cnt].val-1)-(b[cnt-1].val-1+t);
				int pos=-1;
				for(int j=min((ll)b[cnt].r,d);j&gt;=b[cnt].l;--j)
				{
					if(avis[j])continue;
					if(check(d-j,b[cnt].r+1,f[t][cnt-1]-1)){pos=j;break;}
				}
				update(cnt,0,t,pos,d);
			}
	}
	int cur=(f[1][cnt]&gt;0);
	for(int i=1;i&lt;f[cur][cnt];i++)res[i]=0;
	for(int i=cnt;i&gt;0;i--)
	{
		for(int j=0;j&lt;(int)str[cur][i].size();j++)res[j+f[cur][i]]=str[cur][i][j];
		cur=wh[cur][i];
	}
	for(int i=n;i&gt;0;i--)putchar(res[i]+&#39;0&#39;);
	return 0;
}
</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef pair&lt;int,ll&gt; pii;
#define x first
#define y second
#define pb push_back
const int MAXN=200005;

int n,m,cnt;
pii a[MAXN];
bool avis[MAXN];
struct Range
{
	int l,r,type;
	ll val;
	Range(){}
	Range(int l,int r,int type,ll val):l(l),r(r),type(type),val(val){}
}b[MAXN];

int f[2][MAXN],wh[2][MAXN],res[MAXN];
vector&lt;int&gt; str[2][MAXN];
bool check(ll s,int l,int r)
{
	if(s&lt;=0)return !s &amp;&amp; r-l+1&gt;=0;
	ll L=1,R=r-l+1,mid,ans=0;
	while(L&lt;=R)
	{
		mid=(L+R)&gt;&gt;1;
		if((l+l+mid-1)*mid&lt;=s*2)ans=mid,L=mid+1;
		else R=mid-1;
	}
	return s*2&lt;=(r+r-ans+1)*ans;
}
void modify(ll s,int l,int r,vector&lt;int&gt; &amp;tar,int start)
{
	ll L=1,R=r-l+1,mid,ans=0;
	while(L&lt;=R)
	{
		mid=(L+R)&gt;&gt;1;
		if((l+l+mid-1)*mid&lt;=s*2)ans=mid,L=mid+1;
		else R=mid-1;
	}
	for(int i=l;i&lt;=r;i++)
		if(ans &amp;&amp; (i+i+ans-2)*(ans-1)&lt;=(s-i)*2 &amp;&amp; (s-i)*2&lt;=(r+r-ans+2)*(ans-1))
			{--ans,s-=i;tar.pb(1);}
		else tar.pb(0);
}
void update(int i,int ti,int ti_1,int pos,ll d)
{
	if(pos&lt;=f[ti][i])return;
	str[ti][i].clear();
	f[ti][i]=pos;wh[ti][i]=ti_1;
	str[ti][i].pb(1);
	for(int j=f[ti][i]+1;j&lt;=b[i].r;j++)str[ti][i].pb(0);
	modify(d-f[ti][i],b[i].r+1,f[ti_1][i-1]-1,str[ti][i],f[ti][i]);
}

int main()
{
	#ifndef ONLINE_JUDGE
	//freopen(&#34;code.in&#34;,&#34;r&#34;,stdin);
	//freopen(&#34;code.out&#34;,&#34;w&#34;,stdout);
	#endif
	scanf(&#34;%d&#34;,&amp;n);
	for(int i=1;i&lt;=n;i++)
	{
		ll y;
		scanf(&#34;%lld&#34;,&amp;y);
		if(!y)continue;
		a[++m]=make_pair(n-i+1,y);
		avis[n-i+1]=1;
	}
	if(!m)
	{
		for(int i=1;i&lt;=n;i++)putchar(&#39;0&#39;);
		return 0;
	}
	sort(a+1,a+m+1);
	b[cnt=1]=Range(a[m].x,a[m].x,2,a[m].y);
	for(int i=m-1;i;i--)
	{
		if(a[i].y==a[i+1].y)b[cnt].l=a[i].x,b[cnt].type=0;
		else if(a[i].y==a[i+1].y-1)b[cnt].l=a[i].x,b[cnt].type=1,b[cnt].val--;
		else b[++cnt]=Range(a[i].x,a[i].x,2,a[i].y);
	}
	b[cnt+1]=Range(-1,-1,0,0);
	bool error=0;
	f[0][0]=-1;f[1][0]=n+1;
	for(int i=1;i&lt;=cnt;i++)
	{
		f[0][i]=f[1][i]=-1;
		for(int t=0;t&lt;=1;t++)
			if(f[t][i-1]&gt;b[i].r)
			{
				if(b[i].type==0 || b[i].type==2)
				{
					ll d=(b[i].val-1)-(b[i-1].val-1+t);
					int pos=-1;
					for(int j=min(b[i].l-1ll,d);j&gt;b[i+1].r;--j)
						if(check(d-j,b[i].r+1,f[t][i-1]-1)){pos=j;break;}
					update(i,0,t,pos,d);
				}
				if(b[i].type==1 || b[i].type==2)
				{
					ll d=b[i].val-(b[i-1].val-1+t);
					if(check(d-b[i].l,b[i].r+1,f[t][i-1]-1))
						update(i,1,t,b[i].l,d);
				}
			}
		if(f[0][i]&lt;0 &amp;&amp; f[1][i]&lt;0 &amp;&amp; i==cnt &amp;&amp; !b[i].type)error=1;
	}
	if(error)
	{
		for(int t=0;t&lt;=1;t++)
			if(f[t][cnt-1]&gt;b[cnt].r)
			{
				ll d=(b[cnt].val-1)-(b[cnt-1].val-1+t);
				int pos=-1;
				for(int j=min((ll)b[cnt].r,d);j&gt;=b[cnt].l;--j)
				{
					if(avis[j])continue;
					if(check(d-j,b[cnt].r+1,f[t][cnt-1]-1)){pos=j;break;}
				}
				update(cnt,0,t,pos,d);
			}
	}
	int cur=(f[1][cnt]&gt;0);
	for(int i=1;i&lt;f[cur][cnt];i++)res[i]=0;
	for(int i=cnt;i&gt;0;i--)
	{
		for(int j=0;j&lt;(int)str[cur][i].size();j++)res[j+f[cur][i]]=str[cur][i][j];
		cur=wh[cur][i];
	}
	for(int i=n;i&gt;0;i--)putchar(res[i]+&#39;0&#39;);
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #641 (Div. 2)
    1350A
    Орак и делители </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Орак и делители</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Орак изучает теорию чисел, и его очень заинтересовали свойства делимости.</p>     <p>Для двух натуральных чисел $$$a$$$ и $$$b$$$, $$$a$$$ является       делителем $$$b$$$ если и только если существует такое натуральное       число $$$c$$$, что $$$a\cdot c=b$$$.</p>     <p>Для $$$n \ge 2$$$, обозначим за $$$f(n)$$$ минимальный делитель       $$$n$$$, отличный от $$$1$$$.</p>     <p>Например, $$$f(7)=7,f(10)=2,f(35)=5$$$.</p>     <p>Для выбранного числа $$$n$$$ Орак решил прибавить $$$f(n)$$$ к       $$$n$$$. </p>     <p>Например, если у него было число $$$n=5$$$, новое значение       $$$n$$$ будет равно $$$10$$$. А если у него было число $$$n=6$$$,       $$$n$$$ станет равным $$$8$$$.</p>     <p>Ораку так это понравилось, что он решил проделать подобные       операции по несколько раз.</p>     <p>Для двух положительных чисел $$$n$$$ и $$$k$$$, Орак попросил вас       прибавить $$$f(n)$$$ к $$$n$$$ ровно $$$k$$$ раз (обратите       внимание, что $$$n$$$ изменяется после каждой операции,       соотвественно $$$f(n)$$$ тоже может измениться) и сказать ему       итоговое значение $$$n$$$.</p>     <p>Например, если Орак скажет вам, что $$$n=5$$$ и $$$k=2$$$,       сначала вы должны прибавить $$$f(5)=5$$$ к $$$n=5$$$, и новое       значение $$$n$$$ станет равным $$$n=10$$$, после этого вы должны       прибавить $$$f(10)=2$$$ к $$$10$$$, и новое (и итоговое!) значение       $$$n$$$ будет равно $$$12$$$.</p>     <p>Орак может задавать вам эти вопросы несколько раз.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$t\ (1\le t\le       100)$$$: количество запросов Орака.</p>     <p>В каждой из следующий $$$t$$$ строк записаны два целых числа       $$$n,k\ (2\le n\le 10^6, 1\le k\le 10^9)$$$, описывающие очередной запрос.</p>     <p>Гарантируется, что сумма всех $$$n$$$ не превосходит $$$10^6$$$. </p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$t$$$ строк, в $$$i$$$-й из которых должно быть       записано итоговое значение $$$n$$$ для $$$i$$$-го запроса Орака.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
5 1
8 2
3 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
10
12
12
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом запросе $$$n=5$$$ и $$$k=1$$$. Делители $$$5$$$ это       $$$1$$$ и $$$5$$$, и минимальный делитель, отличный от $$$1$$$ это       $$$5$$$. Соответственно, единственная операция это прибавление       $$$f(5)=5$$$ к $$$5$$$, поэтому результат равен $$$10$$$.</p>     <p>Во втором запросе $$$n=8$$$ и $$$k=2$$$. Делители $$$8$$$ это       $$$1,2,4,8$$$, и минимальный из них кроме $$$1$$$ равен $$$2$$$,       затем, после одной операции $$$8$$$ превратится в       $$$8+(f(8)=2)=10$$$. Делители $$$10$$$ это $$$1,2,5,10$$$,       минимальный делитель, отличный от $$$1$$$ это $$$2$$$, поэтому       ответ равен $$$10+(f(10)=2)=12$$$.</p>     <p>В третьем запросе $$$n$$$ изменялось следующим образом: $$$3 \to       6 \to 8 \to 10 \to 12$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1350/problem/A' title='Codeforces Round 641 (Div. 2)'>1350A - Orac and Factors</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p> If we simulate the whole process we will get TLE because $$$k$$$       is too large. So we need some trivial observations:</p>          <ul>                     <li> If $$$n$$$ is even, then for each operation $$$n$$$ will be         added by $$$2$$$ and keep being even.         </li>       <li> If $$$n$$$ is odd, then for the first time $$$n$$$ will be         added by an odd number and then become even.          </li></ul>          <p>So it's easy to see that the answer is $$$$$$ \left\{       \begin{array}{lcl} n+2k &amp; n\textrm{ is even}\\ n+2(k-1)+d(n)       &amp; n\textrm{ is odd}\\ \end{array} \right. $$$$$$ where       $$$d(n)$$$ is the smallest positive factor of $$$x$$$ except       $$$1$$$, which can be calculated in $$$O(n)$$$ time.</p>     <p>The overall complexity is $$$O(n)$$$ .</p></div></div></div>

           
            <pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;

using namespace std;

int main()
{
	int T;
	cin &gt;&gt; T;
	while(T--)
	{
		int n,k;
		cin &gt;&gt; n &gt;&gt; k;
		if(n%2==0)
		{
			cout &lt;&lt; n+2*k &lt;&lt; endl;
			continue;
		}
		int p = 0;
		for(int i = n; i&gt;=2; i--)
			if(n%i==0)
		    	p = i;
		cout &lt;&lt; n+p+2*(k-1) &lt;&lt; endl;
	}
	return 0;
}

</code></pre>
           
            <pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;

using namespace std;

int main()
{
	int T;
	cin &gt;&gt; T;
	while(T--)
	{
		int n,k;
		cin &gt;&gt; n &gt;&gt; k;
		if(n%2==0)
		{
			cout &lt;&lt; n+2*k &lt;&lt; endl;
			continue;
		}
		int p = 0;
		for(int i = n; i&gt;=2; i--)
			if(n%i==0)
		    	p = i;
		cout &lt;&lt; n+p+2*(k-1) &lt;&lt; endl;
	}
	return 0;
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #641 (Div. 2)
    1350B
    Орак и модели </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Орак и модели</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>3 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>В магазине есть $$$n$$$ моделей, пронумерованных от $$$1$$$ до       $$$n$$$, размеры которых равны $$$s_1, s_2, \ldots, s_n$$$.</p>     <p>Орак купит некоторые из этих моделей и упорядочит их по       возрастанию номеров (индексов, а не размеров).</p>     <p>Орак считает, что полученная расстановка <span class="tex-font-style-bf">красивая</span>, если для любых двух       соседних моделей с номерами $$$i_j$$$ и $$$i_{j+1}$$$ (обратите       внимание, что $$$i_j &lt; i_{j+1}$$$, так как Орак упорядочил их       правильно), $$$i_{j+1}$$$ делится на $$$i_j$$$ и $$$s_{i_j} &lt; s_{i_{j+1}}$$$.</p>     <p>Например, для $$$6$$$ моделей с размерами $$$\{3, 6, 7, 7, 7,       7\}$$$, он может купить модели с индексами $$$1$$$, $$$2$$$, и       $$$6$$$, и полученная расстановка будет красивой. Обратите       внимание, что расстановка из одной модели также считается красивой.</p>     <p>Орак хочет знать, какое наибольше число моделей он может купить,       и он может задавать вам эти вопросы по несколько раз.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$t\ (1 \le t\le       100)$$$: количество запросов.</p>     <p>Каждый запрос состоит из двух строк, в первой из которых записано       одно целое число $$$n\ (1\le n\le 100\,000)$$$: количество моделей       в магазине, а во второй записаны $$$n$$$ целых чисел       $$$s_1,\dots,s_n\ (1\le s_i\le 10^9)$$$: размеры моделей.</p>     <p>Гарантируется, что сумма величин $$$n$$$ не превосходит $$$100\,000$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$t$$$ строк, в $$$i$$$-й из которых должно быть       записано максимальное число моделей, которое Орак может купить для       $$$i$$$-го запроса.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
4
5 3 4 6
7
1 4 2 3 6 4 9
5
5 4 3 2 1
1
9
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
3
1
1
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Для первого запроса, например, Орак может купить модели с       индексами $$$2$$$ и $$$4$$$, расстановка которых будет красивой       так как $$$4$$$ делится на $$$2$$$ и $$$6$$$ больше, чем $$$3$$$.       Рассмотрев остальные варианты, можно легко убедиться, что нет       красивой расстановки с более, чем тремя моделями.</p>     <p>Во втором запросе Орак может купить модели с индексами $$$1$$$,       $$$3$$$, и $$$6$$$. Рассмотрев остальные варианты, можно легко       убедиться, что нет красивой расстановки с более, чем тремя моделями.</p>     <p>В третьем примере не существует красивой расстановки с более, чем       одной моделью.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1350/problem/B' title='Codeforces Round 641 (Div. 2)'>1350B - Orac and Models</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Considering DP, we can design DP statuses as follow: $$$f_i$$$       stands for the length of the longest beautiful sequence end up       with index $$$i$$$. </p>     <p>We can find the transformation easily: $$$$$$ f_i =       \max\limits_{j\mid i, s_j&lt;s_i} \{f_j + 1\} $$$$$$</p>     <p>Then, the length of answer sequence is the maximum value among $$$f_1,f_2,\cdots,f_n$$$.</p>     <p>About the complexity of DP: If you transform by iterating       multiples, it will be $$$O(n\log n)$$$ (According to properties of       Harmonic Series); if you iterate divisors, then it will be       $$$O(n\sqrt n)$$$. Fortunately, both of them are acceptable in       this problem.</p></div></div></div>

           
            <pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;
const int MAXN = 500005;
inline int readint()
{
	int res = 0;
	char c = 0;
	while(!isdigit(c))
		c = getchar();
	while(isdigit(c))
		res = res*10+c-&#39;0&#39;, c = getchar();
	return res;	
}
int n,a[MAXN],f[MAXN];

int main()
{
	int T = readint();
	while(T--)
	{
		n = readint();
		for(int i = 1; i&lt;=n; i++)
			a[i] = readint();
		for(int i = 1; i&lt;=n; i++)
			f[i] = 1;
		for(int i = 1; i&lt;=n; i++) 
			for(int j = i*2; j&lt;=n; j += i)
				if(a[i]&lt;a[j])
					f[j] = max(f[j],f[i]+1);
		int ans = 0;
		for(int i = 1; i&lt;=n; i++)
			ans = max(ans,f[i]);
		cout &lt;&lt; ans &lt;&lt; endl;
	}
	return 0;
}

</code></pre>
           
            <pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;
const int MAXN = 500005;
inline int readint()
{
	int res = 0;
	char c = 0;
	while(!isdigit(c))
		c = getchar();
	while(isdigit(c))
		res = res*10+c-&#39;0&#39;, c = getchar();
	return res;	
}
int n,a[MAXN],f[MAXN];

int main()
{
	int T = readint();
	while(T--)
	{
		n = readint();
		for(int i = 1; i&lt;=n; i++)
			a[i] = readint();
		for(int i = 1; i&lt;=n; i++)
			f[i] = 1;
		for(int i = 1; i&lt;=n; i++) 
			for(int j = i*2; j&lt;=n; j += i)
				if(a[i]&lt;a[j])
					f[j] = max(f[j],f[i]+1);
		int ans = 0;
		for(int i = 1; i&lt;=n; i++)
			ans = max(ans,f[i]);
		cout &lt;&lt; ans &lt;&lt; endl;
	}
	return 0;
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #640 (Div. 4)
    1352A
    Сумма круглых чисел </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Сумма круглых чисел</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Положительное целое число называется <span class="tex-font-style-it">круглым</span>, если оно имеет вид <span class="tex-font-style-tt">d00...0</span>. Иными словами,       положительное целое число является круглым, если все его цифры,       кроме самой левой (старшей), равны нулю. В частности, все числа от       $$$1$$$ до $$$9$$$ (включительно) являются круглыми.</p>     <p>Например, следующие числа являются круглыми: $$$4000$$$, $$$1$$$,       $$$9$$$, $$$800$$$, $$$90$$$. Например, следующие числа <span class="tex-font-style-bf">не</span> являются круглыми: $$$110$$$,       $$$707$$$, $$$222$$$, $$$1001$$$.</p>     <p>Вам задано целое положительное число $$$n$$$ ($$$1 \le n \le       10^4$$$). Представьте число $$$n$$$ как сумму круглых чисел,       используя минимальное количество слагаемых. Иными словами, вам       надо разложить заданное число $$$n$$$ в сумму наименьшего       количества слагаемых, каждое из которых является круглым числом.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано целое число $$$t$$$ ($$$1 \le t \le       10^4$$$) — количество наборов входных данных в тесте. Далее       следуют $$$t$$$ наборов входных данных.</p>     <p>Каждый набор представляет собой строку, в которой записано целое       число $$$n$$$ ($$$1 \le n \le 10^4$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$t$$$ ответов на наборы входных данных. Каждый ответ       должен начинаться с целого числа $$$k$$$ — минимального количества       слагаемых. Далее должны следовать $$$k$$$ слагаемых, каждое из       которых является круглым числом, а их сумма равна $$$n$$$.       Слагаемые можно выводить в любом порядке. Если ответов несколько,       то выведите любой из них.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
5009
7
9876
10000
10
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
5000 9
1
7 
4
800 70 6 9000 
1
10000 
1
10 
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1352/problem/A' title='Codeforces Round 640 (Div. 4)'>1352A - Sum of Round Numbers</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Firstly, we need to understand the minimum amount of round       numbers we need to represent $$$n$$$. It equals the number of       non-zero digits in $$$n$$$. Why? Because we can &quot;remove&quot;       exactly one non-zero digit in $$$n$$$ using exactly one round       number (so we need at most this amount of round numbers) and, on       the other hand, the sum of two round numbers has at most two       non-zero digits (the sum of three round numbers has at most three       non-zero digits and so on) so this is useless to try to remove       more than one digit using the sum of several round numbers.</p>     <p>So we need to find all digits of $$$n$$$ and print the required       number for each of these digits. For example, if $$$n=103$$$ then       $$$n=1 \cdot 10^2 + 0 \cdot 10^1 + 3 \cdot 10^0$$$, so we need two       round numbers: $$$1 \cdot 10^2$$$ and $$$3 \cdot 10^0$$$.</p>     <p>Because the last digit of $$$n$$$ is $$$n \% 10$$$ (the remainder       of $$$n$$$ modulo $$$10$$$) and we can remove the last digit of       the number by integer division on $$$10$$$, we can use the       following code to solve the problem:</p>          <pre class="lstlisting"><code class="prettyprint">int n;<br />cin &gt;&gt; n;<br />vector&lt;int&gt; ans;<br />int power = 1;<br />while (n &gt; 0) {<br />	if (n % 10 &gt; 0) {<br />		ans.push_back((n % 10) * power);<br />	}<br />	n /= 10;<br />	power *= 10;<br />}<br />cout &lt;&lt; ans.size() &lt;&lt; endl;<br />for (auto number : ans) cout &lt;&lt; number &lt;&lt; &quot; &quot;;<br />cout &lt;&lt; endl;<br /></code></pre></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
	int t;
	cin &gt;&gt; t;
	while (t--) {
		int n;
		cin &gt;&gt; n;
		vector&lt;int&gt; ans;
		int power = 1;
		while (n &gt; 0) {
			if (n % 10 &gt; 0) {
				ans.push_back((n % 10) * power);
			}
			n /= 10;
			power *= 10;
		}
		cout &lt;&lt; ans.size() &lt;&lt; endl;
		for (auto number : ans) cout &lt;&lt; number &lt;&lt; &#34; &#34;;
		cout &lt;&lt; endl;
	}
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #640 (Div. 4)
    1352B
    Сумма слагаемых одинаковой четности </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Сумма слагаемых одинаковой четности</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Заданы два целых положительных числа $$$n$$$ ($$$1 \le n \le       10^9$$$) и $$$k$$$ ($$$1 \le k \le 100$$$). Представьте число       $$$n$$$ в виде суммы $$$k$$$ положительных целых чисел одинаковой       четности (с одинаковыми остатками от деления на $$$2$$$). </p>     <p>Иными словами, найдите такие $$$a_1, a_2, \ldots, a_k$$$, что все       $$$a_i&gt;0$$$, $$$n = a_1 + a_2 + \ldots + a_k$$$ и либо все       $$$a_i$$$ одновременно четные, либо все $$$a_i$$$ одновременно       нечетные. Если такого представления не существует, то сообщите об этом.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано целое число $$$t$$$ ($$$1 \le t \le       1000$$$) — количество наборов входных данных в тесте. Далее       записаны $$$t$$$ наборов входных данных по одному в строке.</p>     <p>Каждый набор представляет собой два целых положительных числа       $$$n$$$ ($$$1 \le n \le 10^9$$$) и $$$k$$$ ($$$1 \le k \le 100$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите:</p>          <ul> <li> <span class="tex-font-style-tt">YES</span> и искомые         $$$a_i$$$, если ответ существует (если ответов несколько, то         выведите любой из них); </li>       <li> <span class="tex-font-style-tt">NO</span>, если ответа не         существует. </li></ul>          <p>Буквы в словах <span class="tex-font-style-tt">YES</span> и <span class="tex-font-style-tt">NO</span> можно выводить в любом регистре.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
8
10 3
100 4
8 7
97 2
8 8
3 10
5 3
1000000000 9
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
YES
4 2 4
YES
55 5 5 35
NO
NO
YES
1 1 1 1 1 1 1 1
NO
YES
3 1 1
YES
111111110 111111110 111111110 111111110 111111110 111111110 111111110 111111110 111111120
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1352/problem/B' title='Codeforces Round 640 (Div. 4)'>1352B - Same Parity Summands</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Consider two cases: when we choose all odd numbers and all even       numbers. In both cases let's try to maximize the maximum. So, if       we choose odd numbers, let's try to take $$$k-1$$$ ones and the       remainder $$$n-(k-1)$$$. But we need to sure that $$$n-k+1$$$ is       greater than zero and odd. And in case of even numbers, let's try       to take $$$k-1$$$ twos and the remainder $$$n-2(k-1)$$$. We also       need to check that the remainder is greater than zero and even. If       none of these cases is true, print &quot;<span class="tex-font-style-tt">NO</span>&quot;.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
	int t;
	cin &gt;&gt; t;
	while (t--) {
		int n, k;
		cin &gt;&gt; n &gt;&gt; k;
		int n1 = n - (k - 1);
		if (n1 &gt; 0 &amp;&amp; n1 % 2 == 1) {
			cout &lt;&lt; &#34;YES&#34; &lt;&lt; endl;
			for (int i = 0; i &lt; k - 1; ++i) cout &lt;&lt; &#34;1 &#34;;
			cout &lt;&lt; n1 &lt;&lt; endl;
			continue;
		}
		int n2 = n - 2 * (k - 1);
		if (n2 &gt; 0 &amp;&amp; n2 % 2 == 0) {
			cout &lt;&lt; &#34;YES&#34; &lt;&lt; endl;
			for (int i = 0; i &lt; k - 1; ++i) cout &lt;&lt; &#34;2 &#34;;
			cout &lt;&lt; n2 &lt;&lt; endl;
			continue;
		}
		cout &lt;&lt; &#34;NO&#34; &lt;&lt; endl;
	}
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #640 (Div. 4)
    1352C
    K-е неделящееся на n </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. K-е неделящееся на n</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Заданы два целых положительных числа: $$$n$$$ и $$$k$$$. Выведите       $$$k$$$-е положительное целое число, которое не делится на $$$n$$$.</p>     <p>Например, если $$$n=3$$$, а $$$k=7$$$, то все числа, которые не       делятся на $$$3$$$, имеют вид: $$$1, 2, 4, 5, 7, 8, 10, 11, 13       \dots$$$. $$$7$$$-е число среди них равно $$$10$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано целое число $$$t$$$ ($$$1 \le t \le       1000$$$) — количество наборов входных данных в тесте. Далее       записаны $$$t$$$ наборов входных данных по одному в строке.</p>     <p>Каждый набор представляет собой два целых положительных числа       $$$n$$$ ($$$2 \le n \le 10^9$$$) и $$$k$$$ ($$$1 \le k \le 10^9$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите $$$k$$$-е целое       положительное число, которое не делится на $$$n$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
3 7
4 12
2 1000000000
7 97
1000000000 1000000000
2 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
10
15
1999999999
113
1000000001
1
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1352/problem/C' title='Codeforces Round 640 (Div. 4)'>1352C - K-th Not Divisible by n</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Suppose the answer is just $$$k$$$-th positive integer which we       should &quot;shift right&quot; by some number. Each multiplier of       $$$n$$$ shifts our answer by $$$1$$$. The number of such       multipliers is $$$need = \lfloor\frac{k-1}{n-1}\rfloor$$$, where       $$$\lfloor \frac{x}{y} \rfloor$$$ is $$$x$$$ divided by $$$y$$$       rounded down. So the final answer is $$$k + need$$$ ($$$k$$$-th       positive integer with the required number of skipped integers       multipliers of $$$n$$$).</p>     <p>You can also use a binary search to solve this problem :)</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
	int t;
	cin &gt;&gt; t;
	while (t--) {
		int n, k;
		cin &gt;&gt; n &gt;&gt; k;
		int need = (k - 1) / (n - 1);
		cout &lt;&lt; k + need &lt;&lt; endl;
	}
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #640 (Div. 4)
    1352D
    Алиса, Боб и конфеты </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Алиса, Боб и конфеты</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>В ряд выложены $$$n$$$ конфет, которые пронумерованы слева       направо от $$$1$$$ до $$$n$$$. Размер $$$i$$$-й конфеты равен $$$a_i$$$.</p>     <p>Алиса и Боб играют в интересную и вкусную игру — они едят       конфеты. Алиса будет есть конфеты <span class="tex-font-style-bf">слева направо</span>, а Боб — <span class="tex-font-style-bf">справа налево</span>. Игра       заканчивается, когда все конфеты съедены.</p>     <p>Процесс состоит из ходов. Во время хода игрок съедает одну или       более конфет со своей стороны (Алиса ест слева, Боб — справа).       Первый ход делает Алиса. Во время первого хода она съест $$$1$$$       конфету (ее размер равен $$$a_1$$$). Затем каждый следующий ход       стороны чередуются — то есть второй ход совершает Боб, затем       Алиса, затем снова Боб и так далее.</p>     <p>На каждом ходу игрок считает суммарный размер конфет, съеденных       за текущий ход. Как только это число становится строго больше, чем       суммарный размер конфет, съеденных другим игроком на предыдущем       ходу, текущий игрок завершает ход. Иными словами, на очередном       ходу игрок ест наименьшее возможное количество конфет, при котором       сумма размеров съеденных в этот ход конфет <span class="tex-font-style-bf">строго больше</span> суммы размеров       конфет, которые съел другой игрок на <span class="tex-font-style-bf">предыдущем</span> ходу. Если конфет       недостаточно, чтобы совершить ход таким образом, то игрок доедает       все оставшиеся конфеты и игра заканчивается.</p>     <p>Например, если $$$n=11$$$ и $$$a=[3,1,4,1,5,9,2,6,5,3,5]$$$, то:</p>          <ul> <li> ход 1: Алиса съест одну конфету размера $$$3$$$ и         последовательность конфет примет вид         $$$[1,4,1,5,9,2,6,5,3,5]$$$; </li>       <li> ход 2: на предыдущем ходу Алиса съела $$$3$$$, значит, Боб         должен съесть $$$4$$$ или более — Боб съест одну конфету размера         $$$5$$$ и последовательность конфет примет вид         $$$[1,4,1,5,9,2,6,5,3]$$$; </li>       <li> ход 3: на предыдущем ходу Боб съел $$$5$$$, значит, Алиса         должна съесть $$$6$$$ или более — Алиса съест три конфеты         суммарным размером $$$1+4+1=6$$$ и последовательность конфет         примет вид $$$[5,9,2,6,5,3]$$$; </li>       <li> ход 4: на предыдущем ходу Алиса съела $$$6$$$, значит, Боб         должен съесть $$$7$$$ или более — Боб съест две конфеты         суммарным размером $$$3+5=8$$$ и последовательность конфет         примет вид $$$[5,9,2,6]$$$; </li>       <li> ход 5: на предыдущем ходу Боб съел $$$8$$$, значит, Алиса         должна съесть $$$9$$$ или более — на пятом ходу Алиса съест две         конфеты суммарным размером $$$5+9=14$$$ и последовательность         конфет примет вид $$$[2,6]$$$; </li>       <li> ход 6 (последний): на предыдущем ходу Алиса съела $$$14$$$,         значит, Боб должен съесть $$$15$$$ или более — это невозможно,         поэтому Боб съест две оставшиеся конфеты и игра закончится. </li></ul>          <p>Выведите количество ходов в этой игре и два числа:</p>          <ul> <li> $$$a$$$ — суммарный размер всех конфет, съеденных Алисой         за всю игру; </li>       <li> $$$b$$$ — суммарный размер всех конфет, съеденных Бобом за         всю игру. </li></ul></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано целое число $$$t$$$ ($$$1 \le t \le       5000$$$) — количество наборов входных данных. Далее следуют       описания $$$t$$$ наборов входных данных.</p>     <p>Каждый набор состоит из двух строк. В первой строке содержится       целое число $$$n$$$ ($$$1 \le n \le 1000$$$) — количество конфет.       Во второй строке содержится последовательность целых чисел $$$a_1,       a_2, \dots, a_n$$$ ($$$1 \le a_i \le 1000$$$) — размеры конфет в       порядке их расположения слева направо.</p>     <p>Гарантируется, что сумма значений $$$n$$$ по всем наборам входных       данных в тесте не превосходит $$$2\cdot10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите три целых числа —       количество ходов в игре и искомые величины $$$a$$$ и $$$b$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
7
11
3 1 4 1 5 9 2 6 5 3 5
1
1000
3
1 1 1
13
1 2 3 4 5 6 7 8 9 10 11 12 13
2
2 1
6
1 1 1 1 1 1
7
1 1 1 1 1 1 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
6 23 21
1 1000 0
2 1 2
6 45 46
2 2 1
3 4 2
4 4 3
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1352/problem/D' title='Codeforces Round 640 (Div. 4)'>1352D - Alice, Bob and Candies</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>This is just an implementation problem and it can be solved in       $$$O(n)$$$ time but we didn't ask for such solutions so you could       solve it in $$$O(n^2)$$$ or maybe even in $$$O(n^2 log n)$$$. I'll       describe $$$O(n)$$$ solution anyway.</p>     <p>Firstly, we need to maintain several variables: $$$cnt$$$       (initially $$$0$$$, the number of moves passed), $$$l$$$ (the       position of the leftmost remaining candy, initially $$$0$$$),       $$$r$$$ (the position of the rightmost remaining candy, initially       $$$n-1$$$), $$$ansl$$$ (the sum of candies eaten by Alice,       initially $$$0$$$), $$$ansr$$$ (the sum of candied eaten by Bob,       initially $$$0$$$), $$$suml$$$ (the sum of candies eaten by Alice       during her last move, initially $$$0$$$) and $$$sumr$$$ (the sum       of candies eaten by Bob during his last move, initially $$$0$$$).</p>     <p>So, let's just simulate the following process while $$$l \le       r$$$: if the number of moves $$$cnt$$$ is even then now is Alice's       move and we need to maintain <span class="tex-font-style-it">one         more variable</span> $$$nsuml = 0$$$ — the sum of candies Alice       eats during this move. How to calculate it? While $$$l \le r$$$       and $$$nsuml \le sumr$$$, let's eat the leftmost candy, so       variables will change like this: $$$nsuml := nsuml + a_l, l := l +       1$$$. After all, let's add $$$nsuml$$$ to $$$ansl$$$, replace       $$$suml$$$ with $$$nsuml$$$ (assign $$$suml := nsuml$$$) and       increase $$$cnt$$$ by $$$1$$$. If the number of moves $$$cnt$$$ is       odd then the process is the same but from the Bob's side.</p>     <p>I'll also add a simply implemented $$$O(n^2)$$$ solution written       by Gassa below :)</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
	int t;
	cin &gt;&gt; t;
	while (t--) {
		int n;
		cin &gt;&gt; n;
		vector&lt;int&gt; a(n);
		for (auto &amp;it : a) cin &gt;&gt; it;
		int l = 0, r = n - 1;
		int suml = 0, sumr = 0;
		int cnt = 0, ansl = 0, ansr = 0;
		while (l &lt;= r) {
			if (cnt % 2 == 0) {
				int nsuml = 0;
				while (l &lt;= r &amp;&amp; nsuml &lt;= sumr) {
					nsuml += a[l++];
				}
				ansl += nsuml;
				suml = nsuml;
			} else {
				int nsumr = 0;
				while (l &lt;= r &amp;&amp; nsumr &lt;= suml) {
					nsumr += a[r--];
				}
				ansr += nsumr;
				sumr = nsumr;
			}
			++cnt;
		}
		cout &lt;&lt; cnt &lt;&lt; &#34; &#34; &lt;&lt; ansl &lt;&lt; &#34; &#34; &lt;&lt; ansr &lt;&lt; endl;
	}
}
</code></pre>
           
            <pre><code>// Author: Ivan Kazmenko (gassa@mail.ru)
import std.algorithm;
import std.conv;
import std.range;
import std.stdio;
import std.string;

void main ()
{
	auto tests = readln.strip.to !(int);
	foreach (test; 0..tests)
	{
		auto n = readln.strip.to !(int);
		auto a = readln.splitter.map !(to !(int)).array;
		int [2] total;
		int prev = 0;
		int moves = 0;
		while (!a.empty)
		{
			moves += 1;
			int cur = 0;
			while (!a.empty &amp;&amp; cur &lt;= prev)
			{
				cur += a[0];
				a = a[1..$];
			}
			total[moves % 2] += cur;
			prev = cur;
			reverse (a);
		}
		writeln (moves, &#34; &#34;, total[1], &#34; &#34;, total[0]);
	}
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #640 (Div. 4)
    1352E
    Особые элементы </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. Особые элементы</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>64 мегабайта</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>       <span class="tex-font-style-it">Обратите внимание на нестандартное         ограничение по памяти в этой задаче.</span></p>     <p>       <span class="tex-font-style-it">С целью отсечения эффективных         решений от неэффективных в этой задаче ограничение времени         довольно строгое. Предпочтите использование компилируемых         статически типизированных языков (например, C++). Если         используете Python, то отсылайте решения на PyPy. Постарайтесь         написать в самом деле эффективное решение.</span></p>     <p>Задан массив $$$a=[a_1, a_2, \ldots, a_n]$$$ ($$$1 \le a_i \le       n$$$). Его элемент $$$a_i$$$ называется особым, если существует       такая пара индексов $$$l$$$ и $$$r$$$ ($$$1 \le l &lt; r \le       n$$$), что $$$a_i = a_l + a_{l+1} + \ldots + a_r$$$. Иными       словами, элемент называется особым, если он представим в виде       суммы <span class="tex-font-style-bf">двух или более подряд идущих       элементов</span> массива (не важно, особых или нет).</p>     <p>Выведите количество особых элементов заданного массива $$$a$$$.</p>     <p>Например, если $$$n=9$$$ и $$$a=[3,1,4,1,5,9,2,6,5]$$$, то ответ       равен $$$5$$$:</p>          <ul> <li> $$$a_3=4$$$ — особый элемент, так как         $$$a_3=4=a_1+a_2=3+1$$$; </li>       <li> $$$a_5=5$$$ — особый элемент, так как         $$$a_5=5=a_2+a_3=1+4$$$; </li>       <li> $$$a_6=9$$$ — особый элемент, так как         $$$a_6=9=a_1+a_2+a_3+a_4=3+1+4+1$$$; </li>       <li> $$$a_8=6$$$ — особый элемент, так как         $$$a_8=6=a_2+a_3+a_4=1+4+1$$$; </li>       <li> $$$a_9=5$$$ — особый элемент, так как         $$$a_9=5=a_2+a_3=1+4$$$. </li></ul>          <p>Обратите внимание, что среди элементов массива $$$a$$$ могут быть       равные — если несколько элементов равны и являются особыми, то все       они должны быть посчитаны в ответе.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано целое число $$$t$$$ ($$$1 \le t \le       1000$$$) — количество наборов входных данных в тесте. Далее       следуют описания $$$t$$$ наборов входных данных.</p>     <p>Каждый набор задается двумя строками. В первой строке записано       целое число $$$n$$$ ($$$1 \le n \le 8000$$$) — длина массива       $$$a$$$. Во второй строке записаны целые числа $$$a_1, a_2, \dots,       a_n$$$ ($$$1 \le a_i \le n$$$).</p>     <p>Гарантируется, что сумма значений $$$n$$$ по всем наборам входных       данных не превосходит $$$8000$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$t$$$ чисел — количества особых элементов для каждого       из заданных массивов.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
9
3 1 4 1 5 9 2 6 5
3
1 1 2
5
1 1 1 1 1
8
8 7 6 5 4 3 2 1
1
1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
5
1
0
4
0
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1352/problem/E' title='Codeforces Round 640 (Div. 4)'>1352E - Special Elements</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>The intended solution for this problem uses $$$O(n^2)$$$ time and       $$$O(n)$$$ memory. Firstly, let's calculate $$$cnt_i$$$ for each       $$$i$$$ from $$$1$$$ to $$$n$$$, where $$$cnt_i$$$ is the number       of occurrences of $$$i$$$ in $$$a$$$. This part can be done in $$$O(n)$$$.</p>     <p>Then let's iterate over all segments of $$$a$$$ of length at       least $$$2$$$ maintaining the sum of the current segment       $$$sum$$$. We can notice that we don't need sums greater than       $$$n$$$ because all elements do not exceed $$$n$$$. So if the       current sum does not exceed $$$n$$$ then add $$$cnt_{sum}$$$ to       the answer and set $$$cnt_{sum} := 0$$$ to prevent counting the       same elements several times. This part can be done in $$$O(n^2)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
	int t;
	cin &gt;&gt; t;
	while (t--) {
		int n;
		cin &gt;&gt; n;
		vector&lt;int&gt; a(n);
		vector&lt;int&gt; cnt(n + 1);
		int ans = 0;
		for (auto &amp;it : a) {
			cin &gt;&gt; it;
			++cnt[it];
		}
		for (int l = 0; l &lt; n; ++l) {
			int sum = 0;
			for (int r = l; r &lt; n; ++r) {
				sum += a[r];
				if (l == r) continue;
				if (sum &lt;= n) {
					ans += cnt[sum];
					cnt[sum] = 0;
				}
			}
		}
		cout &lt;&lt; ans &lt;&lt; endl;
	}
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #640 (Div. 4)
    1352F
    Восстановление 01-строки </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Восстановление 01-строки</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Для некоторой 01-строки $$$s$$$ (то есть такой, что каждый символ       $$$s_i$$$ — это либо '<span class="tex-font-style-tt">0</span>',       либо '<span class="tex-font-style-tt">1</span>') выписали все пары       подряд идущих символов (все подстроки длины $$$2$$$). Для каждой       пары (подстроки длины $$$2$$$) посчитали количество символов         '<span class="tex-font-style-tt">1</span>' (единиц) в ней.</p>     <p>Вам заданы три числа:</p>          <ul> <li> $$$n_0$$$ — количество пар подряд идущих символов         (подстрок), в которых $$$0$$$ единиц; </li>       <li> $$$n_1$$$ — количество пар подряд идущих символов (подстрок),         в которых $$$1$$$ единица; </li>       <li> $$$n_2$$$ — количество пар подряд идущих символов (подстрок),         в которых $$$2$$$ единицы. </li></ul>          <p>Например, для строки $$$s=$$$«<span class="tex-font-style-tt">1110011110</span>» были бы выписаны       следующие подстроки: «<span class="tex-font-style-tt">11</span>»,         «<span class="tex-font-style-tt">11</span>», «<span class="tex-font-style-tt">10</span>», «<span class="tex-font-style-tt">00</span>», «<span class="tex-font-style-tt">01</span>», «<span class="tex-font-style-tt">11</span>», «<span class="tex-font-style-tt">11</span>», «<span class="tex-font-style-tt">11</span>», «<span class="tex-font-style-tt">10</span>». Таким образом, $$$n_0=1$$$,       $$$n_1=3$$$, $$$n_2=5$$$.</p>     <p>Ваша задача — по заданным $$$n_0, n_1, n_2$$$ восстановить <span class="tex-font-style-bf">любую</span> подходящую 01-строку       (бинарную строку) $$$s$$$. Гарантируется, что хотя бы одно из       чисел $$$n_0, n_1, n_2$$$ отлично от $$$0$$$. Также гарантируется,       что решение существует.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано целое число $$$t$$$ ($$$1 \le t \le       1000$$$) — количество наборов входных данных в тесте. Далее во       входных данных записаны сами наборы.</p>     <p>Каждый набор состоит из одной строки, которая содержит три целых       числа $$$n_0, n_1, n_2$$$ ($$$0 \le n_0, n_1, n_2 \le 100$$$;       $$$n_0 + n_1 + n_2 &gt; 0$$$). Гарантируется, что ответ для       заданных $$$n_0, n_1, n_2$$$ существует.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$t$$$ строк. Каждая из строк должна содержать ответ в       виде 01-строки (бинарной строки) на соответствующий набор входных       данных. Если возможных ответов несколько, выведите любой из них.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
7
1 3 5
1 1 1
3 9 3
0 1 0
3 1 2
0 0 3
2 0 0
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1110011110
0011
0110001100101011
10
0000111
1111
000
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1352/problem/F' title='Codeforces Round 640 (Div. 4)'>1352F - Binary String Reconstruction</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Consider case $$$n_1 = 0$$$ separately and print the sting of       $$$n_0 + 1$$$ zeros or $$$n_2 + 1$$$ ones correspondingly.</p>     <p>Now our string has at least one pair &quot;<span class="tex-font-style-tt">10</span>&quot; or &quot;<span class="tex-font-style-tt">01</span>&quot;. Let's form the pattern         &quot;<span class="tex-font-style-tt">101010 ... 10</span>&quot;       of length $$$n_1 + 1$$$. So, all substrings with the sum $$$1$$$       are satisfied. Now let's insert $$$n_0$$$ zeros before the first       zero, in this way we satisfy the substrings with the sum $$$0$$$.       And then just insert $$$n_2$$$ ones before the first one, in this       way we satisfy the substrings with the sum $$$2$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;


int main() {
	int t;
	cin &gt;&gt; t;
	while (t--) {
		int n0, n1, n2;
		cin &gt;&gt; n0 &gt;&gt; n1 &gt;&gt; n2;
		if (n1 == 0) {
			if (n0 != 0) {
				cout &lt;&lt; string(n0 + 1, &#39;0&#39;) &lt;&lt; endl;
			} else {
				cout &lt;&lt; string(n2 + 1, &#39;1&#39;) &lt;&lt; endl;
			}
			continue;
		}
		string ans;
		for (int i = 0; i &lt; n1 + 1; ++i) {
			if (i &amp; 1) ans += &#34;0&#34;;
			else ans += &#34;1&#34;;
		}
		ans.insert(1, string(n0, &#39;0&#39;));
		ans.insert(0, string(n2, &#39;1&#39;));
		cout &lt;&lt; ans &lt;&lt; endl;
	}
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #640 (Div. 4)
    1352G
    Особая перестановка </h1>

    <div class="problemindexholder" problemindex="G">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">G. Особая перестановка</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Перестановкой длины $$$n$$$ называется такой массив       $$$p=[p_1,p_2,\dots,p_n]$$$, который содержит каждое число от       $$$1$$$ до $$$n$$$ (включительно) и притом ровно по одному разу.       Например, $$$p=[3,1,4,2,5]$$$ — перестановка длины $$$5$$$.</p>     <p>Для заданного числа $$$n$$$ ($$$n \ge 2$$$) найдите такую       перестановку $$$p$$$, в которой разница (то есть модуль разности)       любых двух соседних элементов находится в диапазоне от $$$2$$$ до       $$$4$$$, включительно. Формально, для перестановки $$$p$$$ должно       выполняться $$$2 \le |p_i - p_{i+1}| \le 4$$$ для всех $$$i$$$       ($$$1 \le i &lt; n$$$).</p>     <p>Выведите любую такую перестановку для заданного значения $$$n$$$       или определите, что ее не существует.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано целое число $$$t$$$ ($$$1 \le t \le       100$$$) — количество наборов входных данных в тесте. Далее следуют       описания $$$t$$$ наборов входных данных.</p>     <p>Каждый набор описывается единственной строкой, в которой       содержится целое число $$$n$$$ ($$$2 \le n \le 1000$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$t$$$ строк. Очередная строка должна содержать <span class="tex-font-style-tt">-1</span>, если для соответствующего       набора входных данных искомой перестановки не существует. В       противном случае выведите искомую перестановку. Если таких       перестановок существует несколько, то выведите любую из них.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
10
2
4
6
7
13
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
9 6 10 8 4 7 3 1 5 2 
-1
3 1 4 2 
5 3 6 2 4 1 
5 1 3 6 2 4 7 
13 9 7 11 8 4 1 3 5 2 6 10 12 
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1352/problem/G' title='Codeforces Round 640 (Div. 4)'>1352G - Special Permutation</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>If $$$n &lt; 4$$$ then there is no answer. You can do some       handwork to be sure. Otherwise, the answer exists and there is one       simple way to construct it: firstly, let's put all odd integers       into the answer in decreasing order, then put $$$4$$$, $$$2$$$,       and all other even numbers in increasing order. To test that it       always works, you can run some kind of checker locally (you can       check all $$$1000$$$ tests very fast, in less than one second,       this may be very helpful sometimes).</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
	int t;
	cin &gt;&gt; t;
	while (t--) {
		int n;
		cin &gt;&gt; n;
		if (n &lt; 4) {
			cout &lt;&lt; -1 &lt;&lt; endl;
			continue;
		}
		for (int i = n; i &gt;= 1; --i) {
			if (i &amp; 1) cout &lt;&lt; i &lt;&lt; &#34; &#34;;
		}
		cout &lt;&lt; 4 &lt;&lt; &#34; &#34; &lt;&lt; 2 &lt;&lt; &#34; &#34;;
		for (int i = 6; i &lt;= n; i += 2) {
			cout &lt;&lt; i &lt;&lt; &#34; &#34;;
		}
		cout &lt;&lt; endl;
	}
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #642 (Div. 3)
    1353A
    Наиболее нестабильный массив  </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Наиболее нестабильный массив </div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам даны два целых числа $$$n$$$ и $$$m$$$. Вам нужно построить       массив $$$a$$$ длины $$$n$$$ состоящий из <span class="tex-font-style-bf">неотрицательных целых чисел</span>       (т.е. целых чисел больших или равных нулю) такой, что сумма       элементов этого массива <span class="tex-font-style-bf">в       точности</span> равна $$$m$$$ и величина       $$$\sum\limits_{i=1}^{n-1} |a_i - a_{i+1}|$$$ максимально       возможная. Напомним, что $$$|x|$$$ — абсолютное значение $$$x$$$.</p>     <p>Другими словами, вы хотите максимизировать сумму абсолютных       разностей между соседними (последовательными) элементами.       Например, если массив $$$a=[1, 3, 2, 5, 5, 0]$$$, то величина,       описанная выше, для этого массива равна $$$|1-3| + |3-2| + |2-5| +       |5-5| + |5-0| = 2 + 1 + 3 + 0 + 5 = 11$$$. Заметьте, что этот       пример <span class="tex-font-style-bf">не показывает оптимальный       ответ</span>, но показывает, как считается необходимое значение       для какого-то массива.</p>     <p>Вам нужно ответить на $$$t$$$ независимых наборов тестовых данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка теста содержит одно целое число $$$t$$$ ($$$1 \le t       \le 10^4$$$) — количество наборов тестовых данных. Затем следуют       $$$t$$$ наборов тестовых данных.</p>     <p>Единственная строка набора тестовых данных содержит два целых       числа $$$n$$$ и $$$m$$$ ($$$1 \le n, m \le 10^9$$$) — длину       массива и его сумму соответственно.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите ответ на него —       максимально возможное значение $$$\sum\limits_{i=1}^{n-1} |a_i -       a_{i+1}|$$$ для массива $$$a$$$, состоящего из $$$n$$$       неотрицательных целых чисел, сумма которых равна $$$m$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
1 100
2 2
5 5
2 1000000000
1000000000 1000000000
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
2
10
1000000000
2000000000
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе тестовых данных примера единственный возможный       массив — $$$[100]$$$, и ответ очевидно равен $$$0$$$.</p>     <p>Во втором наборе тестовых данных примера один из возможных       массивов — $$$[2, 0]$$$, и ответ равен $$$|2-0| = 2$$$.</p>     <p>В третьем наборе тестовых данных примера один из возможных       массивов — $$$[0, 2, 0, 3, 0]$$$, и ответ равен $$$|0-2| + |2-0| +       |0-3| + |3-0| = 10$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1353/problem/A' title='Codeforces Round 642 (Div. 3)'>1353A - Most Unstable Array</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>If $$$n=1$$$ then the answer is $$$0$$$. Otherwise, the best way       is to construct the array $$$[0, m, 0, \dots, 0]$$$. For $$$n=2$$$       we can't reach answer more than $$$m$$$ and for $$$n &gt; 2$$$ we       can't reach the answer more than $$$2m$$$ because each unit can't       be used more than twice. So the answer can be represented as       $$$min(2, n - 1) \cdot m$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
	
	int t;
	cin &gt;&gt; t;
	while (t--) {
		int n, m;
		cin &gt;&gt; n &gt;&gt; m;
		cout &lt;&lt; min(2, n - 1) * m &lt;&lt; endl;
	}
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #642 (Div. 3)
    1353B
    Два массива и обмены </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Два массива и обмены</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам даны два массива $$$a$$$ и $$$b$$$, оба состоят из $$$n$$$       положительных (больших нуля) целых чисел. Также вам задано число $$$k$$$.</p>     <p>За один ход вы можете выбрать два индекса $$$i$$$ и $$$j$$$ ($$$1       \le i, j \le n$$$) и поменять местами $$$a_i$$$ и $$$b_j$$$ (i.e.       $$$a_i$$$ становится $$$b_j$$$ и наоборот). Заметьте, что $$$i$$$       и $$$j$$$ могут совпадать или отличаться (в частности, обмен       $$$a_2$$$ с $$$b_2$$$ или обмен $$$a_3$$$ с $$$b_9$$$ оба       считаются приемлемыми ходами).</p>     <p>Ваша задача — назвать <span class="tex-font-style-bf">максимальную</span> возможную сумму,       которую вы можете получить в массиве $$$a$$$, если вы сделаете не       более $$$k$$$ таких ходов (обменов).</p>     <p>Вам нужно ответить на $$$t$$$ независимых наборов тестовых данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка теста содержит одно целое число $$$t$$$ ($$$1 \le t       \le 200$$$) — количество наборов тестовых данных. Затем следуют       $$$t$$$ наборов тестовых данных.</p>     <p>Первая строка набора тестовых данных содержит два целых числа       $$$n$$$ и $$$k$$$ ($$$1 \le n \le 30; 0 \le k \le n$$$) —       количество элементов в $$$a$$$ и $$$b$$$ и максимальное количество       ходов, которое вы можете сделать. Вторая строка набора тестовых       данных содержит $$$n$$$ целых чисел $$$a_1, a_2, \dots, a_n$$$       ($$$1 \le a_i \le 30$$$), где $$$a_i$$$ — это $$$i$$$-й элемент в       $$$a$$$. Третья строка набора тестовых данных содержит $$$n$$$       целых чисел $$$b_1, b_2, \dots, b_n$$$ ($$$1 \le b_i \le 30$$$),       где $$$b_i$$$ — это $$$i$$$-й элемент в $$$b$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите ответ на него — <span class="tex-font-style-bf">максимальную</span> возможную сумму,       которую вы можете получить в массиве $$$a$$$, если вы можете       совершить не более $$$k$$$ обменов.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
2 1
1 2
3 4
5 5
5 5 6 6 5
1 2 5 4 3
5 3
1 2 3 4 5
10 9 10 10 9
4 0
2 2 4 3
2 4 2 3
4 4
1 2 2 1
4 4 5 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
6
27
39
11
17
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе тестовых данных примера вы можете поменять       местами $$$a_1 = 1$$$ и $$$b_2 = 4$$$ и тогда получите $$$a=[4,       2]$$$ и $$$b=[3, 1]$$$.</p>     <p>Во втором наборе тестовых данных примера вам не нужно ничего менять.</p>     <p>В третьем наборе тестовых данных примера вы можете поменять       местами $$$a_1 = 1$$$ и $$$b_1 = 10$$$, $$$a_3 = 3$$$ и $$$b_3 =       10$$$ и $$$a_2 = 2$$$ и $$$b_4 = 10$$$, и получить $$$a=[10, 10,       10, 4, 5]$$$ и $$$b=[1, 9, 3, 2, 9]$$$.</p>     <p>В четвертом наборе тестовых данных примера вы не можете ничего поменять.</p>     <p>В пятом наборе тестовых данных примера вы можете поменять местами       массивы $$$a$$$ и $$$b$$$ и получить $$$a=[4, 4, 5, 4]$$$ и       $$$b=[1, 2, 2, 1]$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1353/problem/B' title='Codeforces Round 642 (Div. 3)'>1353B - Two Arrays And Swaps</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Each move we can choose the minimum element in $$$a$$$, the       maximum element in $$$b$$$ and swap them (if the minimum in       $$$a$$$ is less than maximum in $$$b$$$). If we repeat this       operation $$$k$$$ times, we get the answer. This can be done in       $$$O(n^3)$$$, $$$O(n^2)$$$ but authors solution is $$$O(n \log n)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
	
	int t;
	cin &gt;&gt; t;
	while (t--) {
		int n, k;
		cin &gt;&gt; n &gt;&gt; k;
		vector&lt;int&gt; a(n);
		for (auto &amp;it : a) cin &gt;&gt; it;
		vector&lt;int&gt; b(n);
		for (auto &amp;it : b) cin &gt;&gt; it;
		sort(a.begin(), a.end());
		sort(b.rbegin(), b.rend());
		int ans = 0;
		for (int i = 0; i &lt; n; ++i) {
			if (i &lt; k) ans += max(a[i], b[i]);
			else ans += a[i];
		}
		cout &lt;&lt; ans &lt;&lt; endl;
	}
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #642 (Div. 3)
    1353C
    Ходы на доске </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Ходы на доске</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам задана доска размера $$$n \times n$$$, где $$$n$$$ <span class="tex-font-style-bf">нечетно</span> (не кратно $$$2$$$).       Изначально в каждой клетке доски расположена одна фигура.</p>     <p>За один ход вы можете выбрать <span class="tex-font-style-bf">ровно одну фигуру</span>,       расположенную в какой-либо клетке и передвинуть ее в одну из       клеток, <span class="tex-font-style-bf">имеющую общую сторону или         угол с текущей клеткой</span>, то есть из клетки $$$(i, j)$$$ вы       можете передвинуть фигуру в клетку: </p>     <ul> <li> $$$(i - 1, j - 1)$$$; </li>       <li> $$$(i - 1, j)$$$; </li>       <li> $$$(i - 1, j + 1)$$$; </li>       <li> $$$(i, j - 1)$$$; </li>       <li> $$$(i, j + 1)$$$; </li>       <li> $$$(i + 1, j - 1)$$$; </li>       <li> $$$(i + 1, j)$$$; </li>       <li> $$$(i + 1, j + 1)$$$; </li></ul>          <p>Конечно же, вы <span class="tex-font-style-bf">не можете</span>       двигать фигуры в клетки за пределами доски. Допустимо, что после       хода в одной клетке будет находиться несколько фигур.</p>     <p>Ваша задача — найти минимальное количество ходов, необходимое,       чтобы собрать <span class="tex-font-style-bf">все фигуры</span> в         <span class="tex-font-style-bf">одной</span> клетке (т.е. в       $$$n^2-1$$$ клетках должно быть расположено $$$0$$$ фигур и в       одной клетке должны быть расположены $$$n^2$$$ фигур).</p>     <p>Вам нужно ответить на $$$t$$$ независимых наборов тестовых данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка теста содержит одно целое число $$$t$$$ ($$$1 \le t       \le 200$$$) — количество наборов тестовых данных. Затем следуют       $$$t$$$ наборов тестовых данных.</p>     <p>Единственная строка набора тестовых данных содержит одно целое       число $$$n$$$ ($$$1 \le n &lt; 5 \cdot 10^5$$$) — размер доски.       Гарантируется, что $$$n$$$ нечетно (не делится на $$$2$$$).</p>     <p>Также гарантируется, что сумма $$$n$$$ по всем наборам тестовых       данных не превосходит $$$5 \cdot 10^5$$$ ($$$\sum n \le 5 \cdot 10^5$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите ответ — минимальное       количество ходов, необходимое, чтобы собрать <span class="tex-font-style-bf">все фигуры</span> в <span class="tex-font-style-bf">одной</span> клетке.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
1
5
499993
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
40
41664916690999888
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1353/problem/C' title='Codeforces Round 642 (Div. 3)'>1353C - Board Moves</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>It is intuitive (and provable) that the best strategy is to move       each figure to the center cell $$$(\frac{n+1}{2},       \frac{n+1}{2})$$$. Now, with some paperwork or easy observations,       we can notice that we have exactly $$$8$$$ cells with the shortest       distance $$$1$$$, $$$16$$$ cells with the shortest distance       $$$2$$$, $$$24$$$ cells with the shortest distance $$$3$$$ and so       on. So we have $$$8i$$$ cells with the shortest distance $$$i$$$.       So the answer is $$$1 \cdot 8 + 2 \cdot 16 + 3 \cdot 24 + \dots +       (\frac{n-1}{2})^2 \cdot 8$$$. It can be rewritten as $$$8 (1 + 4 +       9 + \dots + (\frac{n-1}{2})^2)$$$ so we can just calculate the sum       of squares of all integers from $$$1$$$ to $$$\frac{n-1}{2}$$$       using loop (or formula $$$\frac{n(n+1)(2n+1)}{6}$$$) and multiply       the answer by $$$8$$$.</p>     <p>Time complexity: $$$O(n)$$$ or $$$O(1)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
	
	int t;
	cin &gt;&gt; t;
	while (t--) {
		int n;
		cin &gt;&gt; n;
		long long ans = 0;
		for (int i = 1; i &lt;= n / 2; ++i) {
			ans += i * 1ll * i;
		}
		cout &lt;&lt; ans * 8 &lt;&lt; endl;
	}
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #642 (Div. 3)
    1353D
    Построение массива </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Построение массива</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам задана массив $$$a$$$ длины $$$n$$$, состоящий из нулей. Вы       выполняете $$$n$$$ действий с этим массивом: в течение $$$i$$$-го       действия происходит следующая последовательность операций:</p>          <ol> <li> Выбирается максимальный по длине подмассив (<span class="tex-font-style-bf">последовательный подотрезок</span>),         состоящий <span class="tex-font-style-bf">только</span> из         нулей, среди всех таких отрезков выбирается <span class="tex-font-style-bf">самый левый</span>; </li>       <li> Пусть этот отрезок равен $$$[l; r]$$$. Если $$$r-l+1$$$         нечетно (не делится на $$$2$$$), то присваивается         $$$a[\frac{l+r}{2}] := i$$$ (где $$$i$$$ — номер текущего         действия), иначе (если $$$r-l+1$$$ четно) присваивается         $$$a[\frac{l+r-1}{2}] := i$$$. </li></ol>          <p>Рассмотрим массив $$$a$$$ длины $$$5$$$ (изачально $$$a=[0, 0, 0,       0, 0]$$$). Тогда он меняется следующим образом:</p>          <ol> <li> Сначала мы выбираем отрезок $$$[1; 5]$$$ и присваиваем         $$$a[3] := 1$$$, таким образом $$$a$$$ становится равен $$$[0,         0, 1, 0, 0]$$$; </li>       <li> затем мы выбираем отрезок $$$[1; 2]$$$ и присваиваем $$$a[1]         := 2$$$, таким образом $$$a$$$ становится равен $$$[2, 0, 1, 0,         0]$$$; </li>       <li> затем мы выбираем отрезок $$$[4; 5]$$$ и присваиваем $$$a[4]         := 3$$$, таким образом $$$a$$$ становится равен $$$[2, 0, 1, 3,         0]$$$; </li>       <li> затем мы выбираем отрезок $$$[2; 2]$$$ и присваиваем $$$a[2]         := 4$$$, таким образом $$$a$$$ становится равен $$$[2, 4, 1, 3,         0]$$$; </li>       <li> и наконец мы выбираем отрезок $$$[5; 5]$$$ и присваиваем         $$$a[5] := 5$$$, таким образом $$$a$$$ становится равен $$$[2,         4, 1, 3, 5]$$$. </li></ol>          <p>Ваша задача — найти массив $$$a$$$ длины $$$n$$$ после выполнения       всех $$$n$$$ действий. <span class="tex-font-style-bf">Заметьте,         что ответ существует и единственен</span>.</p>     <p>Вам необходимо ответить на $$$t$$$ независимых наборов тестовых данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка входных данных содержит одно целое число $$$t$$$       ($$$1 \le t \le 10^4$$$) — количество наборов тестовых данных.       Затем следуют $$$t$$$ наборов тестовых данных.</p>     <p>Единственная строка набора тестовых данных содержит одно целое       число $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — длину $$$a$$$.</p>     <p>Гарантируется, что сумма $$$n$$$ по всем наборам тестовых данных       не превосходит $$$2 \cdot 10^5$$$ ($$$\sum n \le 2 \cdot 10^5$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите ответ — массив       $$$a$$$ длины $$$n$$$ после выполнения $$$n$$$ действий, описанных       в условии задачи. <span class="tex-font-style-bf">Заметьте, что         ответ существует и единственен</span>.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
1
2
3
4
5
6
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1 
1 2 
2 1 3 
3 1 2 4 
2 4 1 3 5 
3 4 1 5 2 6 
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1353/problem/D' title='Codeforces Round 642 (Div. 3)'>1353D - Constructing the Array</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>This is just an implementation problem. We can use some kind of       heap or ordered set to store all segments we need in order we       need. To solve this problem on C++ with <span class="tex-font-style-tt">std::set</span>, we can just rewrite the       comparator for <span class="tex-font-style-tt">std::set</span>       like this:</p>          <pre class="lstlisting"><code class="prettyprint">struct cmp {<br />	bool operator() (const pair&lt;int, int&gt; &amp;a, const pair&lt;int, int&gt; &amp;b) const {<br />		int lena = a.second - a.first + 1;<br />		int lenb = b.second - b.first + 1;<br />		if (lena == lenb) return a.first &lt; b.first;<br />		return lena &gt; lenb;<br />	}<br />};<br /></code></pre>          <p>And then just write the <span class="tex-font-style-tt">std::set</span> like this:</p>          <pre class="lstlisting"><code class="prettyprint">set&lt;pair&lt;int, int&gt;, cmp&gt; segs;<br /></code></pre>          <p>Now the minimum element of the set will be the segment that we       need to choose. Initially, the set will contain only one segment       $$$[0;n-1]$$$. Suppose we choose the segment $$$[l; r]$$$ during       the $$$i$$$-th action. Let $$$id = \lfloor\frac{l+r}{2}\rfloor$$$,       where $$$\lfloor\frac{x}{y}\rfloor$$$ is $$$x$$$ divided by       $$$y$$$ rounded down. Assign (set) $$$a[id] := i$$$, then if the       segment $$$[l; id-1]$$$ has positive (greater than zero) length,       push this segment to the set and the same with the segment       $$$[id+1;r]$$$. After $$$n$$$ such actions we get the answer.</p>     <p>Time complexity: $$$O(n \log n)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

struct cmp {
	bool operator() (const pair&lt;int, int&gt; &amp;a, const pair&lt;int, int&gt; &amp;b) const {
		int lena = a.second - a.first + 1;
		int lenb = b.second - b.first + 1;
		if (lena == lenb) return a.first &lt; b.first;
		return lena &gt; lenb;
	}
};

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
	
	int t;
	cin &gt;&gt; t;
	while (t--) {
		int n;
		cin &gt;&gt; n;
		set&lt;pair&lt;int, int&gt;, cmp&gt; segs;
		segs.insert({0, n - 1});
		vector&lt;int&gt; a(n);
		for (int i = 1; i &lt;= n; ++i) {
			pair&lt;int, int&gt; cur = *segs.begin();
			segs.erase(segs.begin());
			int id = (cur.first + cur.second) / 2;
			a[id] = i;
			if (cur.first &lt; id) segs.insert({cur.first, id - 1});
			if (id &lt; cur.second) segs.insert({id + 1, cur.second});
		}
		for (auto it : a) cout &lt;&lt; it &lt;&lt; &#34; &#34;;
		cout &lt;&lt; endl;
	}
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #642 (Div. 3)
    1353E
    К-периодичная гирлянда </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. К-периодичная гирлянда</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам задана гирлянда, состоящая из $$$n$$$ ламп. Состояния ламп       описываются строкой $$$s$$$ длины $$$n$$$. $$$i$$$-й символ строки       $$$s_i$$$ равен '<span class="tex-font-style-tt">0</span>', если       $$$i$$$-я лампа выключена, или '<span class="tex-font-style-tt">1</span>', если $$$i$$$-я лампа       включена. Вам также задано положительное целое число $$$k$$$.</p>     <p>За один ход вы можете выбрать <span class="tex-font-style-bf">одну лампу</span> и изменить ее       состояние (то есть включить ее, если она выключена, и наоборот).</p>     <p>Гирлянда называется $$$k$$$-периодичной, если расстояние между         <span class="tex-font-style-bf">каждой парой соседних включенных       ламп</span> равно <span class="tex-font-style-bf">в       точности</span> $$$k$$$. Рассмотрим случай $$$k=3$$$. Тогда       гирлянды «<span class="tex-font-style-tt">00010010</span>», «<span class="tex-font-style-tt">1001001</span>», «<span class="tex-font-style-tt">00010</span>» и «<span class="tex-font-style-tt">0</span>» являются хорошими, а гирлянды         «<span class="tex-font-style-tt">00101001</span>», «<span class="tex-font-style-tt">1000001</span>» и «<span class="tex-font-style-tt">01001100</span>» не являются хорошими.       Заметьте, что <span class="tex-font-style-bf">гирлянда не является       цикличной</span>, то есть первая включенная лампа не идет после       последней включенной лампы и наоборот.</p>     <p>Ваша задача — найти <span class="tex-font-style-bf">минимальное</span> количество ходов,       необходимое для того, чтобы получить $$$k$$$-периодичную гирлянду       из заданной.</p>     <p>Вам необходимо ответить на $$$t$$$ независимых наборов тестовых данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка входных данных содержит одно целое число $$$t$$$       ($$$1 \le t \le 25~ 000$$$) — количество наборов тестовых данных.       Затем следуют $$$t$$$ наборов тестовых данных.</p>     <p>Первая строка набора тестовых данных содержит два целых числа       $$$n$$$ и $$$k$$$ ($$$1 \le n \le 10^6; 1 \le k \le n$$$) — длину       $$$s$$$ и необходимый период. Вторая строка набора тестовых данных       содержит строку $$$s$$$, состоящую из $$$n$$$ символов '<span class="tex-font-style-tt">0</span>' и '<span class="tex-font-style-tt">1</span>'.</p>     <p>Гарантируется, что сумма $$$n$$$ по всем наборам тестовых данных       не превосходит $$$10^6$$$ ($$$\sum n \le 10^6$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите ответ — <span class="tex-font-style-bf">минимальное</span> количество ходов,       необходимое для того, чтобы получить $$$k$$$-периодичную гирлянду       из заданной.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
9 2
010001010
9 3
111100000
7 4
1111111
10 3
1001110101
1 1
1
1 1
0
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
2
5
4
0
0
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1353/problem/E' title='Codeforces Round 642 (Div. 3)'>1353E - K-periodic Garland</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let $$$t_i$$$ be the string containing all characters of $$$s$$$       that have indices $$$i, i + k, i + 2k$$$ and so on (i.e. all such       positions that have the remainder $$$i$$$ modulo $$$k$$$). Suppose       we choose that all turned on lamps will have remainder $$$i$$$       modulo $$$k$$$. Then we need to remove all ones at the positions       that do not belong to this remainder. Also considering the string       $$$t_i$$$, we need to spend the <span class="tex-font-style-bf">minimum</span> number of moves to make       this string of kind &quot;contiguous block of zeros, contiguous       block of ones and again contiguous block of zeros&quot;, because       considering the characters modulo $$$k$$$ will lead us to exactly       this pattern (notice that some blocks can be empty).</p>     <p>How to calculate the answer for the string $$$t_i$$$ in linear       time? Let $$$dp_i[p]$$$ be the number of moves we need to fix the       prefix of $$$t_i$$$ till the $$$p$$$-th character in a way that       the $$$p$$$-th character of $$$t_i$$$ is '<span class="tex-font-style-tt">1</span>'. Let $$$cnt(S, l, r)$$$ be the       number of ones in $$$S$$$ on the segment $$$[l; r]$$$. Notice that       we can calculate all required values $$$cnt$$$ in linear time       using prefix sums. Then we can calculate $$$dp_i[p]$$$ as       $$$min(cnt(t_i, 0, p - 1) + [t_i[p] \ne~ '1'], dp_i[p-1] + [t_i[p]       \ne~ '1'])$$$, where $$$[x]$$$ is the boolean value of the       expression $$$x$$$ ($$$1$$$ if $$$x$$$ is true and $$$0$$$       otherwise). Let $$$len(S)$$$ be the length of $$$S$$$. Then the       actual answer for the string $$$t_i$$$ can be calculated as       $$$ans_i = \min(cnt(t_i, 0, len(t_i) - 1),       \min\limits_{p=0}^{len(t_i) - 1} (dp_i[p] + cnt(t_i, p + 1,       len(t_i) - 1)))$$$ (thus we consider the case when the obtained       string doesn't contan ones at all and consider each position as       the last position of some one).</p>     <p>So the actual answer can be calculated as       $$$\min\limits_{i=0}^{k-1} (ans_i + cnt(s, 0, len(s) - 1) -       cnt(t_i, 0, len(t_i) - 1))$$$.</p>     <p>Time complexity: $$$O(n)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
	
	auto solve = [](const string &amp;s) {
		int n = s.size();
		int all = count(s.begin(), s.end(), &#39;1&#39;);
		int ans = all;
		vector&lt;int&gt; res(n);
		int pref = 0;
		for (int i = 0; i &lt; n; ++i) {
			int cur = (s[i] == &#39;1&#39;);
			pref += cur;
			res[i] = 1 - cur;
			if (i &gt; 0) res[i] += min(res[i - 1], pref - cur);
			ans = min(ans, res[i] + all - pref);
		}
		return ans;
	};
	
	int t;
	cin &gt;&gt; t;
	while (t--) {
		int n, k;
		string s;
		cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;
		vector&lt;string&gt; val(k);
		int cnt = count(s.begin(), s.end(), &#39;1&#39;);
		for (int i = 0; i &lt; n; ++i) {
			val[i % k] += s[i];
		}
		int ans = 1e9;
		for (auto &amp;it : val) ans = min(ans, solve(it) + (cnt - count(it.begin(), it.end(), &#39;1&#39;)));
		cout &lt;&lt; ans &lt;&lt; endl;
	}
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #642 (Div. 3)
    1353F
    Уменьшение высот </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Уменьшение высот</div>     <div class="time-limit"><div class="property-title">ограничение по времени на       тест</div>2.5 секунд</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вы играете в одну популярную sandbox-игру с трехмерным миром.       Карта мира может быть представлена в виде матрицы размера $$$n       \times m$$$, где высота клетки $$$(i, j)$$$ равна $$$a_{i, j}$$$.</p>     <p>Сейчас вы находитесь в клетке $$$(1, 1)$$$ и хотите попасть в       клетку $$$(n, m)$$$. Вы можете перемещаться только вниз (из клетки       $$$(i, j)$$$ в клетку $$$(i + 1, j)$$$) или вправо (из клетки       $$$(i, j)$$$ в клетку $$$(i, j + 1)$$$). Также есть дополнительное         <span class="tex-font-style-bf">ограничение</span>: если высота       текущей клетки равна $$$x$$$, то вы можете переместиться только в       клетку с высотой $$$x+1$$$.</p>     <p>       <span class="tex-font-style-bf">Перед первым перемещением</span>       вы можете выполнить несколько операций. В течение одной операции       вы можете уменьшить высоту <span class="tex-font-style-bf">любой</span> клетки на единицу. То есть       вы выбираете какую-то клетку $$$(i, j)$$$ и присваиваете $$$a_{i,       j} := a_{i, j} - 1$$$. Заметьте, что вы <span class="tex-font-style-bf">можете</span> делать высоты <span class="tex-font-style-bf">меньшими или равными нулю</span>.       Также заметьте, что вы <span class="tex-font-style-bf">можете</span> уменьшать высоту клетки       $$$(1, 1)$$$.</p>     <p>Ваша задача — найти <span class="tex-font-style-bf">минимальное</span> количество операций,       которое необходимо выполнить, чтобы получить хотя бы один       подходящий путь из клетки $$$(1, 1)$$$ в клетку $$$(n, m)$$$.       Гарантируется, что ответ существует.</p>     <p>Вам необходимо ответить на $$$t$$$ независимых наборов тестовых данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка входных данных содержит одно целое число $$$t$$$       ($$$1 \le t \le 100$$$) — Количество наборов тестовых данных.       Затем следуют $$$t$$$ наборов тестовых данных.</p>     <p>Первая строка набора тестовых данных содержит два целых числа       $$$n$$$ и $$$m$$$ ($$$1 \le n, m \le 100$$$) — количество строк и       количество столбцов в карте мира. Следующие $$$n$$$ строк содержат       по $$$m$$$ целых чисел каждая, где $$$j$$$-е число в $$$i$$$-й       строке равно $$$a_{i, j}$$$ ($$$1 \le a_{i, j} \le 10^{15}$$$) —       высоте клетки $$$(i, j)$$$.</p>     <p>Гарантируется, что сумма $$$n$$$ (также как сумма $$$m$$$) по       всем наборам тестовых данных не превосходит $$$100$$$ ($$$\sum n       \le 100; \sum m \le 100$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите ответ — <span class="tex-font-style-bf">минимальное</span> количество операций,       которое необходимо выполнить, чтобы получить хотя бы один       подходящий путь из клетки $$$(1, 1)$$$ в клетку $$$(n, m)$$$.       Гарантируется, что ответ существует.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
3 4
1 2 3 4
5 6 7 8
9 10 11 12
5 5
2 5 4 8 3
9 10 11 5 1
12 8 4 2 5
2 2 5 4 1
6 8 2 4 2
2 2
100 10
10 1
1 2
123456789876543 987654321234567
1 1
42
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
9
49
111
864197531358023
0
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1353/problem/F' title='Codeforces Round 642 (Div. 3)'>1353F - Decreasing Heights</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Firstly, consider the field in $$$0$$$-indexation. Suppose that       the cell $$$(0, 0)$$$ has some fixed height. Let it be $$$b_{0,       0}$$$. Then we can determine what should be the height of the cell       $$$(i, j)$$$ as $$$b_{i, j} = b_{0, 0} + i + j$$$. In fact, it       does not matter which way we choose, we actually need only the       number of moves to reach the cell and the height of the cell       $$$(0, 0)$$$.</p>     <p>Then (when the height of the cell $$$(0, 0)$$$ is fixed) we can       solve the problem with the following dynamic programming:       $$$dp_{i, j}$$$ is the minimum number of operations we need to       reach the cell $$$(i, j)$$$ from the cell $$$(0, 0)$$$. Initially,       all values $$$dp_{i, j} = +\infty$$$ except $$$dp_{0, 0} = 0$$$.       Then $$$dp_{i, j}$$$ can be calculated as $$$min(dp_{i - 1, j},       dp_{i, j - 1}) + (a_{i, j} - b_{i, j})$$$. But one more thing: if       $$$a_{i, j} &lt; b_{i, j}$$$ then this value of $$$dp$$$ is       incorrect and we cannot use it. We also can't update $$$dp$$$ from       the incorrect values. The answer for the problem with the fixed       height of the cell $$$(0, 0)$$$ is $$$dp_{n - 1, m - 1} + a_{0, 0}       - b_{0, 0}$$$ (only when $$$dp_{n-1,m-1}$$$ is correct and       $$$a_{i, j} \ge b_{i, j}$$$). This part can be calculated in $$$O(n^2)$$$.</p>     <p>But if we iterate over all possible heights, our solution obvious       will get time limit exceeded verdict. Now we can notice one       important fact: in the optimal answer, the height of some cell       remains unchanged. Let this cell be $$$(i, j)$$$. Then we can       restore the height of the cell $$$(0, 0)$$$ as $$$a_{i, j} - i -       j$$$ and run our quadratic dynamic programming to find the answer       for this height.</p>     <p>Time complexity: $$$O(n^4)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

#define forn(i, n) for (int i = 0; i &lt; int(n); ++i)

const long long INF64 = 1e18;

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
	
	int t;
	cin &gt;&gt; t;
	while (t--) {
		int n, m;
		cin &gt;&gt; n &gt;&gt; m;
		vector&lt;vector&lt;long long&gt;&gt; a(n, vector&lt;long long&gt;(m));
		forn(i, n) forn(j, m) {
			cin &gt;&gt; a[i][j];
		}
		long long a00 = a[0][0];
		long long ans = INF64;
		forn(x, n) forn(y, m) {
			long long need = a[x][y] - x - y;
			if (need &gt; a00) continue;
			a[0][0] = need;
			vector&lt;vector&lt;long long&gt;&gt; dp(n, vector&lt;long long&gt;(m, INF64));
			dp[0][0] = a00 - need;
			forn(i, n) forn(j, m) {
				long long need = a[0][0] + i + j;
				if (need &gt; a[i][j]) continue;
				if (i &gt; 0) dp[i][j] = min(dp[i][j], dp[i - 1][j] + a[i][j] - need);
				if (j &gt; 0) dp[i][j] = min(dp[i][j], dp[i][j - 1] + a[i][j] - need);
			}
			ans = min(ans, dp[n - 1][m - 1]);
		}
		cout &lt;&lt; ans &lt;&lt; endl;
	}
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 87 (рейтинговый для Див. 2)
    1354A
    Будильник </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Будильник</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Поликарп провел целый день за подготовкой задач для вас. Теперь       ему нужно поспать хотя бы $$$a$$$ минут, чтобы отдохнуть.</p>     <p>       <span class="tex-font-style-bf">Поликарп может проснуться только         от звука будильника.</span> Он только заснул, а его первый       будильник прозвонит ровно через $$$b$$$ минут.</p>     <p>Каждый раз когда Поликарп просыпается, он решает, заводить ли       будильник еще раз или нет. Если он проспал меньше $$$a$$$ минут       суммарно, то он заводит будильник так, чтобы тот прозвонил ровно       через $$$c$$$ минут, и тратит $$$d$$$ минут, чтобы снова заснуть.       Иначе же он встает с кровати, начиная новый день.</p>     <p>Если будильник звонит, пока Поликарп все еще засыпает, то он       снова его заводит на $$$c$$$ минут и опять тратит $$$d$$$ минут,       чтобы заснуть.</p>     <p>Вам же всего лишь предстоит выяснить, когда Поликарп встанет с       кровати или сообщить, что это не случится никогда.</p>     <p>       <span class="tex-font-style-bf">Пожалуйста, прочитайте пояснение,         чтобы получше понять пример.</span></p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$t$$$ ($$$1 \le t \le       1000$$$) — количество наборов входных данных.</p>     <p>В единственной строке каждого набора входных данных записаны       четыре целых числа $$$a, b, c, d$$$ ($$$1 \le a, b, c, d \le       10^9$$$) — время, которое необходимо Поликарпу, чтобы выспаться,       время до первого звонка будильника, время до каждого последующего       звонка будильника и время, необходимое Поликарпу, чтобы заснуть.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>На каждый набор входных данных выведите одно целое число. Если       Поликарп никогда не встанет с кровати, то выведите <span class="tex-font-style-tt">-1</span>. Иначе выведите время, которое       Поликарп потратит до того, как встать с кровати.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
7
10 3 6 4
11 3 6 4
5 9 4 10
6 5 2 3
1 1 1 1
3947465 47342 338129 123123
234123843 13 361451236 361451000
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
27
27
9
-1
1
6471793
358578060125049
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных Поликарп просыпается через $$$3$$$       минуты. Он отдохнул только $$$3$$$ минуты из необходимых $$$10$$$.       Поэтому он снова заводит будильник, чтобы тот прозвенел через       $$$6$$$ минут, и тратит $$$4$$$ минуты, чтобы уснуть. То есть он       отдыхает в течение еще $$$2$$$ минут, что суммируется в       $$$3+2=5$$$ минут сна. Он повторяет эту процедуру еще три раза, и       получается $$$11$$$ минут сна. Наконец, он встает с кровати. Он       потратил $$$3$$$ минуты до первого будильника, в потом заново       завел будильник четыре раза. Ответ равен $$$3+4 \cdot 6 = 27$$$.</p>     <p>Второй набор входных данных похож на первый, но Поликарпу надо       $$$11$$$ минут, чтобы выспаться, вместо $$$10$$$. Однако, это       ничего не меняет, потому что Поликарп получает $$$11$$$ минут сна       при таких настройках будильника так и так.</p>     <p>В третьем наборе входных данных Поликарп просыпается достаточно       отдохнувшим уже после первого будильника. Поэтому ответ равен $$$b=9$$$.</p>     <p>В четвертом наборе входных данных Поликарп просыпается через       $$$5$$$ минут. К сожалению, дальше он не может отдохнуть ни       минуты, заводя будильник все снова и снова бесконечно :(</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1354/problem/A' title='Educational Codeforces Round 87 (Rated for Div. 2)'>1354A - Alarm Clock</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's handle some cases. Firstly, if $$$b \ge a$$$ then Polycarp       wakes up rested enough immediately, so $$$b$$$ is the answer. </p>     <p>Otherwise, what does Polycarp do? He sets alarm to go off in       $$$c$$$ minutes and falls asleep in $$$d$$$ minutes. Thus, he       spends $$$c-d$$$ minutes sleeping. Notice that if $$$c-d$$$ is       non-positive, then Polycarp always resets his alarm without       sleeping. So for that case the answer is <span class="tex-font-style-tt">-1</span>.</p>     <p>Finally, if Polycarp resets his alarm $$$x$$$ times then he ends       up with $$$b + x \cdot (c - d)$$$ minutes of sleep in total and       ends up spending $$$b + x \cdot c$$$ minutes of time. We know that       $$$b + x \cdot (c - d)$$$ should be greater or equal to $$$a$$$       and $$$x$$$ should be the smallest possible. </p>     <p>$$$$$$b + x \cdot (c - d) \ge a \leftrightarrow x \cdot (c - d)       \ge a - b \leftrightarrow x \ge \frac{a - b}{c - d}$$$$$$ </p>     <p>Thus, the smallest possible integer $$$x$$$ is equal to $$$\lceil       \frac{a - b}{c - d} \rceil$$$. And the answer is $$$b + x \cdot c$$$.</p>     <p>Overall complexity: $$$O(1)$$$ per testcase.</p></div></div></div>

           
            <pre><code>t = int(input())
for _ in range(t):
	a, b, c, d = map(int, input().split())
	if b &gt;= a:
		print(b)
		continue
	if c &lt;= d:
		print(-1)
		continue
	a -= b
	dif = c - d
	print(b + (a + dif - 1) // dif * c)
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 87 (рейтинговый для Див. 2)
    1354B
    Троичная строка </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Троичная строка</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам дана строка $$$s$$$, каждый символ которой — <span class="tex-font-style-tt">1</span>, <span class="tex-font-style-tt">2</span> или <span class="tex-font-style-tt">3</span>. Вы должны выбрать кратчайшую       непрерывную подстроку $$$s$$$, в которой каждый из трех символов       встречается хотя бы один раз.</p>     <p>Непрерывная подстрока $$$s$$$ — строка, которую можно получить из       $$$s$$$ удалением какого-то количества (возможно, ни одного)       символов из начала строки $$$s$$$ и какого-то количества       (возможно, ни одного) символов из конца строки $$$s$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке задано одно целое число $$$t$$$ ($$$1 \le t \le       20000$$$) — количество наборов входных данных.</p>     <p>Каждый набор входных данных состоит из одной строки $$$s$$$ ($$$1       \le |s| \le 200000$$$). Гарантируется, что каждый символ $$$s$$$ —         <span class="tex-font-style-tt">1</span>, <span class="tex-font-style-tt">2</span> или <span class="tex-font-style-tt">3</span>.</p>     <p>Сумма длин всех строк не превосходит $$$200000$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите одно число — длину       кратчайшей подстроки $$$s$$$, содержащей символы всех трех типов.       Если такой подстроки нет, выведите $$$0$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
7
123
12222133333332
112233
332211
12121212
333333
31121
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
3
4
4
0
0
4
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Рассмотрим пример из условия:</p>     <p>В первом наборе входных данных можно использовать подстроку <span class="tex-font-style-tt">123</span>.</p>     <p>Во втором наборе входных данных можно использовать подстроку         <span class="tex-font-style-tt">213</span>.</p>     <p>В третьем наборе входных данных можно использовать подстроку         <span class="tex-font-style-tt">1223</span>.</p>     <p>В четвертом наборе входных данных можно использовать подстроку         <span class="tex-font-style-tt">3221</span>.</p>     <p>В пятом наборе входных данных в $$$s$$$ нету символа <span class="tex-font-style-tt">3</span>.</p>     <p>В шестом наборе входных данных в $$$s$$$ нету символа <span class="tex-font-style-tt">1</span>.</p>     <p>В седьмом наборе входных данных можно использовать подстроку         <span class="tex-font-style-tt">3112</span>.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1354/problem/B' title='Educational Codeforces Round 87 (Rated for Div. 2)'>1354B - Ternary String</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>There are multiple solutions involving advanced methods such as       binary search or two pointers, but I'll try to describe a simpler one.</p>     <p>The main idea of my solution is that the answer should look like         <span class="tex-font-style-tt">abb...bbbbbc</span>: one       character of type $$$a$$$, a block of characters of type $$$b$$$,       and one character of type $$$c$$$. If we find all blocks of       consecutive equal characters in our string, each candidate for the       answer can be obtained by expanding a block to the left and to the       right by exactly one character. So the total length of all       candidates is $$$O(n)$$$, and we can check them all.</p>     <p>Why does the answer look like <span class="tex-font-style-tt">abb...bbbbbc</span>? If the first       character of the substring appears somewhere else in it, it can be       deleted. The same applies for the last character. So, the first       and the last characters should be different, and should not appear       anywhere else within the string. Since there are only three types       of characters, the answer always looks like <span class="tex-font-style-tt">abb...bbbbbc</span>.</p></div></div></div>

           
            <pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;

char buf[200043];

int main()
{
	int t;
	scanf(&#34;%d&#34;, &amp;t);
	for(int i = 0; i &lt; t; i++)
	{
		scanf(&#34;%s&#34;, buf);
		string s = buf;
		int ans = int(1e9);
		int n = s.size();
		vector&lt;pair&lt;char, int&gt; &gt; c;
		for(auto x : s)
		{
			if(c.empty() || c.back().first != x)
				c.push_back(make_pair(x, 1));
			else
				c.back().second++;
		}
		int m = c.size();
		for(int i = 1; i &lt; m - 1; i++)
			if(c[i - 1].first != c[i + 1].first)
				ans = min(ans, c[i].second + 2);
		if(ans &gt; n)
			ans = 0;
		printf(&#34;%d\n&#34;, ans);
	}
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 87 (рейтинговый для Див. 2)
    1354D
    Мультимножество </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Мультимножество</div>     <div class="time-limit"><div class="property-title">ограничение по времени на       тест</div>1.5 секунд</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>28 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>       <span class="tex-font-style-bf">Обратите внимание на нестандартное         ограничение памяти.</span></p>     <p>Вам задано мультимножество из $$$n$$$ целых чисел. Вы должны       обрабатывать запросы двух типов:</p>          <ul> <li> добавить элемент $$$k$$$ в мультимножество; </li>       <li> найти $$$k$$$-ю порядковую статистику в мультимножестве и         удалить ее. </li></ul>          <p>Напомним, что $$$k$$$-я порядковая статистика в мультимножестве —       это элемент, который будет на позиции $$$k$$$, если выписать все       его элементы в порядке неубывания. Например, если в       мультимножестве содержатся числа $$$1$$$, $$$4$$$, $$$2$$$,       $$$1$$$, $$$4$$$, $$$5$$$, $$$7$$$ и $$$k = 3$$$, то необходимо       найти $$$3$$$-й элемент в списке $$$[1, 1, 2, 4, 4, 5, 7]$$$, и он       равен $$$2$$$. Если в мультимножестве несколько копий удаляемого       элемента, удаляется только одна из них.</p>     <p>После всех запросов выведите <span class="tex-font-style-bf">любое</span> число, принадлежащее       мультимножеству, или сообщите, что оно пустое.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке заданы два числа $$$n$$$ и $$$q$$$ ($$$1 \le n, q       \le 10^6$$$) — количество элементов в мультимножестве и количество       запросов, соответственно.</p>     <p>Во второй строке заданы $$$n$$$ целых чисел $$$a_1$$$, $$$a_2$$$,       ..., $$$a_n$$$ ($$$1 \le a_1 \le a_2 \le \dots \le a_n \le n$$$) —       элементы мультимножества.</p>     <p>В третьей строке заданы $$$q$$$ целых чисел $$$k_1$$$, $$$k_2$$$,       ..., $$$k_q$$$, каждое из которых описывает очередной запрос       следующим образом: </p>     <ul> <li> если $$$1 \le k_i \le n$$$, то $$$i$$$-й запрос —         «добавить $$$k_i$$$ в мультимножество»; </li>       <li> если $$$k_i &lt; 0$$$, то $$$i$$$-й запрос — «удалить         $$$|k_i|$$$-ю порядковую статистику». Гарантируется, что в таком         случае $$$|k_i|$$$ не превосходит размера множества. </li></ul></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Если после всех запросов мультимножество оказалось пустым,       выведите $$$0$$$.</p>     <p>Иначе выведите любое число, принадлежащее мультимножеству.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5 5
1 2 3 4 5
-1 -1 -1 -1 -1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5 4
1 2 3 4 5
-5 -1 -3 -1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
6 2
1 1 1 2 3 4
5 6
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
6
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере последовательно удаляются все элементы мультимножества.</p>     <p>Во втором примере последовательно удалятся элементы $$$5$$$,       $$$1$$$, $$$4$$$, $$$2$$$.</p>     <p>В третьем примере $$$6$$$ — не единственный ответ.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1354/problem/D' title='Educational Codeforces Round 87 (Rated for Div. 2)'>1354D - Multiset</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>First solution: write some data structure that would simulate the       operations as they are given, for example, a segment tree or a       Fenwick tree. Probably will require optimization since the limits       are strict.</p>     <p>Second solution: notice that we have to find only one number       belonging to the multiset. For example, let's find the minimum       element. We can do it with binary search as follows: let's write a       function that, for a given element $$$x$$$, tells the number of       elements not greater than $$$x$$$ in the resulting multiset. To       implement it, use the fact that all elements $$$\le x$$$ are       indistinguishable, and all elements $$$&gt; x$$$ are       indistinguishable too, so the multiset can be maintained with just       two counters.</p>     <p>Okay, how does this function help? The minimum in the resulting       multiset is the minimum $$$x$$$ such that this function returns       non-zero for it, and since the function is monotonous, we can find       the answer with binary search.</p></div></div></div>

           
            <pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;

int n, q;
vector&lt;int&gt; a, k;

int count_le(int x)
{
	int cnt = 0;
	for(auto y : a)
		if(y &lt;= x)
			cnt++;
	for(auto y : k)
	{
		if(y &gt; 0 &amp;&amp; y &lt;= x)
			cnt++;
		if(y &lt; 0 &amp;&amp; abs(y) &lt;= cnt)
			cnt--;
	}
	return cnt;
}

int main()
{
	scanf(&#34;%d %d&#34;, &amp;n, &amp;q);
	a.resize(n);
	k.resize(q);
	for(int i = 0; i &lt; n; i++)
		scanf(&#34;%d&#34;, &amp;a[i]);
	for(int i = 0; i &lt; q; i++)
		scanf(&#34;%d&#34;, &amp;k[i]);
	if(count_le(int(1e9)) == 0)
	{
		puts(&#34;0&#34;);
		return 0;
	}
	int lf = 0;
	int rg = int(1e6) + 1;
	while(rg - lf &gt; 1)
	{
		int mid = (lf + rg) / 2;
		if(count_le(mid) &gt; 0)
			rg = mid;
		else
			lf = mid;
	}
	printf(&#34;%d\n&#34;, rg);
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 87 (рейтинговый для Див. 2)
    1354E
    Раскраска графа </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. Раскраска графа</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам задан неориентированный граф без петель и кратных ребер,       состоящий из $$$n$$$ вершин и $$$m$$$ ребер. Также вам задано три       числа $$$n_1$$$, $$$n_2$$$ и $$$n_3$$$.</p>     <p>Определите, можно ли расставить в вершины графа цифры <span class="tex-font-style-tt">1</span>, <span class="tex-font-style-tt">2</span> и <span class="tex-font-style-tt">3</span> так, чтобы выполнялись       следующие условия: </p>     <ol> <li> В каждой вершине должно стоять ровно одно из чисел <span class="tex-font-style-tt">1</span>, <span class="tex-font-style-tt">2</span>, <span class="tex-font-style-tt">3</span>; </li>       <li> Суммарно количество чисел <span class="tex-font-style-tt">1</span> во всех вершинах должно         равняться $$$n_1$$$; </li>       <li> Суммарно количество чисел <span class="tex-font-style-tt">2</span> во всех вершинах должно         равняться $$$n_2$$$; </li>       <li> Суммарно количество чисел <span class="tex-font-style-tt">3</span> во всех вершинах должно         равняться $$$n_3$$$; </li>       <li> Для каждого ребра $$$(u, v)$$$ должно быть верно $$$|col_u -         col_v| = 1$$$, где $$$col_x$$$ — цвет вершины с индексом         $$$x$$$. </li></ol>          <p>Если существует несколько раскрасок, удовлетворяющим все       описанным выше условиям, разрешено найти любую из них.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке следуют два целых числа $$$n$$$ и $$$m$$$ ($$$1       \le n \le 5000$$$; $$$0 \le m \le 10^5$$$) — количество вершин в       графе и количество ребер в графе.</p>     <p>Во второй строке следуют три целых числа $$$n_1$$$, $$$n_2$$$ и       $$$n_3$$$ ($$$0 \le n_1, n_2, n_3 \le n$$$) — необходимое       количество цифр <span class="tex-font-style-tt">1</span>, <span class="tex-font-style-tt">2</span> и <span class="tex-font-style-tt">3</span>, соответственно. Гарантируется,       что $$$n_1 + n_2 + n_3 = n$$$.</p>     <p>В следующих $$$m$$$ строках следует описание ребер: в $$$i$$$-й       строке следуют два целых числа $$$u_i$$$, $$$v_i$$$ ($$$1 \le u_i,       v_i \le n$$$; $$$u_i \neq v_i$$$) — номера вершин, которые       соединяет $$$i$$$-е ребро. Гарантируется, что граф не содержит       петель и кратных ребер.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Если существует раскраска, удовлетворяющая всем описанным       условиям, выведите в первую строку «<span class="tex-font-style-tt">YES</span>» (без кавычек). Во вторую       строку выведите строку длины $$$n$$$, состоящую только из цифр         <span class="tex-font-style-tt">1</span>, <span class="tex-font-style-tt">2</span> и <span class="tex-font-style-tt">3</span>, причем $$$i$$$-й символ этой       строки должен быть равен цифре, которую нужно поставить в       $$$i$$$-ю вершину.</p>     <p>Если подходящей раскраски не существует, выведите «<span class="tex-font-style-tt">NO</span>» (без кавычек).</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6 3
2 2 2
3 1
5 4
2 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
YES
112323
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5 9
0 2 3
1 2
1 3
1 5
2 3
2 4
2 5
3 4
3 5
4 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
NO
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1354/problem/E' title='Educational Codeforces Round 87 (Rated for Div. 2)'>1354E - Graph Coloring</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's rephrase the fifth condition. Each edge should connect two       vertices with the numbers of different parity (either $$$1$$$ to       $$$2$$$ or $$$3$$$ to $$$2$$$). So the graph should actually be       bipartite and the first partition should have only the odd numbers       ($$$1$$$ or $$$3$$$) and the second partition should have only the       even numbers (only $$$2$$$).</p>     <p>Notice how $$$1$$$ and $$$3$$$ are completely interchangeable in       the sense that if you have exactly $$$n_1 + n_3$$$ vertices which       should be assigned odd numbers then you can assign whichever       $$$n_1$$$ of them to $$$1$$$ and the rest to $$$3$$$ you want.</p>     <p>So you can guess that the first step is to check if the given       graph is bipartite. If it isn't then the answer doesn't exist. It       can be done with a single dfs. Actually the algorithm for that       extracts the exact partitions, which comes pretty handy.</p>     <p>If the graph was a single connected component then the problem       would be easy. Just check if either the first partition or the       second one has size $$$n_2$$$ and assigned its vertices color       $$$2$$$. If neither of them are of size $$$n_2$$$ then the answer       obviously doesn't exist.</p>     <p>However, the issue is that there might be multiple connected       components and for each of them you can choose the partition to       assign $$$2$$$ to independently. Still, each of the connected       components should be bipartite for the answer to exist.</p>     <p>This can be done with a knapsack-like dp. Let the $$$i$$$-th       connected component have partitions of sizes $$$(l_i, r_i)$$$.       Then the state can be $$$dp[i][j]$$$ is true if $$$i$$$ connected       components are processed and it's possible to assign $$$2$$$ to       exactly $$$j$$$ vertices of these components. As for transitions,       for the $$$i$$$-th component you can either take the partition       with $$$l_i$$$ vertices or with $$$r_i$$$ vertices. Thus, if       $$$dp[i][j]$$$ is true then both of $$$dp[i + 1][j + l_i]$$$ and       $$$dp[i + 1][j + r_i]$$$ are also true.</p>     <p>If $$$dp[number\_of\_connected\_components][n_2]$$$ is false then       there is no answer. Otherwise, you can always restore the answer       through the dp. The easiest way is probably to store not       true/false in $$$dp[i][j]$$$ but three values: $$$-1$$$ for false,       $$$0$$$ for the case the state is reached by taking the first       partition of the $$$(i-1)$$$-th component and $$$1$$$ for the       second partition. Also, you should store not only the sizes of the       partitions but the vertices in each of them as well. This way you       can recover the answer by backtracking from the final state.</p>     <p>Overall complexity: $$$O(n^2)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

#define x first
#define y second
#define mp make_pair
#define pb push_back
#define sqr(a) ((a) * (a))
#define sz(a) int(a.size())
#define all(a) a.begin(), a.end()
#define forn(i, n) for(int i = 0; i &lt; int(n); i++) 
#define fore(i, l, r) for(int i = int(l); i &lt; int(r); i++)

typedef long long li;
typedef long double ld;
typedef pair&lt;int, int&gt; pt;

template &lt;class A, class B&gt; ostream&amp; operator &lt;&lt; (ostream&amp; out, const pair&lt;A, B&gt; &amp;a) {
	return out &lt;&lt; &#34;(&#34; &lt;&lt; a.x &lt;&lt; &#34;, &#34; &lt;&lt; a.y &lt;&lt; &#34;)&#34;;
}

template &lt;class A&gt; ostream&amp; operator &lt;&lt; (ostream&amp; out, const vector&lt;A&gt; &amp;v) {
	out &lt;&lt; &#34;[&#34;;
	forn(i, sz(v)) {
		if(i) out &lt;&lt; &#34;, &#34;;
		out &lt;&lt; v[i];
	}
	return out &lt;&lt; &#34;]&#34;;
}

mt19937 rnd(time(NULL));

const int INF = int(1e9);
const li INF64 = li(1e18);
const int MOD = int(1e9) + 7;
const ld EPS = 1e-9;
const ld PI = acos(-1.0);

const int N = 5000 + 7;

int n, m;
int a[3];
vector&lt;int&gt; g[N];

bool read () {
	if (scanf(&#34;%d%d&#34;, &amp;n, &amp;m) != 2)
		return false;
	forn(i, 3) scanf(&#34;%d&#34;, &amp;a[i]);
	forn(i, n)
		g[i].clear();
	forn(i, m){
		int v, u;
		scanf(&#34;%d%d&#34;, &amp;v, &amp;u);
		--v, --u;
		g[v].pb(u);
		g[u].pb(v);
	}
	return true;
}

int tot0, tot1;
int clr[N];
vector&lt;vector&lt;int&gt;&gt; vts[2];
bool ok;

void dfs(int v){
	tot0 += clr[v] == 0;
	tot1 += clr[v] == 1;
	vts[clr[v]].back().pb(v);
	for (auto u : g[v]){
		if (clr[u] == -1){
			clr[u] = clr[v] ^ 1;
			dfs(u);
		}
		else if (clr[u] == clr[v]){
			ok = false;
		}
	}
}

int dp[N][N];
int res[N];

void solve() {
	vector&lt;pt&gt; siz;
	memset(clr, -1, sizeof(clr));
	vts[0].clear();
	vts[1].clear();
	forn(i, n) if (clr[i] == -1){
		tot0 = tot1 = 0;
		clr[i] = 0;
		ok = true;
		vts[0].pb(vector&lt;int&gt;());
		vts[1].pb(vector&lt;int&gt;());
		dfs(i);
		if (!ok){
			puts(&#34;NO&#34;);
			return;
		}
		siz.pb(mp(tot0, tot1));
	}
	
	memset(dp, -1, sizeof(dp));
	dp[0][0] = 0;
	forn(i, sz(siz)) forn(j, N) if (dp[i][j] != -1){
		dp[i + 1][j + siz[i].x] = 0;
		dp[i + 1][j + siz[i].y] = 1;
	}
	
	if (dp[sz(siz)][a[1]] == -1){
		puts(&#34;NO&#34;);
		return;
	}
	
	puts(&#34;YES&#34;);
	memset(res, -1, sizeof(res));
	int cur = a[1];
	for (int i = sz(siz); i &gt; 0; --i){
		for (auto it : vts[dp[i][cur]][i - 1])
			res[it] = 2;
		cur -= sz(vts[dp[i][cur]][i - 1]);
	}
	
	forn(i, n) if (res[i] == -1){
		if (a[0] &gt; 0){
			res[i] = 1;
			--a[0];
		}
		else{
			res[i] = 3;
			--a[2];
		}
	}
	
	forn(i, n) printf(&#34;%d&#34;, res[i]);
	puts(&#34;&#34;);
}

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
	
	int tt = clock();
	
#endif
	
	cerr.precision(15);
	cout.precision(15);
	cerr &lt;&lt; fixed;
	cout &lt;&lt; fixed;

	while(read()) {	
		solve();
		
#ifdef _DEBUG
	cerr &lt;&lt; &#34;TIME = &#34; &lt;&lt; clock() - tt &lt;&lt; endl;
	tt = clock();
#endif

	}
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 87 (рейтинговый для Див. 2)
    1354F
    Призыв существ </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Призыв существ</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>6 секунд</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Поликарп играет в компьютерную игру. В этой игре игроки призывают       армии магических существ и сражаются с армиями существ других игроков.</p>     <p>Поликарп может призвать $$$n$$$ разных существ, $$$i$$$-е       существо изначально имеет силу $$$a_i$$$; кроме того, когда       Поликарп призывает его, оно увеличивает на $$$b_i$$$ силу всех       ранее призванных существ (исключая себя). Поликарп может призывать       существ в любом порядке.</p>     <p>Однако под контролем Поликарпа может находиться не более $$$k$$$       существ одновременно. Поэтому, помимо призыва существ, он может       уничтожать ранее призванных существ. Каждое существо может быть       призвано (а, значит, и уничтожено) не более одного раза.</p>     <p>Цель Поликарпа — собрать максимально сильную армию существ. Он       хочет, чтобы после всех его действий суммарная сила всех       призванных (но не уничтоженных) им существ была максимально возможной.</p>     <p>Помогите Поликарпу составить оптимальную последовательность       действий, чтобы собрать максимально сильную армию!</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке задано одно целое число $$$T$$$ ($$$1 \le T \le       75$$$) — количество наборов тестовых данных.</p>     <p>Каждый набор тестовых данных начинается строкой, содержащей два       целых числа $$$n$$$ и $$$k$$$ ($$$1 \le k \le n \le 75$$$) —       количество существ, доступных для призыва, и максимальное       количество существ, которые могут одновременно быть под контролем       Поликарпа, соответственно.</p>     <p>Затем следуют $$$n$$$ строк, $$$i$$$-я из которых содержит       $$$2$$$ целых числа $$$a_i$$$ и $$$b_i$$$ ($$$1 \le a_i \le       10^5$$$, $$$0 \le b_i \le 10^5$$$) — параметры $$$i$$$-го существа.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите оптимальную       последовательность действий в следующем формате:</p>     <p>Сначала выведите $$$m$$$ — количество действий, которые должен       совершить Поликарп ($$$0 \le m \le 2n$$$). После этого выведите       $$$m$$$ целых чисел $$$o_1$$$, $$$o_2$$$, ..., $$$o_m$$$, где       $$$o_i$$$ описывает $$$i$$$-е действие следующим образом: если       $$$i$$$-е действие — это «призвать существо $$$x$$$», то $$$o_i =       x$$$, а если $$$i$$$-е действие — это «уничтожить существо       $$$x$$$», то $$$o_i = -x$$$. Каждое существо может быть призвано       не более одного раза и не может быть уничтожено, если оно еще не       призвано (или уже уничтожено). После каждого действия под       контролем Поликарпа должно быть не более $$$k$$$ существ.</p>     <p>Если оптимальных последовательностей действий несколько, выведите       любую из них.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
5 2
5 3
7 0
5 0
4 0
10 0
2 1
10 100
50 10
5 5
1 5
2 4
3 3
4 2
5 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
4
2 1 -1 5
1
2
5
5 4 3 2 1
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Рассмотрим пример из условия.</p>     <p>В первом наборе тестовых данных можно сначала вызвать существо       $$$2$$$ с силой $$$7$$$, затем призвать существо $$$1$$$, которое       увеличит силу предыдущего существа на $$$3$$$, после этого       уничтожить существо $$$1$$$ и поставить существо $$$5$$$. В итоге       у Поликарпа будут два существа с силой $$$10$$$.</p>     <p>Во втором наборе тестовых данных у Поликарпа не может быть более       одного существа под контролем, поэтому достаточно выбрать самое       сильное существо и призвать его.</p>     <p>В третьем наборе тестовых данных Поликарп может призвать всех       существ, никого не уничтожая.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1354/problem/F' title='Educational Codeforces Round 87 (Rated for Div. 2)'>1354F - Summoning Minions</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>First of all, let's try to find the best strategy to play       minions. All minions should be summoned (if someone is not       summoned, summoning and deleting it won't make the answer worse),       the resulting number of minions should be exactly $$$k$$$ (if it       is less, then we didn't need to delete the last deleted minion).       Furthermore, if some minion should be deleted, we can delete it       just after it is summoned. All these greedy ideas lead to the       following structure of the answer:</p>          <ul> <li> we choose $$$k - 1$$$ minions and summon them in some         order; </li>       <li> we choose $$$n - k$$$ minions which will be summoned and         instantly deleted; </li>       <li> we summon the remaining minion. </li></ul>          <p>Let's analyze how these minions affect the answer. The first       minion has power $$$a_i$$$ and does not give bonus to anyone, the       second one has power $$$a_i$$$ and gives bonus to one minion, and       so on — the $$$j$$$-th minion from the first group adds $$$a_i +       (j - 1)b_i$$$ to the answer. Minions from the second group buff       $$$k - 1$$$ minions each, so they add $$$b_i(k - 1)$$$ to the       answer; and the last minion adds $$$a_i + b_i(k - 1)$$$. Let's       unite the first group and the last minion; then we will have two       groups of minions — those which are destroyed (the second group)       and those which are not destroyed (the first group).</p>     <p>From there, we will have two possible ways to finish the solution:</p>          <ul> <li> there are $$$n$$$ minions and $$$n$$$ positions for them,         and for each pair (minion, position) we may calculate the value         this pair adds to the answer. After that, we should assign each         monster a position in such a way that each position is chosen         exactly once, and the sum of values is maximized. It can be done         with mincost flows or Hungarian algorithm; </li>       <li> the minions from the first group should be played in         non-descending order of their $$$b_i$$$. Let's sort all minions         by $$$b_i$$$ and write the following dynamic programming:         $$$dp_{x, y}$$$ is the maximum answer if we considered $$$x$$$         first minions, and $$$y$$$ of them were assigned to the first         group. Since the minions are sorted by $$$b_i$$$, whenever we         add a minion to the first group, it should add exactly $$$a_i +         yb_i$$$ to the answer (and increase $$$y$$$ by $$$1$$$); and if         a minion is added to the second group, the answer is increased         by $$$(k - 1)b_i$$$. </li></ul></div></div></div>

           
            <pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;

const int N = 243;

struct edge
{
    int y, c, f, cost;
    edge() {};
    edge(int y, int c, int f, int cost) : y(y), c(c), f(f), cost(cost) {};
};

int s, t, V;
vector&lt;int&gt; g[N];
vector&lt;edge&gt; e;

void add(int x, int y, int c, int cost)
{
    g[x].push_back(e.size());
    e.push_back(edge(y, c, 0, cost));
    g[y].push_back(e.size());
    e.push_back(edge(x, 0, 0, -cost));
}

int rem(int num)
{
    return e[num].c - e[num].f;
}   

int p[N];
int d[N];
int pe[N];
int inq[N];

bool enlarge()
{
    for(int i = 0; i &lt; V; i++)
    {
        d[i] = int(1e9);
        p[i] = -1;
        pe[i] = -1;
        inq[i] = 0;
    }
    d[s] = 0;
    queue&lt;int&gt; q;
    q.push(s);
    inq[s] = 1;
    while(!q.empty())
    {
        int k = q.front();
        q.pop();
        inq[k] = 0;
        for(auto z : g[k])
        {
            if(!rem(z)) continue;
            if(d[e[z].y] &gt; d[k] + e[z].cost)
            {
                p[e[z].y] = k;
                pe[e[z].y] = z;
                d[e[z].y] = d[k] + e[z].cost;
                if(!inq[e[z].y])
                {
                    q.push(e[z].y);
                    inq[e[z].y] = 1;
                }
            }
        }
    }
    if(p[t] == -1)
        return false;
    int cur = t;
    while(cur != s)
    {
        e[pe[cur]].f++;
        e[pe[cur] ^ 1].f--;
        cur = p[cur];
    }
    return true;
}

void process_test()
{
	int n, k;
	cin &gt;&gt; n &gt;&gt; k;
	vector&lt;int&gt; a(n), b(n);
	for(int i = 0; i &lt; n; i++)
	{
		cin &gt;&gt; a[i] &gt;&gt; b[i];
	}
	s = 2 * n;
	t = 2 * n + 1;
	V = 2 * n + 2;
	for(int i = 0; i &lt; n; i++)
	{
		add(s, i, 1, 0);
		add(i + n, t, 1, 0);
	}
	for(int i = 0; i &lt; n; i++)
		for(int j = 0; j &lt; n; j++)
		{
			if(j &lt; k - 1)
				add(i, j + n, 1, -(a[i] + b[i] * j));
			else if(j == n - 1)
				add(i, j + n, 1, -(a[i] + b[i] * (k - 1)));
			else
				add(i, j + n, 1, -(b[i] * (k - 1)));
		}
	for(int i = 0; i &lt; n; i++)
		enlarge();
	vector&lt;int&gt; order(n);
	for(int i = 0; i &lt; n; i++)
		for(auto x : g[i])
		{
			int to = e[x].y;
			if(to &gt;= n &amp;&amp; to &lt; 2 * n &amp;&amp; e[x].f == 1)
				order[to - n] = i;
		}
	cout &lt;&lt; k + (n - k) * 2 &lt;&lt; endl;
	for(int i = 0; i &lt; n; i++)
	{
		cout &lt;&lt; order[i] + 1 &lt;&lt; &#34; &#34;;
		if(i &gt;= k - 1 &amp;&amp; i &lt; n - 1)
			cout &lt;&lt; -(order[i] + 1) &lt;&lt; &#34; &#34;;
	}
	cout &lt;&lt; endl;
	e.clear();
	for(int i = 0; i &lt; V; i++)
		g[i].clear();
}

int main()
{                       
    int t;
	cin &gt;&gt; t;
	for(int i = 0; i &lt; t; i++)
		process_test();
}
</code></pre>
           
            <pre><code>#include &lt;algorithm&gt;
#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

template&lt;typename T&gt; ostream&amp; operator&lt;&lt;(ostream &amp;os, const vector&lt;T&gt; &amp;v) { os &lt;&lt; &#39;{&#39;; string sep; for (const auto &amp;x : v) os &lt;&lt; sep &lt;&lt; x, sep = &#34;, &#34;; return os &lt;&lt; &#39;}&#39;; }
template&lt;typename A, typename B&gt; ostream&amp; operator&lt;&lt;(ostream &amp;os, const pair&lt;A, B&gt; &amp;p) { return os &lt;&lt; &#39;(&#39; &lt;&lt; p.first &lt;&lt; &#34;, &#34; &lt;&lt; p.second &lt;&lt; &#39;)&#39;; }

void dbg_out() { cerr &lt;&lt; endl; }
template&lt;typename Head, typename... Tail&gt; void dbg_out(Head H, Tail... T) { cerr &lt;&lt; &#39; &#39; &lt;&lt; H; dbg_out(T...); }

#ifdef NEAL_DEBUG
#define dbg(...) cerr &lt;&lt; &#34;(&#34; &lt;&lt; #__VA_ARGS__ &lt;&lt; &#34;):&#34;, dbg_out(__VA_ARGS__)
#else
#define dbg(...)
#endif

template&lt;typename T&gt;
void output_vector(const vector&lt;T&gt; &amp;v, bool add_one = false, int start = -1, int end = -1) {
    if (start &lt; 0) start = 0;
    if (end &lt; 0) end = int(v.size());

    for (int i = start; i &lt; end; i++)
        cout &lt;&lt; v[i] + (add_one ? 1 : 0) &lt;&lt; (i &lt; end - 1 ? &#39; &#39; : &#39;\n&#39;);
}

const int64_t INF64 = int64_t(2e18) + 5;

vector&lt;int&gt; assignment;

template&lt;typename T&gt;
int64_t hungarian(vector&lt;vector&lt;T&gt;&gt; costs) {
    int n = int(costs.size());
    int m = costs.empty() ? 0 : int(costs[0].size());

    if (n &gt; m) {
        vector&lt;vector&lt;T&gt;&gt; new_costs(m, vector&lt;T&gt;(n));

        for (int i = 0; i &lt; n; i++)
            for (int j = 0; j &lt; m; j++)
                new_costs[j][i] = costs[i][j];

        swap(costs, new_costs);
        swap(n, m);
    }

    vector&lt;int64_t&gt; u(n + 1), v(m + 1);
    vector&lt;int&gt; p(m + 1), way(m + 1);

    for (int i = 1; i &lt;= n; i++) {
        vector&lt;int64_t&gt; min_v(m + 1, INF64);
        vector&lt;bool&gt; used(m + 1, false);
        p[0] = i;
        int j0 = 0;

        do {
            used[j0] = true;
            int i0 = p[j0], j1 = 0;
            int64_t delta = INF64;

            for (int j = 1; j &lt;= m; j++)
                if (!used[j]) {
                    int64_t cur = costs[i0 - 1][j - 1] - u[i0] - v[j];

                    if (cur &lt; min_v[j]) {
                        min_v[j] = cur;
                        way[j] = j0;
                    }

                    if (min_v[j] &lt; delta) {
                        delta = min_v[j];
                        j1 = j;
                    }
                }

            for (int j = 0; j &lt;= m; j++)
                if (used[j]) {
                    u[p[j]] += delta;
                    v[j] -= delta;
                } else {
                    min_v[j] -= delta;
                }

            j0 = j1;
        } while (p[j0] != 0);

        do {
            int j1 = way[j0];
            p[j0] = p[j1];
            j0 = j1;
        } while (j0 != 0);
    }

    // Note that p[j] is the row assignment of column j (both 1-based). If p[j] = 0, the column is unassigned.
    assignment = p;
    return -v[0];
}


void run_case() {
    int N, K;
    cin &gt;&gt; N &gt;&gt; K;
    vector&lt;int&gt; A(N), B(N);

    for (int i = 0; i &lt; N; i++)
        cin &gt;&gt; A[i] &gt;&gt; B[i];

    vector&lt;vector&lt;int&gt;&gt; costs(N, vector&lt;int&gt;(N, 0));

    for (int i = 0; i &lt; N; i++)
        for (int position = 0; position &lt; N; position++)
            if (position &lt; K)
                costs[i][position] = -(A[i] + position * B[i]);
            else
                costs[i][position] = -((K - 1) * B[i]);

    int64_t score = -hungarian(costs);
    dbg(score);
    vector&lt;int&gt; solution;

    for (int k = 1; k &lt; K; k++)
        solution.push_back(assignment[k]);

    for (int k = K + 1; k &lt;= N; k++) {
        solution.push_back(assignment[k]);
        solution.push_back(-assignment[k]);
    }

    solution.push_back(assignment[K]);
    assert(int(solution.size()) == 2 * N - K);
    cout &lt;&lt; solution.size() &lt;&lt; &#39;\n&#39;;
    output_vector(solution);
}

int main() {
    ios::sync_with_stdio(false);
#ifndef NEAL_DEBUG
    cin.tie(nullptr);
#endif

    int tests;
    cin &gt;&gt; tests;

    while (tests-- &gt; 0)
        run_case();
}
</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;
 
using namespace std;
 
#define x first
#define y second
#define mp make_pair
#define pb push_back
#define sqr(a) ((a) * (a))
#define sz(a) int(a.size())
#define all(a) a.begin(), a.end()
#define forn(i, n) for(int i = 0; i &lt; int(n); i++) 
#define fore(i, l, r) for(int i = int(l); i &lt; int(r); i++)
 
typedef long long li;
typedef long double ld;
typedef pair&lt;int, int&gt; pt;
 
template &lt;class A, class B&gt; ostream&amp; operator &lt;&lt; (ostream&amp; out, const pair&lt;A, B&gt; &amp;a) {
	return out &lt;&lt; &#34;(&#34; &lt;&lt; a.x &lt;&lt; &#34;, &#34; &lt;&lt; a.y &lt;&lt; &#34;)&#34;;
}
 
template &lt;class A&gt; ostream&amp; operator &lt;&lt; (ostream&amp; out, const vector&lt;A&gt; &amp;v) {
	out &lt;&lt; &#34;[&#34;;
	forn(i, sz(v)) {
		if(i) out &lt;&lt; &#34;, &#34;;
		out &lt;&lt; v[i];
	}
	return out &lt;&lt; &#34;]&#34;;
}
 
mt19937 rnd(time(NULL));
 
const int INF = int(1e9);
const li INF64 = li(1e18);
const int MOD = int(1e9) + 7;
const ld EPS = 1e-9;
const ld PI = acos(-1.0);
 
const int N = 100;
 
int n, k;
pair&lt;pt, int&gt; a[N];
 
bool read () {
	if (scanf(&#34;%d%d&#34;, &amp;n, &amp;k) != 2)
		return false;
	forn(i, n){
		scanf(&#34;%d%d&#34;, &amp;a[i].x.x, &amp;a[i].x.y);
		a[i].y = i;
	}
	return true;
}
 
int dp[N][N];
int p[N][N];
 
void solve() {
	sort(a, a + n, [](const pair&lt;pt, int&gt; &amp;a, const pair&lt;pt, int&gt; &amp;b){
		if (a.x.y != b.x.y)
			return a.x.y &lt; b.x.y;
		return a.x.x &lt; b.x.x;
	});
	
	forn(i, N) forn(j, N)
		dp[i][j] = -INF;
	dp[0][0] = 0;
	forn(i, n) forn(j, N) if (dp[i][j] &gt;= 0){
		if (dp[i + 1][j] &lt; dp[i][j] + a[i].x.y * (k - 1)){
			dp[i + 1][j] = dp[i][j] + a[i].x.y * (k - 1);
			p[i + 1][j] = j;
		}
		if (dp[i + 1][j + 1] &lt; dp[i][j] + a[i].x.y * j + a[i].x.x){
			dp[i + 1][j + 1] = dp[i][j] + a[i].x.y * j + a[i].x.x;
			p[i + 1][j + 1] = j;
		}
	}
	
	vector&lt;int&gt; ans1, ans2;
	int cur = k;
	for (int i = n; i &gt; 0; --i){
		if (p[i][cur] == cur)
			ans2.pb(a[i - 1].y + 1);
		else
			ans1.pb(a[i - 1].y + 1);
		cur = p[i][cur];
	}
	
	reverse(all(ans1));
	reverse(all(ans2));
	printf(&#34;%d\n&#34;, sz(ans1) + sz(ans2) * 2);
	forn(i, sz(ans1) - 1)
		printf(&#34;%d &#34;, ans1[i]);
	for (auto it : ans2)
		printf(&#34;%d %d &#34;, it, -it);
	printf(&#34;%d\n&#34;, ans1.back());
}
 
int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
	
	int tt = clock();
	
#endif
	
	cerr.precision(15);
	cout.precision(15);
	cerr &lt;&lt; fixed;
	cout &lt;&lt; fixed;
 
	int tc;
	scanf(&#34;%d&#34;, &amp;tc);
	while(tc--) {	
		read();
		solve();
		
#ifdef _DEBUG
	cerr &lt;&lt; &#34;TIME = &#34; &lt;&lt; clock() - tt &lt;&lt; endl;
	tt = clock();
#endif
 
	}
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 87 (рейтинговый для Див. 2)
    1354G
    Найди подарок </h1>

    <div class="problemindexholder" problemindex="G">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">G. Найди подарок</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>       <span class="tex-font-style-it">Это интерактивная задача. Не         забывайте при выводе запросов сбрасывать буфер с помощью <span class="tex-font-style-tt">cout.flush()</span> или <span class="tex-font-style-tt">fflush(stdout)</span> в <span class="tex-font-style-tt">C++</span> и аналогичных функций в         других языках программирования.</span></p>     <p>На столе стоят $$$n$$$ коробок с подарками, пронумерованные от       $$$1$$$ по $$$n$$$ слева направо. Известно, что ровно в $$$k$$$ из       них лежат ценные подарки — в остальных просто камешки на удачу.       Выглядят все коробки одинаково и отличить их можно только по весу.       Все <span class="tex-font-style-it">коробки с камнями весят         одинаково и строго больше</span>, чем коробки с ценными       подарками. Массы коробок с подарками же могут как совпадать, так и       различаться между собой.</p>     <p>Вы можете сделать не более $$$50$$$ запросов (без учета вывода       ответа). Каждым запросом вы можете сравнить массы двух       непересекающихся подмножеств коробок $$$a_1, a_2, \dots,       a_{k_a}$$$ и $$$b_1, b_2, \dots, b_{k_b}$$$ на чашечных весах. В       ответ вы получите один из четырех вариантов:</p>          <ul> <li> <span class="tex-font-style-tt">FIRST</span>, если         подмножество $$$a_1, a_2, \dots, a_{k_a}$$$ <span class="tex-font-style-bf">тяжелее</span>; </li>       <li> <span class="tex-font-style-tt">SECOND</span>, если         подмножество $$$b_1, b_2, \dots, b_{k_b}$$$ <span class="tex-font-style-bf">тяжелее</span>; </li>       <li> <span class="tex-font-style-tt">EQUAL</span>, если массы         подмножеств совпадают; </li>       <li> <span class="tex-font-style-tt">WASTED</span>, если запрос         некорректен или превышено количество запросов. </li></ul>          <p>Используя данные запросы (или просто интуицию), определите       коробку с ценным подарком с <span class="tex-font-style-bf">минимальным номером</span>.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Входные данные состоят из нескольких наборов. В начале вам       выдается целое число $$$T$$$ ($$$1 \le T \le 500$$$) — количество       наборов входных данных.</p>     <p>В начале каждого набора вам выдаются два целых числа $$$n$$$ и       $$$k$$$ ($$$2 \le n \le 1000$$$, $$$1 \le k \le \frac{n}{2}$$$) —       количество коробок в ряду и количество с ценными подарками среди них.</p>     <p>Гарантируется, что порядок коробок в каждом наборе фиксирован и       сумма $$$n$$$ по всем наборам не превосходит $$$1000$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите минимальный номер       коробки, содержащей ценный подарок, в следующем формате: «<span class="tex-font-style-tt">! $$$x$$$</span>», где $$$x$$$ ($$$1       \le x \le n$$$) — искомый номер.</p></div>         <div>     <div class="section-title">Протокол взаимодействия</div>          <p>Выводите каждый запрос в три строки. В первой строке выводите       размеры подмножеств в следующем формате: «<span class="tex-font-style-tt">? $$$k_a$$$ $$$k_b$$$</span>», где       $$$k_a$$$ и $$$k_b$$$ ($$$1 \le k_a, k_b \le n$$$; $$$k_a + k_b       \le n$$$) — их соответствующие размеры.</p>     <p>Во второй строке выведите $$$k_a$$$ целых чисел $$$a_1, a_2,       \dots, a_{k_a}$$$ ($$$1 \le a_i \le n$$$; $$$a_i \neq a_j$$$ при       $$$i \neq j$$$) — номера коробок в первом подмножестве.</p>     <p>В третьей строке выведите $$$k_b$$$ целых чисел $$$b_1, b_2,       \dots, b_{k_b}$$$ ($$$1 \le b_i \le n$$$; $$$b_i \neq b_j$$$ при       $$$i \neq j$$$) — номера коробок во втором подмножестве.</p>     <p>Подмножества не должны пересекаться, то есть $$$a_i \neq b_j$$$       для всех $$$i$$$ и $$$j$$$.</p>     <p>В ответ будет получен один из четырех вариантов, описанных выше.       В случае получения <span class="tex-font-style-tt">WASTED</span>       завершите работу программы во избежание получения вердиктов       тестирования, отличных от <span class="tex-font-style-tt">Wrong Answer</span>.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
2 1
-
-
-
FIRST
-
5 2
-
-
-
FIRST
-
-
-
SECOND
-
-
-
EQUAL
-</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
-
-
? 1 1
1
2
-
! 2
-
? 1 1
1
2
-
? 2 3
4 2
1 3 5
-
? 1 1
4
5
-
! 1</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Дополнительные разделители «–» в примере использованы только для       наглядности самого примера. <span class="tex-font-style-bf">При         отправке запросов и получении ответов не должно быть никаких         лишних символов или переводов строк.</span></p>     <p>       <span class="tex-font-style-it">Взломы в данной задаче запрещены.</span></p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1354/problem/G' title='Educational Codeforces Round 87 (Rated for Div. 2)'>1354G - Find a Gift</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>The solution consists of several steps.</p>     <p>       <span class="tex-font-style-it">The first step.</span> Let's find       out &quot;does the first box contain stone or valuable gift&quot;       using random. Let's make $$$30$$$ queries to compare the weight of       the first box with the weight of another random box. If the first       box is lighter than we found an answer, otherwise the probability       of the first box having stones is at least $$$1 - 2^{-30}$$$.</p>     <p>       <span class="tex-font-style-it">The second step.</span> Let's       compare the weights of the first box and the second one. If they       are equal then let's compare the weights of boxes $$$[1, 2]$$$ and       $$$[3,4]$$$. If they are equal then let's compare the boxes $$$[1       \dots 4]$$$ and $$$[5 \dots 8]$$$ and so on. In other words, let's       find the minimum $$$k \ge 0$$$ such that $$$[1, 2^k]$$$ contains       only boxes with stones but $$$[2^k + 1, 2^{k + 1}]$$$ contain at       least one box with a valuable gift. It's easy to see that we'd       spend no more than $$$10$$$ queries.</p>     <p>       <span class="tex-font-style-it">The third step.</span> We have       segment $$$[1, 2^k]$$$ with only stones and $$$[2^k + 1, 2^{k +       1}]$$$ with at least one gift. Let's just binary search the       leftmost gift in the segment $$$[2^k + 1, 2^{k + 1}]$$$ using       boxes from $$$[1, 2^k]$$$ as reference: if we need to know       &quot;does segment of boxes $$$[l, mid)$$$ have at least one       gift&quot;, let's just compare it with segment $$$[0, mid - l)$$$       which have only stones. if $$$[l, mid)$$$ is lighter then it has,       otherwise doesn't have. This part also requires no more than       $$$10$$$ queries.</p></div></div></div>

           
            <pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;

#define fore(i, l, r) for(int i = int(l); i &lt; int(r); i++)
#define sz(a) int((a).size())

#define x first
#define y second

typedef long long li;
typedef pair&lt;int, int&gt; pt;

const int MAG = 30;
int lst;

int n, k;

inline bool read() {
	if(!(cin &gt;&gt; n &gt;&gt; k))
		return false;
	return true;
}

int ask(int l1, int r1, int l2, int r2) {
	assert(l1 &lt; r1 &amp;&amp; l2 &lt; r2);
	assert(r1 &lt;= l2 || r2 &lt;= l1);
	
	cout &lt;&lt; &#34;? &#34; &lt;&lt; r1 - l1 &lt;&lt; &#34; &#34; &lt;&lt; r2 - l2 &lt;&lt; endl;
	fore(i, l1, r1) {
		if (i &gt; l1) cout &lt;&lt; &#34; &#34;;
		cout &lt;&lt; i + 1;
	}
	cout &lt;&lt; endl;
	fore(i, l2, r2) {
		if (i &gt; l2) cout &lt;&lt; &#34; &#34;;
		cout &lt;&lt; i + 1;
	}
	cout &lt;&lt; endl;
	cout.flush();
	
	string resp;
	cin &gt;&gt; resp;
	
	if (resp == &#34;FIRST&#34;)
		return -1;
	if (resp == &#34;SECOND&#34;)
		return 1;
	if (resp == &#34;EQUAL&#34;)
		return 0;
	
	exit(0);
}

inline void solve() {
	//check first position
	mt19937 rnd(lst ^ (n * 1024 + k));
	for(int q = 0; q &lt; MAG; q++) {
		int cur = 1 + rnd() % (n - 1);
		
		int resp = ask(0, 1, cur, cur + 1);
		if (resp == 1) {
			cout &lt;&lt; &#34;! 1&#34; &lt;&lt; endl;
			cout.flush();
			return;
		}
	}
	
	int len = 1;
	while(true) {
		int cnt = min(len, n - len);
		int resp = ask(0, cnt, len, len + cnt);
		if (resp != 0) {
			assert(resp == -1);
			break;
		}
		len &lt;&lt;= 1;
	}
	
	int lf = len, rg = min(2 * len, n);
	while(rg - lf &gt; 1) {
		int mid = (lf + rg) &gt;&gt; 1;
		int resp = ask(0, mid - lf, lf, mid);
		assert(resp != 1);
		
		if (resp == 0)
			lf = mid;
		else
			rg = mid;
	}
	cout &lt;&lt; &#34;! &#34; &lt;&lt; lf + 1 &lt;&lt; endl;
	cout.flush();
	
	lst = lf + 1;
}

int main() {
	int tc;
	cin &gt;&gt; tc;
	
	lst = tc;
	while(tc--) {
		assert(read());
		solve();
	}
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #643 (Div. 2)
    1355A
    Последовательность с цифрами </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Последовательность с цифрами</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Определим рекуррентную последовательность следующим образом:       $$$$$$a_{n+1} = a_{n} + minDigit(a_{n}) \cdot maxDigit(a_{n}).$$$$$$</p>     <p>Здесь $$$minDigit(x)$$$ и $$$maxDigit(x)$$$ — минимальная и       максимальная цифры в десятичной записи числа $$$x$$$ без ведущих       нулей соответственно. Для примеров обратитесь к примечаниям.</p>     <p>Ваша задача — по заданным $$$a_{1}$$$ и $$$K$$$ вычислить $$$a_{K}$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано единственное число $$$t$$$ ($$$1 \le t       \le 1000$$$) — количество независимых наборов входных данных.</p>     <p>Каждый набор входных данных состоит из двух целых чисел       $$$a_{1}$$$ и $$$K$$$ ($$$1 \le a_{1} \le 10^{18}$$$, $$$1 \le K       \le 10^{16}$$$), записанных через пробел на отдельной строке.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите одно число $$$a_{K}$$$       на отдельной строке.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
8
1 4
487 1
487 2
487 3
487 4
487 5
487 6
487 7
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
42
487
519
528
544
564
588
628
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>$$$a_{1} = 487$$$ </p>     <p> $$$a_{2} = a_{1} + minDigit(a_{1}) \cdot maxDigit(a_{1}) = 487 +       \min (4, 8, 7) \cdot \max (4, 8, 7) = 487 + 4 \cdot 8 = 519$$$ </p>     <p> $$$a_{3} = a_{2} + minDigit(a_{2}) \cdot maxDigit(a_{2}) = 519 +       \min (5, 1, 9) \cdot \max (5, 1, 9) = 519 + 1 \cdot 9 = 528$$$ </p>     <p> $$$a_{4} = a_{3} + minDigit(a_{3}) \cdot maxDigit(a_{3}) = 528 +       \min (5, 2, 8) \cdot \max (5, 2, 8) = 528 + 2 \cdot 8 = 544$$$ </p>     <p> $$$a_{5} = a_{4} + minDigit(a_{4}) \cdot maxDigit(a_{4}) = 544 +       \min (5, 4, 4) \cdot \max (5, 4, 4) = 544 + 4 \cdot 5 = 564$$$ </p>     <p> $$$a_{6} = a_{5} + minDigit(a_{5}) \cdot maxDigit(a_{5}) = 564 +       \min (5, 6, 4) \cdot \max (5, 6, 4) = 564 + 4 \cdot 6 = 588$$$ </p>     <p> $$$a_{7} = a_{6} + minDigit(a_{6}) \cdot maxDigit(a_{6}) = 588 +       \min (5, 8, 8) \cdot \max (5, 8, 8) = 588 + 5 \cdot 8 = 628$$$</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1355/problem/A' title='Codeforces Round 643 (Div. 2)'>1355A - Sequence with Digits</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's calculate the sequence for fixed $$$a_{1} = 1$$$: $$$1, 2,       6, 42, 50, 50, 50, \ldots$$$</p>     <p>We got lucky and the minimal digit has become 0, after that the       element has stopped changing because we always add 0.</p>     <p>Actually it is not luck and that will always happen. Note that we       add no more than $$$9 \cdot 9 = 81$$$ every time, so the       difference between two consecutive elements of the sequence is       bounded by 81. Assume that we will never have minimal digit equal       to 0. Then the sequence will go to infinity. Let's take $$$X =       1000(\lfloor \frac{a_{1}}{1000} \rfloor + 1)$$$. All the numbers       on segment $$$[X;X+99]$$$ have 0 in hundreds digit, so none of       them can be element of our sequence. But our sequence should have       numbers greater than $$$X$$$. Let's take the smallest of them, it       should be at least $$$X + 100$$$. But then the previous number in       the sequence is at least $$$(X + 100) - 81 = X + 19$$$. It is       greater than $$$X$$$ but smaller than the minimal of such numbers. Contradiction.</p>     <p>In the previous paragraph we have actually shown that we have no       numbers greater than $$$X + 100$$$ in our sequence and we will see       the number with 0 among first 1001 elements.</p>     <p>That means that we can build the sequence till we find the first       number with 0 and then it will repeat forever.</p>     <p>In reality the maximal index of the first elements with 0 is 54       and minimal $$$a_{1}$$$ for that to happen is 28217.</p></div></div></div>

           
            <pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;unordered_set&gt;
#include &lt;unordered_map&gt;
#include &lt;queue&gt;
#include &lt;ctime&gt;
#include &lt;cassert&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;chrono&gt;
#include &lt;random&gt;
#include &lt;bitset&gt;
using namespace std;

#ifdef LOCAL
	#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);
#else
	#define eprintf(...) 42
#endif

using ll = long long;
using ld = long double;
using uint = unsigned int;
using ull = unsigned long long;
template&lt;typename T&gt;
using pair2 = pair&lt;T, T&gt;;
using pii = pair&lt;int, int&gt;;
using pli = pair&lt;ll, int&gt;;
using pll = pair&lt;ll, ll&gt;;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
 
#define pb push_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second

double startTime;
double getCurrentTime() {
	return ((double)clock() - startTime) / CLOCKS_PER_SEC;
}

ll getAdd(ll x) {
	ll m1 = 10, m2 = 0;
	while(x &gt; 0) {
		ll y = x % 10;
		x /= 10;
		m1 = min(m1, y);
		m2 = max(m2, y);
	}
	return m1 * m2;
}

int main()
{
	startTime = (double)clock();
//	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);

	int t;
	scanf(&#34;%d&#34;, &amp;t);
	while(t--) {
		ll x, k;
		scanf(&#34;%lld%lld&#34;, &amp;x, &amp;k);
		k--;
		while(k--) {
			ll y = getAdd(x);
			if (y == 0) break;
			x += y;
		}
		printf(&#34;%lld\n&#34;, x);
	}

	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #643 (Div. 2)
    1355B
    Юные следопыты </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Юные следопыты</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Отряд юных следопытов отправился в учебную экспедицию навстречу       своим первым приключениям. И возглавляет их старший следопыт       Рассел. Вот герои зашли в лес, разбили лагерь и дальше решили       разделиться на группы, чтобы исследовать как можно больше       интересных мест. Рассел должен был выбрать состав групп, но       столкнулся с одной проблемой...</p>     <p>Многие юные следопыты неопытны, и отправлять их маленькими       группами — не всегда хорошая идея. Даже сам Рассел недавно стал       старшим следопытом и нечасто бывал в экспедициях. Каждый следопыт       характеризуется своей неопытностью — целым положительным числом       $$$e_i$$$. Рассел решил, что юный следопыт с неопытностью $$$e$$$       может идти лишь в группе, количество следопытов в которой не       меньше $$$e$$$.</p>     <p>Теперь задача Рассела — определить, какое наибольшее число групп       следопытов он сможет организовать. При этом может получиться, что       некоторые следопыты не войдут в состав ни одной группы, это не       страшно, ведь и в лагере для них найдется работа. Рассел очень       переживает за успех экспедиции, и потому попросил вас помочь ему.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано число $$$T$$$ ($$$1 \leq T \leq 2 \cdot       10^5$$$) — количество независимых тестовых случаев. В следующих       $$$2T$$$ строках следует описание тестовых случаев.</p>     <p>В первой строке описания каждого теста задано целое число юных       следопытов $$$N$$$ ($$$1 \leq N \leq 2 \cdot 10^5$$$).</p>     <p>В следующей строке записаны $$$N$$$ целых чисел $$$e_1, e_2,       \ldots, e_N$$$ ($$$1 \leq e_i \leq N$$$), где $$$e_i$$$ —       неопытность $$$i$$$-го следопыта.</p>     <p>Гарантируется, что сумма $$$N$$$ по всем тестовым случаям не       превосходит $$$3 \cdot 10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$T$$$ чисел, каждое на отдельной строке.</p>     <p>В $$$i$$$-й строке выведите наибольшее число групп, которое можно       организовать в $$$i$$$-м тестовом случае.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
3
1 1 1
5
2 3 1 2 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
2
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере можно сформировать три группы, в каждой из       которых будет один следопыт. Это возможно, так как неопытность       всех трех следопытов равна $$$1$$$, что не меньше, чем размер их групп.</p>     <p>Во втором примере можно сформировать две группы. В первой группе       окажутся следопыты с неопытностью $$$1$$$, $$$2$$$ и $$$3$$$, а во       второй группе — два следопыта с неопытностью $$$2$$$.</p>     <p>Этот способ — не единственный возможный. Можно, например,       сформировать одну группу из трех следопытов с неопытностью       $$$2$$$, а также еще одну группу, в которой будет всего один       следопыт с неопытностью $$$1$$$. При таком разбиении на группы       следопыт с неопытностью $$$3$$$ не войдет в состав ни одной группы.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1355/problem/B' title='Codeforces Round 643 (Div. 2)'>1355B - Young Explorers</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's sort all the explorers by non-decreasing inexperience.       Suppose we have formed some group, how can we check is this group       is valid? Inexperience of all the explorers in the group should be       not greater than the group size. But we have sorted all the       explorers, so the last explorer from the group has the largest       inexperience. Therefore, to check the group for validity it is       necessary and sufficient to check that inexperience of the last       explorer is not greater than the group size.</p>     <p>We can notice that we don't even look at all the explorers except       the last one, the only important thing is their number. In fact,       we can organize the creation of groups in this way: first choose       the explorers that will be the last in their groups, then assign       sufficient number of other explorers to corresponding groups. It       is not profitable to assign more explorers than needed for this       particular last explorer, because we can always leave them at the camp.</p>     <p>So how should we choose the last explorers? We want to make more       groups, so the groups themselves should me smaller... It is       tempting to use the following greedy algorithm: let's greedily       pick the leftmost (which means with the smallest necessary group       size) explorer such that they have enough explorers to the left of       them to create a valid group. The idea is that we spend the       smallest number of explorers and leave the most potential last       explorers in the future. Let's strictly prove this greedy:</p>     <p>The solution is defined by positions of the last explorers in       their corresponding groups $$$1 \le p_{1} &lt; p_{2} &lt; \ldots       &lt; p_{k} \le n$$$. Notice that the solution is valid if and only       if $$$e_{p_{1}} + e_{p_{2}} + \ldots + e_{p_{i}} \le p_{i}$$$ for       all $$$1 \le i \le k$$$ (we always have enough explorers to form       first $$$i$$$ groups).</p>     <p>Let $$$1 \le p_{1} &lt; p_{2} &lt; \ldots &lt; p_{k} \le n$$$ be       the greedy solution and $$$1 \le q_{1} &lt; q_{2} &lt; \ldots &lt;       q_{m} \le n$$$ be the optimal solution such that it has the       largest common prefix with greedy one among all optimal solutions.       Let $$$t$$$ be the position of first difference in these       solutions. $$$t \le k$$$ since otherwise the greedy algorithm       couldn't add one more group but it was possible. $$$p_{t} &lt;       q_{t}$$$ since otherwise the greedy algorithm would take       $$$q_{t}$$$ instead of $$$p_{t}$$$. Since the explorers are sorted       we have $$$e_{p_{t}} \le e_{q_{t}}$$$. But then $$$1 \le q_{1}       &lt; q_{2} &lt; \ldots &lt; q_{t - 1} &lt; p_{t} &lt; q_{t + 1}       &lt; \ldots &lt; q_{m} \le n$$$ is a valid optimal solution and it       has strictly larger common prefix with the greedy one which       contradicts the choosing of our optimal solution.</p>     <p>To implement this solution it is enough to sort the explorers by       the non-decreasing inexperience, then go from left to right and       maintain the number of unused explorers. As soon as we encounter       the possibility to create a new group, we do it.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
    int t;
    cin &gt;&gt; t;
    
    while (t--) {
        int n;
        cin &gt;&gt; n;
        vector &lt;int&gt; a(n);
        for (int i = 0; i &lt; n; i++) {
            cin &gt;&gt; a[i];
        }
        sort(a.begin(), a.end());
        int ans = 0, cur = 0;
        for (int i = 0; i &lt; n; i++) {
            if (++cur == a[i]) {
                ans++;
                cur = 0;
            }
        }
        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
    }
    return 0;
}</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #643 (Div. 2)
    1355C
    Сосчитайте треугольники </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Сосчитайте треугольники</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Как и у любого неизвестного математика, у Юрия есть любимые       числа: $$$A$$$, $$$B$$$, $$$C$$$ и $$$D$$$, причем $$$A \leq B       \leq C \leq D$$$. Также Юрий очень любит треугольники, поэтому в       один день он задумался: сколько существует невырожденных       треугольников с целочисленными длинами сторон $$$x$$$, $$$y$$$ и       $$$z$$$ таких, что $$$A \leq x \leq B \leq y \leq C \leq z \leq D$$$?</p>     <p>Сейчас Юрий очень занят подготовкой задач для очередной       олимпиады, поэтому он просит вас помочь посчитать количество       интересующих его треугольников. </p>     <p>Треугольник называется невырожденным тогда и только тогда, когда       его вершины не лежат на одной прямой.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В единственной строке через пробел записаны четыре целых числа       $$$A$$$, $$$B$$$, $$$C$$$ и $$$D$$$ ($$$1 \leq A \leq B \leq C       \leq D \leq 5 \cdot 10^5$$$) — любимые числа Юрия.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одно число — количество невырожденных треугольников с       целочисленными длинами сторон $$$x$$$, $$$y$$$ и $$$z$$$, для       которых выполнено неравенство: $$$A \leq x \leq B \leq y \leq C       \leq z \leq D$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
1 2 3 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
4
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
1 2 2 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
500000 500000 500000 500000
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере можно составить треугольники со следующими       длинами сторон: $$$(1, 3, 3)$$$, $$$(2, 2, 3)$$$, $$$(2, 3, 3)$$$       и $$$(2, 3, 4)$$$.</p>     <p>Во втором примере можно составить треугольники: $$$(1, 2, 2)$$$,       $$$(2, 2, 2)$$$ и $$$(2, 2, 3)$$$.</p>     <p>В третьем примере можно составить лишь один равносторонний       треугольник. Длины всех сторон будут равны $$$5 \cdot 10^5$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1355/problem/C' title='Codeforces Round 643 (Div. 2)'>1355C - Count Triangles</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Since $$$x \le y \le z$$$ to be a non-degenerate triangle for       given triple it is necessary and sufficient to satisfy $$$z &lt; x       + y$$$. Let's calculate for all $$$s = x + y$$$ how many ways       there are to choose $$$(x, y)$$$. To do that we will try all       $$$x$$$ and add 1 on segment $$$[x + B; x + C]$$$ offline using       prefix sums. Let's calculate prefix sums once more, now we can       find in $$$O(1)$$$ how many ways there are to choose $$$(x, y)$$$       such that their sum if greater than $$$z$$$. Try all $$$z$$$,       calculate the answer. Total complexity — $$$O(C)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;unordered_set&gt;
#include &lt;unordered_map&gt;
#include &lt;queue&gt;
#include &lt;ctime&gt;
#include &lt;cassert&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;chrono&gt;
#include &lt;random&gt;
#include &lt;bitset&gt;
using namespace std;

#ifdef LOCAL
	#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);
#else
	#define eprintf(...) 42
#endif

using ll = long long;
using ld = long double;
using uint = unsigned int;
using ull = unsigned long long;
template&lt;typename T&gt;
using pair2 = pair&lt;T, T&gt;;
using pii = pair&lt;int, int&gt;;
using pli = pair&lt;ll, int&gt;;
using pll = pair&lt;ll, ll&gt;;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
 
#define pb push_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second

double startTime;
double getCurrentTime() {
	return ((double)clock() - startTime) / CLOCKS_PER_SEC;
}

const int N = (int)1e6 + 77;
int A, B, C, D;
ll a[N];

int main()
{
	startTime = (double)clock();
//	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);

	scanf(&#34;%d%d%d%d&#34;, &amp;A, &amp;B, &amp;C, &amp;D);
	for (int i = A; i &lt;= B; i++) {
		a[i + B]++;
		a[i + C + 1]--;
	}
	for (int i = 1; i &lt; N; i++)
		a[i] += a[i - 1];
	for (int i = 1; i &lt; N; i++)
		a[i] += a[i - 1];
	ll ans = 0;
	for (int i = C; i &lt;= D; i++)
		ans += a[N - 1] - a[i];
	printf(&#34;%lld\n&#34;, ans);

	return 0;
}
</code></pre>
           
            <pre><code>// #pragma comment(linker, &#34;/stack:200000000&#34;)
// #pragma GCC optimize(&#34;Ofast,no-stack-protector&#34;)
// #pragma GCC target(&#34;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native&#34;)
// #pragma GCC optimize(&#34;unroll-loops&#34;)

#include &lt;bits/stdc++.h&gt;

#ifdef PERVEEVM_LOCAL
    #define debug(x) std::cerr &lt;&lt; (#x) &lt;&lt; &#34;:\t&#34; &lt;&lt; (x) &lt;&lt; std::endl
#else
    #define debug(x) 238;
#endif

#define fastIO std::ios_base::sync_with_stdio(false); std::cin.tie(0); std::cout.tie(0)
#define NAME &#34;File&#34;

using ll = long long;
using ld = long double;

#ifdef PERVEEVM_LOCAL
    std::mt19937 rnd(238);
#else
    std::mt19937 rnd(std::chrono::high_resolution_clock::now().time_since_epoch().count());
#endif

const double PI = atan2(0.0, -1.0);
const int INF = 0x3f3f3f3f;
const ll LINF = (ll)2e18;

ll calcProgression(ll a, ll d, ll n) {
    return (2 * a + d * (n - 1)) * n / 2;
}

void run() {
    int a, b, c, d;
    scanf(&#34;%d%d%d%d&#34;, &amp;a, &amp;b, &amp;c, &amp;d);

    ll ans = 0;
    for (int z = c; z &lt;= d; ++z) {
        int minX = std::max(a, z - c + 1);
        if (minX &gt; b) {
            continue;
        }

        int mid = z - b + 1;
        int start = c - std::max(b, z - minX + 1) + 1;

        if (mid &lt;= minX) {
            ans += 1ll * (c - b + 1) * (b - minX + 1);
        } else if (mid &gt; b) {
            // ans += 1ll * (b - minX + 1) * (b - minX + 2) / 2;
            ans += calcProgression(start, 1, b - minX + 1);
        } else {
            ans += calcProgression(start, 1, mid - minX + 1);
            ans += 1ll * (b - mid) * (c - b + 1);
            // ans += 1ll * (mid - minX + 1) * (mid - minX + 2) / 2 + 1ll * (b - mid) * (c - b + 1);
        }
    }    

    printf(&#34;%lld\n&#34;, ans);
}

int main(void) {
    // freopen(NAME&#34;.in&#34;, &#34;r&#34;, stdin);
    // freopen(NAME&#34;.out&#34;, &#34;w&#34;, stdout);

    auto start = std::chrono::high_resolution_clock::now();
    run();
    auto end = std::chrono::high_resolution_clock::now();

    #ifdef PERVEEVM_LOCAL
        std::cerr &lt;&lt; &#34;Execution time: &#34;
                  &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start).count()
                  &lt;&lt; &#34; ms&#34; &lt;&lt; std::endl;
    #endif

    return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #643 (Div. 2)
    1355D
    Игра с массивом </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Игра с массивом</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Петя и Вася, как всегда, заняты тем, что соревнуются между собой       в новой интересной игре.</p>     <p>Сначала Петя должен придумать массив длины $$$N$$$, состоящий из       целых положительных чисел, сумма которых равна $$$S$$$, а также       целое число $$$K$$$ такое, что $$$0 \leq K \leq S$$$. Чтобы       выиграть, Вася должен найти такой непустой подотрезок в массиве       Пети, что сумма его элементов равна $$$K$$$ или $$$S - K$$$. В       противном случае Васе придётся признать своё поражение.</p>     <p>Зная $$$N$$$ и $$$S$$$, определите, может ли Петя одержать победу       при условии, что Вася будет играть наилучшим для себя способом.       Если Петя может выиграть, подскажите, как ему следует сыграть.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В единственной строке содержатся два целых числа $$$N$$$ и       $$$S$$$ ($$$1 \leq N \leq S \leq 10^{6}$$$) — необходимая длина       массива и сумма его элементов.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Если Петя может победить, то в первой строке следует вывести         «<span class="tex-font-style-tt">YES</span>» (без кавычек), во       второй строке нужно вывести необходимый массив, состоящий из       $$$N$$$ натуральных чисел, сумма которых равна $$$S$$$, а в       третьей строке вывести одно целое число $$$K$$$. Если подходящих       ответов несколько, то можно вывести любой из них.</p>     <p>В противном случае в единственной строке выведите «<span class="tex-font-style-tt">NO</span>» (без кавычек).</p>     <p>Вы можете выводить каждую букву в любом регистре (строчную или заглавную).</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
1 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
YES
4
2</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
3 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
NO</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
3 8
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
YES
2 1 5
4</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1355/problem/D' title='Codeforces Round 643 (Div. 2)'>1355D - Game With Array</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>For $$$S \ge 2N$$$ Petya wins: let's take array $$$[2, 2, \ldots,       2, S - 2(N - 1)]$$$ and $$$K = 1$$$. All the elements are strictly       greater than 1, so there are no segment with sum 1 or $$$S - 1$$$.</p>     <p>Let's prove that for $$$S &lt; 2N$$$ Petya will lose. Suppose it       is not true and there exist an array and $$$K &gt; 0$$$ (it is       obvious that $$$K = 0$$$ is bad). Note that the condition that       there is a segment with sum $$$K$$$ or $$$S - K$$$ is equivalent       to the condition that there is a segment with sum $$$K$$$ in       cyclic array. Let's calculate prefix sums for our array, and for       prefix sum $$$M$$$ let's mark all the numbers of the form $$$M +       TS$$$ for integer $$$T \ge 0$$$. It is easy to see that numbers       $$$X$$$ and $$$X + K$$$ cannot be marked simultaneously: otherwise       there is a segment with sum $$$K$$$ in a cyclic array. Let's       consider half-interval $$$[0; 2KS)$$$. It is clear that exactly       $$$2KN$$$ numbers are marked on this half-interval. On the other       hand, we can split all the numbers from this half-interval into       $$$KS$$$ pairs with difference $$$K$$$: $$$(0, K), (1, K + 1),       \ldots, (K - 1, 2K - 1), (2K, 3K), (2K + 1, 3K + 1), \ldots (2KS -       K - 1, 2KS - 1)$$$. In every such pair no more than one number is       marked, so the total number of marked numbers is bounded by       $$$KS$$$. Therefore $$$2KN \le KS$$$ which means $$$2N \le S$$$. Contradiction.</p></div></div></div>

           
            <pre><code>#include &lt;iostream&gt;
using namespace std;

int main() {
	int n, s;
	cin &gt;&gt; n &gt;&gt; s;
	
	if (2 * n &lt;= s) {
		cout &lt;&lt; &#34;YES\n&#34;;
		for (int i = 0; i &lt; n - 1; i++) {
			cout &lt;&lt; 2 &lt;&lt; &#39; &#39;;
			s -= 2;
		}
		cout &lt;&lt; s &lt;&lt; &#39;\n&#39; &lt;&lt; 1;
	} else {
		cout &lt;&lt; &#34;NO&#34;;
	}
	return 0;
}</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #643 (Div. 2)
    1355E
    Реставрационное расстояние </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. Реставрационное расстояние</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам нужно отреставрировать стену. Стена состоит из $$$N$$$       столбиков кирпичей, высота $$$i$$$-го столбика изначально равна       $$$h_{i}$$$, высота измеряется количеством кирпичей. После       реставрации все $$$N$$$ столбиков должны иметь одинаковую высоту.</p>     <p>Вам доступны следующие операции:</p>          <ul>                     <li> положить кирпич на верх одного из столбиков, стоимость этой         операции равна $$$A$$$;         </li>       <li> убрать кирпич с верха одного из непустых столбиков, стоимость         этой операции равна $$$R$$$;         </li>       <li> переложить один кирпич с верха одного из непустых столбиков         на верх другого столбика, стоимость этой операции равна $$$M$$$.         </li></ul>          <p>Вы не можете создавать дополнительные столбики или игнорировать       какие-то из существующих столбиков, даже если их высота стала       равна $$$0$$$.</p>     <p>За какую минимальную суммарную стоимость возможно провести       реставрацию, то есть сделать высоты всех столбиков равными?</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записаны четыре целых числа $$$N$$$, $$$A$$$,       $$$R$$$, $$$M$$$ ($$$1 \le N \le 10^{5}$$$, $$$0 \le A, R, M \le       10^{4}$$$) — количество столбиков кирпичей в стене, а также       стоимости доступных операций.</p>     <p>Во второй строке записаны $$$N$$$ целых чисел $$$h_{i}$$$ ($$$0       \le h_{i} \le 10^{9}$$$) — изначальные высоты столбиков.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одно целое число — минимальную суммарную стоимость       реставрации стены.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3 1 100 100
1 3 8
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
12
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
3 100 1 100
1 3 8
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
9
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
3 100 100 1
1 3 8
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
4
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5 1 2 4
5 5 3 6 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
4
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5 1 2 2
5 5 3 6 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1355/problem/E' title='Codeforces Round 643 (Div. 2)'>1355E - Restorer Distance</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>First of all let's do $$$M = \min(M, A + R)$$$ — this is true       since we can emulate moving by adding+removing. After that it is       never profitable to add and remove in one solution, since we can       always move instead.</p>     <p>Suppose we have fixed $$$H$$$ — the resulting height for all       pillars. How can we calculate the minimal cost for given $$$H$$$?       Some pillars have no more than $$$H$$$ bricks, let the total       number of missing bricks in these pillars be $$$P$$$. Other       pillars have no less than $$$H$$$ bricks, let the total number of       extra bricks in these pillars be $$$Q$$$. If $$$P \ge Q$$$ then we       are missing $$$(P - Q)$$$ bricks in total, so we have to make       $$$(P - Q)$$$ additions. There won't be any more additions or       removals, and we have to do at least $$$Q$$$ moves since we have       to somehow get rid of extra bricks from those pillars which have       more than $$$H$$$ bricks initially. It is clear that $$$Q$$$ moves       is enough. Therefore the total cost will be $$$C = A(P - Q) +       MQ$$$. Similarly, if $$$Q \ge P$$$ then the total cost will be       $$$C = R(Q - P) + MP$$$.</p>     <p>Let's now assume that $$$P \ge Q$$$, we have exactly $$$X$$$       pillars with no more than $$$H$$$ bricks and exactly $$$N - X$$$       pillars with strictly more than $$$H$$$ bricks. Let's try to       increase $$$H$$$ by 1 and see how the total cost will change.       $$$P' = P + X$$$, $$$Q' = Q - (N - X) = Q - N + X$$$. $$$C' = A(P'       - Q') + MQ' = A(P + X - Q + N - X) + M(Q - N + X) = A(P - Q) + MQ       + AN - M(N - X)$$$. We can see that the total cost has changed by       $$$AN - M(N - X)$$$. While $$$X$$$ is constant the cost change       will be constant. What are the moments when $$$X$$$ changes? When       $$$H$$$ is equal to the initial height of some pillar. Therefore       the cost as a function of $$$H$$$ is piecewise linear with       breakpoints in points corresponding to initial heights.</p>     <p>There is a nuance — we have assumed $$$P \ge Q$$$. The same thing       will be true for $$$P \le Q$$$ but there can be additional       breakpoints when we change between these two states. This change       will happen only once for $$$H \approx \frac{\sum h_{i}}{N}$$$       (approximate equality here means that this point can be       non-integral so we should add both $$$\lfloor \frac{\sum h_{i}}{N}       \rfloor$$$ and $$$\lceil \frac{\sum h_{i}}{N} \rceil$$$ as breakpoints).</p>     <p>The minima of piecewise linear function are in breakpoints so it       is enough to calculate the cost for breakpoints (initial heights       and $$$H \approx \frac{\sum h_{i}}{N}$$$) and choose minimal of them.</p>     <p>To calculate the cost for given $$$H$$$ fast we can sort the       initial heights and calculate prefix sums of heights. Then using       binary search we can determine which pillars have height less than       $$$H$$$ and greater than $$$H$$$ and then calculate $$$P$$$ and       $$$Q$$$ using prefix sums. We can use two pointers instead of       binary searches but it will not improve the total complexity which       is $$$O(N \log N)$$$ due to sorting (and binary searches if we are       using them).</p></div></div></div>

           
            <pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;unordered_set&gt;
#include &lt;unordered_map&gt;
#include &lt;queue&gt;
#include &lt;ctime&gt;
#include &lt;cassert&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;chrono&gt;
#include &lt;random&gt;
#include &lt;bitset&gt;
using namespace std;

#ifdef LOCAL
	#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);
#else
	#define eprintf(...) 42
#endif

using ll = long long;
using ld = long double;
using uint = unsigned int;
using ull = unsigned long long;
template&lt;typename T&gt;
using pair2 = pair&lt;T, T&gt;;
using pii = pair&lt;int, int&gt;;
using pli = pair&lt;ll, int&gt;;
using pll = pair&lt;ll, ll&gt;;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
 
#define pb push_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second

double startTime;
double getCurrentTime() {
	return ((double)clock() - startTime) / CLOCKS_PER_SEC;
}

const ll INF = (ll)2e18 + 77;
const int N = 100100;
int n;
ll h[N];
ll pref[N];
ll A, R, M;
ll ans = INF;

ll solve(ll H) {
	int pos = lower_bound(h, h + n, H) - h;
	ll res = 0;
	ll k1 = H * pos - pref[pos];
	ll k2 = pref[n] - pref[pos] - H * (n - pos);
	res = min(k1, k2);
	k1 -= res;
	k2 -= res;
	res *= M;
	res += k1 * A;
	res += k2 * R;
	return res;
}

int main()
{
	startTime = (double)clock();
//	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);

	scanf(&#34;%d%lld%lld%lld&#34;, &amp;n, &amp;A, &amp;R, &amp;M);
	M = min(M, A + R);
	for (int i = 0; i &lt; n; i++)
		scanf(&#34;%lld&#34;, &amp;h[i]);
	sort(h, h + n);
	for (int i = 0; i &lt; n; i++)
		pref[i + 1] = pref[i] + h[i];

	ans = min(ans, solve(pref[n] / n));
	ans = min(ans, solve(pref[n] / n + 1));
	for (int i = 0; i &lt; n; i++)
		ans = min(ans, solve(h[i]));
	printf(&#34;%lld\n&#34;, ans);

	return 0;
}
</code></pre>
           
            <pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;unordered_set&gt;
#include &lt;unordered_map&gt;
#include &lt;queue&gt;
#include &lt;ctime&gt;
#include &lt;cassert&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;chrono&gt;
#include &lt;random&gt;
#include &lt;bitset&gt;
using namespace std;

#ifdef LOCAL
	#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);
#else
	#define eprintf(...) 42
#endif

using ll = long long;
using ld = long double;
using uint = unsigned int;
using ull = unsigned long long;
template&lt;typename T&gt;
using pair2 = pair&lt;T, T&gt;;
using pii = pair&lt;int, int&gt;;
using pli = pair&lt;ll, int&gt;;
using pll = pair&lt;ll, ll&gt;;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
 
#define pb push_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second

double startTime;
double getCurrentTime() {
	return ((double)clock() - startTime) / CLOCKS_PER_SEC;
}

const ll INF = (ll)2e18 + 77;
const int N = 100100;
int n;
ll h[N];
ll pref[N];
ll A, R, M;
ll ans = INF;

ll solve(ll H) {
	int pos = lower_bound(h, h + n, H) - h;
	ll res = 0;
	ll k1 = H * pos - pref[pos];
	ll k2 = pref[n] - pref[pos] - H * (n - pos);
	res = min(k1, k2);
	k1 -= res;
	k2 -= res;
	res *= M;
	res += k1 * A;
	res += k2 * R;
	return res;
}

int main()
{
	startTime = (double)clock();
//	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);

	scanf(&#34;%d%lld%lld%lld&#34;, &amp;n, &amp;A, &amp;R, &amp;M);
	M = min(M, A + R);
	for (int i = 0; i &lt; n; i++)
		scanf(&#34;%lld&#34;, &amp;h[i]);
	sort(h, h + n);
	for (int i = 0; i &lt; n; i++)
		pref[i + 1] = pref[i] + h[i];

	ll L = h[0], R = h[n - 1];
	while(R - L &gt; (ll)1e6) {
		ll M1 = L + (R - L) / 3, M2 = R - (R - L) / 3;
		if (solve(M1) &gt; solve(M2)) {
			L = M1;
		} else {
			R = M2;
		}
	}
	for (ll x = L; x &lt;= R; x++)
		ans = min(ans, solve(x));
	printf(&#34;%lld\n&#34;, ans);

	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #643 (Div. 2)
    1355F
    Угадать количество делителей </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Угадать количество делителей</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>       <span class="tex-font-style-it">Это интерактивная задача.</span></p>     <p>Загадано число $$$1 \le X \le 10^{9}$$$. Вам <span class="tex-font-style-bf">не нужно</span> угадывать это число.       Вам нужно <span class="tex-font-style-bf">определить количество       делителей</span> этого числа, и даже это вам <span class="tex-font-style-bf">не нужно делать точно</span>: ваш       ответ будет считаться верным, если его абсолютная погрешность не       превышает 7 <span class="tex-font-style-bf">или</span> его       относительная погрешность не превышает $$$0.5$$$. Формально, пусть       ваш ответ равен $$$ans$$$, а количество делителей $$$X$$$ равно       $$$d$$$, тогда ваш ответ будет считаться правильным, если       выполнено <span class="tex-font-style-bf">хотя бы одно</span> из       следующих двух условий:</p>          <ul>                     <li> $$$| ans - d | \le 7$$$;         </li>       <li> $$$\frac{1}{2} \le \frac{ans}{d} \le 2$$$.         </li></ul>          <p>Вы можете не более $$$22$$$ раз сделать запрос. Запрос состоит из       одного целого числа $$$1 \le Q \le 10^{18}$$$. В ответ на запрос       вы получите $$$gcd(X, Q)$$$ — наибольший общий делитель $$$X$$$ и $$$Q$$$.</p>     <p>Число $$$X$$$ зафиксировано до всех запросов. Иными словами,         <span class="tex-font-style-bf">интерактор не является адаптивным</span>.</p>     <p>Назовём процесс отгадывания количества делителей числа $$$X$$$         <span class="tex-font-style-it">игрой</span>. В рамках одного       теста вам нужно будет сыграть $$$T$$$ независимых игр, то есть       отгадать количество делителей $$$T$$$ раз для $$$T$$$ независимых       чисел $$$X$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>На первой строке записано одно целое число $$$T$$$ ($$$1 \le T       \le 100$$$) — количество игр.</p></div>         <div>     <div class="section-title">Протокол взаимодействия</div>          <p>Чтобы сделать запрос, выведите строку вида «<span class="tex-font-style-tt">? Q</span>» ($$$1 \le Q \le       10^{18}$$$). После запроса считайте одно число — $$$gcd(X, Q)$$$.       Вы можете сделать не более $$$22$$$ таких запросов в рамках одной игры.</p>     <p>Если вы считаете, что знаете количество делителей $$$X$$$ с       достаточной точностью, выведите ваш ответ в формате «<span class="tex-font-style-tt">! ans</span>». $$$ans$$$ должно быть       целым числом. Если это последняя игра, то вы должны завершить       выполнение программы, иначе вы должны начать следующую игру.       Обратите внимание, что интерактор не выводит ничего в ответ на       вывод ответа.</p>     <p>После вывода запроса или ответа не забудьте вывести перевод       строки и сбросить буфер вывода. Для сброса буфера вывода используйте:</p>          <ul>                     <li> <span class="tex-font-style-tt">fflush(stdout)</span> или           <span class="tex-font-style-tt">cout.flush()</span> в C++;         </li>       <li> <span class="tex-font-style-tt">System.out.flush()</span> в Java;         </li>       <li> <span class="tex-font-style-tt">flush(output)</span> в Pascal;         </li>       <li> <span class="tex-font-style-tt">stdout.flush()</span> в Python;         </li>       <li> смотрите документацию для других языков.         </li></ul>          <p>       <span class="tex-font-style-bf">Взломы</span></p>     <p>Для взломов используйте следующий формат:</p>     <p>Первая строка содержит одно целое число $$$T$$$ ($$$1 \le T \le       100$$$) — количество игр.</p>     <p>Каждая из следующих $$$T$$$ строк содержит одно целое число       $$$X$$$($$$1 \le X \le 10^{9}$$$) — загаданное число.</p>     <p>Так, пример из условия имеет вид </p>     <pre class="verbatim"><br/>2<br/>998244353<br/>4194304<br/></pre></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2

1

1

1


1024

1048576

4194304
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>

? 982306799268821872

? 230856864650023977

? 134690134760714371

! 5
? 1024

? 1048576

? 1073741824

! 42
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Почему ограничение на запросы именно 22? Возможно, автор задачи —       фанат Тейлор Свифт.</p>     <p>Рассмотрим пример из условия.</p>     <p>В первой игре загадано число $$$X = 998\,244\,353$$$. Было бы       сложно это угадать, правда? Это число является простым, то есть       количество его делителей равно 2. Решение сделало запросы с       несколькими случайными числами, и ответы на все запросы оказались       равны 1 (удивительно, что ни один из трёх запросов не оказался       кратным $$$998\,244\,353$$$). Логично предположить, что у       загаданного числа не очень много делителей, поэтому решение       ответило 5. Почему бы и не 5. Этот ответ будет засчитан, так как       $$$| 5 - 2 | = 3 \le 7$$$.</p>     <p>Во второй игре загадано число $$$X = 4\,194\,304 = 2^{22}$$$,       количество его делителей равно 23. Решение сделало запросы $$$1024       = 2^{10}$$$, $$$1\,048\,576 =2^{20}$$$, $$$1\,073\,741\,824 =       2^{30}$$$ и получило ответы $$$1024 = 2^{10}$$$, $$$1\,048\,576       =2^{20}$$$, $$$4\,194\,304 = 2^{22}$$$, соответственно. Затем       решение окончательно запуталось и выдало ответ на Главный вопрос       жизни, Вселенной и всего такого. Этот ответ будет засчитан, так       как $$$\frac{1}{2} \le \frac{42}{23} \le 2$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1355/problem/F' title='Codeforces Round 643 (Div. 2)'>1355F - Guess Divisors Count</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>If $$$X = p_{1}^{\alpha_{1}} \cdot p_{2}^{\alpha_{2}} \cdot       \ldots \cdot p_{k}^{\alpha_{k}}$$$ then $$$d(X) = (\alpha_{1} + 1)       \cdot (\alpha_{2} + 1) \cdot \ldots \cdot (\alpha_{k} + 1)$$$.</p>     <p>If $$$X$$$ has prime $$$p$$$ in power $$$\alpha$$$ and $$$Q$$$       has $$$p$$$ in power $$$\beta$$$ then $$$gcd(X, Q)$$$ will have       $$$p$$$ in power $$$\gamma = \min (\alpha, \beta)$$$. If $$$\gamma       &lt; \beta$$$ then $$$\alpha = \gamma$$$, otherwise $$$\gamma =       \beta$$$ and $$$\alpha \ge \gamma$$$. We don't know $$$X$$$, but       we can choose $$$Q$$$. If we'll choose $$$Q$$$ with known prime       factorization then we'll be able to extract all the information       from query fast (in $$$O(\log Q)$$$).</p>     <p>After all the queries for each prime $$$p$$$ we'll know either       the exact power in which $$$X$$$ has it, or lower bound for it. We       can get upper bound from the fact that $$$X \le 10^{9}$$$.</p>     <p>It is clear that we cannot get information about all primes —       there are too many of them and too few queries. We want to somehow       use the fact that we don't have to find the exact answer...</p>     <p>Suppose we have figured out that $$$X = X_{1} \cdot X_{2}$$$       where we know $$$X_{1}$$$ exactly and we also know that       $$$X_{2}$$$ has no more than $$$t$$$ prime factors (including       multiplicity). Then $$$d(X_{1}) \le d(X) \le d(X_{1}) \cdot       d(X_{2}) \le d(X_{1}) \cdot 2^{t}$$$. If $$$t \le 1$$$ then our       answer will have relative error no more than $$$0.5$$$...</p>     <p>One of the ways to guarantee that $$$X_{2}$$$ has few prime       factors is to show that it cannot have small prime factors. That       means that we have to calculate the exact power for all small       primes. This gives an overall idea for the solution: let's make a       query $$$Q=p^{\beta}$$$ for all primes $$$p \le B$$$ (for some       bound $$$B$$$) where $$$\beta$$$ is chosen in such a way that       $$$p^{\beta} &gt; 10^{9}$$$. This allows us to know the exact       power in which $$$X$$$ has $$$p$$$.</p>     <p>This basic idea can be improved in several ways:</p>          <ol>                     <li> $$$X$$$ has no more than 9 different prime factors, so for         most primes its power is 0. If we could exclude these redundant         primes fast it could speed up the solution significantly. And         there is a way: we could make a query $$$Q = p_{1} p_{2} \ldots         p_{s}$$$ for $$$s$$$ different primes, after that we will know         which of them are factors of $$$X$$$;         </li>       <li> $$$\beta$$$ can be chosen such that $$$p^{\beta + 1} &gt;         10^{9}$$$, because even if $$$\gamma = \beta$$$ and $$$\alpha         \ge \gamma = \beta$$$ we will know that $$$\alpha \le \beta$$$         since otherwise $$$X &gt; 10^{9}$$$;         </li>       <li> From the previous point follows that we can find the exact         power for two primes simultaneously, just make a query with a         product of two respective numbers.         </li></ol>          <p>How to choose $$$B$$$? Apparently we want $$$B^{2} &gt;       10^{9}$$$. But actually $$$t \le 2$$$ is ok for us: if we know       that $$$L \le d(X) \le 4L$$$ then we can answer $$$2L$$$ and the       relative error will be no more than $$$0.5$$$. That means we want       $$$B^{3} &gt; 10^{9}$$$ or $$$B = 1001$$$.</p>     <p>We are close: there are 168 primes less than 1001, we can check 6       primes (for being a factor of $$$X$$$) in one query since       $$$1000^{6} \le 10^{18}$$$, so we need 28 queries.</p>     <p>Let's note that if we have found some prime factors of $$$X$$$       (let's say their product is $$$X_{1}$$$) then $$$X_{2} \le       \frac{10^{9}}{X_{1}}$$$. Suppose we have checked all the primes       not greater than $$$p$$$ and $$$X_{1} \cdot p^{3} &gt; 10^{9}$$$.       That means that $$$X_{2}$$$ has no more than 2 prime divisors and       we are good.</p>     <p>What is left is to use our right to have absolute error: if       $$$X_{1} \le 3$$$ we can just print 8! Either $$$X_{1} \le 3$$$       and we are fine with $$$X_{2}$$$ having 3 prime factors, or       $$$X_{1} \ge 4$$$ and we have to check all primes up to       $$$\sqrt[3]{10^{9} / 4} &lt; 630$$$. There are 114 such primes, so       we need only 19 queries.</p>     <p>We will also need some queries to find out the exact power for       those small prime factors of $$$X$$$ we have found. If we have       found no more than 2 prime factors, we'll need 1 query, otherwise       we'll have to check primes only up to $$$\sqrt[3]{10^{9} / (2       \cdot 3 \cdot 5)} &lt; 330$$$, of which there are only 66 so the       first part of the solution spends no more than 11 queries.</p>     <p>So we have shown that the solution spends no more than 20       queries. We did some rough estimations, the actual bound for this       solution is 17 queries.</p></div></div></div>

           
            <pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;unordered_set&gt;
#include &lt;unordered_map&gt;
#include &lt;queue&gt;
#include &lt;ctime&gt;
#include &lt;cassert&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;chrono&gt;
#include &lt;random&gt;
#include &lt;bitset&gt;
using namespace std;

#ifdef LOCAL
	#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);
#else
	#define eprintf(...) 42
#endif

using ll = long long;
using ld = long double;
using uint = unsigned int;
using ull = unsigned long long;
template&lt;typename T&gt;
using pair2 = pair&lt;T, T&gt;;
using pii = pair&lt;int, int&gt;;
using pli = pair&lt;ll, int&gt;;
using pll = pair&lt;ll, ll&gt;;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
 
#define pb push_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second

double startTime;
double getCurrentTime() {
	return ((double)clock() - startTime) / CLOCKS_PER_SEC;
}

const int N = 2020;
const ll INF = (ll)1e18;
bool p[N];

ll query(ll x) {
	printf(&#34;? %lld\n&#34;, x);
	cerr &lt;&lt; &#34;? &#34; &lt;&lt; x &lt;&lt; endl;
	fflush(stdout);
	scanf(&#34;%lld&#34;, &amp;x);
	cerr &lt;&lt; &#34;gcd &#34; &lt;&lt; x &lt;&lt; endl;
	return x;
}

void solve() {

	ll C = (ll)1e9 / 2 / 2;
	vector&lt;ll&gt; hv;
	vector&lt;ll&gt; cur;
	ll curProd = 1;
	for (int i = 2; i &lt; N; i++) {
		if (!p[i]) continue;
		ll cc = C;
		for (int j = 0; j &lt; 3; j++)
			cc /= i;
		if (cc == 0) break;
		if (INF / i &lt; curProd) {
			ll g = query(curProd);
			while(!cur.empty()) {
				if (g % cur.back() == 0) {
					hv.push_back(cur.back());
					if ((int)hv.size() &lt;= 2) C *= 2;
					C /= hv.back();
				}
				cur.pop_back();
			}
			curProd = 1;
		}
		cur.push_back((ll)i);
		curProd *= i;
	}
	if (!cur.empty()) {
		ll g = query(curProd);
		while(!cur.empty()) {
			if (g % cur.back() == 0) hv.push_back(cur.back());
			cur.pop_back();
		}
	}
	if ((int)hv.size() &amp; 1) {
		for (int i = 2; i &lt; N; i++) {
			if (!p[i]) continue;
			bool fnd = false;
			for (ll x : hv)
				fnd |= i == x;
			if (!fnd) {
				hv.push_back(i);
				break;
			}
		}
	}
	ll ans = 2;
	for (int i = 0; i &lt; (int)hv.size(); i += 2) {
		ll p1 = hv[i], p2 = hv[i + 1];
		ll x1 = 1, x2 = 1;
		while(x1 * p1 &lt;= (ll)1e9) x1 *= p1;
		while(x2 * p2 &lt;= (ll)1e9) x2 *= p2;
		ll g = query(x1 * x2);
		int t1 = 1, t2 = 1;
		while(g % p1 == 0) {
			g /= p1;
			t1++;
		}
		while(g % p2 == 0) {
			g /= p2;
			t2++;
		}
		ans *= t1 * t2;
	}
	printf(&#34;! %lld\n&#34;, max(8LL, ans));
	cerr &lt;&lt; &#34;ans &#34; &lt;&lt; ans &lt;&lt; endl;
	fflush(stdout);
}

int main()
{
	startTime = (double)clock();
//	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);

	for (int i = 2; i &lt; N; i++)
		p[i] = 1;
	for (int i = 2; i &lt; N; i++) {
		if (!p[i]) continue;
		for (int j = 2 * i; j &lt; N; j += i)
			p[j] = 0;
	}

	int t;
	scanf(&#34;%d&#34;, &amp;t);
	cerr &lt;&lt; &#34;tests = &#34; &lt;&lt; t &lt;&lt; endl;
	while(t--) solve();


	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #645 (Div. 2)
    1358A
    Освещение парка </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Освещение парка</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>В связи с эпидемией коронавируса власти города обязали жителей       соблюдать социальную дистанцию. Мэр города Семён Сергеевич хочет       осветить парк Глухарники, чтобы люди даже ночью могли видеть друг       друга и соблюдали дистанцию. </p>     <p>Парк представляет из себя прямоугольную таблицу состоящую из       $$$n$$$ строк и $$$m$$$ столбцов, где клетки таблицы — площади, а       границы между клетками — улицы. Также улицами являются внешние       границы. Каждая улица имеет длину $$$1$$$. Например, у парка       размера $$$n=m=2$$$ всего $$$12$$$ улиц.</p>     <p>Вам поручили разработать план освещения парка. Вы можете ставить       фонари в серединах улиц. Фонарь освещает две площади, между       которыми он стоит (или только одну площадь, если он стоит на       границе парка).</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/18aa1573b5d0c49e178a230e693800b5a0c2e6a8.png" style="max-width: 100.0%;max-height: 100.0%;"/>         <span class="tex-font-size-small">Пример парка размеров:         $$$n=4$$$, $$$m=5$$$. Освещенные площади отмечены жёлтым цветом.         Обратите внимание, что все улицы имеют длины $$$1$$$. Фонари         ставятся в середины улиц. На картинке <span class="tex-font-style-bf">не все</span> площади       освещены.</span> </center>          <p>Семён Сергеевич хочет потратить на освещение наименьшее возможное       количество денег, но также хочет чтобы люди по всему парку держали       социальную дистанцию. Поэтому он просит вас узнать, какое       минимальное количество фонарей понадобится, чтобы осветить все площади.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит одно целое число $$$t$$$ ($$$1 \le t \le       10^4$$$) — количество наборов входных данных. Далее следуют       $$$t$$$ наборов входных данных.</p>     <p>Каждый набор входных данных записывается одной строкой,       содержащей два натуральных числа $$$n$$$ и $$$m$$$ ($$$1 \le n, m       \le 10^4$$$) — размеры парка.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$t$$$ ответов на наборы тестовых данных. Каждый ответ       должен содержать одно целое число — минимальное количество фонарей       для того, чтобы осветить все площади.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
1 1
1 3
2 2
3 3
5 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
2
2
5
8
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Возможное оптимальное расположение фонарей для $$$2$$$-го набора       входных данных примера: <img class="tex-graphics" src="https://espresso.codeforces.com/9c98cd06c74ee783b366a57440a9ab57d0317193.png" style="max-width: 100.0%;max-height: 100.0%;"/></p>     <p>Возможное оптимальное расположение фонарей для $$$3$$$-го набора       входных данных примера: <img class="tex-graphics" src="https://espresso.codeforces.com/ea550342416cdfaeadf987bfcfdab6d169d5f8ad.png" style="max-width: 100.0%;max-height: 100.0%;"/> </p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1358/problem/A' title='Codeforces Round 645 (Div. 2)'>1358A - Park Lighting</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Note that if at least one of the sides is even, the square can be       divided into pairs of neighbors and the answer is       $$$\frac{nm}{2}$$$. </p>     <p>If both sides are odd, we can first light up a $$$(n - 1) \times       m$$$ part of the park. Then we'll still have the part $$$m \times       1$$$. We can light it up with $$$\frac{m + 1}{2}$$$ lanterns. Then       the total number of the lanterns is $$$\frac{(n-1) \cdot m}{2} +       \frac{m + 1}{2} = \frac{nm - m + m + 1}{2} = \frac{nm + 1}{2}$$$.</p>     <p>Note that both cases can be combined into one formula: $$$\lfloor       \frac{nm + 1}{2} \rfloor$$$.</p>     <p>The overall compexity is $$$\mathcal{O}(1)$$$ per test.</p></div></div></div>

           
            <pre><code>#include &lt;iostream&gt;

using namespace std;

int main() {
    int t, n, m;
    cin &gt;&gt; t;
    while (t--) {
        cin &gt;&gt; n &gt;&gt; m;
        cout &lt;&lt; (n * m + 1) / 2 &lt;&lt; &#39;\n&#39;;
    }
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #645 (Div. 2)
    1358B
    Марья Ивановна нарушает самоизоляцию </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Марья Ивановна нарушает самоизоляцию</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Марье Ивановне, самой активной бабушке двора, надоело сидеть       дома. Она решила организовать обряд против коронавируса.</p>     <p>У неё есть $$$n$$$ подруг-бабушек (сама Марья Ивановна в это       количество не входит). Бабушка с номером $$$i$$$ готова прийти на       обряд при условии, если в момент её появления во дворе кроме неё       там будет как минимум $$$a_i$$$ других бабушек. Обратите внимание,       что бабушки могут приходить во двор одновременно. Формально,       бабушка $$$i$$$ готова прийти, если количество бабушек пришедших       ранее или одновременно с ней больше или равно $$$a_i$$$.</p>     <p>Бабушки собираются во дворе так.</p>          <ul> <li> Изначально во дворе находится только Марья Ивановна (то         есть количество бабушек во дворе равно $$$1$$$). Все остальные         $$$n$$$ бабушек пока сидят по домам.         </li>       <li> На очередном шаге Марья Ивановна выбирает подмножество         бабушек, ни одна из которых ещё не вышла во двор. Каждой из них         она обещает, что когда бабушка выйдет, во дворе будет не менее         $$$a_i$$$ других бабушек (включая Марью Ивановну). Марья         Ивановна может звонить сразу нескольким соседкам. В таком случае         выбранные бабушки выйдут во двор <span class="tex-font-style-bf">одновременно</span>.          </li>       <li> Вы не можете обманывать бабушек, то есть ситуация, когда         $$$i$$$-я бабушка, после выхода во двор обнаружит, что сейчас во         дворе строго меньше $$$a_i$$$ других бабушек (кроме неё самой,         но включая Марью Ивановну), запрещена. Обратите внимание, что         если несколько бабушек появились во дворе одновременно, то они         каждая из них видит в том числе остальных в момент выхода. </li></ul>          <p>Ваша задача — найти, какое максимальное количество бабушек       (включая себя) Марья Ивановна может собрать во дворе для       проведения обряда «обкуривания от Короны-Вируса». Ведь чем больше       людей в одном месте во время карантина, тем эффективнее обряд!</p>     <p>Рассмотрим пример: если $$$n=6$$$ и $$$a=[1,5,4,5,1,9]$$$, то:</p>          <ul> <li> на первом шаге Марья Ивановна может позвать бабушек с         номерами $$$1$$$ и $$$5$$$, каждая из них будет видеть двух         бабушек в момент выхода во двор (заметим, что $$$a_1=1 \le 2$$$         и $$$a_5=1 \le 2$$$); </li>       <li> на втором шаге Марья Ивановна может позвать бабушек с         номерами $$$2$$$, $$$3$$$ и $$$4$$$, каждая из них будет видеть         пять бабушек в момент выхода во двор (заметим, что $$$a_2=5 \le         5$$$, $$$a_3=4 \le 5$$$ и $$$a_4=5 \le 5$$$); </li>       <li> бабушку номер $$$6$$$ позвать во двор не получится —         следовательно, ответ на для такого примера равен $$$6$$$ (сама         Марья Ивановна и еще $$$5$$$ суммарно вышедших бабушек). </li></ul></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке находится одно целое число $$$t$$$ ($$$1 \le t       \le 10^4$$$) — количество наборов входных данных в тесте. Далее       следуют описания наборов входных данных.</p>     <p>Первая строка описания набора содержит одно целое число $$$n$$$       ($$$1 \le n \le 10^5$$$) — количество бабушек (Марья Ивановна в       это количество не входит). </p>     <p>Вторая строка содержит $$$n$$$ целых чисел $$$a_1, a_2, \ldots,       a_n$$$ ($$$1 \le a_i \le 2\cdot10^5$$$).</p>     <p>Гарантируется, что сумма значений $$$n$$$ по всем наборам входных       данных не превосходит $$$10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите единственное целое       число $$$k$$$ ($$$1 \le k \le n + 1$$$) — максимальное возможное       количество бабушек во дворе.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
5
1 1 2 2 1
6
2 3 4 5 6 7
6
1 5 4 5 1 9
5
1 2 3 5 6
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
6
1
6
4
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных примера Марья Ивановна на первом       шаге может позвать всех бабушек. Тогда каждая из них увидит пять       бабушек, когда выйдет. Иными словами, ни одна не уйдёт домой.       Поэтому во дворе будет Марья Ивановна и пять других бабушек.</p>     <p>Во втором наборе входных данных примера никто не сможет       находиться во дворе, поэтому Марья Ивановна останется там одна.</p>     <p>Третий набор входных данных примера подробно разобран выше.</p>     <p>В четвёртом тестовом случае Марья Ивановна на первом шаге может       позвать бабушек с номерами $$$1$$$, $$$2$$$ и $$$3$$$. Если на       втором шаге Марья Ивановна позовёт только $$$4$$$-ю или только       $$$5$$$-ю, то когда эта бабушка выходила бы во двор, то она бы       увидела четверых бабушек, то есть Марья Ивановна по отдельности       позвать $$$4$$$-ю и $$$5$$$-ю не может. Если она позовёт сразу       обеих — $$$4$$$-ю и $$$5$$$-ю, то когда они будут выходить, то       увидят по $$$4+1=5$$$ бабушек. Несмотря на то, что $$$4$$$-ю       бабушку это устраивает, $$$5$$$-ю — этот вариант не устраивает.       Следовательно, позвать одновременно $$$4$$$-ю и $$$5$$$-ю Марья       Ивановна тоже не может. То есть во дворе будет только Марья       Ивановна и три бабушки из первого шага.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1358/problem/B' title='Codeforces Round 645 (Div. 2)'>1358B - Maria Breaks the Self-isolation</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let $$$x$$$ be the maximum number of grannies that can go out to       the yard. Then if Maria Ivanovna calls them all at the same time,       then everyone will see $$$x$$$ grannies. Since $$$x$$$ is the       maximum answer, then each granny of them satisfy $$$a_i \le x$$$       (otherwise there's no way for these grannies to gather in the       yard), that is, such call is correct. So it is always enough to       call once.</p>     <p>Note that if you order grannies by $$$a_i$$$, Maria Ivanovna will       have to call $$$x$$$ first grannies from this list. She can take       $$$x$$$ grannies if $$$a_x \le x$$$ (otherwise, after all $$$x$$$       grannies arrived, the last one will leave). To find $$$x$$$ we can       do a linear search.</p>     <p>The overall compexity is $$$\mathcal{O}(n\log{n})$$$ per test.</p></div></div></div>

           
            <pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

void solve() {
    int n;
    cin &gt;&gt; n;
    vector&lt;int&gt; arr(n);
    for (int &amp;el : arr)
        cin &gt;&gt; el;
    sort(arr.begin(), arr.end());
    for (int i = n - 1; i &gt;= 0; i--) {
        if (arr[i] &lt;= i + 1) {
            cout &lt;&lt; i + 2 &lt;&lt; &#39;\n&#39;;
            return;
        }
    }
    cout &lt;&lt; 1 &lt;&lt; &#39;\n&#39;;
}

int main() {
    int t;
    cin &gt;&gt; t;
    while (t--)
        solve();
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #645 (Div. 2)
    1358C
    Обновление Celex </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Обновление Celex</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>В связи с карантином, у Cайкромофта появилось больше свободного       времени для реализации новых функций в «<span class="tex-font-style-tt">Celex-2021</span>». Разработчики сделали       новую функцию <span class="tex-font-style-tt">GAZ-GIZ</span>,       которая от левого верхнего угла бесконечно заполняет бесконечную       вправо и вниз таблицу следующим образом:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/ab3c49666e913d52a14ebf7f09d741f3f712bacb.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>Клетка с координатами $$$(x, y)$$$ находится на пересечение       $$$x$$$-й строки и $$$y$$$-го столбца. Левая верхняя клетка       $$$(1,1)$$$ содержит число $$$1$$$.</p>     <p>Разработчики функции <span class="tex-font-style-tt">SUM</span>       тоже не спят. От скуки они сговорились с разработчиками функции         <span class="tex-font-style-tt">RAND</span>, поэтому они       добавили возможность посчитать сумму на произвольном пути от одной       клетки до другой, передвигаясь вниз или вправо. Формально, из       клетки $$$(x,y)$$$ за один шаг можно переместиться в клетку       $$$(x+1, y)$$$ или $$$(x, y+1)$$$.</p>     <p>После очередного обновления Dinwows, Левиан решил изучать «<span class="tex-font-style-tt">Celex-2021</span>» (ведь он хочет стать       бухгалтером!). После заполнения таблицы функцией <span class="tex-font-style-tt">GAZ-GIZ</span> он попросил вас посчитать       количество возможных различных сумм на пути от заданной клетки       $$$(x_1, y_1)$$$ до другой заданной клетки $$$(x_2, y_2$$$), если       за один ход вы можете ходить только на одну ячейку вниз или вправо.</p>     <p>Формально, рассмотрим все пути из клетки $$$(x_1, y_1)$$$ в       клетку $$$(x_2, y_2)$$$ такие, что каждая следующая клетка в пути       располагается либо справа, либо снизу от предыдущей. Посчитайте       количество различных сумм значений элементов для всех таких путей.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит одно целое число $$$t$$$ ($$$1 \le t \le       57179$$$) — количество наборов входных данных.</p>     <p>Каждая из следующих $$$t$$$ строк содержит четыре целых       положительных числа $$$x_1$$$, $$$y_1$$$, $$$x_2$$$, $$$y_2$$$       ($$$1 \le x_1 \le x_2 \le 10^9$$$, $$$1 \le y_1 \le y_2 \le       10^9$$$) — координаты стартовой и конечной клеток. </p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>На каждый набор входных данных в отдельной строке выведите ответ       — количество возможных различных сумм на пути от одной клетки до другой.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
1 1 2 2
1 2 2 4
179 1 179 100000
5 7 5 7
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
3
1
1
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных есть две возможных суммы:       $$$1+2+5=8$$$ и $$$1+3+5=9$$$. <img class="tex-graphics" src="https://espresso.codeforces.com/f80a32136dea106987ece7d1135079a5c040c792.png" style="max-width: 100.0%;max-height: 100.0%;"/></p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1358/problem/C' title='Codeforces Round 645 (Div. 2)'>1358C - Celex Update</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's look at the way with the minimum sum (first we go       $$$y_2-y_1$$$ steps right, and then $$$x_2-x_1$$$ steps down).       Let's look at such a change in the &quot;bends&quot; of the way:         <img class="tex-graphics" src="https://espresso.codeforces.com/62fb82fe60fcd4070ba7340fdbdee393ba3c352d.png" style="max-width: 100.0%;max-height: 100.0%;" />       After each step, the sum on the way will increase by $$$1$$$.</p>     <p>We're going to bend like this until we get to the maximum sum.       We're not going to miss any possible sum, because we're       incrementing the sum by 1. We started with the minimum sum and       finished with the maximum sum, so we can use these changes to get       all possible sums.</p>     <p>In order for us to come from the minimum to the maximum way, we       must bend the way exactly 1 time per each cell of table (except       for the cells of the minimum way). That is, the number of changes       equals the number of cells not belonging to the minimum way —       $$$(x_2-x_1)\cdot(y_2-y_1)$$$. Then the number of different sums       will be $$$(x_2-x_1)\cdot(y_2-y_1) + 1$$$.</p>     <p>The overall compexity is $$$\mathcal{O}(1)$$$ per test.</p></div></div></div>

           
            <pre><code>#include &lt;iostream&gt;

using namespace std;

int main() {
    int t;
    cin &gt;&gt; t;
    while (q--) {
        long long a, b, c, d;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
        cout &lt;&lt; (c - a) * (d - b) + 1 &lt;&lt; &#39;\n&#39;;
    }
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #645 (Div. 2)
    1358D
    Лучший отпуск </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Лучший отпуск</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вы давно влюблены в Коронавирус-тян, но до сих пор не знали, где       она живёт. И буквально сейчас выяснили, что она живёт в далёком       местечке под названием Ньаху. </p>     <p>Вы немедленно решили взять отпуск на своей скучной работы и       навестить Коронавирус-тян. Ваш отпуск длится ровно $$$x$$$ дней, и       ровно столько дней вы проведёте в гостях у подруги. В гостях вы       проведёте ровно $$$x$$$ подряд идущих дней.</p>     <p>В Ньаху используется очень необычный календарь: всего в году       $$$n$$$ месяцев, $$$i$$$-й месяц длится ровно $$$d_i$$$ дней. Дни       в $$$i$$$-м месяце пронумерованы от $$$1$$$ до $$$d_i$$$. В Ньаху       нет високосных годов.</p>     <p>Настроение Коронавирус-тян (и, соответственно, её желание вас       обнять) зависит от номера дня в месяце. А именно, в $$$j$$$-й день       месяца вы получаете $$$j$$$ объятий, если вы находитесь в гостях у Коронавирус-тян.</p>     <p>Вы знаете об этой особенности своей подруги и хотите спланировать       свою поездку так, чтобы суммарно получить наибольшее возможное       количество объятий (и тогда, быть может, вы сможете завоевать       сердечко Коронавирус-тян). </p>     <p>Обратите внимание, ваша поездка <span class="tex-font-style-bf">не обязательно</span> должна начаться       и закончиться в одном и том же году.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке входных данных даны два натуральных числа $$$n$$$       и $$$x$$$ ($$$1 \le n \le 2 \cdot 10^5$$$) — количество месяцев в       году и количество дней, которые вы можете провести в гостях у подруги.</p>     <p>Во второй строке даны $$$n$$$ целых чисел $$$d_1, d_2, \ldots,       d_n$$$, где $$$d_i$$$ — количество дней в $$$i$$$-м месяце ($$$1       \le d_i \le 10^6$$$).</p>     <p>Гарантируется, что $$$1 \le x \le d_1 + d_2 + \ldots + d_n$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите единственное число — максимальное число объятий, которое       вы можете получить от Коронавирус-тян за время лучшего отпуска в       своей жизни.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3 2
1 3 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
5</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
3 6
3 3 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
12</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5 6
4 2 3 1 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
15</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере номера дней года (номера в соответствующих       месяцах) имеет вид: $$$\{1,1,2,3,1\}$$$. Коронавирус-тян обнимет       вас больше всего раз, если вы приедете в третий день года:       $$$2+3=5$$$ объятий.</p>     <p>Во втором примере номера дней года (номера в соответствующих       месяцах) имеет вид: $$$\{1,2,3,1,2,3,1,2,3\}$$$. Больше всего       объятий вы получите если приедете в третий день года:       $$$3+1+2+3+1+2=12$$$ объятий.</p>     <p>В третьем примере номера дней имеют вид: $$$\{1,2,3,4,1,2, 1,2,3,       1, 1,2,3\}$$$. Больше всего объятий вы получите если приедете в       двенадцатый день года: подруга обнимет вас $$$2+3+1+2+3+4=15$$$       раз. </p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1358/problem/D' title='Codeforces Round 645 (Div. 2)'>1358D - The Best Vacation</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>We will double the array of days and solve the problem when the       day vacation starts and the day it ends is always in the same       year. Then $$$a$$$ is an array of number of days in each of the months.</p>     <p>Consider array $$$B = [1, 2, ..., a_1] + [1, 2, ..., a_2] + ...       [1, 2, ..., a_n] + [1, 2, ..., a_n]$$$. Our task is to find a       subsection of length $$$k$$$ with the maximum sum in it. Further       we will call this segment optimal. </p>     <p>       <span class="tex-font-style-bf">Statement</span>: We will find       such an optimal segment that its end coincides with the end of       some month. </p>     <p>       <span class="tex-font-style-bf">Proof by contradiction</span>:       Pretend that's not the case. Consider the rightmost optimal       segment. Let its last element be $$$x$$$, then the next one is       $$$x+1$$$, otherwise $$$x$$$ coincides with $$$a_i$$$. Note that       if we move this segment to the right, the sum must be reduced,       which means that the first element of the segment $$$&gt;x+1$$$.       Then its left neighbor $$$&gt;x$$$. It means that you can move the       segment by $$$1$$$ to the left so that the sum increases. So, the       chosen segment is not optimal. Contradiction. (see picture) </p>     <p>       <img class="tex-graphics" src="https://espresso.codeforces.com/07c95f060c3adb9ca6c782d1d10f67fc01803396.png" style="max-width: 100.0%;max-height: 100.0%;" /></p>     <p>Solution: now we just need to go through all the possible ends of       the segment, which are only $$$\mathcal{O}(n)$$$. Let's build two       arrays of prefix sums:</p>     <p>$$$c_i = a_1 + a_2 + ... + a_i\\$$$ $$$d_i = \frac{a_1 (a_1 +       z)}{2} + ... + \frac{a_i (a_i + 1)}{2}$$$</p>     <p>$$$c_i$$$ is responsible for the number of days before the       $$$i$$$-th month, and $$$d_i$$$ is responsible for the sum of       numbers of all days before the $$$i$$$-th month.</p>     <p>For each of the n ends, let's make a binsearch to find which       month contains its left border ($$$k$$$ days less than the right       one). You can use array $$$c_i$$$ to check whether the left border       lies to the left/in the block/to the right, and use array       $$$d_i$$$ to restore the answer.</p>     <p>The overall compexity is $$$\mathcal{O}(n\log{n})$$$.</p></div></div></div>

           
            <pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

#define int long long

using namespace std;

signed main() {
  int n, len;
  cin &gt;&gt; n &gt;&gt; len;
  vector&lt;int&gt; A(2 * n);
  for (int i = 0; i &lt; n; i++) {
    cin &gt;&gt; A[i];
    A[n + i] = A[i];
  }
  n *= 2;
  
  vector&lt;int&gt; B = {0}, C = {0};
  for (int i = 0; i &lt; n; i++) 
    B.push_back(B.back() + A[i]);
  for (int i = 0; i &lt; n; i++) 
    C.push_back(C.back() + (A[i] * (A[i] + 1)) / 2);
  int ans = 0;
  for (int i = 0; i &lt; n; i++) {
    if (B[i + 1] &gt;= len) {
      int z = upper_bound(B.begin(), B.end(), B[i + 1] - len) - B.begin();
      int cnt = C[i + 1] - C[z];
      int days = B[i + 1] - B[z];
      int too = len - days;
      cnt += ((A[z - 1] * (A[z - 1] + 1)) / 2);
      cnt -= (((A[z - 1] - too) * (A[z - 1] - too + 1)) / 2);
      ans = max(ans, cnt);
    }
  }
  cout &lt;&lt; ans;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #645 (Div. 2)
    1358E
    Вы уволены? </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. Вы уволены?</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Левиан работает бухгалтером в большой компании. Он знает, сколько       компания заработала в каждый из $$$n$$$ подряд идущих месяцев — в       $$$i$$$-й месяц у компании доход был равен $$$a_i$$$       (положительный доход означает прибыль, отрицательный доход       означает убыль, нулевой доход означает отсутствие изменений).       Из-за всеобщей самоизоляции, первые $$$\lceil \tfrac{n}{2}       \rceil$$$ месяцев доход мог быть совершенно нестабилен, но потом       всё стабилизировалось и последние $$$\lfloor \tfrac{n}{2}       \rfloor$$$ месяцев <span class="tex-font-style-bf">доход был одинаковый</span>.</p>     <p>Левиан решил, что на совете директоров сообщит $$$n-k+1$$$ число       — суммарный доход компании за каждые $$$k$$$ подряд идущих       месяцев. Формально, для всех $$$i$$$ от $$$1$$$ до $$$n-k+1$$$ он       скажет число $$$a_i + a_{i+1} + \ldots + a_{i + k - 1}$$$.       Например, если $$$a=[-1, 0, 1, 2, 2]$$$ и $$$k=3$$$, то он сообщит       числа $$$0, 3, 5$$$.</p>     <p>К большому сожалению, если хоть один суммарный доход, сообщаемый       Левианом, не является прибылью (то есть доход $$$\le 0$$$), то       начальство разозлится и уволит не справившегося с работой бухгалтера.</p>     <p>Спасите карьеру Левиана: найдите такое число $$$k$$$, что за       любые $$$k$$$ подряд идущих месяцев компания получила прибыль или       скажите, что это невозможно.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит одно целое число $$$n$$$ ($$$2 \le n \le       5\cdot 10^5$$$) — количество месяцев, за которые Левиан должен       отчитаться. </p>     <p>Вторая строка содержит $$$\lceil{\frac{n}{2}}\rceil$$$ целых       чисел $$$a_1, a_2, \ldots, a_{\lceil{\frac{n}{2}}\rceil}$$$, где       $$$a_i$$$ ($$$-10^9 \le a_i \le 10^9$$$) — доход компании в       $$$i$$$-м месяце.</p>     <p>Третья строка содержит одно целое число $$$x$$$ ($$$-10^9 \le x       \le 10^9$$$)— доход в каждый месяц с $$$\lceil{\frac{n}{2}}\rceil       + 1$$$ до $$$n$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>В единственной строке выведите искомое число $$$k$$$ или       $$$-1$$$, если его не существует.   Если существует несколько       возможных решений, выведите любое из них.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
2 -1
2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
2 2 -8
2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
-1</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
-2 -2 6
-1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
4</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере подходят $$$k=2$$$ и $$$k=3$$$: в первом случае       Левиан сообщит числа $$$1, 1$$$ а во втором — одно число $$$3$$$.</p>     <p>Во втором примере ни одно $$$k$$$ не подходит.</p>     <p>В третьем примере ответом является только $$$k=4$$$: он сообщит       числа $$$1,2,3$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1358/problem/E' title='Codeforces Round 645 (Div. 2)'>1358E - Are You Fired?</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's call the value of all elements in the second half of the       array $$$x$$$.</p>     <p>Let $$$s_i = a_i + a_{i+1} + \ldots + a_{i+k-1}$$$ — the reported incomes.</p>     <p>Pretend there exists such a $$$k$$$ that $$$k\le\tfrac{n}{2}$$$.       Consider the following reported incomes: $$$s_i$$$ and       $$$s_{i+k}$$$. Notice that if we double $$$k$$$, the $$$i$$$-th       reported income will be equal to $$$s_i+s_{i+k}$$$. $$$s_i&gt;0$$$       and $$$s_{i+k}&gt;0$$$ imply $$$s_i+s_{i+k}&gt;0$$$. It means that       after doubling $$$k$$$, the new value will still be correct $$$\       \implies\ $$$ if some $$$k$$$ exists, there's also $$$k&gt;\tfrac{n}{2}$$$.</p>     <p>Now, let's notice that $$$s_{i+1} = s_i + (a_{i + k} - a_i)$$$.</p>     <p>It means we can think of $$$s_i$$$ as prefix sums of the       following array: $$$\\p = [s_1,\ a_{k+1}-a_1,\ a_{k+2}-a_2,\       \ldots,\ a_n - a_{n-k}]$$$. $$$ \\$$$ As $$$k&gt;\tfrac{n}{2}$$$,       $$$a_{k+j} = x$$$ holds for $$$j \ge 0$$$, so, actually $$$\\p =       [s_1,\ x-a_1,\ x-a_2,\ \ldots,\ x-a_{n-k}]$$$.</p>     <p>How is this array changed when we increment $$$k$$$ by 1?       $$$\\p_{new} = [s_1+a_{k+1},\ a_{k+2}-a_1,\ a_{k+3}-a_2,\ \ldots,\       a_n-a_{n-k-1}]$$$, which equals $$$[s_1+x,\ x-a_1,\ x-a_2,\       \ldots,\ x-a_{n-k-1}]$$$. $$$ \\$$$ So, when you increase $$$k$$$       by 1, the first element is changed, and the last element is       removed — and that's it.</p>     <p>Recall that $$$s_i = p_1 + p_2 + \ldots + p_i$$$. Notice that the       minimum reported income (some number from $$$s$$$) doesn't depend       on the first element of $$$p$$$ because it's a term of all sums       ($$$s_1, s_2, \ldots$$$). For example, if $$$p_1$$$ is increased       by $$$1$$$, all $$$s_i$$$ are increased by $$$1$$$ too. So, let's       calculate the following array $$$m$$$: $$$ \\$$$ $$$m_i =       min(s_1-p_1, s_2-p_1, \ldots, s_i-p_1) = min(0, p_2,\ p_2+p_3,\       \ldots,\ p_2+\ldots+p_i)$$$. $$$ \\$$$ This can be done in       $$$\mathcal{O}(n)$$$. </p>     <p>Notice that this array is the same for all $$$k$$$, except its       size. So, it's obvious that the minimum reported income for a       particular $$$k$$$ is       $$$p_1+m_{n-k+1}=a_1+\ldots+a_k+m_{n-k+1}$$$. So, we can just       check if this number is greater than $$$0$$$ for some $$$k$$$.</p>     <p>We can calculate prefix sums and $$$m$$$ in $$$\mathcal{O}(n)$$$,       so the overall complexity is $$$\mathcal{O}(n)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

#define int long long

signed main() {
  int n;
  cin &gt;&gt; n;
  int N = (n + 1) / 2;
  vector&lt;int&gt; a(N);
  for (int &amp;el : a)
    cin &gt;&gt; el;
  int Ax;
  cin &gt;&gt; Ax;
  vector&lt;int&gt; m(N + 1, 0);
  int Pprefsm = 0;
  for (int i = 1; i &lt; N + 1; ++i) {
    Pprefsm += Ax - a[i - 1];
    m[i] = min(m[i - 1], Pprefsm);
  }
  int Aprefsm = 0;
  for (int k = 1; k &lt;= N; ++k)
    Aprefsm += a[k - 1];
  for (int k = N; k &lt;= n; ++k) {
    if (Aprefsm + m[n - k] &gt; 0)
      return cout &lt;&lt; k, 0;
    Aprefsm += Ax;
  }
  cout &lt;&lt; -1;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #645 (Div. 2)
    1358F
    Вкусная печенька </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Вкусная печенька</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>3 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>О нет!</p>     <p>Вас поймал коронавирус, и теперь вы сидите в тёмном подвале,       связанные по ногам (но не по рукам). У вас есть вкусная печенька,       а также перед вами стоит ноутбук, и там открыта ваша любимая среда       разработки. Коронавирус убеждает вас решить следующую задачу.</p>     <p>Вам дано два массива $$$A$$$ и $$$B$$$ размера $$$n$$$. Вы можете       делать операции двух типов с массивом $$$A$$$: </p>     <ul> <li> Развернуть массив $$$A$$$. То есть массив $$$[A_1,\ A_2,\         \ldots,\ A_n]$$$ переходит в $$$[A_n,\ A_{n-1},\ \ldots,\         A_1]$$$ </li>       <li> Заменить $$$A$$$ на массив его префиксных сумм. То есть         массив $$$[A_1,\ A_2,\ \ldots,\ A_n]$$$ переходит в $$$[A_1,\         (A_1+A_2),\ \ldots,\ (A_1+A_2+\ldots+A_n)]$$$ </li></ul>          <p>Вам нужно понять, можно ли из массива $$$A$$$ получить массив       $$$B$$$. Если это можно сделать, то вам придётся восстановить       порядок этих операций, минимизировав количество операций второго       типа. К счастью, коронавирус сегодня добрый, поэтому он разрешил       вам не восстанавливать действия, если минимальное количество       операций второго типа превышает $$$2\cdot 10^5$$$. Но коронавирус       обижен на вас, поэтому если вы восстанавливаете ответ, то       суммарное количество операций не должно превышать $$$5\cdot 10^5$$$.</p>     <p>Решите эту задачу, или коронавирус продлит карантин на пять лет и       заставит всю экономику рухнуть! </p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке входных данных вводится число $$$n$$$ ($$$1\le n       \le 2\cdot 10^5$$$).</p>     <p>Вторая строка содержит $$$n$$$ целых чисел $$$A_1, A_2, \ldots,       A_n$$$ ($$$1 \le A_i \le 10 ^ {12}$$$).</p>     <p>Третья строка содержит $$$n$$$ целых чисел $$$B_1, B_2, \ldots,       B_n$$$ ($$$1 \le B_i \le 10 ^ {12}$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Если из массива $$$A$$$ нельзя получить массив $$$B$$$, в       единственной строке выведите «<span class="tex-font-style-tt">IMPOSSIBLE</span>» (без кавычек).</p>     <p>Если минимальное количество операций второго типа превышает       $$$2\cdot 10^5$$$, то в первой строке выведите «<span class="tex-font-style-tt">BIG</span>» (без кавычек). Во второй       строке выведите минимальное количество операций второго типа,       которые нужно применить, чтобы из массива $$$A$$$ получить $$$B$$$.</p>     <p>Иначе, в первой строке выведите «<span class="tex-font-style-tt">SMALL</span>» (без кавычек). Во второй       строке выведите суммарное количество операций первого и второго       типа $$$m \le 5\cdot 10^5$$$ (гарантируется, что в этом случае       существует такая последовательность действий). В третьей строке       выведите строку длины $$$m$$$, состоящую из символов «<span class="tex-font-style-tt">R</span>» и «<span class="tex-font-style-tt">P</span>» (без кавычек):</p>     <p>$$$i$$$-й символ должен быть равен '<span class="tex-font-style-tt">R</span>', если $$$i$$$-е действие       первого типа, и должен быть равен '<span class="tex-font-style-tt">P</span>', иначе.</p>     <p>Если таких последовательностей несколько, выведите любую из них.</p>     <p>Вы можете выводить все символы как в нижнем регистре, так и в верхнем.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
5 7
5 7
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
SMALL
0

</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
1 1
300000 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
BIG
299999
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
10 1
13 14
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
SMALL
6
RPPPRP
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
1 2 1
2 1 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
IMPOSSIBLE
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере массивы $$$A$$$ и $$$B$$$ уже совпадает, поэтому       количество нужных операций $$$=0$$$.</p>     <p>Во втором примере надо $$$299999$$$ раз заменить $$$A$$$ на       префиксную сумму, а потом развернуть массив. Так как       $$$299999&gt;2\cdot 10^5$$$, то восстанавливать ответ не нужно.</p>     <p>В четвёртом примере из массива $$$A$$$ никак нельзя получить $$$B$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1358/problem/F' title='Codeforces Round 645 (Div. 2)'>1358F - Tasty Cookie</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's define a few operations and constants: </p>     <ul> <li> $$$pref$$$ — replace an array with its prefix sums array </li>       <li> $$$reverse$$$ — reverse an array </li>       <li> $$$rollback$$$ — restore the original array from a prefix         sums array </li>       <li> $$$C$$$ — the array values upper bound — $$$10^{12}$$$ </li></ul>          <p>First, we can prove that $$$rollback$$$ is unambiguosly defined       for strictly increasing arrays. Consider an array $$$X$$$. Let       $$$Y$$$ be the prefix sums array of $$$X$$$. Notice that $$$X_0 =       Y_0$$$, $$$X_i = Y_i - Y_{i - 1}$$$ (for $$$i&gt;1$$$). Thus we       can restore $$$X$$$ from $$$Y$$$. Note that if we apply       $$$rollback$$$ to an array for which $$$Y_i &gt; Y_{i - 1}$$$       doesn't hold, the resulting array will have a non-positive element       which is forbidden by the statements.</p>     <p>Now let's analyze how many $$$pref$$$ operations can       theoretically be applied for arrays of different lengths (let's       call their count $$$t$$$) (We can do that by applying $$$pref$$$       to array $$$[1, 1, ..., 1]$$$ while all numbers are below $$$C$$$):</p>     <p>       <img class="tex-graphics" src="https://espresso.codeforces.com/092d38e3ff113dfc68cc4c86e68626a605d83a1d.png" style="max-width: 100.0%;max-height: 100.0%;" /></p>     <p>It's obvious that we'll need no more than $$$t$$$ $$$rollback$$$s       for an array of length $$$n$$$. It can also be proved that $$$t = \mathcal{O}(\sqrt[n-1]{C\cdot(n-1)!})$$$.</p>     <p>Let's restore the array $$$B$$$ in steps. One each step we have       several cases: </p>     <ul> <li> If $$$B$$$ equals $$$A$$$ or $$$reverse(A)$$$, we know how         to get $$$A$$$ from $$$B$$$. </li>       <li> If $$$B$$$ is strictly increasing, apply $$$rollback$$$. </li>       <li> If $$$B$$$ is strictly decreasing, apply $$$reverse$$$. </li>       <li> Otherwise, the answer is &quot;$$$impossible$$$&quot;. </li></ul>          <p>This solution will run infinitely when $$$n=1$$$ and $$$A \ne       B$$$, so the case when $$$n=1$$$ has to be handled separately.</p>     <p>The asymptotic of this solution is $$$\mathcal{O}(n\cdot ans)$$$.       Notice that $$$ans \le 2t+1$$$ because we can't have two       $$$reverse$$$ operations in a row. It means this solution will fit       into TL for $$$n \ge 3$$$, but we need a separate solution for $$$n=2$$$.</p>     <p>Consider an array $$$[x, y]$$$. If we $$$rollback$$$ it while       $$$x&lt;y$$$, the array will be transformed into $$$[x, y \mod       x]$$$. It means we can $$$rollback$$$ several iterations at once.</p>     <p>So, the solution for $$$n=2$$$ is: </p>     <ul> <li> First sort $$$A$$$ and $$$B$$$ so that they both increase         (and take this into account when printing answer) </li>       <li> Now start the $$$rollback$$$ loop: <ul> <li> If             $$$B_1=A_1$$$, we can break the loop if $$$(B_2 - A_2) \mod             B_1=0$$$, otherwise the answer is             &quot;$$$impossible$$$&quot;. </li>           <li> If $$$B_1 \ne A_1$$$, we can calculate how many             $$$rollback$$$ operations we should apply to transform             $$$B=[x, y]$$$ into $$$[x, y \mod x]$$$, modify the answer             accordingly and jump to the next iteration for $$$B=[y \mod             x, x]$$$ (after applying one $$$reverse$$$ operation).         </li></ul> </li></ul>          <p>This algorithm is very similar to the Euclidian's algorithm, and       that's how we can prove there will be $$$\mathcal{O}(\log C)$$$ $$$rollback$$$s.</p>     <p>The overall complexity is $$$\mathcal{O}(n\cdot ans)$$$ for       $$$n&gt;2$$$;  $$$\mathcal{O}(\log C)$$$ for $$$n=2$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

#define int long long
const int LIM = 2e5;

bool is_increasing(const vector&lt;int&gt; &amp;vec) {
  for (int i = 0; i &lt; vec.size() - 1; i++) {
    if (vec[i] &gt;= vec[i + 1])
      return false;
  }
  return true;
}

bool is_decreasing(const vector&lt;int&gt; &amp;vec) {
  for (int i = 0; i &lt; vec.size() - 1; i++) {
    if (vec[i] &lt;= vec[i + 1])
      return false;
  }
  return true;
}

vector&lt;int&gt; rollback(const vector&lt;int&gt; &amp;vec) {
  vector&lt;int&gt; ans(vec.size());
  ans[0] = vec[0];
  for (int i = 1; i &lt; vec.size(); i++)
    ans[i] = vec[i] - vec[i - 1];
  return ans;
}

signed main() {
  int n;
  cin &gt;&gt; n;
  vector&lt;int&gt; a(n), b(n);
  for (int &amp;i : a)
    cin &gt;&gt; i;
  for (int &amp;i : b)
    cin &gt;&gt; i;
  vector&lt;int&gt; a_rev = a;
  reverse(a_rev.begin(), a_rev.end());

  if (n == 1) {
    if (a == b)
      cout &lt;&lt; &#34;SMALL&#34; &lt;&lt; &#39;\n&#39; &lt;&lt; 0 &lt;&lt; &#39;\n&#39;;
    else
      cout &lt;&lt; &#34;IMPOSSIBLE&#34; &lt;&lt; &#39;\n&#39;;
    return 0;
  }

  int sum_a = accumulate(a.begin(), a.end(), 0LL);
  int sum_b = accumulate(b.begin(), b.end(), 0LL);
  int rollback_cnt = 0;

  if (n == 2) {
    vector&lt;int&gt; ans; // -1 = R, X = PPP..PP (x times)
    int move_cnt = 0, roll_cnt = 0;  // both types

    bool rev = a[0] &gt; a[1];
    if (rev)
      swap(a[0], a[1]);

    if (b[0] &gt; b[1]) {
      swap(b[0], b[1]);
      ans.push_back(-1);
      move_cnt++;
    }
    while (true) {
      if (sum_a &gt; sum_b) {
        cout &lt;&lt; &#34;IMPOSSIBLE&#34; &lt;&lt; &#39;\n&#39;;
        return 0;
      }

      if (sum_a == sum_b) {
        if (a != b) {
          cout &lt;&lt; &#34;IMPOSSIBLE&#34; &lt;&lt; &#39;\n&#39;;
          return 0;
        }

        if (rev) {
          ans.push_back(-1);
          move_cnt++;
        }

        if (rollback_cnt &gt; LIM) {
          cout &lt;&lt; &#34;BIG&#34; &lt;&lt; &#39;\n&#39; &lt;&lt; rollback_cnt &lt;&lt; &#39;\n&#39;;
          return 0;
        } else {
          cout &lt;&lt; &#34;SMALL&#34; &lt;&lt; &#39;\n&#39; &lt;&lt; move_cnt &lt;&lt; &#39;\n&#39;;
          reverse(ans.begin(), ans.end());
          for (auto i : ans) {
            if (i == -1)
              cout &lt;&lt; &#34;R&#34;;
            else {
              for (int _ = 0; _ &lt; i; _++)
                cout &lt;&lt; &#34;P&#34;;
            }
          }
          cout &lt;&lt; &#39;\n&#39;;
          return 0;
        }
      }

      if (a[0] == b[0]) {
        if ((b[1] - a[1]) % b[0] == 0) {
          roll_cnt = (b[1] - a[1]) / b[0];
          ans.push_back(roll_cnt);
          move_cnt += roll_cnt, rollback_cnt += roll_cnt;
          b = a;
          sum_b = b[0] + b[1];
        } else {
          cout &lt;&lt; &#34;IMPOSSIBLE&#34; &lt;&lt; &#39;\n&#39;;
          return 0;
        }
      } else {
        roll_cnt = b[1] / b[0];
        ans.push_back(roll_cnt);
        move_cnt += roll_cnt, rollback_cnt += roll_cnt;

        ans.push_back(-1);
        move_cnt++;
        swap(b[0], b[1]);
        b[0] %= b[1];
        sum_b = b[0] + b[1];
      }
    }
  }

  string ans;

  while (true) {
    if (sum_a == sum_b) {
      if (a_rev == b) {
        ans.push_back(&#39;R&#39;);
        reverse(b.begin(), b.end());
      }
      if (a == b) {
        reverse(ans.begin(), ans.end());
        if (rollback_cnt &gt; LIM)
          cout &lt;&lt; &#34;BIG&#34; &lt;&lt; &#39;\n&#39; &lt;&lt; rollback_cnt &lt;&lt; &#39;\n&#39;;
        else
          cout &lt;&lt; &#34;SMALL&#34; &lt;&lt; &#39;\n&#39; &lt;&lt; ans.size() &lt;&lt; &#39;\n&#39; &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
      } else
        cout &lt;&lt; &#34;IMPOSSIBLE&#34; &lt;&lt; &#39;\n&#39;;
      return 0;
    } else if (is_increasing(b)) {
      b = rollback(b);
      sum_b = accumulate(b.begin(), b.end(), 0LL);
      ans += &#39;P&#39;;
      rollback_cnt++;
    } else if (is_decreasing(b)) {
      reverse(b.begin(), b.end());
      ans += &#39;R&#39;;
    } else {
      cout &lt;&lt; &#34;IMPOSSIBLE&#34; &lt;&lt; &#39;\n&#39;;
      return 0;
    }
  }
}
</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;
#define int long long

signed main() {
  int n;
  cin &gt;&gt; n;
  vector&lt;int&gt; a(n), b(n);
  for (int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i];
  for (int i = 0; i &lt; n; ++i) cin &gt;&gt; b[i];
  if (n == 1) {
    if (a[0] == b[0]) cout &lt;&lt; &#34;SMALL\n&#34; &lt;&lt; 0;
    else cout &lt;&lt; &#34;IMPOSSIBLE&#34;;
    return 0;
  }
  if (n == 2) {
    vector&lt;pair&lt;int, bool&gt;&gt; res;
    int kol = 0;
    while (true) {
      if (b[0] == 0 || b[1] == 0) {
        cout &lt;&lt; &#34;IMPOSSIBLE&#34;;
        return 0;
      }
      if (a == b) break;
      if (a[0] == b[1] &amp;&amp; a[1] == b[0]) {
        res.emplace_back(1, false);
        break;
      }
      if (b[0] == b[1]) {
        cout &lt;&lt; &#34;IMPOSSIBLE&#34;;
        return 0;
      }
      if (b[0] &gt; b[1]) {
        res.emplace_back(1, false);
        swap(b[0], b[1]);
      }
      if (a[0] == b[0] &amp;&amp; a[1] &lt; b[1] &amp;&amp; a[1] % b[0] == b[1] % b[0]) {
        res.emplace_back((b[1] - a[1]) / b[0], true);
        kol += res.back().first;
        break;
      }
      if (a[1] == b[0] &amp;&amp; a[0] &lt; b[1] &amp;&amp; a[0] % b[0] == b[1] % b[0]) {
        res.emplace_back((b[1] - a[0]) / b[0], true);
        kol += res.back().first;
        res.emplace_back(1, false);
        break;
      }
      kol += b[1] / b[0];
      res.emplace_back(b[1] / b[0], true);
      b[1] %= b[0];
    }
    if (kol &gt; 2e5) {
      cout &lt;&lt; &#34;BIG\n&#34;;
      cout &lt;&lt; kol;
    } else {
      cout &lt;&lt; &#34;SMALL\n&#34;;
      int flex = 0;
      for (auto i : res) flex += i.first;
      cout &lt;&lt; flex &lt;&lt; &#34;\n&#34;;
      for (int i = res.size() - 1; i &gt;= 0; --i) {
        for (int j = 0; j &lt; res[i].first; ++j) {
          if (res[i].second) cout &lt;&lt; &#34;P&#34;;
          else cout &lt;&lt; &#34;R&#34;;
        }
      }
    }
    return 0;
  }
  vector&lt;bool&gt; ans;
  int kol = 0;
  while (true) {
    if (a == b) break;
    reverse(b.begin(), b.end());
    if (a == b) {
      ans.push_back(false);
      break;
    }
    reverse(b.begin(), b.end());
    bool vozr = false, ub = false, r = false;
    for (int i = 1; i &lt; n; ++i) {
      if (b[i] &gt; b[i - 1]) vozr = true;
      else if (b[i] &lt; b[i - 1]) ub = true;
      else r = true;
    }
    if (r || (vozr &amp;&amp; ub)) {
      cout &lt;&lt; &#34;IMPOSSIBLE&#34;;
      return 0;
    }
    vector&lt;int&gt; c(n);
    if (ub) {
      ans.push_back(false);
      reverse(b.begin(), b.end());
    }
    c[0] = b[0];
    for (int i = 1; i &lt; n; ++i) {
      c[i] = b[i] - b[i - 1];
    }
    ans.push_back(true);
    b = c;
    ++kol;
  }
  if (kol &gt; 2e5) {
    cout &lt;&lt; &#34;BIG\n&#34; &lt;&lt; kol;
  } else {
    cout &lt;&lt; &#34;SMALL\n&#34; &lt;&lt; ans.size() &lt;&lt; &#34;\n&#34;;
    for (int i = ans.size() - 1; i &gt;= 0; --i) {
      if (ans[i]) cout &lt;&lt; &#34;P&#34;;
      else cout &lt;&lt; &#34;R&#34;;
    }
  }
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 88 (рейтинговый для Див. 2)
    1359A
    Берляндский покер </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Берляндский покер</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>В берляндский покер играют с колодой из $$$n$$$ карт, $$$m$$$ из       которых являются джокерами. В игре участвует $$$k$$$ игроков       ($$$n$$$ делится на $$$k$$$).</p>     <p>В начале игры каждый игрок берет $$$\frac{n}{k}$$$ карт из колоды       (таким образом, каждая карта берется ровно одним игроком). Игрок,       у которого максимальное количество джокеров в руке, является       победителем, и он получает количество очков, равное $$$x - y$$$,       где $$$x$$$ — количество джокеров в руке победителя, а $$$y$$$ —       максимальное количество джокеров среди всех других игроков. Если       есть два или более игроков с максимальным количеством джокеров,       все они являются победителями, и они получают $$$0$$$ очков.</p>     <p>Вот несколько примеров:</p>          <ul> <li> $$$n = 8$$$, $$$m = 3$$$, $$$k = 2$$$. Если один игрок         получает $$$3$$$ джокера и $$$1$$$ простую карту, а другой игрок         получает $$$0$$$ джокеров и $$$4$$$ простые карты, то первый         игрок является победителем и получает $$$3 - 0 = 3$$$ очка; </li>       <li> $$$n = 4$$$, $$$m = 2$$$, $$$k = 4$$$. Два игрока получают         простые карты, а два других игрока получают джокеры, так что оба         они являются победителями и получают $$$0$$$ очков; </li>       <li> $$$n = 9$$$, $$$m = 6$$$, $$$k = 3$$$. Если первый игрок         получает $$$3$$$ джокера, второй игрок получает $$$1$$$ джокера         и $$$2$$$ простые карты, а третий игрок получает $$$2$$$ джокера         и $$$1$$$ простую карту, то первый игрок является победителем, и         он получает $$$3 - 2 = 1$$$ очко; </li>       <li> $$$n = 42$$$, $$$m = 0$$$, $$$k = 7$$$. Поскольку джокеров         нет, каждый получает $$$0$$$ джокеров, каждый является         победителем, и каждый получает $$$0$$$ очков. </li></ul>          <p>Для заданных $$$n$$$, $$$m$$$ и $$$k$$$ вычислите максимальное       количество очков, которое игрок может получить за победу в игре.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка входных данных содержит одно целое число $$$t$$$       ($$$1 \le t \le 500$$$) — количество наборов входных данных.</p>     <p>Каждый набор входных данных содержит три целых числа $$$n$$$,       $$$m$$$ и $$$k$$$ ($$$2 \le n \le 50$$$, $$$0 \le m \le n$$$, $$$2       \le k \le n$$$, $$$k$$$ делит $$$n$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите одно целое число —       максимальное количество очков, которое игрок может получить за       победу в игре.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
8 3 2
4 2 4
9 6 3
42 0 7
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
0
1
0
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Тесты из примера разобраны в условии.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1359/problem/A' title='Educational Codeforces Round 88 (Rated for Div. 2)'>1359A - Berland Poker</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>There are many different ways to solve this problem. The easiest       one, in my opinion, is to iterate on the number of jokers the       winner has (let it be $$$a_1$$$) and the number of jokers the       runner-up has (let it be $$$a_2$$$). Then the following conditions       should be met:</p>          <ul> <li> $$$a_1 \ge a_2$$$ (the winner doesn't have less jokers         than the runner-up); </li>       <li> $$$a_1 \le \frac{n}{k}$$$ (the number of jokers in the         winner's hand does not exceed the number of cards in his hand); </li>       <li> $$$a_1 + a_2 \le m$$$ (the number of jokers for these two         players does not exceed the total number of jokers); </li>       <li> $$$a_1 + (k - 1)a_2 \ge m$$$ (it is possible to redistribute         remaining jokers among other players so that they have at most         $$$a_2$$$ jokers). </li></ul>          <p>Iterating on $$$a_1$$$ and $$$a_2$$$, then checking these       constraints gives us a $$$O(n^2)$$$ solution. It is possible to       get a constant-time solution using some greedy assumptions and       math (the first player should get as many jokers as possible,       while the remaining jokers should be evenly distributed among       other players).</p></div></div></div>

           
            <pre><code>t = int(input())

for i in range(t):
    n, m, k = map(int, input().split())
    d = n // k
    a1 = min(m, d)
    a2 = (m - a1 + k - 2) // (k - 1)
    print(a1 - a2)
</code></pre>
           
            <pre><code>t = int(input())

for i in range(t):
    n, m, k = map(int, input().split())
    ans = 0
    d = n // k
    for a1 in range(m + 1):
        for a2 in range(a1 + 1):
            if(a1 &gt; d):
                continue
            if(a1 + a2 &gt; m):
                continue
            if(a1 + (k - 1) * a2 &lt; m):
                continue
            ans = max(ans, a1 - a2)
    print(ans)
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 88 (рейтинговый для Див. 2)
    1359B
    Новая Театральная площадь </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Новая Театральная площадь</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Возможно, вы помните Театральную площадь из <a href="https://codeforces.com/problemset/problem/1/A">задачи       1A</a>. Сегодня ее покрытие наконец-то заменят.</p>     <p>Площадь все еще является прямоугольником $$$n \times m$$$ метров.       Однако, рисунок на ней будет более сложным в этот раз. Пусть       $$$a_{i,j}$$$ будет $$$j$$$-й ячейкой в $$$i$$$-м ряду покрытия плитками.</p>     <p>Вам задан рисунок покрытия:</p>          <ul> <li> если $$$a_{i,j} = $$$ «<span class="tex-font-style-tt">*</span>», то $$$j$$$-я ячейка в         $$$i$$$-м ряду должна быть <span class="tex-font-style-bf">черной</span>; </li>       <li> если $$$a_{i,j} = $$$ «<span class="tex-font-style-tt">.</span>», то $$$j$$$-я ячейка в         $$$i$$$-м ряду должна быть <span class="tex-font-style-bf">белой</span>. </li></ul>          <p>Черные ячейки уже покрыты. Вам же необходимо покрыть белые       ячейки. Существует две опции плиток:</p>          <ul> <li> $$$1 \times 1$$$ плитки — каждая плитка стоит $$$x$$$         бурлей и покрывает ровно $$$1$$$ ячейку; </li>       <li> $$$1 \times 2$$$ плитки — каждая плитка стоит $$$y$$$ бурлей         и покрывает ровно $$$2$$$ соседние ячейки в <span class="tex-font-style-bf">одном ряду</span>. <span class="tex-font-style-bf">Обратите внимание, что нельзя           вращать эти плитки или резать их на плитки $$$1 \times         1$$$.</span> </li></ul>          <p>       <span class="tex-font-style-bf">Вам необходимо покрыть все белые         ячейки, никакие две плитки не должны накладываться друг на друга         и никакие черные ячейки не должны быть накрыты плитками</span>.</p>     <p>Чему равна наименьшая суммарная цена плиток, которые могут       покрыть все белые клетки?</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$t$$$ ($$$1 \le t \le       500$$$) — количество наборов входных данных. Затем следует       описание $$$t$$$ наборов.</p>     <p>В первой строке каждого набора входных данных записаны четыре       целых числа $$$n$$$, $$$m$$$, $$$x$$$ и $$$y$$$ ($$$1 \le n \le       100$$$; $$$1 \le m \le 1000$$$; $$$1 \le x, y \le 1000$$$) —       размеры Театральной площади, цена плитки $$$1 \times 1$$$ и цена       плитки $$$1 \times 2$$$.</p>     <p>В каждой из следующих $$$n$$$ строк записаны по $$$m$$$ символов.       $$$j$$$-й символ в $$$i$$$-й строке — это $$$a_{i,j}$$$. Если       $$$a_{i,j} = $$$ «<span class="tex-font-style-tt">*</span>», то       $$$j$$$-я ячейка в $$$i$$$-м ряду должна быть <span class="tex-font-style-bf">черной</span>, а если $$$a_{i,j} = $$$         «<span class="tex-font-style-tt">.</span>», то $$$j$$$-я ячейка       в $$$i$$$-м ряду должна быть <span class="tex-font-style-bf">белой</span>.</p>     <p>       <span class="tex-font-style-bf">Гарантируется, что сумма $$$n         \times m$$$ по всем наборам входных данных не превышает $$$10^5$$$</span>.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите одно целое число —       наименьшая суммарная цена плиток, которые могут покрыть все белые       клетки, в бурлях.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
1 1 10 1
.
1 2 10 1
..
2 1 10 1
.
.
3 3 3 7
..*
*..
.*.
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
10
1
20
18
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных необходимо использовать одну       плитку $$$1 \times 1$$$, несмотря на то, что плитка $$$1 \times       2$$$ дешевле. Поэтому суммарная цена равна $$$10$$$ бурлей.</p>     <p>Во втором наборе можно использовать либо две плитки $$$1 \times       1$$$ и потратить $$$20$$$ бурлей, либо одну плитку $$$1 \times       2$$$ плитку и потратить $$$1$$$ бурль. Второй вариант дешевле,       поэтому ответ равен $$$1$$$.</p>     <p>Третий набор показывает, что нельзя поворачивать плитки $$$1       \times 2$$$. Приходится использовать две плитки $$$1 \times 1$$$ с       суммарной ценой $$$20$$$.</p>     <p>В четвертом наборе самый дешевый способ — это использовать $$$1       \times 1$$$ плитки повсюду. Итоговая цена — $$$6 \cdot 3 = 18$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1359/problem/B' title='Educational Codeforces Round 88 (Rated for Div. 2)'>1359B - New Theatre Square</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Notice that rows can be solved completely separately of each       other. Each tile takes either one or two squares but it's always       in the same row.</p>     <p>So let's take a look at a single row. There are sequences of dot       characters separated by some asterisks. Once again each of these       sequences can be solved independently of the others.</p>     <p>Thus, we have these empty strips of empty squares $$$1 \times       k$$$ which, when solved, can be summed up into the whole answer.</p>     <p>There are two cases, depending on if a $$$1 \times 2$$$ is       cheaper than two $$$1 \times 1$$$ tiles. </p>     <p>If it is then we want to use of many $$$1 \times 2$$$ tiles as       possible. So given $$$k$$$, we can place $$$\lfloor \frac k 2       \rfloor$$$ $$$1 \times 2$$$ tiles and cover the rest $$$k - 2       \cdot \lfloor \frac k 2 \rfloor = k~mod~2$$$ squares with $$$1       \times 1$$$ tiles.</p>     <p>If it isn't cheaper then we want to cover everything with $$$1       \times 1$$$ tiles and never use $$$1 \times 2$$$ ones. So all       $$$k$$$ should be $$$1 \times 1$$$.</p>     <p>The easier way to implement this might be the following. Let's       update the price of the $$$1 \times 2$$$ tile with the minimum of       $$$y$$$ and $$$2 \cdot x$$$. This way the first algorithm will       produce exactly the same result of the second one in the case when       a $$$1 \times 2$$$ tile isn't cheaper than two $$$1 \times 1$$$ ones.</p>     <p>Overall complexity: $$$O(nm)$$$ per testcase.</p></div></div></div>

           
            <pre><code>t = int(input())
for _ in range(t):
	n, m, x, y = map(int, input().split())
	ans = 0
	y = min(y, 2 * x)
	for __ in range(n):
		s = input()
		i = 0
		while i &lt; m:
			if s[i] == &#39;*&#39;:
				i += 1
				continue
			j = i
			while j + 1 &lt; m and s[j + 1] == &#39;.&#39;:
				j += 1
			l = j - i + 1
			ans += l % 2 * x + l // 2 * y
			i = j + 1
	print(ans)
</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;

#define forn(i, n) for (int i = 0; i &lt; int(n); i++)

using namespace std;


int main() {
	int tc;
	scanf(&#34;%d&#34;, &amp;tc);
	forn(_, tc){
		int h, c, t;
		scanf(&#34;%d%d%d&#34;, &amp;h, &amp;c, &amp;t);
		if (h + c - 2 * t &gt;= 0)
			puts(&#34;2&#34;);
		else{
			int a = h - t;
			int b = 2 * t - c - h;
			int k = 2 * (a / b) + 1;
			long long val1 = abs(k / 2 * 1ll * c + (k + 1) / 2 * 1ll * h - t * 1ll * k);
			long long val2 = abs((k + 2) / 2 * 1ll * c + (k + 3) / 2 * 1ll * h - t * 1ll * (k + 2));
			printf(&#34;%d\n&#34;, val1 * (k + 2) &lt;= val2 * k ? k : k + 2);
		}
	}
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 88 (рейтинговый для Див. 2)
    1359C
    Смешиваем воду </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Смешиваем воду</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Есть два бесконечных источника воды:</p>          <ul> <li> горячая вода температуры $$$h$$$; </li>       <li> холодная вода температуры $$$c$$$ ($$$c &lt; h$$$). </li></ul>          <p>Вы совершаете следующую чередующуюся последовательность действий:</p>          <ol> <li> набрать <span class="tex-font-style-bf">одну</span> кружку           <span class="tex-font-style-bf">горячей</span> воды и вылить         ее в бесконечно глубокую бочку; </li>       <li> набрать <span class="tex-font-style-bf">одну</span> кружку           <span class="tex-font-style-bf">холодной</span> воды и вылить         ее в бесконечно глубокую бочку; </li>       <li> набрать <span class="tex-font-style-bf">одну</span> кружку           <span class="tex-font-style-bf">горячей</span> воды         $$$\dots$$$ </li>       <li> и так далее $$$\dots$$$ </li></ol>          <p>       <span class="tex-font-style-bf">Обратите внимание, что вы всегда         начинаете с кружки горячей воды</span>.</p>     <p>Бочка изначально пустая. Необходимо налить <span class="tex-font-style-bf">хотя бы одну кружку</span> в бочку.       Температура воды в бочке равна средней температуре вылитых кружек.</p>     <p>Вы хотите получить воду температуры как можно ближе к $$$t$$$. То       есть если температура воды в бочке равна $$$t_b$$$, то <span class="tex-font-style-bf">абсолютная разность</span> $$$t_b$$$ и       $$$t$$$ ($$$|t_b - t|$$$) должна быть минимально возможна.</p>     <p>Сколько кружек необходимо налить в бочку, чтобы температура стала       как можно ближе к $$$t$$$? Если существует несколько ответов с       минимальной абсолютной разностью, то выведите наименьший из них.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$T$$$ ($$$1 \le T \le       3 \cdot 10^4$$$) — количество наборов входных данных.</p>     <p>В каждой из следующих $$$T$$$ строк записаны по три целых числа       $$$h$$$, $$$c$$$ и $$$t$$$ ($$$1 \le c &lt; h \le 10^6$$$; $$$c       \le t \le h$$$) — температура горячей воды, температура холодной       воды и желаемая температура в бочке.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>На каждый набор входных данных выведите одно положительное целое       число — минимальной количество кружек, которое необходимо вылить в       бочку, чтобы получить температуру, как можно более близкую к $$$t$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
30 10 20
41 15 30
18 13 18
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
7
1
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных температура после $$$2$$$ налитых       кружек: $$$1$$$ горячей и $$$1$$$ холодной — равна $$$20$$$. И это       самое близкое возможное значение.</p>     <p>Во втором наборе температура после $$$7$$$ налитых кружек:       $$$4$$$ горячих и $$$3$$$ холодных — примерно $$$29.857$$$. Если       наливать больше воды, то температура не станет ближе к $$$t$$$.</p>     <p>В третьем наборе температура после $$$1$$$ налитой кружки:       $$$1$$$ горячей — равна $$$18$$$. Это совпадает с $$$t$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1359/problem/C' title='Educational Codeforces Round 88 (Rated for Div. 2)'>1359C - Mixing Water</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>So there are two kinds of stops to consider: $$$k$$$ hot and       $$$k$$$ cold cup and $$$(k + 1)$$$ hot and $$$k$$$ cold cups.</p>     <p>The first case is trivial: the temperature is always $$$\frac{h +       c}{2}$$$. In the second case the temperature is always strictly       greater than $$$\frac{h + c}{2}$$$. Thus, if $$$t \le \frac{h +       c}{2}$$$, then the answer is $$$2$$$.</p>     <p>Let's show that otherwise the answer is always achieved through       the second case.</p>     <p>The temperature after $$$(k + 1)$$$ hot cups and $$$k$$$ cold       cups is $$$t_k = \frac{(k + 1) \cdot h + k \cdot c}{2k + 1}$$$.       The claim is that $$$t_0 &gt; t_1 &gt; \dots$$$. Let's prove that       by induction.</p>     <p>$$$t_0 = h, t_1 = \frac{2 \cdot h + c}{3}$$$. $$$c &lt; h$$$,       thus $$$t_0 &gt; t_1$$$.</p>     <p>Now compare $$$t_k$$$ and $$$t_{k+1}$$$.</p>     <p>$$$$$$t_k &gt; t_{k+1}$$$$$$</p>     <p>$$$$$$\frac{(k + 1) \cdot h + k \cdot c}{2k + 1} &gt; \frac{(k +       2) \cdot h + (k + 1) \cdot c}{2k + 3}$$$$$$</p>     <p>$$$$$$\frac{k \cdot (h + c) + h}{2k + 1} &gt; \frac{(k + 1) \cdot       (h + c) + h}{2k + 3}$$$$$$</p>     <p>$$$$$$2k \cdot (k \cdot (h + c) + h) + 3k \cdot (h + c) + 3h &gt;       2k \cdot ((k + 1) \cdot (h + c) + h) + (k + 1) \cdot (h + c) + h$$$$$$</p>     <p>$$$$$$2k \cdot (k \cdot (h + c) + h - (k + 1) \cdot (h + c) - h)       &gt; (k + 1) \cdot (h + c) + h - 3k \cdot (h + c) - 3h$$$$$$</p>     <p>$$$$$$2k \cdot (-(h + c)) &gt; (-2k + 1) \cdot (h + c) - 2h$$$$$$</p>     <p>$$$$$$2h &gt; (h + c)$$$$$$</p>     <p>$$$$$$h &gt; c$$$$$$</p>     <p>We can also show that this series converges to $$$\frac{h + c}{2}$$$:</p>     <p>I'm sorry that I'm not proficient with any calculus but my       intuition says that it's enough to show that $$$\forall k~t_k &gt;       \frac{h + c}{2}$$$ and $$$\forall \varepsilon \exists k~t_k &lt;       \frac{h + c}{2}$$$ with $$$k \ge 0$$$.</p>     <p>So the first part is:</p>     <p>$$$$$$\frac{(k + 1) \cdot h + k \cdot c}{2k + 1} &gt; \frac{h + c}{2}$$$$$$</p>     <p>$$$$$$\frac{k \cdot (h + c) + h}{2k + 1} &gt; \frac{h + c}{2}$$$$$$</p>     <p>$$$$$$2k \cdot (h + c) + 2h &gt; (2k + 1) \cdot (h + c)$$$$$$</p>     <p>$$$$$$2h &gt; h + c$$$$$$</p>     <p>$$$$$$h &gt; c$$$$$$</p>     <p>And the second part is:</p>     <p>$$$$$$\frac{(k + 1) \cdot h + k \cdot c}{2k + 1} &lt; \frac{h +       c}{2} + \varepsilon$$$$$$</p>     <p>$$$$$$\frac{k \cdot (h + c) + h}{2k + 1} &lt; \frac{h + c}{2} + \varepsilon$$$$$$</p>     <p>$$$$$$2k \cdot (h + c) + 2h &lt; (2k + 1) \cdot (h + c) + (2k +       1) \cdot \varepsilon$$$$$$</p>     <p>$$$$$$2h &lt; (h + c) + (2k + 1) \cdot \varepsilon$$$$$$</p>     <p>$$$$$$h &lt; c + (2k + 1) \cdot \varepsilon$$$$$$</p>     <p>$$$$$$\frac{h - c}{\varepsilon} &lt; 2k + 1$$$$$$</p>     <p>So that claim makes us see that for any $$$t$$$ greater than       $$$\frac{h + c}{2}$$$ the answer is always achieved from the       second case.</p>     <p>That allows us to find such $$$k$$$, that the value of $$$t_k$$$       is exactly $$$t$$$. However, such $$$k$$$ might not be integer.       $$$\frac{(k + 1) \cdot h + c}{2k + 1} = t \leftrightarrow$$$       $$$\frac{k \cdot (h + c) + h}{2k + 1} = t \leftrightarrow$$$ $$$k       \cdot (h + c) + h = 2kt + t \leftrightarrow$$$ $$$k \cdot (h + c -       2t) = t - h \leftrightarrow$$$ $$$k = \frac{t - h}{h + c - 2t}$$$.</p>     <p>The only thing left is to compare which side is better to round       $$$k$$$ to. It seems some implementations with float numbers might       fail due to precision errors. However, it's possible to do these       calculations completely in integers.</p>     <p>Let's actually rewrite that so that the denominator is always       positive $$$k = \frac{h - t}{2t - h - c}$$$. Now we can round this       value down and compare $$$k$$$ and $$$k + 1$$$.</p>     <p>So the optimal value is $$$k$$$ if $$$|\frac{k \cdot (h + c) +       h}{2k + 1} - t| \le |\frac{(k + 1) \cdot (h + c) + h}{2k + 3}| -       t$$$. So $$$|(k \cdot (h + c) + h) - t \cdot (2k + 1)| \cdot (2k +       3) \le |((k + 1) \cdot (h + c) + h) - t \cdot (2k + 3)| \cdot (2k       + 1)$$$. Otherwise, the answer is $$$k + 1$$$.</p>     <p>You can also find the optimal $$$k$$$ with binary search but the       formulas are exactly the same and you have to rely on monotonosity       as well. Also, these formulas can get you the better understanding       for the upper bound of the answer.</p>     <p>Overall complexity: $$$O(1)$$$ or $$$O(\log h)$$$ per testcase.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 88 (рейтинговый для Див. 2)
    1359D
    Очередная очередная задача </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Очередная очередная задача</div>     <div class="time-limit"><div class="property-title">ограничение по времени на       тест</div>1.5 секунд</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Алиса и Боб играют в очередную игру с карточками. На этот раз       правила следующие. Перед ними в ряд лежат $$$n$$$ карточек. У       $$$i$$$-й карточки значение $$$a_i$$$.</p>     <p>Сначала Алиса выбирает непустой последовательный отрезок карточек       $$$[l; r]$$$ ($$$l \le r$$$). Затем Боб удаляет одну карточку       $$$j$$$ из этого отрезка $$$(l \le j \le r)$$$. Счет игры равен       сумме значений оставшихся на отрезке карточек $$$(a_l + a_{l + 1}       + \dots + a_{j - 1} + a_{j + 1} + \dots + a_{r - 1} + a_r)$$$. В       частности, если Алиса выбрала отрезок с ровно одним элементом, то       после того, как Боб удалит единственную карточку, счет будет равен $$$0$$$.</p>     <p>Алиса хочет сделать счет как можно больше. Боб удаляет такую       карточку, чтобы счет стал как можно меньше.</p>     <p>Какой отрезок должна выбрать Алиса, чтобы счет был максимально       возможным? Выведите максимальный счет.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$n$$$ ($$$1 \le n \le       10^5$$$) — количество карточек.</p>     <p>Во второй строке записаны $$$n$$$ целых чисел $$$a_1, a_2, \dots,       a_n$$$ ($$$-30 \le a_i \le 30$$$) — значения на карточках.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одно целое число — итоговый счет игры.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
5 -2 10 -1 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
6
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
8
5 2 5 3 -30 -30 6 9
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
10
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
-10 6 -15
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере Алиса выбирает отрезок $$$[1;5]$$$ — весь ряд       карточек. Боб удаляет карточку $$$3$$$ со значением $$$10$$$ из       этого отрезка. Поэтому итоговый счет равен $$$5 + (-2) + (-1) + 4       = 6$$$.</p>     <p>Во втором примере Алиса выбирает отрезок $$$[1;4]$$$, и так как       Боб удаляет либо карточку $$$1$$$, либо $$$3$$$, со значением       $$$5$$$, то ответ становится $$$5 + 2 + 3 = 10$$$.</p>     <p>В третьем примере Алиса может выбрать любой из отрезков длины       $$$1$$$: $$$[1;1]$$$, $$$[2;2]$$$ или $$$[3;3]$$$. Боб удаляет       единственную карточку, поэтому счет равен $$$0$$$. Если Алиса       выберет любой другой отрезок, то ответ будет меньше $$$0$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1359/problem/D' title='Educational Codeforces Round 88 (Rated for Div. 2)'>1359D - Yet Another Yet Another Task</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Alice wants to choose such a segment $$$[l; r]$$$ that $$$\sum       \limits_{l \le i \le r} a_i - \max \limits_{l \le i \le r} a_i$$$       is maximum possible. </p>     <p>There is a well-known problem where you have to find a segment       with maximum $$$\sum \limits_{l \le i \le r} a_i$$$. That problem       is solved with Kadane algorithm. Let's learn how to reduce our       problem to that one.</p>     <p>Notice that the values in the array are unusually small. Let's       iterate over the maximum value on segment. Let $$$mx$$$ be the       current value. If we make all $$$a_i$$$ such that $$$a_i &gt;       mx$$$ equal to $$$-\infty$$$, then it will never be optimal to       take them in a segment. Find the maximum sum subarray in that       modified array and update the answer with its $$$sum - mx$$$.</p>     <p>Notice that you can ignore the fact if there is a value exactly       equal to $$$mx$$$ on the maximum sum segment. If there isn't then       you'll update the answer with a smaller value than the actual one.       Let the actual maximum on the maximum sum segment be some $$$y$$$.       You can see that for any value between $$$y$$$ and $$$mx$$$ the       maximum sum segment will always be that chosen one. Thus, when you       reach $$$y$$$, you'll update the answer with the correct value.</p>     <p>Overall complexity: $$$O(\max a_i \cdot n)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

#define forn(i, n) for (int i = 0; i &lt; int(n); i++)

using namespace std;

const int INF = 1e9;

int main() {
	int n;
	scanf(&#34;%d&#34;, &amp;n);
	vector&lt;int&gt; a(n);
	forn(i, n) scanf(&#34;%d&#34;, &amp;a[i]);
	long long ans = 0;
	forn(mx, 31){
		long long cur = 0;
		long long best = 0;
		forn(i, n){
			int val = (a[i] &gt; mx ? -INF : a[i]);
			cur += val;
			best = min(best, cur);
			ans = max(ans, (cur - best) - mx);
		}
	}
	printf(&#34;%lld\n&#34;, ans);
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 88 (рейтинговый для Див. 2)
    1359E
    Модульная стабильность </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. Модульная стабильность</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Обозначим за $$$x \bmod y$$$ остаток от целочисленного деления       $$$x$$$ на $$$y$$$ (оператор $$$\%$$$ в C++ или Java, <span class="tex-font-style-tt">mod</span> в Pascal).</p>     <p>Назовем массив целых чисел $$$[a_1, a_2, \dots, a_k]$$$ <span class="tex-font-style-it">стабильным</span>, если для каждой       перестановки $$$p$$$ целых чисел от $$$1$$$ до $$$k$$$, и для       каждого неотрицательного целого числа $$$x$$$ выполняется       следующее условие:</p>          <center> $$$ (((x \bmod a_1) \bmod a_2) \dots \bmod a_{k - 1}) \bmod       a_k = (((x \bmod a_{p_1}) \bmod a_{p_2}) \dots \bmod a_{p_{k -       1}}) \bmod a_{p_k} $$$ </center>          <p>Другими словами, для каждого неотрицательного целого $$$x$$$       значение $$$(((x \bmod a_1) \bmod a_2) \dots \bmod a_{k - 1})       \bmod a_k$$$ не зависит от порядка элементов в массиве $$$a$$$.</p>     <p>Для двух заданных целых чисел $$$n$$$ и $$$k$$$ посчитайте       количество <span class="tex-font-style-it">стабильных</span>       массивов $$$[a_1, a_2, \dots, a_k]$$$, в которых $$$1 \le a_1 &lt;       a_2 &lt; \dots &lt; a_k \le n$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В единственной строке заданы два целых числа $$$n$$$ и $$$k$$$       ($$$1 \le n, k \le 5 \cdot 10^5$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите количество <span class="tex-font-style-it">стабильных</span> массивов $$$[a_1, a_2,       \dots, a_k]$$$, в которых $$$1 \le a_1 &lt; a_2 &lt; \dots &lt;       a_k \le n$$$. Так как ответ может быть очень большим, выведите его       по модулю $$$998244353$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
7 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
16
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
3 7
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
1337 42
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
95147305
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
1 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
500000 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
500000
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1359/problem/E' title='Educational Codeforces Round 88 (Rated for Div. 2)'>1359E - Modular Stability</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>We claim that the array is stable if and only if all elements are       divisible by its minimum. The proof of this fact will be at the       end of the editorial.</p>     <p>To calculate the number of stable arrays now, we need to iterate       on the minimum in the array and choose the remaining elements so       that they are multiples of it. If the minimum is $$$i$$$, then the       resulting elements should be divisible by $$$i$$$. There are $$$d       = \lfloor\frac{n}{i}\rfloor$$$ such numbers between $$$1$$$ and       $$$n$$$, and we have to choose $$$k - 1$$$ elements out of $$$d -       1$$$ (since $$$i$$$ is already chosen). The number of ways to do       it can be calculated by precomputing factorials modulo       $$$998244353$$$, since it is a binomial coefficient.</p>     <p>       <span class="tex-font-style-bf">Proof of the claim at the         beginning of the editorial:</span></p>     <p>On the one hand, since $$$(x \bmod a) \bmod (ba) = (x \bmod (ba))       \bmod a = x \bmod a$$$, if all elements in the array are divisible       by some element, nothing depends on the order of these elements.</p>     <p>On the other hand, suppose there exists an element $$$a_i$$$ such       that it is not divisible by $$$a_1$$$. Let's take $$$x = a_i$$$       and two following reorders of the array $$$a$$$: $$$[a_1, a_2,       \dots, a_k]$$$ and $$$[a_i, a_1, a_2, \dots, a_{i - 1}, a_{i + 1},       \dots, a_k]$$$. For the first array, we get $$$x \bmod a_1 = a_i       \bmod a_1$$$, which is non-zero; and for the second array, $$$a_i       \bmod a_i = 0$$$, so the result is zero.</p></div></div></div>

           
            <pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;

const int N = 500043;
const int MOD = 998244353;

int fact[N];

int add(int x, int y)
{
	x += y;
	while(x &gt;= MOD) x -= MOD;
	while(x &lt; 0) x += MOD;
	return x;
}

int mul(int x, int y)
{
	return (x * 1ll * y) % MOD;
}

int binpow(int x, int y)
{
	int z = 1;
	while(y &gt; 0)
	{
		if(y % 2 == 1)
			z = mul(z, x);
		x = mul(x, x);
		y /= 2;
	}
	return z;
}

int inv(int x)
{
	return binpow(x, MOD - 2);
}

int divide(int x, int y)
{
	return mul(x, inv(y));
}

void precalc()
{
	fact[0] = 1;
	for(int i = 1; i &lt; N; i++)
		fact[i] = mul(i, fact[i - 1]);
}

int C(int n, int k)
{
	if(k &gt; n) return 0;
	return divide(fact[n], mul(fact[n - k], fact[k]));
}

int main()
{
	int n, k;
	cin &gt;&gt; n &gt;&gt; k;
	int ans = 0;
	precalc();
	for(int i = 1; i &lt;= n; i++)
	{
		int d = n / i;
		ans = add(ans, C(d - 1, k - 1));
	}
	cout &lt;&lt; ans &lt;&lt; endl;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 88 (рейтинговый для Див. 2)
    1359F
    Шоу взрывов на радиоуправлении </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Шоу взрывов на радиоуправлении</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>6 секунд</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Знаете, в наше время довольно сложно организовать шоу с большим       количеством участников и зрителей в одном месте. Тем не менее, вы       не отказываетесь от своей мечты провести шоу со взрывами машин! Вы       решили заменить настоящие машины радиоуправляемыми, назвать       мероприятия «Шоу взрывов на радиоуправлении» и транслировать все онлайн.</p>     <p>Для подготовки вы нашли арену — бесконечную 2D-сетку. Вы также       закупили $$$n$$$ радиоуправляемых машинок и расставили их по       арене. К сожалению, эти машинки могут ехать только вперед, без       возможности поворотов налево, направо или разворотов. Более того,       вы направили машинки туда, куда хотите, чтобы они поехали.</p>     <p>Формально, для каждой машинки $$$i$$$ ($$$1 \le i \le n$$$) вы       зафиксировали ее начальную позицию ($$$x_i, y_i$$$) и вектор       направление ($$$dx_i, dy_i$$$). Более того, у каждой машинки есть       константная скорость $$$s_i$$$ единиц в секунду. То есть после       запуска машинка $$$i$$$ двигается из ($$$x_i, y_i$$$) в       направлении ($$$dx_i, dy_i$$$) с константной скоростью $$$s_i$$$.</p>     <p>Цель вашего шоу — столкнуть две машинки как можно скорее! Вы       обратили внимание, что если запускать все машинки в самом начале       шоу, то довольно часто столкновений не происходит вообще. Поэтому       вы решили запустить $$$i$$$-ю машинку в некоторый момент       $$$t_i$$$. <span class="tex-font-style-bf">Вы еще не выбрали         $$$t_i$$$, это еще надо решить</span>. Обратите внимание, что       $$$t_i$$$ не обязательно должно быть целым, и допустимо, чтобы       $$$t_i$$$ совпадало с $$$t_j$$$ для любых $$$i, j$$$.</p>     <p>Шоу начинается в момент времени $$$0$$$. Шоу заканчивается, когда       какие-нибудь две машинки $$$i$$$ и $$$j$$$ ($$$i \ne j$$$)       сталкиваются (то есть оказываются в одной точке в одно и то же       время). Длительность шоу равна времени между началом и концом.</p>     <p>Какое самое быстрое столкновение вы можете организовать, выбрав       все $$$t_i$$$? Если возможно организовать столкновение, тогда       выведите минимальную возможную длительность шоу. Иначе сообщите,       что это невозможно.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$n$$$ ($$$1 \le n \le       25000$$$) — количество машинок.</p>     <p>В каждой из следующих $$$n$$$ строк записаны по пять целых чисел       $$$x_i$$$, $$$y_i$$$, $$$dx_i$$$, $$$dy_i$$$, $$$s_i$$$ ($$$-10^3       \le x_i, y_i \le 10^3$$$; $$$1 \le |dx_i| \le 10^3$$$; $$$1 \le       |dy_i| \le 10^3$$$; $$$1 \le s_i \le 10^3$$$) — начальная позиция       $$$i$$$-й машинки, ее вектор направления и ее скорость, соответственно.</p>     <p>       <span class="tex-font-style-bf">Гарантируется, что все машинки         начинают в различных позициях (то есть $$$(x_i, y_i) \neq (x_j,         y_j)$$$ для $$$i \neq j$$$).</span></p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите наименьшую возможную длительность шоу, если возможно       организовать столкновение, выбрав все $$$t_i$$$. Иначе, выведите         «<span class="tex-font-style-tt">No show :(</span>».</p>     <p>Ваш ответ будет считаться правильным, если его абсолютная или       относительная ошибка не превосходит $$$10^{-6}$$$.</p>     <p>Формально, пусть ваш ответ равен $$$a$$$, а ответ жюри равен       $$$b$$$. Ваш ответ будет зачтен, если и только если $$$\frac{|a -       b|}{\max{(1, |b|)}} \le 10^{-6}$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
3 -1 -1 1 2
2 3 -3 -2 10
-4 2 1 -2 1
-2 -2 -1 2 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0.585902082262898
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
-1 1 -1 1 200
1 1 1 5 200
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
No show :(
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Картинка для первого примера: </p>     <center> <img class="tex-graphics" src="https://espresso.codeforces.com/16d5fda96c67dc81d6c6dc1fd5bf565df8b977d7.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>Самое раннее возможное столкновение произойдет с машинками       $$$2$$$ и $$$4$$$. Запустим машинку $$$2$$$ в $$$0$$$, машинку       $$$4$$$ примерно в $$$0.096762$$$ и машинки $$$1$$$ и $$$3$$$       когда угодно. Тогда машинки $$$2$$$ и $$$4$$$ столкнутся примерно       в $$$0.585902$$$. Тогда вот как поле будет выглядеть в момент столкновения:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/9f49bf567d0bcdd60779341a6bf1da70d18c03cb.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>Вот картинка для второго примера:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/f0eac2dc847f0751a4ef51982a70780b0311fdc7.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1359/problem/F' title='Educational Codeforces Round 88 (Rated for Div. 2)'>1359F - RC Kaboom Show</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let $$$f(t)$$$ be true if it's possible to have a collision       before time $$$t$$$. That function is monotonous, thus let's       binary search for $$$t$$$.</p>     <p>For some fixed $$$t$$$ car $$$i$$$ can end up in any point from       $$$(x_i, y_i)$$$ to $$$s_i \cdot t$$$ units along the ray       $$$((x_i, y_i), (x_i + dx_i, y_i + dy_i))$$$. That makes it a segment.</p>     <p>So the collision can happen if some pair of segments intersects.       Let's learn how to find that out.</p>     <p>The general idea is to use sweep line. So let's add the events       that the $$$i$$$-th segment $$$(x1_i, y1_i, x2_i, y2_i)$$$ such       that $$$x1_i &lt; x2_i$$$ opens at $$$x1_i$$$ and closes at       $$$x2_i$$$. There were no vertical segments, so $$$x1_i$$$ and       $$$x2_i$$$ are always different. </p>     <p>At every moment of time $$$T$$$ we want to maintain the segments       ordered by their intersection with the line $$$x = T$$$. Note that       if two segments change their order moving along the sweep line,       then they intersect.</p>     <p>So we can maintain a set with a custom comparator that returns if       one segment intersects the current line lower than the other one.</p>     <p>When adding a segment to set, you want to check it's       intersections with the next segment in the order and the previous       one. When removing a segment, you want to check the intersection       between the next and the previous segment in the order. If any       check triggers, then return true immediately. It's easy to show       that if the intersection happens between some pair of segments,       then the intersection between only these pairs of segment also happens.</p>     <p>Now for the implementation details. Precision errors play a huge       role here since we use binary search and also store some stuff       dependant on floats in the set.</p>     <p>The solution I want to tell requires no epsilon comparisons, thus       it calculates the answer only with the precision of binary search.</p>     <p>So the first issue rises when we have to erase elements from the       set. Notice that we can make a mistake when we are adding the       segment and there is a segment with almost the same intersection       point. That will not make the answer incorrect (that's not trivial       to show but it's possible if you consider some cases). If you can       find it later to remove, then it's not an issue at all. However,       that will probably mess up the lower_bound in the set. </p>     <p>Thus, let's save the pointer to each element in the set and       remove it later by that pointer.</p>     <p>The second issue comes when you have to check the intersection of       two segments. The error might appear when one segment $$$((x_i,       y_i), (nx_i, ny_i))$$$ (let the first point be the original       $$$(x_i, y_i)$$$ and the second point be calculated depending on       $$$t$$$) has it's intersection point with segment $$$((x_j, y_j),       (nx_j, ny_j))$$$ at exactly $$$(x_i, y_i)$$$. So the slightest       miscalculations could matter a lot.</p>     <p>Let's learn to intersect in such a way that no epsilon       comparisons are required. Firstly, we can store lines in the set       instead of segments. Second, we can check the intersection of rays       first and only then proceed to check the intersection of segments.</p>     <p>So two rays intersect if: </p>     <ul> <li> their lines intersect — easy to check in integers; </li>       <li> the intersection point lies in the correct direction of both         rays — the intersection point is always a pair of fractions         $$$(\frac{Dx}{D}, \frac{Dy}{D})$$$ and you want to compare the         signs of $$$dx_i$$$ and $$$\frac{Dx}{D} - x_i$$$. </li></ul>          <p>Finally, if all the checks hold, then you can compare maximum of       distances from $$$(x_i, y_i)$$$ and $$$(x_j, y_j)$$$ to the       intersection point and $$$t$$$. If $$$t$$$ is greater or equal       then they intersect in time. There is no way to make that       comparison in integers. However, it's precision only depends on       the precision of $$$t$$$ as in the error here can't affect the       answer greatly.</p>     <p>Overall complexity: $$$O(n \log n \log maxt)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

#define forn(i, n) for (int i = 0; i &lt; int(n); i++)
#define x first
#define y second

using namespace std;

const double INF = 1e13;

struct line{
	int A, B, C;
	line(){}
	line(int x1, int y1, int x2, int y2){
		A = y1 - y2;
		B = x2 - x1;
		C = -A * x1 - B * y1;
		// A is guaranteed to be non-zero
		if (A &lt; 0) A = -A, B = -B, C = -C;
		int g = __gcd(A, __gcd(abs(B), abs(C)));
		A /= g, B /= g, C /= g;
	}
};

bool operator ==(const line &amp;a, const line &amp;b){
	return a.A == b.A &amp;&amp; a.B == b.B &amp;&amp; a.C == b.C;
}

double x;

bool operator &lt;(const line &amp;a, const line &amp;b){
	double val1 = (-a.A * x - a.C) / a.B;
	double val2 = (-b.A * x - b.C) / b.B;
	return val1 &lt; val2;
}

struct car{
	int x, y, dx, dy, s;
	line l;
	double vx, vy;
};

int n;
vector&lt;car&gt; a(n);

long long det(int a, int b, int c, int d){
	return a * 1ll * d - b * 1ll * c;
}

bool inter(const line &amp;a, const line &amp;b, long long &amp;D, long long &amp;Dx, long long &amp;Dy){
	D = det(a.A, a.B, b.A, b.B);
	if (D == 0) return false;
	Dx = -det(a.C, a.B, b.C, b.B);
	Dy = -det(a.A, a.C, b.A, b.C);
	return true;
}

int sg(int x){
	return x &lt; 0 ? -1 : 1;
}

int sg(long long a, long long b, int c){
	// sign of a/b-c
	if (b &lt; 0) a = -a, b = -b;
	return a - c * b &lt; 0 ? -1 : (a - c * b &gt; 0);
}

bool inter(int i, int j, double &amp;len){
	if (i == -1 || j == -1)
		return false;
	long long D, Dx, Dy;
	if (!inter(a[i].l, a[j].l, D, Dx, Dy))
		return false;
	if (sg(Dx, D, a[i].x) != 0 &amp;&amp; sg(a[i].dx) != sg(Dx, D, a[i].x))
		return false;
	if (sg(Dx, D, a[j].x) != 0 &amp;&amp; sg(a[j].dx) != sg(Dx, D, a[j].x))
		return false;
	double x = Dx / double(D);
	double y = Dy / double(D);
	double di = (a[i].x - x) * (a[i].x - x) + (a[i].y - y) * (a[i].y - y);
	double dj = (a[j].x - x) * (a[j].x - x) + (a[j].y - y) * (a[j].y - y);
	return len * len &gt;= di / a[i].s &amp;&amp; len * len &gt;= dj / a[j].s;
}

vector&lt;set&lt;pair&lt;line, int&gt;&gt;::iterator&gt; del;
set&lt;pair&lt;line, int&gt;&gt; q;

void get_neighbours(int i, int &amp;l, int &amp;r){
	l = r = -1;
	auto it = q.lower_bound({a[i].l, -1});
	if (it != q.end())
		r = it-&gt;y;
	if (!q.empty() &amp;&amp; it != q.begin()){
		--it;
		l = it-&gt;y;
	}
}

bool check(double t){
	vector&lt;pair&lt;double, pair&lt;int, int&gt;&gt;&gt; cur;
	del.resize(n);
	forn(i, n){
		double x1 = a[i].x;
		double x2 = a[i].x + a[i].vx * t;
		if (x1 &gt; x2) swap(x1, x2);
		cur.push_back({x1, {i, 0}});
		cur.push_back({x2, {i, 1}});
	}
	q.clear();
	
	sort(cur.begin(), cur.end());
	for (auto &amp;qr : cur){		
		x = qr.x;
		int i = qr.y.x;
		int l, r;
		
		if (qr.y.y == 0){
			get_neighbours(i, l, r);
			
			if (r != -1 &amp;&amp; a[i].l == a[r].l)
				return true;
			if (inter(i, l, t))
				return true;
			if (inter(i, r, t))
				return true;
			
			del[i] = q.insert({a[i].l, i}).x;
		}
		else{			
			q.erase(del[i]);
			get_neighbours(i, l, r);
			
			if (inter(l, r, t))
				return true;
		}
	}
	return false;
}

int main() {
	scanf(&#34;%d&#34;, &amp;n);
	a.resize(n);
	forn(i, n){
		scanf(&#34;%d%d%d%d%d&#34;, &amp;a[i].x, &amp;a[i].y, &amp;a[i].dx, &amp;a[i].dy, &amp;a[i].s);
		a[i].l = line(a[i].x, a[i].y, a[i].x + a[i].dx, a[i].y + a[i].dy);
		double d = sqrt(a[i].dx * a[i].dx + a[i].dy * a[i].dy);
		a[i].vx = a[i].dx / d * a[i].s;
		a[i].vy = a[i].dy / d * a[i].s;
		a[i].s *= a[i].s;
	}
	double l = 0, r = INF;
	bool ok = false;
	forn(_, 100){
		double m = (l + r) / 2;
		if (check(m)){
			ok = true;
			r = m;
		}
		else{
			l = m;
		}
	}
	if (!ok)
		puts(&#34;No show :(&#34;);
	else
		printf(&#34;%.15lf\n&#34;, l);
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #644 (Div. 3)
    1360A
    Минимальный квадрат </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Минимальный квадрат</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Найдите минимальную площадь <span class="tex-font-style-bf">квадратного</span> участка земли, на       котором можно разместить два одинаковых прямоугольных дома       размерами $$$a \times b$$$. Стороны домов должны быть параллельны       сторонам искомого квадратного участка.</p>     <p>Формально:</p>          <ul> <li> Вам даны два одинаковых прямоугольника с длинами сторон         $$$a$$$ и $$$b$$$ ($$$1 \le a, b \le 100$$$) — целые         положительные числа (вам заданы просто размеры, но <span class="tex-font-style-bf">не</span> их положения). </li>       <li> Найдите квадрат минимальной площади, который содержит в себе         оба заданных прямоугольника. Прямоугольники можно поворачивать         (оба или любой один), перемещать, но стороны прямоугольников         должны быть параллельны сторонам искомого квадрата. </li></ul>          <p>Два прямоугольника могут произвольным образом касаться друг друга       (по стороне или углу), но не могут пересекаться. Также       прямоугольники могут касаться сторон квадрата, но обязаны       полностью находиться внутри него. Поворачивать прямоугольники       можно. Изучите примеры для лучшего понимания.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/1e598f03ef46e0e02e952a4624168bc6f2799a22.png" style="max-width: 100.0%;max-height: 100.0%;"/>         <span class="tex-font-size-small">На картинке изображен квадрат,         который содержит в себе красный и зеленый прямоугольники.</span> </center></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$t$$$ ($$$1 \le t \le       10\,000$$$) — количество наборов тестовых данных в тесте. Далее       следуют $$$t$$$ наборов тестовых данных.</p>     <p>Каждый набор представляет собой строку, в которой записано два       целых числа $$$a$$$, $$$b$$$ ($$$1 \le a, b \le 100$$$) — стороны прямоугольников.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$t$$$ ответов на наборы тестовых данных. Каждый ответ       должен содержать одно целое число — минимальную площадь квадрата,       содержащего два прямоугольника $$$a \times b$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
8
3 2
4 2
1 1
3 1
4 7
1 3
7 4
100 100
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
16
16
4
9
64
9
64
40000
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Ниже изображены ответы для первых двух наборов тестовых данных: </p>     <center> <img class="tex-graphics" src="https://espresso.codeforces.com/1e598f03ef46e0e02e952a4624168bc6f2799a22.png" style="max-width: 100.0%;max-height: 100.0%;"/>     </center> <center> <img class="tex-graphics" src="https://espresso.codeforces.com/c543a559b4f04d83008aa7bcd6d11c643dba8b4d.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1360/problem/A' title='Codeforces Round 644 (Div. 3)'>1360A - Minimal Square</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Obviously that both rectangles should completely touch by one of       the sides. Otherwise, you can move them closer to each other so       that the total height or total width decreases, and the other       dimension does not change. Thus, there are only two options: </p>     <ul> <li> The rectangles touch by width, we get the side of the         square equal to $$$\max(2b, a)$$$, </li>       <li> The rectangles touch by height, we get the side of the square         equal to $$$\max(2a, b)$$$. </li></ul> Thus, the minimum side of     the square is equal to the minimum of these two options. Then the     answer is $$$(\min(\max(2b, a), \max(2a, b)))^2$$$.</div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #644 (Div. 3)
    1360B
    Честный тренер </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Честный тренер</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Перед вами стоит $$$n$$$ спортсменов. Спортсмены пронумерованы от       $$$1$$$ до $$$n$$$ слева направо. Про каждого спортсмена вы знаете       его силу — спортсмен с номером $$$i$$$ имеет силу $$$s_i$$$.</p>     <p>Вы хотите разделить всех спортсменов на две команды. В каждой       команде должен быть хотя бы один спортсмен, и каждый спортсмен       должен быть ровно в одной команде.</p>     <p>Вы хотите, чтобы самый сильный спортсмен из первой команды по       силе как можно меньше отличался от самого слабого спортсмена из       второй команды. Формально, вы хотите разделить спортсменов на две       команды $$$A$$$ и $$$B$$$ так, чтобы величина $$$|\max(A) -       \min(B)|$$$ была как можно меньше, где $$$\max(A)$$$ —       максимальная сила спортсмена из команды $$$A$$$, а $$$\min(B)$$$ —       минимальная сила спортсмена из команды $$$B$$$.</p>     <p>Например, если $$$n=5$$$ и силы спортсменов равны $$$s=[3, 1, 2,       6, 4]$$$, то одно из возможных разделений на команды имеет вид: </p>     <ul> <li> первая команда: $$$A = [1, 2, 4]$$$, </li>       <li> вторая команда: $$$B = [3, 6]$$$. </li></ul>          <p>В этом случае величина $$$|\max(A) - \min(B)|$$$ будет равна       $$$|4-3|=1$$$. Этот пример иллюстрирует один из способов       оптимального разбиения на две команды.</p>     <p>Выведите минимальное значение $$$|\max(A) - \min(B)|$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано целое число $$$t$$$ ($$$1 \le t \le       1000$$$) — количество наборов тестовых данных в тесте. Далее       записаны $$$t$$$ наборов тестовых данных.</p>     <p>Каждый набор состоит из двух строк. В первой строке содержится       целое положительное число $$$n$$$ ($$$2 \le n \le 50$$$) —       количество спортсменов. </p>     <p>В следующей строке содержится $$$n$$$ положительных целых чисел       $$$s_1, s_2, \ldots, s_n$$$ ($$$1 \le s_i \le 1000$$$), где       $$$s_i$$$ — это сила $$$i$$$-го спортсмена. Обратите внимание, что       среди элементов массива $$$s$$$ могут быть равные значения.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите одно целое число —       минимальное значение величины $$$|\max(A) - \min(B)|$$$ при       оптимальном разбиении всех спортсменов на команды. Каждый из       спортсменов должен оказаться членом ровно одной из двух команд.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
5
3 1 2 6 4
6
2 1 3 2 4 3
4
7 9 3 1
2
1 1000
3
100 150 200
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
0
2
999
50
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Первый набор тестовых данных разобран в условии. Во втором наборе       одно из оптимальных разбиений имеет вид $$$A=[2, 1]$$$, $$$B=[3,       2, 4, 3]$$$, поэтому ответ равен $$$|2-2|=0$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1360/problem/B' title='Codeforces Round 644 (Div. 3)'>1360B - Honest Coach</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's found two athletes with numbers $$$a$$$ and $$$b$$$ (the       strength of $$$a$$$ is not greater than the strength of $$$b$$$),       which have the minimal modulus of the difference of their       strength. Obviously, we cannot get an answer less than this. Let's       show how to get the partition with exactly this answer.</p>     <p>Sort all athletes by strength. Our two athletes will stand in       neighboring positions (otherwise, we can decrease the answer). Let       the first team contains all athletes who stand on positions not       further than $$$a$$$, and the second team contains other athletes.       We got a partition, in which the athlete with number $$$a$$$ has       the maximal strength in the first team, and the athlete with       number $$$b$$$ has the minimal strength in the second team.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #644 (Div. 3)
    1360C
    Похожие пары </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Похожие пары</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Назовем два числа $$$x$$$ и $$$y$$$ <span class="tex-font-style-it">похожими</span>, если они имеют       одинаковую четность (одинаковый остаток при делении на $$$2$$$),       или если $$$|x-y|=1$$$. Например, в каждой из пар $$$(2, 6)$$$,       $$$(4, 3)$$$, $$$(11, 7)$$$ числа похожи между собой, а в парах       $$$(1, 4)$$$, $$$(3, 12)$$$ — нет.</p>     <p>Вам дан массив $$$a$$$ из $$$n$$$ (число $$$n$$$ четно) целых       положительных чисел. Проверьте, существует ли такое разбиение       массива на пары, что каждый элемент массива принадлежит ровно       одной паре, и в каждой паре числа похожи между собой.</p>     <p>Например для массива $$$a = [11, 14, 16, 12]$$$ существует       разбиение на пары $$$(11, 12)$$$ и $$$(14, 16)$$$. Числа в первой       паре похожи, потому что модуль их разности равен единице, а во       второй паре — потому что они оба четные.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$t$$$ ($$$1 \le t \le       1000$$$) — количество наборов тестовых данных в тесте. Далее       следуют $$$t$$$ наборов тестовых данных.</p>     <p>Каждый набор задается двумя строками. В первой строке записано         <span class="tex-font-style-bf">четное</span> целое число       $$$n$$$ ($$$2 \le n \le 50$$$) — длина массива $$$a$$$. </p>     <p>Во второй строке записано $$$n$$$ целых чисел $$$a_1, a_2, \dots,       a_n$$$ ($$$1 \le a_i \le 100$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите:</p>          <ul> <li> <span class="tex-font-style-tt">YES</span>, если разбиение         существует; </li>       <li> <span class="tex-font-style-tt">NO</span>, если разбиения не         существует. </li></ul>          <p>Буквы в словах <span class="tex-font-style-tt">YES</span> и <span class="tex-font-style-tt">NO</span> можно выводить в любом регистре.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
7
4
11 14 16 12
2
1 8
4
1 1 1 1
4
1 2 5 6
2
12 13
6
1 6 3 10 5 8
6
1 12 3 10 5 8
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
YES
NO
YES
YES
YES
YES
NO
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Первый набор тестовых данных примера разобран в условии.</p>     <p>Во втором наборе два заданных числа не являются похожими.</p>     <p>В третьем наборе подходит любое разбиение.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1360/problem/C' title='Codeforces Round 644 (Div. 3)'>1360C - Similar Pairs</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let $$$e$$$ — be the number of even numbers in the array, and       $$$o$$$ — be the number of odd numbers in the array. Note that if       the parities of $$$e$$$ and of $$$o$$$ do not equal, then the       answer does not exist. Otherwise, we consider two cases: </p>     <ul> <li> $$$e$$$ and $$$o$$$ — are even numbers. Then all numbers         can be combined into pairs of equal parity. </li>       <li> $$$e$$$ and $$$o$$$ — are odd numbers. Then you need to check         whether there are two numbers in the array such that the modulus         of their difference is $$$1$$$. If there are two such numbers,         then combine them into one pair. $$$e$$$ and $$$o$$$ will         decrease by $$$1$$$ and become even, then the solution exists as         shown in the previous case. <ul></ul></li></ul></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #644 (Div. 3)
    1360D
    Покупка лопат </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Покупка лопат</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Поликарп хочет купить <span class="tex-font-style-bf">ровно</span> $$$n$$$ лопат. В магазине       продаются упаковки с лопатами. Всего в магазине $$$k$$$ различных       видов упаковок — упаковка $$$i$$$-го вида состоит из $$$i$$$ лопат       ($$$1 \le i \le k$$$). В магазине есть бесконечное количество       упаковок каждого вида.</p>     <p>Поликарп хочет выбрать <span class="tex-font-style-bf">один</span> вид упаковки и после этого       купить несколько (одну или более) упаковок этого вида. Какое       наименьшее количество упаковок придется купить Поликарпу, чтобы       суммарно купить ровно $$$n$$$ лопат?</p>     <p>Например, если $$$n=8$$$ и $$$k=7$$$, то Поликарп купит $$$2$$$       упаковки из $$$4$$$ лопат.</p>     <p>Помогите Поликарпу найти минимальное количество упаковок, которое       необходимо купить при условии, что он:</p>          <ul> <li> суммарно купит ровно $$$n$$$ лопат; </li>       <li> размеры <span class="tex-font-style-bf">всех</span> купленных         им упаковок одинаковы и являются целым числом от $$$1$$$ до         $$$k$$$ включительно. </li></ul></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано целое число $$$t$$$ ($$$1 \le t \le       100$$$) — количество наборов тестовых данных в тесте. Далее       записаны $$$t$$$ наборов тестовых данных по одному в строке.</p>     <p>Каждый набор представляет собой два целых положительных числа       $$$n$$$ ($$$1 \le n \le 10^9$$$) и $$$k$$$ ($$$1 \le k \le       10^9$$$) — количество лопат и количество видов упаковок.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$t$$$ ответов на наборы тестовых данных. Каждый ответ       является целым положительным числом — минимальным количеством упаковок.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
8 7
8 1
6 10
999999733 999999732
999999733 999999733
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
8
1
999999733
1
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Ответ на первый набор тестовых данных разобран в условии.</p>     <p>Во втором наборе существует только один способ купить $$$8$$$       лопат — $$$8$$$ упаковок по одной лопате.</p>     <p>В третьем наборе нужно купить $$$1$$$ упаковку из $$$6$$$ лопат.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1360/problem/D' title='Codeforces Round 644 (Div. 3)'>1360D - Buying Shovels</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>If Polycarp buys $$$a$$$ packages of $$$b$$$ shovels and gets       exactly $$$n$$$ shovels in total, then $$$a \cdot b = n$$$, that       is, $$$a$$$ and $$$b$$$ are divisors of $$$n$$$. Then the problem       reduces to the following, you need to find the maximum divisor of       the number $$$n$$$ not greater than $$$k$$$. To do this, iterate       over all the numbers $$$x$$$ from $$$1$$$ to $$$\sqrt n$$$       inclusive and check whether $$$n$$$ is divisible by $$$x$$$. If       so, then $$$x$$$ and $$$\frac{n}{x}$$$ — are both divisors of       $$$n$$$ and you can use them to try to improve the answer.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #644 (Div. 3)
    1360E
    Полигон </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. Полигон</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Полигон — это не только лучшая платформа для разработки задач, но       и квадратная матрица со стороной $$$n$$$, изначально состоящая из нулей.</p>     <p>На полигоне проводятся боевые учения. Поэтому над каждой клеткой       в первой строке и слева от каждой клетки первого столбца находится       пушка. Таким образом, всего есть $$$2n$$$ пушек.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/5c881cddb6835c9ccbae4d64339c61ee89ca98e6.png" style="max-width: 100.0%;max-height: 100.0%;"/>         <span class="tex-font-size-small">Изначальный полигон для       $$$n=4$$$.</span> </center>          <p>Пушки стреляют единицами. В один момент времени стреляет не       больше одной пушки. Когда единица вылетает из пушки, то она летит       вперед, по направлению выстрела, до тех пор, пока не столкнется с       границей полигона или другой единицей. После этого она занимает       клетку, в которой находилась перед столкновением, и остается там.       Изучите примеры для лучшего понимания.</p>     <p>Более формально: </p>     <ul> <li> если пушка, стоящая в строке $$$i$$$ перед первым         столбцом, стреляет единицей, то единица начинает свой полет из         клетки ($$$i, 1$$$) и заканчивает в какой-то клетке ($$$i,         j$$$); </li>       <li> если пушка, стоящая в столбце $$$j$$$ над первой строкой,         стреляет единицей, то единица начинает свой полет из клетки         ($$$1, j$$$) и заканчивает в какой-то клетке ($$$i, j$$$). </li></ul>          <p>Например, рассмотрим следующую последовательность выстрелов:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/477656491c995331732d67143a59e43b21075bcc.png" style="max-width: 100.0%;max-height: 100.0%;"/>        <p> <span class="tex-font-size-small">1. Стреляет пушка в строке           $$$2$$$.                         2. Стреляет пушка в строке           $$$2$$$.                         3. Стреляет пушка в столбце         $$$3$$$.</span> </p></center>          <p>У вас на столе лежит отчет с проведенных учений. Этот отчет       является квадратной матрицей с длиной стороны $$$n$$$, состоящей       из нулей и единиц. Вам интересно, действительно ли произошли       учения. Другими словами, существует ли такая последовательность       выстрелов, что в конце получится заданная матрица?</p>     <p>Каждая пушка может сделать произвольное количество выстрелов.       Перед началом учений полигон состоит из нулей.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано целое число $$$t$$$ ($$$1 \le t \le       1000$$$) — количество наборов тестовых данных в тесте. Далее       следуют $$$t$$$ наборов тестовых данных.</p>     <p>Каждый набор начинается со строки, в которой записано целое число       $$$n$$$ ($$$1 \le n \le 50$$$) — размер полигона.</p>     <p>Далее следуют $$$n$$$ строк длины $$$n$$$, состоящих из нулей и       единиц — матрица полигона после проведения учений.</p>     <p>Суммарная площадь матриц во всех наборах тестовых данных в одном       тесте не превосходит $$$10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите:</p>          <ul> <li> <span class="tex-font-style-tt">YES</span>, если         существует последовательность выстрелов, приводящая к заданной         матрице; </li>       <li> <span class="tex-font-style-tt">NO</span>, если такой         последовательности не существует. </li></ul>          <p>Буквы в словах <span class="tex-font-style-tt">YES</span> и <span class="tex-font-style-tt">NO</span> можно выводить в любом регистре.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
4
0010
0011
0000
0000
2
10
01
2
00
00
4
0101
1111
0101
0111
4
0100
1110
0101
0111
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
YES
NO
YES
YES
NO
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Первый набор тестовых данных примера разобран в условии.</p>     <p>Ответ на второй набор <span class="tex-font-style-tt">NO</span>,       так как, вылетев из любой пушки, единица в клетке ($$$1, 1$$$)       продолжила бы свой полет дальше.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1360/problem/E' title='Codeforces Round 644 (Div. 3)'>1360E - Polygon</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's see how the matrix looks like after some sequence of       shoots: </p>     <ul> <li> The matrix consists of <span class="tex-font-style-tt">0</span>, or </li>       <li> There is at least one <span class="tex-font-style-tt">1</span> at position ($$$n, i$$$) or         ($$$i, n$$$), and any <span class="tex-font-style-tt">1</span>         not at position ($$$n, j$$$) or ($$$j, n$$$) must have <span class="tex-font-style-tt">1</span> below or right. </li></ul>          <p>If the second condition is violated, then the <span class="tex-font-style-tt">1</span> in the corresponding cell would       continue its flight. Thus, it is necessary and sufficient to       verify that the matrix satisfies the condition above.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #644 (Div. 3)
    1360F
    Строка-шпион </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Строка-шпион</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам даны $$$n$$$ строк $$$a_1, a_2, \ldots, a_n$$$, все они имеют       одинаковую длину $$$m$$$. Строки состоят из строчных букв       латинского алфавита.</p>     <p>Найдите любую такую строку $$$s$$$ длины $$$m$$$, что каждая из       заданных $$$n$$$ строк отличается от $$$s$$$ не более чем в одной       позиции. Формально, для каждой заданной строки $$$a_i$$$ должно       существовать не более одной позиции $$$j$$$, в которой $$$a_i[j]       \ne s[j]$$$.</p>     <p>Заметим, что искомая строка $$$s$$$ может как совпадать с одной       из заданных строк $$$a_i$$$, так и отличаться от всех заданных строк.</p>     <p>Например, если вам даны строки <span class="tex-font-style-tt">abac</span> и <span class="tex-font-style-tt">zbab</span>, тогда ответом на задачу       может быть строка <span class="tex-font-style-tt">abab</span>,       которая отличается от первой только последним символом, а от       второй только первым.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано целое число $$$t$$$ ($$$1 \le t \le       100$$$) — количество наборов тестовых данных в тесте. Далее       записаны $$$t$$$ наборов тестовых данных.</p>     <p>Каждый набор начинается со строки, в которой записаны целые числа       $$$n$$$ ($$$1 \le n \le 10$$$) и $$$m$$$ ($$$1 \le m \le 10$$$) —       количество заданных строк и их длина.</p>     <p>Далее следуют $$$n$$$ строк $$$a_i$$$. Каждая имеет длину $$$m$$$       и состоит из строчных латинских букв.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$t$$$ ответов на наборы тестовых данных. Каждый ответ       (если он существует) — это строка длины $$$m$$$, состоящая из       строчных латинских букв. Если существует несколько ответов, то       выведите любой из них. Если ответа не существует, выведите «<span class="tex-font-style-tt">-1</span>» («минус один», без кавычек).</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
2 4
abac
zbab
2 4
aaaa
bbbb
3 3
baa
aaa
aab
2 2
ab
bb
3 1
a
b
c
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
abab
-1
aaa
ab
z</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Первый набор тестовых данных примера разобран в условии.</p>     <p>Во втором наборе ответа не существует.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1360/problem/F' title='Codeforces Round 644 (Div. 3)'>1360F - Spy-string</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Consider all strings that differ from the first one in no more       than one position (this is either the first string or the first       string with one character changed). We will go through all such       strings and see if they can be the answer. To do this, go through       all the strings and calculate the number of positions where they differ.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #644 (Div. 3)
    1360G
    A/B матрица </h1>

    <div class="problemindexholder" problemindex="G">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">G. A/B матрица</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам даны четыре целых положительных числа $$$n$$$, $$$m$$$,       $$$a$$$, $$$b$$$ ($$$1 \le b \le n \le 50$$$; $$$1 \le a \le m \le       50$$$). Найдите любую такую прямоугольную матрицу размера $$$n       \times m$$$, что выполняются все следующие условия:</p>          <ul> <li> в каждой строке матрицы ровно $$$a$$$ единиц; </li>       <li> в каждом столбце матрицы ровно $$$b$$$ единиц; </li>       <li> все остальные элементы — нули. </li></ul>          <p>Если искомой матрицы не существует, то укажите это.</p>     <p>Например, для $$$n=3$$$, $$$m=6$$$, $$$a=2$$$, $$$b=1$$$       существует такая матрица, удовлетворяющая условиям выше:</p>     <p>$$$$$$ \begin{vmatrix} 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1       \\ 1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1       &amp; 0 &amp; 1 &amp; 0 \end{vmatrix} $$$$$$</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано целое число $$$t$$$ ($$$1 \le t \le       1000$$$) — количество наборов тестовых данных в тесте. Далее       следуют $$$t$$$ наборов тестовых данных.</p>     <p>Каждый набор тестовых данных описывается четырьмя целыми       положительными числами $$$n$$$, $$$m$$$, $$$a$$$, $$$b$$$ ($$$1       \le b \le n \le 50$$$; $$$1 \le a \le m \le 50$$$), где $$$n$$$ и       $$$m$$$ — размеры матрицы, а $$$a$$$ и $$$b$$$ — ограничения на       количества единиц для строк и столбцов, соответственно.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите:</p>          <ul> <li> «YES» (без кавычек) и искомую матрицу (если существует         несколько ответов, выведите любой), если она существует, или, </li>       <li> «NO» (без кавычек), если ее не существует. </li></ul>          <p>Чтобы вывести матрицу $$$n \times m$$$, выведите $$$n$$$ строк,       каждая из которых содержит $$$m$$$ чисел $$$0$$$ или $$$1$$$,       описывающих очередную строку матрицы. Числа нужно выводить <span class="tex-font-style-bf">без пробелов</span>.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
3 6 2 1
2 2 2 1
2 2 2 2
4 4 2 2
2 1 1 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
YES
010001
100100
001010
NO
YES
11
11
YES
1100
1100
0011
0011
YES
1
1
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1360/problem/G' title='Codeforces Round 644 (Div. 3)'>1360G - A/B Matrix</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's see how the desired matrix looks like. Since each row       should have exactly $$$a$$$ ones, and each column should have       exactly $$$b$$$ ones, the number of ones in all rows $$$a \cdot       n$$$ should be equal to the number of ones in all columns $$$b       \cdot m$$$. Thus, the desired matrix exists iff $$$a \cdot n = b       \cdot m$$$ or $$$\frac{n}{m} = \frac{b}{a}$$$.</p>     <p>Let's show how to construct the desired matrix if it exists.       Let's find any number $$$0&lt;d&lt;m$$$ such that $$$(d \cdot n)       \% m = 0$$$, where $$$a \% b$$$ — is the remainder of dividing       $$$a$$$ by $$$b$$$. In the first row of the desired matrix, we put       the ones at the positions $$$[1, a]$$$, and in the $$$i$$$-th row       we put the ones, as in the $$$i-1$$$ row, but cyclically shifted       by $$$d$$$ to the right.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #644 (Div. 3)
    1360H
    Двоичная медиана </h1>

    <div class="problemindexholder" problemindex="H">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">H. Двоичная медиана</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Рассмотрим все двоичные строки длины $$$m$$$ ($$$1 \le m \le       60$$$), то есть строки, состоящие из символов <span class="tex-font-style-tt">0</span> и <span class="tex-font-style-tt">1</span>. Например, <span class="tex-font-style-tt">0110</span> является двоичной строкой, а         <span class="tex-font-style-tt">012aba</span> — нет. Очевидно,       что всего таких строк ровно $$$2^m$$$.</p>     <p>Строка $$$s$$$ лексикографически меньше строки $$$t$$$ (обе имеют       одинаковую длину $$$m$$$), если в первой слева позиции $$$i$$$, в       которой они отличаются, верно $$$s[i] &lt; t[i]$$$. Именно такой       способ сравнения строк используется в словарях и в большинстве       современных языков программирования при их сравнении стандартным       способом. Например, строка <span class="tex-font-style-tt">01011</span> лексикографически меньше       строки <span class="tex-font-style-tt">01100</span>, потому что       первые два символа совпадают, а третий символ в первой строке       меньше, чем во второй.</p>     <p>Удалим из этого множества $$$n$$$ ($$$1 \le n \le \min(2^m-1,       100)$$$) <span class="tex-font-style-bf">различных</span> двоичных       строк $$$a_1, a_2, \ldots, a_n$$$, каждая длины $$$m$$$. Таким       образом, в множестве останется $$$k=2^m-n$$$ строк. Отсортируем       все строки полученного множества в порядке лексикографического       возрастания (как в словаре).</p>     <p>Пронумеруем все строки после сортировки от $$$0$$$ до $$$k-1$$$.       Выведите строку, номер которой равен $$$\lfloor \frac{k-1}{2}       \rfloor$$$ (такой элемент называется <span class="tex-font-style-it">медианой</span>), где $$$\lfloor x       \rfloor$$$ является округлением числа вниз к ближайшему целому.</p>     <p>Например, если $$$n=3$$$, $$$m=3$$$ и $$$a=[$$$<span class="tex-font-style-tt">010</span>, <span class="tex-font-style-tt">111</span>, <span class="tex-font-style-tt">001</span>$$$]$$$, то после удаления       строк $$$a_i$$$ и сортировки результат примет вид: $$$[$$$<span class="tex-font-style-tt">000</span>, <span class="tex-font-style-tt">011</span>, <span class="tex-font-style-tt">100</span>, <span class="tex-font-style-tt">101</span>, <span class="tex-font-style-tt">110</span>$$$]$$$. Таким образом,       искомая медиана равна <span class="tex-font-style-tt">100</span>.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано целое число $$$t$$$ ($$$1 \le t \le       1000$$$) — количество наборов тестовых данных в тесте. Далее       следуют $$$t$$$ наборов тестовых данных.</p>     <p>В первой строке каждого набора записаны целые числа $$$n$$$ ($$$1       \le n \le \min(2^m-1, 100)$$$) и $$$m$$$ ($$$1 \le m \le 60$$$),       где $$$n$$$ — количество удаляемых строк, $$$m$$$ — длина двоичных       строк. Следующие $$$n$$$ строк содержат $$$a_1, a_2, \ldots,       a_n$$$ — <span class="tex-font-style-bf">различные</span> двоичные       строки длины $$$m$$$.</p>     <p>Суммарная длина всех заданных двоичных строк во всех наборах       тестовых данных в одном тесте не превосходит $$$10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$t$$$ ответов на наборы тестовых данных. Ответом       является строка длины $$$m$$$ — медиана оставшихся строк.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
3 3
010
001
111
4 3
000
111
100
011
1 1
1
1 1
0
3 2
00
01
10
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
100
010
0
1
11
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Первый набор тестовых данных примера разобран в условии.</p>     <p>Во втором наборе результат после удаления строк и сортировки       равен $$$[$$$<span class="tex-font-style-tt">001</span>, <span class="tex-font-style-tt">010</span>, <span class="tex-font-style-tt">101</span>, <span class="tex-font-style-tt">110</span>$$$]$$$. Следовательно,       искомая медиана равна <span class="tex-font-style-tt">010</span>.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1360/problem/H' title='Codeforces Round 644 (Div. 3)'>1360H - Binary Median</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>If we did not delete the strings, then the median would be equal       to the binary notation of $$$2^{(m-1)}$$$. After deleting $$$n$$$       strings, the median cannot change (numerically) by more than $$$2       \cdot n$$$. </p>     <p>Let's start with the median $$$2^{(m-1)}$$$ and each time       decrease it by one if there are fewer not deleted smaller numbers       than not deleted large numbers. Similarly, you need to increase       the median by one, otherwise. The algorithm stops when the result       is the median of the current set. All these steps will run at most       $$$200$$$ times.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #647 (Div. 1) - Thanks, Algo Muse!
    1361A
    Джонни и вклад </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Джонни и вклад</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Сегодня Джонни хочет увеличить свой вклад. Его план подразумевает       написание $$$n$$$ блогов. Один блог покрывает одну тему, но одна       тема может быть покрыта несколькими блогами. Также, некоторые       блоги связаны друг с другом ссылками. Каждая пара блогов,       связанных ссылкой, должна покрывать две разные темы. Потому что       иначе читатели могут заметить, что блоги разделены только для       того, чтобы набрать больше вклада. Множество блогов и двусторонние       ссылки между некоторыми парами из них называются сетью блогов.</p>     <p>Всего есть $$$n$$$ различных тем, пронумерованных от $$$1$$$ до       $$$n$$$, упорядоченных по пониманию Джонни. Структура сети блогов       уже приготовлена. Теперь Джонни должен написать все блоги в       некотором порядке. Он ленивый, поэтому каждый раз перед написанием       блога, он смотрит на все уже написанные соседние блоги (связанные       ссылкой с текущим) и выбирает тему с минимальным номером, которая       еще не покрыта соседними блогами. Можно заметить, что такая       стратегия всегда позволит ему выбрать тему, потому что       максимальное количество соседних блогов равно $$$n - 1$$$.</p>     <p>Например, если уже написанные, соседние с текущим, блоги       покрывают темы с номерами $$$1$$$, $$$3$$$, $$$1$$$, $$$5$$$ и       $$$2$$$, Джонни выберет тему номер $$$4$$$ для текущего блога,       потому что темы номер $$$1$$$, $$$2$$$ и $$$3$$$ уже покрыты       соседними блогами, а тема номер $$$4$$$ — нет.</p>     <p>Как хороший друг, вы провели некоторые исследования и предсказали       наилучшую темы для каждого блога. Не могли бы вы сказать Джонни, в       каком порядке он должен писать блоги, чтобы в результате его       стратегии каждый блог покрывал выбранную вами тему?</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит два целых числа $$$n$$$ $$$(1 \leq n \leq       5 \cdot 10^5)$$$ и $$$m$$$ $$$(0 \leq m \leq 5 \cdot 10^5)$$$ —       количество блогов и ссылок, соответственно.</p>     <p>Каждая из следующих $$$m$$$ строк содержит два целых числа       $$$a$$$ и $$$b$$$ ($$$a \neq b$$$; $$$1 \leq a, b \leq n$$$),       которые означают, что в сети блогов есть ссылка между блогами с       номерами $$$a$$$ и $$$b$$$. Гарантируется, что граф сети блогов не       содержит кратных ребер.</p>     <p>Последняя строка содержит $$$n$$$ целых чисел $$$t_1, t_2,       \ldots, t_n$$$, $$$i$$$-е из них обозначает желаемую тему для       $$$i$$$-го блога ($$$1 \le t_i \le n$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Если решение не существует, выведите $$$-1$$$. Иначе, выведите       $$$n$$$ различных целых чисел $$$p_1, p_2, \ldots, p_n$$$ $$$(1       \leq p_i \leq n)$$$, которые обозначают номера блогов в том       порядке, в котором Джонни должен их написать. Если существует       несколько решений, выведите любое.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3 3
1 2
2 3
3 1
2 1 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2 1 3
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
3 3
1 2
2 3
3 1
1 1 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
-1
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5 3
1 2
2 3
4 5
2 1 2 2 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2 5 1 3 4
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере, Джонни начинает с написания блога номер       $$$2$$$, у него пока еще нет написанных соседних блогов, поэтому       Джонни выбирает тему номер один. Потом он пишет блог номер       $$$1$$$, у него есть ссылка на уже написанный второй блог, поэтому       Джонни выбирает вторую тему. Наконец, он пишет блог номер $$$3$$$,       у него есть ссылки на блоги номер $$$1$$$ и $$$2$$$, поэтому       Джонни выбирает третью тему.</p>     <p>Второй пример: Не существует ни одной перестановки,       удовлетворяющей всем условиям.</p>     <p>Третий пример: Сначала Джонни пишет блог номер $$$2$$$, который       получает тему $$$1$$$. Затем, он пишет блог $$$5$$$, который тоже       получает тему $$$1$$$, потому из него нет ссылки на единственный       уже написанный блог (номер $$$2$$$). Затем, он пишет блог $$$1$$$,       он получает тему $$$2$$$, потому что из него есть ссылка на блог       $$$2$$$ с темой $$$1$$$. Затем, он пишет блог $$$3$$$, из него       есть ссылка на блог $$$2$$$, поэтому он получает тему $$$2$$$.       Наконец, он пишет блог $$$4$$$, из него есть ссылка на блог       $$$5$$$, поэтому он получает тему $$$2$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1361/problem/A' title='Codeforces Round 647 (Div. 1) - Thanks, Algo Muse!'>1361A - Johnny and Contribution</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>We can view blogs as a graph, references as edges, and topics as       colors. Now we can reformulate our problem as finding a       permutation of vertices such that given in the statement greedy       coloring algorithm returns coloring as described in the input.</p>     <p>Let us start with two observations:</p>     <p>       <span class="tex-font-style-bf">Observation 1:</span> If there is       an edge between vertices with the same color, then the answer is $$$-1$$$.</p>     <p>       <span class="tex-font-style-bf">Observation 2:</span> If for a       vertex $$$u$$$ with color $$$c$$$ there exist a color $$$c' &lt;       c$$$ such that $$$u$$$ has no edge to any vertex with color       $$$c'$$$ then the answer is $$$-1$$$.</p>     <p>Both observations are rather straightforward to prove, so we skip       it. Let us create permutation where vertices are sorted firstly by       desired color and secondly by indices. We claim that if there       exists any ordering fulfilling given regulations, then this       permutation fulfills these too. Let us prove it:</p>     <p>Let us analyze vertex $$$u$$$ with color $$$c$$$. From       observation $$$2$$$ we know that for each color $$$c' &lt; c$$$       there exist $$$v$$$ with color $$$c'$$$ such that $$$u$$$ and       $$$v$$$ are connected by an edge. Because vertices are sorted by       colors in our permutation, $$$v$$$ is before $$$u$$$ in ordering.       So the greedy algorithm will assign that vertex color $$$k \geq       c$$$. From observation $$$1$$$, we now that $$$u$$$ does not have       an edge to vertex with color $$$c$$$, so the greedy algorithm has       to assign to $$$u$$$ color $$$k \leq c$$$. Combining both       inequalities, we reach that greedy must assign color $$$k = c$$$,       which completes our proof.</p>     <p>So now the algorithm is rather straightforward – sort vertices by       colors, check if that ordering fulfills given regulations, if so,       then write it down, otherwise print $$$-1$$$. This can be       implemented in $$$\mathcal{O}(n \log n)$$$ or $$$\mathcal{O}(n)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

const int N = 1e6 + 7;

int n, m;
int ans[N];

int last[N];
vector &lt;int&gt; G[N];
vector &lt;int&gt; in[N];

int main(){
	scanf(&#34;%d %d&#34;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= m; ++i){
		int u, v;
		scanf(&#34;%d %d&#34;, &amp;u, &amp;v);
		
		G[u].push_back(v);
		G[v].push_back(u);
	}
	
	for(int i = 1; i &lt;= n; ++i){
		int color;
		scanf(&#34;%d&#34;, &amp;color);

		in[color].push_back(i);
		if(color &gt; n){
			puts(&#34;-1&#34;);
			exit(0);
		}
	}
	
	vector &lt;int&gt; result;
	for(int i = 1; i &lt;= n; ++i){
		for(auto u: in[i]){
			for(auto v: G[u])
				last[ans[v]] = u;
			
			ans[u] = 1;
			while(last[ans[u]] == u)
				++ans[u];
			
			if(ans[u] != i){
				puts(&#34;-1&#34;);
				exit(0);
			}
			
			result.push_back(u);
		}
	}
	
	for(int i = 0; i &lt; n; ++i)
		printf(&#34;%d%c&#34;, result[i], i == n - 1 ? &#39;\n&#39; : &#39; &#39;);
	return 0;
}
</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

const int N = 1e6 + 7;

int n, m;
int ans[N];

int last[N];
vector &lt;int&gt; G[N];
vector &lt;int&gt; in[N];

int main(){
	scanf(&#34;%d %d&#34;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= m; ++i){
		int u, v;
		scanf(&#34;%d %d&#34;, &amp;u, &amp;v);
		
		G[u].push_back(v);
		G[v].push_back(u);
	}
	
	for(int i = 1; i &lt;= n; ++i){
		int color;
		scanf(&#34;%d&#34;, &amp;color);

		in[color].push_back(i);
		if(color &gt; n){
			puts(&#34;-1&#34;);
			exit(0);
		}
	}
	
	vector &lt;int&gt; result;
	for(int i = 1; i &lt;= n; ++i){
		for(auto u: in[i]){
			for(auto v: G[u])
				last[ans[v]] = u;
			
			ans[u] = 1;
			while(last[ans[u]] == u)
				++ans[u];
			
			if(ans[u] != i){
				puts(&#34;-1&#34;);
				exit(0);
			}
			
			result.push_back(u);
		}
	}
	
	for(int i = 0; i &lt; n; ++i)
		printf(&#34;%d%c&#34;, result[i], i == n - 1 ? &#39;\n&#39; : &#39; &#39;);
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #647 (Div. 1) - Thanks, Algo Muse!
    1361B
    Джонни и гроссмейстер </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Джонни и гроссмейстер</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Джонни недавно нашел новый отличный туториал: «Как стать       гроссмейстером?». В туториале говорится много странных и       неожиданных для Джонни вещей, таких как то, что он должен быть       терпеливым или что очень важно решать много все более и более       сложных задач.</p>     <p>Мальчик нашел онлайн архив с задачами, разделенными по темам. Он       выбрал $$$p^{k_i}$$$ задач из $$$i$$$-й категории ($$$p$$$ — его       любимое число). Он хочет решить все эти задачи за две недели       (терпение еще слишком сложно для Джонни, поэтому он смотрит только       на простые задачи, которые могут быть решены за такой период).       Теперь наш будущий гроссмейстер должен решить, какие темы покрыть       на первой неделе, а какие на второй. Помогите ему распределить       темы таким образом, чтобы нагрузка была равномерной.</p>     <p>Формально, дано $$$n$$$ чисел $$$p^{k_i}$$$, мальчик хочет       разделить их на два непересекающихся набора, минимизировав       разность между суммами чисел в наборах. Найдите минимальное       значение модуля такой разности. Выведите остаток от деления       результата на $$$10^{9}+7$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Входные данные состоят из нескольких наборов входных данных.       Первая строка содержит одно целое число $$$t$$$ $$$(1 \leq t \leq       10^5)$$$ — количество наборов входных данных.</p>     <p>Первая строка каждого набора входных данных содержит два целых       числа $$$n$$$ и $$$p$$$ $$$(1 \leq n, p \leq 10^6)$$$. Вторая       строка содержит $$$n$$$ целых чисел $$$k_i$$$ $$$(0 \leq k_i \leq 10^6)$$$.</p>     <p>Сумма $$$n$$$ по всем наборам входных данных не превышает $$$10^6$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одно целое число — остаток от деления ответа на $$$1\,000\,000\,007$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
5 2
2 3 4 4 3
3 1
2 10 1000
4 5
0 1 1 100
1 8
89
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
4
1
146981438
747093407
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Вы должны минимизировать модуль разности, а не остаток модуля       разности. Например, если минимальная разность равна $$$2$$$, но       существует также разбиение, при котором разность равна $$$10^9 +       8$$$, ответ равен $$$2$$$, а не $$$1$$$.</p>     <p>В первом наборе входных данных числа равны: $$$4$$$, $$$8$$$,       $$$16$$$, $$$16$$$ и $$$8$$$. Мы можем разделить их на два набора:       $$${4, 8, 16}$$$ и $$${8, 16}$$$. Тогда модуль разности между       суммами чисел в наборах будет равен $$$4$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1361/problem/B' title='Codeforces Round 647 (Div. 1) - Thanks, Algo Muse!'>1361B - Johnny and Grandmaster</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>The solution for the case $$$p = 1$$$ is trivial, the answer is       $$$1$$$ for odd $$$n$$$ and $$$0$$$ for even $$$n$$$. From now on,       I will assume that $$$p &gt; 1$$$. Instead of partitioning the       elements into two sets, I will think of placing plus and minus       signs before them to minimize the absolute value of the resulting expression.</p>     <p>We will process the exponents in non-increasing order and       maintain the invariant that the current sum is nonnegative. Say we       are processing $$$k_i.$$$ In such cases, we will know the current       sum modulo $$$10^{9}+7$$$ and its exact value divided by       $$$p^{k_i}$$$ (denoted as $$$v$$$) or information that it's too big.</p>     <p>Initially, the sum (I will denote it $$$s$$$) equals $$$0$$$.       While processing elements:</p>     <p>If $$$s &gt; 0$$$, subtract the current element from the sum (it       easy to show that it won't be negative after this operation).</p>     <p>If $$$s = 0$$$, add the current element to the sum.</p>     <p>If at any point of the algorithm, $$$v = \frac{s}{p^{k_i}} &gt;       n$$$, there is no need to store the exact value of $$$v$$$       anymore, because it is so big that all the elements from this       moment on will be subtracted. Thus, it is enough to store this       information and the current sum modulo $$$10^{9}+7$$$.</p>     <p>When we move to the next element, the exponent may change, and       $$$v$$$ needs to be multiplied by a power of $$$p$$$. Since the       exponents can be large, we use fast multiplication. </p>     <p>The time complexity of this solution is $$$\mathcal{O}(n \log n +       n \log \max k_i)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;

const ll INF = 1e6+100;
const ll mod = ll(1e9)+7;

ll fexp (ll a, int e)
{
	ll ret = 1LL;
	while (e&gt;0)
	{
		if (e%2==1) ret = ret * a % mod;
		a = a*a % mod;
		e/=2;
	}
	return ret;
}

int main ()
{
	int t;
	scanf (&#34;%d&#34;, &amp;t);
	for (int test = 0; test &lt; t; test++)
	{
		int n;
		ll p;
		scanf (&#34;%d %lld&#34;, &amp;n, &amp;p);
		vector &lt;int&gt; K(n);
		for (int &amp;x: K) scanf (&#34;%d&#34;, &amp;x);
		sort(K.begin(), K.end());
		
		vector &lt;int&gt; Exp = K;
		
		ll currSum = 0;
		ll result = 0;
		bool infty = false;
		
		int prevExp = 1e6+10;
		while (!Exp.empty())
		{
			/* Update the currSum and result (multiply by a power of k) */
			int k = Exp.back();
			Exp.pop_back();
			int delta = prevExp - k;
			prevExp = k;
			
			result = result * fexp(p, delta) % mod;
			
			/* Multiplying by p 20 times will either 
			not change the currSum at all or make it bigger than n */
			for (int i=0; i&lt;min(delta, 20); i++)
			{
				currSum *= p;
				if (currSum &gt; INF) infty = true;
			}
			
			/* Process all the elements equal p^k */
			while (!K.empty() &amp;&amp; K.back()==k)
			{
				K.pop_back();
				if (infty || currSum &gt; 0)
				{
					currSum--;
					result+=mod - 1;
				}
				else
				{
					currSum++;
					result++;
				}
				result%=mod;
			}
		}
		
		result = result * fexp(p, prevExp) % mod;
		
		printf (&#34;%lld\n&#34;, result % mod);
	}
}

</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;

const ll INF = 1e6+100;
const ll mod = ll(1e9)+7;

ll fexp (ll a, int e)
{
	ll ret = 1LL;
	while (e&gt;0)
	{
		if (e%2==1) ret = ret * a % mod;
		a = a*a % mod;
		e/=2;
	}
	return ret;
}

int main ()
{
	int t;
	scanf (&#34;%d&#34;, &amp;t);
	for (int test = 0; test &lt; t; test++)
	{
		int n;
		ll p;
		scanf (&#34;%d %lld&#34;, &amp;n, &amp;p);
		vector &lt;int&gt; K(n);
		for (int &amp;x: K) scanf (&#34;%d&#34;, &amp;x);
		sort(K.begin(), K.end());
		
		vector &lt;int&gt; Exp = K;
		
		ll currSum = 0;
		ll result = 0;
		bool infty = false;
		
		int prevExp = 1e6+10;
		while (!Exp.empty())
		{
			/* Update the currSum and result (multiply by a power of k) */
			int k = Exp.back();
			Exp.pop_back();
			int delta = prevExp - k;
			prevExp = k;
			
			result = result * fexp(p, delta) % mod;
			
			/* Multiplying by p 20 times will either 
			not change the currSum at all or make it bigger than n */
			for (int i=0; i&lt;min(delta, 20); i++)
			{
				currSum *= p;
				if (currSum &gt; INF) infty = true;
			}
			
			/* Process all the elements equal p^k */
			while (!K.empty() &amp;&amp; K.back()==k)
			{
				K.pop_back();
				if (infty || currSum &gt; 0)
				{
					currSum--;
					result+=mod - 1;
				}
				else
				{
					currSum++;
					result++;
				}
				result%=mod;
			}
		}
		
		result = result * fexp(p, prevExp) % mod;
		
		printf (&#34;%lld\n&#34;, result % mod);
	}
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #647 (Div. 1) - Thanks, Algo Muse!
    1361C
    Джонни и ожерелье Меган </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Джонни и ожерелье Меган</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>3 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У младшей сестры Джонни, Меган, недавно был день рождения. Её       брат подарил ей коробочку, подписанную как: «Твое прекрасное       ожерелье — сделай сама!». Коробочка содержит много частей ожерелья       и магический клей.</p>     <p>Каждая часть ожерелья представляет собой цепочку, соединяющую две       жемчужины. Цвет каждой из жемчужин может быть представлен целым       неотрицательным числом. Магический клей позволяет Меган склеивать       две жемчужины (возможно, из одной части ожерелья) в одну. Красота       соединения двух жемчужин цветов $$$u$$$ и $$$v$$$ определяется       следующим образом: пусть $$$2^k$$$ — максимальная степень двух,       делящая $$$u \oplus v$$$ — <a href="https://en.wikipedia.org/wiki/Exclusive_or#Computer_science">исключающее       или</a> $$$u$$$ и $$$v$$$. Тогда красота соединения равна $$$k$$$.       Если $$$u = v$$$, вы можете считать, что красота равна $$$20$$$.</p>     <p>Каждая жемчужина может быть склеена с другой максимум один раз.       Склеивание двух частей ожерелья объединяет их. Используя клей       несколько раз, Меган может наконец получить свое ожерелье, которое       является циклом, сделанным из соединенных последовательно частей       ожерелья (так, что каждая жемчужина в ожерелье соединена с ровно       одной другой жемчужиной). Красота такого ожерелья равна       минимальной красоте соединений в нем. Девочка хочет использовать       все доступные части ожерелья, чтобы получить <span class="tex-font-style-bf">ровно одно</span> ожерелье, содержащее         <span class="tex-font-style-bf">все части</span>, с максимальной       возможной красотой. Помогите ей!</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит целое число $$$n$$$ $$$(1 \leq n \leq 5       \cdot 10^5)$$$ — количество частей ожерелья в коробочке.</p>     <p>Каждая из следующих $$$n$$$ строк содержит два целых числа       $$$a$$$ и $$$b$$$ $$$(0 \leq a, b &lt; 2^{20})$$$, которые       обозначают цвета жемчужин из этой части ожерелья. Жемчужины на       $$$i$$$-й строке имеют индексы $$$2i - 1$$$ и $$$2i$$$, соответственно.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Первая строка должна содержать одно целое число $$$b$$$,       обозначающее максимальную возможную красоту ожерелья, собранного       из всех данных частей.</p>     <p>Следующая строка должна содержать $$$2n$$$ различных целых чисел       $$$p_i$$$ $$$(1 \leq p_i \leq 2n)$$$ — индексы исходных жемчужин в       порядке, в котором они должны быть расположены в ожерелье. Индексы       жемчужин, принадлежащих одной части, должны быть расположены на       соседних позициях в перестановке (поэтому $$$1\,4\,3\,2$$$ не       является корректным выводом, а $$$2\,1\,4\,3$$$ и $$$4\,3\,1\,2$$$       являются). Если существует несколько подходящих ответов, вы можете       вывести любой.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
13 11
11 1
3 5
17 1
9 27
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
8 7 9 10 5 6 1 2 3 4 
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
13 11
11 1
3 5
17 1
7 29
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
8 7 10 9 5 6 4 3 2 1 
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
1
1 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
20
2 1 
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере следующие пары жемчужин объединяются: $$$(7,       9)$$$, $$$(10, 5)$$$, $$$(6, 1)$$$, $$$(2, 3)$$$ и $$$(4, 8)$$$.       Красота соединений равна: $$$3$$$, $$$3$$$, $$$3$$$, $$$20$$$,       $$$20$$$, соответственно.</p>     <p>Иллюстрация показывает эту конструкцию:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/69d60d8bfa6bc79bd945ddb77b0979b45ae8d7f1.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1361/problem/C' title='Codeforces Round 647 (Div. 1) - Thanks, Algo Muse!'>1361C - Johnny and Megan's Necklace</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Say that we want to check if it is possible to construct a       necklace with beauty at least $$$b$$$. To this end, we will       construct a graph of $$$2^{b}$$$ vertices. For a necklace part       with pearls in colors $$$u$$$ and $$$v$$$ there will be an edge in       this graph between vertices with zero-based indices $$$v\text{       &amp; }(2^b-1)$$$ and $$$u\text{ &amp; }(2^b-1)$$$. In a necklace       with beauty (at least) $$$b$$$, only pearl with colors having last       $$$b$$$ bits the same can be glued together. Note that this is the       exact condition that the edge endpoints have to satisfy to be in       the same vertex. Since all the necklace parts have to be used, a       necklace of beauty at least $$$b$$$ is an Euler cycle of this graph.</p>     <p>The solution will construct the graph mentioned above for all       possible values of $$$b$$$ (we can iterate over all of them since       there are only $$$21$$$ of them). If the constructed graph is       Eulerian, it is possible to achieve the current value of $$$b$$$.</p>     <p>In order to find a sample necklace with the optimal beauty, one       has to find the Euler cycle in the graph corresponding to the       optimal value. </p>     <p>       <span class="tex-font-style-bf">Challenge</span>: In another       version of this task you are not allowed to glue pearls of the       same color together. There is also a guarantee that there are no       three pearls of the same color. Time complexity of the solution is       the same.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

#define st first
#define nd second
#define PII pair &lt;int, int&gt;

const int N = 1 &lt;&lt; 20;

int n;
int part[N][2];

bool vis[N];
vector &lt;int&gt; ans;
vector &lt;PII&gt; G[N];

//mark whole component as visited
void dfs(int u){
	vis[u] = true;
	for(auto v: G[u])
		if(!vis[v.st])
			dfs(v.st);
}

//check if the graph for a given Mask is correct
bool check(int Mask){
	for(int i = 0; i &lt;= Mask; ++i)
		G[i].clear(), vis[i] = false;

	for(int i = 1; i &lt;= n; ++i){
		int u = part[i][0] &amp; Mask;
		int v = part[i][1] &amp; Mask;
		
		G[u].push_back({v, 2 * i - 1});
		G[v].push_back({u, 2 * i - 2});
	}
	
	//calculate number of components and check if all degrees are even
	int comps = 0;
	for(int i = 0; i &lt;= Mask; ++i){
		if(G[i].size() &amp; 1)
			return false;
		
		if(!vis[i] &amp;&amp; G[i].size() &gt; 0){
			++comps;
			dfs(i);
		}
	}
	
	return comps == 1;
}

//find euler cycle
void go(int u, int prv = -1){
	while(G[u].size()){
		auto e = G[u].back();
		G[u].pop_back();

		if(vis[e.nd / 2])
			continue;
		
		vis[e.nd / 2] = true;
		go(e.st, e.nd);
	}
	
	if(prv != -1){
		ans.push_back(prv);
		ans.push_back(prv ^ 1);
	}
}

//restore the sequence corresponding to the result for given mask
//the result is already checked so the graph is built
void restore(int Mask){
	for(int i = 0; i &lt;= n; ++i)
		vis[i] = false;
	
	for(int i = 0; i &lt;= Mask; ++i)
		if(G[i].size()){
			go(i);
			break;
		}
	
	//cycle is reversed but thats fine
	for(int i = 0; i &lt; n + n; ++i)
		printf(&#34;%d%c&#34;, ans[i] + 1, &#34; \n&#34;[i + 1 == n + n]);
}

int main(){
	scanf(&#34;%d&#34;, &amp;n);
	for(int i = 1; i &lt;= n; ++i)
		scanf(&#34;%d %d&#34;, &amp;part[i][0], &amp;part[i][1]);

	for(int i = 20; i &gt;= 0; --i)
		if(check((1 &lt;&lt; i) - 1)){
			printf(&#34;%d\n&#34;, i);
			restore((1 &lt;&lt; i) - 1);
			exit(0);
		}
	
	assert(false);
	return 0;
}
</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

#define st first
#define nd second
#define PII pair &lt;int, int&gt;

const int N = 1 &lt;&lt; 20;

int n;
int part[N][2];

bool vis[N];
vector &lt;int&gt; ans;
vector &lt;PII&gt; G[N];

//mark whole component as visited
void dfs(int u){
	vis[u] = true;
	for(auto v: G[u])
		if(!vis[v.st])
			dfs(v.st);
}

//check if the graph for a given Mask is correct
bool check(int Mask){
	for(int i = 0; i &lt;= Mask; ++i)
		G[i].clear(), vis[i] = false;

	for(int i = 1; i &lt;= n; ++i){
		int u = part[i][0] &amp; Mask;
		int v = part[i][1] &amp; Mask;
		
		G[u].push_back({v, 2 * i - 1});
		G[v].push_back({u, 2 * i - 2});
	}
	
	//calculate number of components and check if all degrees are even
	int comps = 0;
	for(int i = 0; i &lt;= Mask; ++i){
		if(G[i].size() &amp; 1)
			return false;
		
		if(!vis[i] &amp;&amp; G[i].size() &gt; 0){
			++comps;
			dfs(i);
		}
	}
	
	return comps == 1;
}

//find euler cycle
void go(int u, int prv = -1){
	while(G[u].size()){
		auto e = G[u].back();
		G[u].pop_back();

		if(vis[e.nd / 2])
			continue;
		
		vis[e.nd / 2] = true;
		go(e.st, e.nd);
	}
	
	if(prv != -1){
		ans.push_back(prv);
		ans.push_back(prv ^ 1);
	}
}

//restore the sequence corresponding to the result for given mask
//the result is already checked so the graph is built
void restore(int Mask){
	for(int i = 0; i &lt;= n; ++i)
		vis[i] = false;
	
	for(int i = 0; i &lt;= Mask; ++i)
		if(G[i].size()){
			go(i);
			break;
		}
	
	//cycle is reversed but thats fine
	for(int i = 0; i &lt; n + n; ++i)
		printf(&#34;%d%c&#34;, ans[i] + 1, &#34; \n&#34;[i + 1 == n + n]);
}

int main(){
	scanf(&#34;%d&#34;, &amp;n);
	for(int i = 1; i &lt;= n; ++i)
		scanf(&#34;%d %d&#34;, &amp;part[i][0], &amp;part[i][1]);

	for(int i = 20; i &gt;= 0; --i)
		if(check((1 &lt;&lt; i) - 1)){
			printf(&#34;%d\n&#34;, i);
			restore((1 &lt;&lt; i) - 1);
			exit(0);
		}
	
	assert(false);
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #647 (Div. 1) - Thanks, Algo Muse!
    1361D
    Джонни и Джеймс </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Джонни и Джеймс</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У Джеймса Бонда, любимого секретного агента Джонни, новая миссия.       Есть $$$n$$$ вражеских баз, каждая из которых задана своими       координатами, так что мы можем рассматривать их как точки на плоскости.</p>     <p>Базы могут общаться друг с другом, посылая сигнал, который       является лучом, из выбранной точки в направлении начала координат       или в противоположном направлении. Исключением является       центральная база, расположенная в начале координат. Она может       посылать сигнал в любом направлении.</p>     <p>Когда какие-то две базы хотят коммуницировать, существует два       возможных сценария. Если они лежат на одной прямой с началом       координат, одна из них посылает сигнал непосредственно второй.       Иначе, из первой базы сигнал посылается на центральную, и оттуда —       на вторую. Обозначим расстоянием между двумя базами суммарное       Евклидово расстояние, которое сигнал, посланный между ними, должен пройти.</p>     <p>Бонд может повредить все, кроме некоторых $$$k$$$ баз, которые он       может выбрать на свое усмотрение. Поврежденная база не может       посылать или получать сигнал напрямую, но все еще может передавать       его между двумя работающими базами. В частности, Джеймс может       повредить центральную базу, и сигнал <span class="tex-font-style-bf">все еще может быть послан</span> между       любыми двумя неповрежденными базами, как и раньше, и расстояние       между ними останется неизменным. Какова максимальная сумма       расстояний между всеми парами оставшихся баз, которую 007 может       достичь, уничтожив ровно $$$n - k$$$ баз?</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит два целых числа $$$n$$$ и $$$k$$$ $$$(2       \leq k \leq n \leq 5 \cdot 10^5)$$$ — количество баз и количество       баз, которое должно остаться, соответственно.</p>     <p>Каждая из следующих $$$n$$$ строк содержит два целых числа       $$$x$$$ и $$$y$$$ $$$(-10^9 \leq x, y \leq 10^9)$$$, $$$i$$$-я       строка содержит координаты $$$i$$$-й базы. Гарантируется, что       никакие две точки не совпадают и что одна из точек равна $$$(0, 0)$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Вы должны вывести одно число — максимальную возможную сумму       расстояний между всеми парами некоторых $$$k$$$ из баз. Ваш ответ       будет считаться правильным, если его абсолютная или относительная       погрешность не превышает $$$10^{-6}$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6 2
0 0
1 1
2 2
3 3
0 1
0 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
6.24264069
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
6 5
0 0
1 1
2 2
3 3
0 1
0 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
32.62741700
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
13 10
0 0
1 0
2 0
3 0
4 0
5 0
6 0
7 0
8 0
9 0
0 -2
0 1
0 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
237.00000000
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
10 5
2 2
4 4
3 5
6 10
0 5
0 0
5 0
10 0
0 10
4 7
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
181.52406315
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере, в оптимальном решении Бонд <span class="tex-font-style-bf">не</span> разрушает базы с номерами       $$$4$$$ и $$$6$$$ (помечены оранжевым): </p>     <center> <img class="tex-graphics" src="https://espresso.codeforces.com/c9fb6601db4a76fcc522afb554b05909e0e2f21b.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>Следующая иллюстрация показывает оптимальное решение для второго       примера. Следующие базы <span class="tex-font-style-bf">не</span>       разрушены: $$$2$$$, $$$3$$$, $$$4$$$, $$$5$$$, $$$6$$$ (помечены оранжевым).</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/c10877d2e8cc4d3f6b67968e0f6dba15f95304fc.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>Оптимальное решение для третьего теста изображено на иллюстрации.       Только базы с номерами $$$3$$$, $$$4$$$ и $$$5$$$ разрушены.       Снова, <span class="tex-font-style-bf">не</span> разрушенные базы       помечены оранжевым.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/b8d1a440b2809b2e3febfca36b2927b7baa80213.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1361/problem/D' title='Codeforces Round 647 (Div. 1) - Thanks, Algo Muse!'>1361D - Johnny and James</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>We can easily model the way of calculating distances from the       problem statement as a tree with $$$n$$$ vertices, each       corresponding to a base. This tree has the following structure:       there is only one vertex which can have degree bigger than $$$2$$$       (the one corresponding to the central base), I will call it the       center of the tree. There are also some paths consisting of       vertices corresponding to bases lying on the same half-line       starting at point $$$(0, 0)$$$. We will call those arms of the       tree. Assume that the center does not belong to any arm.</p>     <p>The task is to choose $$$k$$$ vertices in a way that maximizes       the sum of distances between them. Let us start with a lemma:</p>     <p>If $$$x$$$ vertices are chosen from an arm, at least $$$ min(x,       \lfloor \frac{k}{2} \rfloor)$$$ of them are the ones furthest from       the center.</p>     <p>Say that less than $$$min(x, \lfloor \frac{k}{2} \rfloor)$$$ is       chosen from the end of the arm (counting from the center). Then       there exists such chosen vertex $$$v$$$ on the arm, that the next       (counting from the center) vertex $$$u$$$ is not chosen. Let the       length of the edge between them be $$$l$$$ and let there be       $$$t$$$ vertices further from the center than $$$v$$$. If we had       chosen $$$u$$$ instead of $$$v$$$, the sum of distances would       change by $$$l \cdot (k - t - 1) - l \cdot t = l \cdot (k - 2t -       1)$$$ (the chosen vertex would move closer by $$$l$$$ to $$$t$$$       vertices, but also it's distance to $$$k-t-1$$$ vertices would       increase by $$$l$$$). But since $$$t &lt; \frac{k}{2}$$$, this       value is non-negative (the sum of distances would not decrease).</p>     <p>There are two cases which will be solved independently:</p>     <p>First case: there is no arm containing more than       $$$\frac{k}{2}$$$ vertices chosen. By the lemma, in every arm,       only vertices furthest from the center will be selected in an       optimal solution. </p>     <p>If a vertex is chosen, all the ones in the same arm further from       the center are chosen as well. Using this knowledge, we can assign       weights to vertices in such a way that the result for a set will       be the sum of weights. Weight for vertex $$$v$$$ equals: $$$ w_v =       dist(center, v) * (k - 1 - t - t) $$$ where $$$t$$$ is the number       of vertices further from center in the same arm as $$$v$$$. The       weight of the center equals $$$0$$$. Note that (with exception to       the center) $$$w_v \leq 0 $$$ iff taking $$$v$$$ would violate the       condition that at most $$$\frac{k}{2}$$$ are chosen from every arm.</p>     <p>The algorithm for this case is to add the vertices greedily to       the set until $$$k$$$ vertices have been chosen. The complexity of       the above algorithm is $$$\mathcal{O}(n \log n)$$$.</p>     <p>Second case: there is an arm, in which more than       $$$\frac{k}{2}$$$ vertices are chosen in the optimal solution.</p>     <p>From the lemma, we know that $$$\lfloor \frac{k}{2} \rfloor$$$       vertices lying furthest from the center will be chosen. It can be       proved (in a similar manner as the lemma) that in an optimal       solution, all other selected vertices from this arm will be as       close to the center as possible. Furthermore, the center and all       the vertices in the other arms will be selected. Intuitively, when       there are $$$\lfloor \frac{k}{2} \rfloor$$$ chosen vertices on a       single-arm, we will not decrease the sum of distances by moving       another selected vertex further from them along an edge.</p>     <p>There is at most one set of $$$k$$$ vertices satisfying those       conditions so that this part can be implemented in $$$\mathcal{O}(n)$$$.</p>     <p>The time complexity of this solution is $$$\mathcal{O}(n \log n)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long double T;

#define st first
#define nd second
#define PII pair &lt;int, int&gt;

const int N = 1e6 + 7;

int n, m, k;
vector &lt;T&gt; arms[N];

void read(){
	map &lt;PII, int&gt; M;

	scanf(&#34;%d %d&#34;, &amp;n, &amp;k);	
	for(int i = 1; i &lt;= n; ++i){
		int x, y;
		scanf(&#34;%d %d&#34;, &amp;x, &amp;y);
		
		if(x == 0 &amp;&amp; y == 0)
			continue;
		
		int d = __gcd(abs(x), abs(y));
		PII my_id = {x / d, y / d};
		
		if(!M.count(my_id))
			M[my_id] = ++m;
		
		auto id = M[my_id];
		arms[id].push_back(sqrtl((T)x * x + (T)y * y));
	}
	
	for(int i = 1; i &lt;= m; ++i){
		sort(arms[i].begin(), arms[i].end());
		reverse(arms[i].begin(), arms[i].end());
	}
}

T solve_center(){
	T ans = 0;
	vector &lt;T&gt; vals = {0};

	for(int i = 1; i &lt;= m; ++i){
		int it = 0;
		for(auto v: arms[i]){
			++it;
			vals.push_back(v * (k - it - it + 1));
		}
	}
	
	sort(vals.begin(), vals.end());
	reverse(vals.begin(), vals.end());

	for(int i = 0; i &lt; k; ++i)
		ans += vals[i];
	return ans;
}

T solve_arm(int id){
	T ans = 0;
	for(int i = 1; i &lt;= m; ++i){
		if(i == id)
			continue;
		
		int it = 0;
		for(auto v: arms[i]){
			++it;
			ans += v * (k - it - it + 1);
		}
	}
	
	int half = k / 2;
	int first_half = k - half - (n - arms[id].size());
		
	for(int i = 0; i &lt; half; ++i)
		ans += arms[id][i] * (k - i - i - 1);
	
	for(int i = 0; i &lt; first_half; ++i){
		T val = arms[id][arms[id].size() - i - 1];
		ans += val * (k - half - half - 2 * first_half + 2 * i + 1);
	}
	
	return ans;
}

int main(){
	read();
	T ans = solve_center();
	if(k &lt; n){
		for(int i = 1; i &lt;= m; ++i)
			if(2 * (n - (int)arms[i].size()) &lt;= k)
				ans = max(ans, solve_arm(i));
	}

	printf(&#34;%.10Lf\n&#34;, ans);
	return 0;
}
</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long double T;

#define st first
#define nd second
#define PII pair &lt;int, int&gt;

const int N = 1e6 + 7;

int n, m, k;
vector &lt;T&gt; arms[N];

void read(){
	map &lt;PII, int&gt; M;

	scanf(&#34;%d %d&#34;, &amp;n, &amp;k);	
	for(int i = 1; i &lt;= n; ++i){
		int x, y;
		scanf(&#34;%d %d&#34;, &amp;x, &amp;y);
		
		if(x == 0 &amp;&amp; y == 0)
			continue;
		
		int d = __gcd(abs(x), abs(y));
		PII my_id = {x / d, y / d};
		
		if(!M.count(my_id))
			M[my_id] = ++m;
		
		auto id = M[my_id];
		arms[id].push_back(sqrtl((T)x * x + (T)y * y));
	}
	
	for(int i = 1; i &lt;= m; ++i){
		sort(arms[i].begin(), arms[i].end());
		reverse(arms[i].begin(), arms[i].end());
	}
}

T solve_center(){
	T ans = 0;
	vector &lt;T&gt; vals = {0};

	for(int i = 1; i &lt;= m; ++i){
		int it = 0;
		for(auto v: arms[i]){
			++it;
			vals.push_back(v * (k - it - it + 1));
		}
	}
	
	sort(vals.begin(), vals.end());
	reverse(vals.begin(), vals.end());

	for(int i = 0; i &lt; k; ++i)
		ans += vals[i];
	return ans;
}

T solve_arm(int id){
	T ans = 0;
	for(int i = 1; i &lt;= m; ++i){
		if(i == id)
			continue;
		
		int it = 0;
		for(auto v: arms[i]){
			++it;
			ans += v * (k - it - it + 1);
		}
	}
	
	int half = k / 2;
	int first_half = k - half - (n - arms[id].size());
		
	for(int i = 0; i &lt; half; ++i)
		ans += arms[id][i] * (k - i - i - 1);
	
	for(int i = 0; i &lt; first_half; ++i){
		T val = arms[id][arms[id].size() - i - 1];
		ans += val * (k - half - half - 2 * first_half + 2 * i + 1);
	}
	
	return ans;
}

int main(){
	read();
	T ans = solve_center();
	if(k &lt; n){
		for(int i = 1; i &lt;= m; ++i)
			if(2 * (n - (int)arms[i].size()) &lt;= k)
				ans = max(ans, solve_arm(i));
	}

	printf(&#34;%.10Lf\n&#34;, ans);
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #647 (Div. 1) - Thanks, Algo Muse!
    1361E
    Джеймс и погоня </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. Джеймс и погоня</div>     <div class="time-limit"><div class="property-title">ограничение по времени на       тест</div>2.5 секунд</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У Джеймса Бонда есть новый план, как поймать своего врага. Есть       несколько городов и <span class="tex-font-style-bf">ориентированные</span> дороги между       ними, причем используя эти дороги можно добраться из любого города       до любого другого. Когда враг появляется в каком-то городе, Бонд       знает её следующий пункт назначения, но понятия не имеет, какой       путь она выберет, чтобы ехать туда.</p>     <p>Город $$$a$$$ называется интересным, если для любого города       $$$b$$$, существует ровно один простой путь из $$$a$$$ в $$$b$$$.       Простым путем называется последовательность различных городов, в       которой для каждых двух соседних городов есть дорога, ведущая из       первого города во второй.</p>     <p>Враг Бонда хороша в побегах, поэтому только погоня, начатая в       интересном городе дает шанс поймать её. Джеймс хочет расположить       своих людей в таких городах. Однако, если интересных городов       недостаточно много, весь план не имеет смысла, потому что людям       Бонда, возможно, придется ждать появления врага очень долго.</p>     <p>Вы ответственны за поиск всех интересных городов. Выведите их,       либо сообщите, что их недостаточно много. Под недостаточно много,       Джеймс подразумевает строго меньше $$$20\%$$$ всех городов.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит одно целое число $$$t$$$ ($$$1 \leq t \leq       2\,000$$$) — количество наборов входных данных. Каждый набор       входных данных описывается следующим образом:</p>     <p>Первая строка содержит два целых числа $$$n$$$ и $$$m$$$ ($$$1       \leq n \le 10^5$$$, $$$0 \leq m \le 2 \cdot 10^5$$$) — количество       городов и дорог между ними. Каждая из следующих $$$m$$$ строк       содержит два целых числа $$$u$$$ и $$$v$$$ ($$$u \neq v$$$; $$$1       \leq u, v \leq n$$$), которые обозначают дорогу из города $$$u$$$       в город $$$v$$$.</p>     <p>Гарантируется, что между каждой упорядоченной парой городов       существует максимум одна дорога. Сумма $$$n$$$ по всем наборам       входных данных не превышает $$$10^5$$$, а сумма $$$m$$$ не       превышает $$$2 \cdot 10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Если строго меньше $$$20\%$$$ всех городов являются интересными,       выведите $$$-1$$$. Иначе, пусть $$$k$$$ равно количеству       интересных городов. Выведите $$$k$$$ различных целых чисел в       порядке возрастания — номера интересных городов.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
3 3
1 2
2 3
3 1
3 6
1 2
2 1
2 3
3 2
1 3
3 1
7 10
1 2
2 3
3 1
1 4
4 5
5 1
4 6
6 7
7 4
6 1
6 8
1 2
2 3
3 4
4 5
5 6
6 1
6 2
5 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1 2 3 
-1
1 2 3 5 
-1
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>На всех иллюстрациях, если город интересный, он помечен зеленым,       а иначе — красным.</p>     <p>В первом наборе входных данных, все города интересные. </p>     <center> <img class="tex-graphics" src="https://espresso.codeforces.com/87e0bbcee48594de37b23a676007c13fed7e8861.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>Во втором наборе входных данных, ни один город не интересен. </p>     <center> <img class="tex-graphics" src="https://espresso.codeforces.com/67e3f1d2fe5a3ae679a81637a28cba8d10690d12.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>В третьем наборе входных данных, города $$$1$$$, $$$2$$$, $$$3$$$       и $$$5$$$ интересные. </p>     <center> <img class="tex-graphics" src="https://espresso.codeforces.com/770d1dc42d1d76bc99074e566acc63becca03f19.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>В четвертом наборе входных данных, только город $$$1$$$ является       интересным. Это строго меньше, чем $$$20\%$$$ всех городов,       поэтому ответ $$$-1$$$. </p>     <center> <img class="tex-graphics" src="https://espresso.codeforces.com/feac6ccbfd9e4443658aaf9c32ad9b3ca8ef3cb2.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1361/problem/E' title='Codeforces Round 647 (Div. 1) - Thanks, Algo Muse!'>1361E - James and the Chase</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>First, let us describe an algorithm for checking if a vertex is       interesting. Let $$$v$$$ be the vertex we want to check. Find any       DFS tree rooted in that vertex. We can see that $$$v$$$ is       interesting if and only if that tree is unique. The tree is unique       iff every non-tree edge leads from some vertex $$$u$$$ to       $$$u$$$'s ancestor. That condition can be easily checked in $$$\mathcal{O}(n)$$$.</p>     <p>Using the fact that we are interested only in cases when at least       $$$20\%$$$ of vertices are interesting, we can find any       interesting vertex by choosing a random vertex, checking if it is       interesting and repeating that algorithm $$$T$$$ times or until we       find an interesting vertex. For $$$T = 100$$$ the probability of       failure is around $$$2 \cdot 10^{-10}$$$.</p>     <p>Denote that vertex as $$$r$$$. Find the DFS tree rooted in that       vertex. We can notice that vertex is interesting if and only if it       has a unique path to all of its ancestors in this tree. We will       say that edge is passing vertex $$$v$$$ if it starts in its       subtree (including $$$v$$$) and ends in one of the proper       ancestors of $$$v$$$. It is evident that if two edges pass through       $$$v$$$, then $$$v$$$ cannot be interesting.</p>     <p>Let us pick vertex $$$v$$$ such that there is at most one edge       passing through it. It is evident that if $$$v \neq r$$$, then       there is at least one such edge (because our graph is strongly       connected). Let $$$u$$$ be the endpoint of this edge being a       proper ancestor of $$$v$$$. We prove that $$$v$$$ is interesting       if and only if $$$u$$$ is interesting.</p>     <p>Pick arbitrary ancestor of $$$v$$$ which is <span class="tex-font-style-bf">not</span> an ancestor of $$$u$$$, let       us denote it by $$$t$$$. There is precisely one simple path from       $$$v$$$ to $$$t$$$ – descending in the subtree of $$$v$$$, using       the non-tree edge to $$$u$$$ and then tree edges to reach $$$t$$$.</p>     <p>Now pick arbitrary common ancestor of $$$v$$$ and $$$u$$$, let it       be $$$k$$$. If there is more than one simple path from $$$u$$$ to       $$$k$$$, then obviously there is more than one simple path from       $$$v$$$ to $$$k$$$. Otherwise, there is precisely one simple path       from $$$v$$$ to $$$k$$$ – descend in the subtree, use edge to       $$$u$$$ and from $$$u$$$ there is one simple path to $$$k$$$.</p>     <p>The above observations allow computing interesting vertices using       simple DFSs. The final complexity is $$$\mathcal{O}(Tn)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

const int N = 1e5 + 7;

int n, m;
bool bad[N];
vector &lt;int&gt; G[N];

int vis[N];
bool interesting;

int lvl[N];
int best[N];
int balance[N];

void clear(){
	for(int i = 1; i &lt;= n; ++i){
		lvl[i] = 0;
		best[i] = 0;
		balance[i] = 0;

		G[i].clear();		
		bad[i] = false;
	}
}

void no_answer(){
	puts(&#34;-1&#34;);
	clear();
}

int getInt(int a = INT_MIN, int b = INT_MAX){
	static mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
	return uniform_int_distribution &lt;int&gt; (a, b)(rng);
}

void dfs(int u){
	vis[u] = 1;
	for(auto v: G[u])
		if(vis[v] == 0)
			dfs(v);
		else if(vis[v] == 2)
			interesting = false;
	vis[u] = 2;
}

bool check(int r){
	for(int i = 1; i &lt;= n; ++i)
		vis[i] = 0;
	interesting = true;

	dfs(r);
	return interesting;
}

int find_any(){
	int tests = 100;
	while(tests--){
		int r = getInt(1, n);
		if(check(r))
			return r;
	}
	
	return -1;
}

int find_bad(int u){
	vis[u] = 1;
	best[u] = u;
	for(auto v: G[u])
		if(vis[v] == 0){
			lvl[v] = lvl[u] + 1;
			balance[u] += find_bad(v);
			
			if(lvl[best[v]] &lt; lvl[best[u]])
				best[u] = best[v];
		}
		else{
			balance[u]++;
			balance[v]--;
			
			if(lvl[v] &lt; lvl[best[u]])
				best[u] = v;
		}
	
	if(balance[u] &gt; 1)
		bad[u] = true;
	return balance[u];
}

void propagate_bad(int u){
	vis[u] = 1;
	if(!bad[u] &amp;&amp; bad[best[u]])
		bad[u] = true;

	for(auto v: G[u])
		if(vis[v] == 0)
			propagate_bad(v);
}

vector &lt;int&gt; find_all(int r){
	for(int i = 1; i &lt;= n; ++i)
		vis[i] = 0;
	vector &lt;int&gt; ans;

	find_bad(r);
	for(int i = 1; i &lt;= n; ++i)
		vis[i] = 0;

	propagate_bad(r);
	for(int i = 1; i &lt;= n; ++i)
		if(!bad[i])
			ans.push_back(i);
	return ans;
}

void solve(){
	scanf(&#34;%d %d&#34;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= m; ++i){
		int u, v;
		scanf(&#34;%d %d&#34;, &amp;u, &amp;v);		
		G[u].push_back(v);
	}
	
	int id = find_any();
	if(id == -1){
		no_answer();
		return;
	}
	
	auto ans = find_all(id);
	if(5 * ans.size() &gt;= n){
		for(auto v: ans)
			printf(&#34;%d &#34;, v);
		puts(&#34;&#34;);
		clear();
	}
	else
		no_answer();
}

int main(){
	int cases;
	scanf(&#34;%d&#34;, &amp;cases);
	
	while(cases--)
		solve();
	return 0;
}

</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

const int N = 1e5 + 7;

int n, m;
bool bad[N];
vector &lt;int&gt; G[N];

int vis[N];
bool interesting;

int lvl[N];
int best[N];
int balance[N];

void clear(){
	for(int i = 1; i &lt;= n; ++i){
		lvl[i] = 0;
		best[i] = 0;
		balance[i] = 0;

		G[i].clear();		
		bad[i] = false;
	}
}

void no_answer(){
	puts(&#34;-1&#34;);
	clear();
}

int getInt(int a = INT_MIN, int b = INT_MAX){
	static mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
	return uniform_int_distribution &lt;int&gt; (a, b)(rng);
}

void dfs(int u){
	vis[u] = 1;
	for(auto v: G[u])
		if(vis[v] == 0)
			dfs(v);
		else if(vis[v] == 2)
			interesting = false;
	vis[u] = 2;
}

bool check(int r){
	for(int i = 1; i &lt;= n; ++i)
		vis[i] = 0;
	interesting = true;

	dfs(r);
	return interesting;
}

int find_any(){
	int tests = 100;
	while(tests--){
		int r = getInt(1, n);
		if(check(r))
			return r;
	}
	
	return -1;
}

int find_bad(int u){
	vis[u] = 1;
	best[u] = u;
	for(auto v: G[u])
		if(vis[v] == 0){
			lvl[v] = lvl[u] + 1;
			balance[u] += find_bad(v);
			
			if(lvl[best[v]] &lt; lvl[best[u]])
				best[u] = best[v];
		}
		else{
			balance[u]++;
			balance[v]--;
			
			if(lvl[v] &lt; lvl[best[u]])
				best[u] = v;
		}
	
	if(balance[u] &gt; 1)
		bad[u] = true;
	return balance[u];
}

void propagate_bad(int u){
	vis[u] = 1;
	if(!bad[u] &amp;&amp; bad[best[u]])
		bad[u] = true;

	for(auto v: G[u])
		if(vis[v] == 0)
			propagate_bad(v);
}

vector &lt;int&gt; find_all(int r){
	for(int i = 1; i &lt;= n; ++i)
		vis[i] = 0;
	vector &lt;int&gt; ans;

	find_bad(r);
	for(int i = 1; i &lt;= n; ++i)
		vis[i] = 0;

	propagate_bad(r);
	for(int i = 1; i &lt;= n; ++i)
		if(!bad[i])
			ans.push_back(i);
	return ans;
}

void solve(){
	scanf(&#34;%d %d&#34;, &amp;n, &amp;m);
	for(int i = 1; i &lt;= m; ++i){
		int u, v;
		scanf(&#34;%d %d&#34;, &amp;u, &amp;v);		
		G[u].push_back(v);
	}
	
	int id = find_any();
	if(id == -1){
		no_answer();
		return;
	}
	
	auto ans = find_all(id);
	if(5 * ans.size() &gt;= n){
		for(auto v: ans)
			printf(&#34;%d &#34;, v);
		puts(&#34;&#34;);
		clear();
	}
	else
		no_answer();
}

int main(){
	int cases;
	scanf(&#34;%d&#34;, &amp;cases);
	
	while(cases--)
		solve();
	return 0;
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #647 (Div. 1) - Thanks, Algo Muse!
    1361F
    Джонни и новая игрушка </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Джонни и новая игрушка</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>15 секунд</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на       тест</div>1024 мегабайта</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У Джонни новая игрушка. Как вы можете догадаться, она немного       необычная. Игрушка является перестановкой $$$P$$$ чисел от $$$1$$$       до $$$n$$$, записанных в строку друг за другом.</p>     <p>Для каждого $$$i$$$ от $$$1$$$ до $$$n - 1$$$, между $$$P_i$$$ и       $$$P_{i + 1}$$$ написан вес $$$W_i$$$, и эти веса также образуют       перестановку чисел от $$$1$$$ до $$$n - 1$$$. Дополнительно есть       веса $$$W_0 = W_n = 0$$$.</p>     <p>Инструкция гласит, что отрезок $$$[L, R]$$$ является хорошим,       если $$$W_{L - 1} &lt; W_i$$$ и $$$W_R &lt; W_i$$$ для всех       $$$i$$$ из $$$\{L, L + 1, \ldots, R - 1\}$$$. Для такого отрезка       она также определяет $$$W_M$$$ как минимум из множества $$$\{W_L,       W_{L + 1}, \ldots, W_{R - 1}\}$$$. </p>     <p>Теперь начинается веселье. За один ход, игрок может выбрать один       из хороших подотрезков, разрезать на $$$[L, M]$$$ и $$$[M + 1,       R]$$$ и поменять местами эти части. Более точно, до операции       выбранный подотрезок игрушки выглядел следующим образом:       $$$$$$W_{L - 1}, P_L, W_L, \ldots, W_{M - 1}, P_M, W_M, P_{M + 1},       W_{M + 1}, \ldots, W_{R - 1}, P_R, W_R$$$$$$ А после, он стал       выглядеть так: $$$$$$W_{L - 1}, P_{M + 1}, W_{M + 1}, \ldots, W_{R       - 1}, P_R, W_M, P_L, W_L, \ldots, W_{M - 1}, P_M, W_R$$$$$$</p>     <p>Такая операция может быть выполнена несколько раз (возможно,       ноль), и целью является получить минимальное возможное количество       инверсий в $$$P$$$.</p>     <p>Младшая сестра Джонни, Меган, считает, что правила слишком       запутанные, поэтому она хочет проверить своего брата, выбирая       некоторые пары индексов $$$X$$$ и $$$Y$$$, и меняя местами       $$$P_X$$$ и $$$P_Y$$$ ($$$X$$$ может быть равно $$$Y$$$). После       каждого действия сестры, Джонни интересуется, какого минимального       количества инверсий можно достичь, начиная с текущего $$$P$$$ и       делая корректные действия?</p>     <p>Вы можете считать, что входные данные были сгенерированы <span class="tex-font-style-bf">случайно</span>. $$$P$$$ и $$$W$$$ были       выбраны случайно и равновероятно среди всех перестановок, а       запросы Меган были выбраны случайно и равновероятно среди всех пар индексов.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит одно целое число $$$n$$$ $$$(2 \leq n \leq       2 \cdot 10^5)$$$, обозначающее длину игрушки.</p>     <p>Вторая строка содержит $$$n$$$ различных целых чисел $$$P_1, P_2,       \ldots, P_n$$$ $$$(1 \leq P_i \leq n)$$$, обозначающих исходную       перестановку $$$P$$$. Третья строка содержит $$$n - 1$$$ различных       целых чисел $$$W_1, W_2, \ldots, W_{n - 1}$$$ $$$(1 \leq W_i \leq       n - 1)$$$, обозначающих веса.</p>     <p>Четвертая строка содержит одно целое число $$$q$$$ $$$(1 \leq q       \leq 5 \cdot 10^4)$$$ — количество действий Меган. Следующие       $$$q$$$ строк содержат по два целых числа $$$X$$$ и $$$Y$$$ $$$(1       \leq X, Y \leq n)$$$ — индексы элементов $$$P$$$, меняющихся       местами. Запросы не независимы, после каждого из них перестановка меняется.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$q$$$ строк. Строка номер $$$i$$$ должна содержать       одно целое число — минимальное количество инверсий в перестановке,       которое может быть получено, если начинать с $$$P$$$ после первых       $$$i$$$ запросов и выполнять операции, описанные в инструкции.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
3 2 1
2 1
3
1 3
3 2
3 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
1
0
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
4 3 2 5 1
3 2 1 4
7
5 4
5 2
1 5
2 4
2 4
4 3
3 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
1
2
1
2
3
3
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Рассмотрим первый пример. После первого запроса, $$$P$$$       отсортирована, поэтому мы уже получили перестановку без инверсий.</p>     <p>После второго запроса, $$$P$$$ равна [$$$1$$$, $$$3$$$, $$$2$$$],       в ней есть одна инверсия, и можно доказать, что получить $$$0$$$       инверсий невозможно.</p>     <p>В конце, $$$P$$$ равна [$$$2$$$, $$$3$$$, $$$1$$$]. Мы можем       выбрать всю перестановку в качестве хорошего подотрезка, после       чего $$$P$$$ станет равным [$$$1$$$, $$$2$$$, $$$3$$$], в котором       $$$0$$$ инверсий.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1361/problem/F' title='Codeforces Round 647 (Div. 1) - Thanks, Algo Muse!'>1361F - Johnny and New Toy</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let us start with an analysis of good subsegments for the fixed       permutation. The whole permutation is a good subsegment itself, as       $$$W_0 = W_n = 0 &lt; W_k$$$ for any $$$k \in [1, 2, \ldots, n -       1]$$$. If we denote the minimal weight in $$$W_1, \ldots, W_{n -       1}$$$ as $$$W_m$$$, then we can notice that subsegments $$$[1,       m]$$$ and $$$[m + 1, n]$$$ contain all good subsegments except the       whole permutation. As a result, we can recursively find all good       subsegments by recursive calls in $$$[1, m]$$$ and $$$[m + 1,       n]$$$. We can view the structure of good subsegments as a binary tree.</p>     <p>Example structure of tree for $$$P = [3, 4, 6, 2, 1, 5]$$$ and       $$$W = [5, 2, 3, 1, 4]$$$: </p>     <center> <img class="tex-graphics" src="https://espresso.codeforces.com/e408eefb93fc6928f9b18493a996d02bef20be95.png" style="max-width: 100.0%;max-height: 100.0%;" /> </center>          <p>Now we want to analyze the possible moves for players. It turns       out that the player's move is equivalent to choosing a vertex of a       tree and swapping its left and right subtree. Notice that moves       made in different vertices influence disjoint pairs of elements,       so in some sense these moves are independent if we are interested       only in the number of inversions. This observation allows us to       find a simple method for calculating the result. For each vertex,       calculate the number of inversions between the left and right       subtree. Using these numbers for each vertex, we can find out       whether we want to swap its subtrees or not, so the result can be       calculated by a simple loop over all vertices.</p>     <p>From randomness of the input, we can deduce that the tree we       built has height $$$\mathcal{O}(\log n)$$$. We can calculate the       number of inversions easily if in each vertex we keep a structure       with elements from permutation contained in that vertex. Such       structure must support querying the number of elements smaller       than some $$$x$$$. The shortest implementation uses the ordered       set, but any BST can do it (segment tree needs some squeezing to       fit into ML).</p>     <p>The above solution works fast if there are no queries. We can       view each request as two removals and additions of elements. If       so, we can notice that each query modifies the number of       inversions in at most $$$\mathcal{O}(\log n)$$$ vertices. So all       we need to do is update the number of inversions in these vertices       and recalculate the global result.</p>     <p>Building a tree and calculating initial number of inversions       takes $$$\mathcal{O}(n \log n)$$$ or $$$\mathcal{O}(n \log^2n)$$$,       answering each query cost $$$\mathcal{O}(\log^2 n)$$$, so the       final complexity is $$$\mathcal{O}(n \log n + q \log^2 n)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;
#include &lt;ext/pb_ds/assoc_container.hpp&gt;
#include &lt;ext/pb_ds/tree_policy.hpp&gt;

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef tree &lt; int, null_type, less &lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update &gt; ordered_set;

const int N = 2e5 + 7;

//cartesian tree node
//while creating we calculate set of elements and number of inversions
struct node{
	int splitter = -1;
	long long invs = 0;	
	
	ordered_set S;
	node *left = nullptr, *right = nullptr;
	node(){}
};

int n;
int in[N];
int weight[N];

long long ans = 0;
node *root = nullptr;

void read(){
	scanf(&#34;%d&#34;, &amp;n);
	for(int i = 1; i &lt;= n; ++i)
		scanf(&#34;%d&#34;, &amp;in[i]);
	
	for(int i = 1; i &lt; n; ++i)
		scanf(&#34;%d&#34;, &amp;weight[i]);
}

//add/delete contribution from fiven node to result
void add_result(node *cur, int mt = 1){
	if(cur -&gt; splitter == 0)
		return;
	ans += mt * min(cur -&gt; invs, (ll)cur -&gt; left -&gt; S.size() * (ll)cur -&gt; right -&gt; S.size() - cur -&gt; invs);
}

//Create cartesian tree
//Because expected depth is O(logn) we can use bruteforce to find the smallest weight
node* get_cartesian(int from, int to){
	node *ret = new node();
	if(from == to){
		ret -&gt; S.insert(in[from]);
		return ret;
	}
	
	int id = from;
	for(int i = from + 1; i &lt; to; ++i)
		if(weight[i] &lt; weight[id])
			id = i;
	
	ret -&gt; splitter = id;
	ret -&gt; left = get_cartesian(from, id);
	ret -&gt; right = get_cartesian(id + 1, to);
	
	//get elements from ordered set
	for(auto v: ret -&gt; right -&gt; S)
		ret -&gt; S.insert(v);
	
	//calculate number of inversions
	for(auto v: ret -&gt; left -&gt; S){
		ret -&gt; S.insert(v);
		ret -&gt; invs += ret -&gt; right -&gt; S.order_of_key(v);
	}
	
	//add contribution to the result
	add_result(ret);
	return ret;
}

//depending on mt, removes/add element val on position p
void update_cart(int p, int val, int mt){
	node *cur = root;
	while(cur -&gt; splitter != -1){
		add_result(cur, -1);
		if(mt == -1)
			cur -&gt; S.erase(val);
		else
			cur -&gt; S.insert(val);
		
		if(p &lt;= cur -&gt; splitter){
			cur -&gt; invs += mt * (int)(cur -&gt; right -&gt; S.order_of_key(val));
			cur = cur -&gt; left;
		}
		else{
			cur -&gt; invs += mt * (int)(cur -&gt; left -&gt; S.size() - cur -&gt; left -&gt; S.order_of_key(val));
			cur = cur -&gt; right;
		}
	}
	
	if(mt == -1)
		cur -&gt; S.erase(val);
	else
		cur -&gt; S.insert(val);	

	cur = root;
	while(cur -&gt; splitter != -1){
		add_result(cur, 1);
		if(p &lt;= cur -&gt; splitter)
			cur = cur -&gt; left;
		else
			cur = cur -&gt; right;
	}
}

int main(){
	read();
	root = get_cartesian(1, n);
	
	int q;
	scanf(&#34;%d&#34;, &amp;q);
	while(q--){
		int x, y;
		scanf(&#34;%d %d&#34;, &amp;x, &amp;y);
		
		if(x == y){
			printf(&#34;%lld\n&#34;, ans);
			continue;
		}
		
		//remove both numbers
		update_cart(x, in[x], -1);
		update_cart(y, in[y], -1);
		swap(in[x], in[y]);
		
		//add both numbers
		update_cart(x, in[x], 1);
		update_cart(y, in[y], 1);
		printf(&#34;%lld\n&#34;, ans);
	}
	
	return 0;
}
</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;
#include &lt;ext/pb_ds/assoc_container.hpp&gt;
#include &lt;ext/pb_ds/tree_policy.hpp&gt;

using namespace std;
using namespace __gnu_pbds;

typedef long long ll;
typedef tree &lt; int, null_type, less &lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update &gt; ordered_set;

const int N = 2e5 + 7;

//cartesian tree node
//while creating we calculate set of elements and number of inversions
struct node{
	int splitter = -1;
	long long invs = 0;	
	
	ordered_set S;
	node *left = nullptr, *right = nullptr;
	node(){}
};

int n;
int in[N];
int weight[N];

long long ans = 0;
node *root = nullptr;

void read(){
	scanf(&#34;%d&#34;, &amp;n);
	for(int i = 1; i &lt;= n; ++i)
		scanf(&#34;%d&#34;, &amp;in[i]);
	
	for(int i = 1; i &lt; n; ++i)
		scanf(&#34;%d&#34;, &amp;weight[i]);
}

//add/delete contribution from fiven node to result
void add_result(node *cur, int mt = 1){
	if(cur -&gt; splitter == 0)
		return;
	ans += mt * min(cur -&gt; invs, (ll)cur -&gt; left -&gt; S.size() * (ll)cur -&gt; right -&gt; S.size() - cur -&gt; invs);
}

//Create cartesian tree
//Because expected depth is O(logn) we can use bruteforce to find the smallest weight
node* get_cartesian(int from, int to){
	node *ret = new node();
	if(from == to){
		ret -&gt; S.insert(in[from]);
		return ret;
	}
	
	int id = from;
	for(int i = from + 1; i &lt; to; ++i)
		if(weight[i] &lt; weight[id])
			id = i;
	
	ret -&gt; splitter = id;
	ret -&gt; left = get_cartesian(from, id);
	ret -&gt; right = get_cartesian(id + 1, to);
	
	//get elements from ordered set
	for(auto v: ret -&gt; right -&gt; S)
		ret -&gt; S.insert(v);
	
	//calculate number of inversions
	for(auto v: ret -&gt; left -&gt; S){
		ret -&gt; S.insert(v);
		ret -&gt; invs += ret -&gt; right -&gt; S.order_of_key(v);
	}
	
	//add contribution to the result
	add_result(ret);
	return ret;
}

//depending on mt, removes/add element val on position p
void update_cart(int p, int val, int mt){
	node *cur = root;
	while(cur -&gt; splitter != -1){
		add_result(cur, -1);
		if(mt == -1)
			cur -&gt; S.erase(val);
		else
			cur -&gt; S.insert(val);
		
		if(p &lt;= cur -&gt; splitter){
			cur -&gt; invs += mt * (int)(cur -&gt; right -&gt; S.order_of_key(val));
			cur = cur -&gt; left;
		}
		else{
			cur -&gt; invs += mt * (int)(cur -&gt; left -&gt; S.size() - cur -&gt; left -&gt; S.order_of_key(val));
			cur = cur -&gt; right;
		}
	}
	
	if(mt == -1)
		cur -&gt; S.erase(val);
	else
		cur -&gt; S.insert(val);	

	cur = root;
	while(cur -&gt; splitter != -1){
		add_result(cur, 1);
		if(p &lt;= cur -&gt; splitter)
			cur = cur -&gt; left;
		else
			cur = cur -&gt; right;
	}
}

int main(){
	read();
	root = get_cartesian(1, n);
	
	int q;
	scanf(&#34;%d&#34;, &amp;q);
	while(q--){
		int x, y;
		scanf(&#34;%d %d&#34;, &amp;x, &amp;y);
		
		if(x == y){
			printf(&#34;%lld\n&#34;, ans);
			continue;
		}
		
		//remove both numbers
		update_cart(x, in[x], -1);
		update_cart(y, in[y], -1);
		swap(in[x], in[y]);
		
		//add both numbers
		update_cart(x, in[x], 1);
		update_cart(y, in[y], 1);
		printf(&#34;%lld\n&#34;, ans);
	}
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #647 (Div. 2) - Thanks, Algo Muse!
    1362A
    Джонни и древний компьютер </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Джонни и древний компьютер</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Недавно Джонни обнаружил древний сломанный компьютер. У него есть       только один регистр, в который можно записать некоторое значение.       После чего, за одну операцию вы можете применить к значению       битовый сдвиг влево или вправо на не более чем три позиции. Сдвиг       вправо запрещен, если в результате <span class="tex-font-style-bf">будут потеряны единичные биты</span>.       Так что, на самом деле, за одну операцию вы можете умножить или       разделить значение на $$$2$$$, $$$4$$$ или $$$8$$$, и деление       разрешено только если значение делится нацело на выбранный делитель.</p>     <p>Формально, если регистр содержит целое положительное число       $$$x$$$, за одну операцию оно может быть заменено одним из       следующих: </p>     <ul> <li> $$$x \cdot 2$$$ </li>       <li> $$$x \cdot 4$$$ </li>       <li> $$$x \cdot 8$$$ </li>       <li> $$$x / 2$$$, если $$$x$$$ делится на $$$2$$$ </li>       <li> $$$x / 4$$$, если $$$x$$$ делится на $$$4$$$ </li>       <li> $$$x / 8$$$, если $$$x$$$ делится на $$$8$$$ </li></ul>          <p>Например, если $$$x = 6$$$, за одну операцию оно может быть       заменено на $$$12$$$, $$$24$$$, $$$48$$$ или $$$3$$$. Значение       $$$6$$$ не делится на $$$4$$$ или $$$8$$$, поэтому существуют       только четыре варианта замены.</p>     <p>Теперь Джонни интересуется, какое минимальное количество операций       необходимо, если он запишет в регистр значение $$$a$$$ и в конце       хочет получить там значение $$$b$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Входные данные состоят из нескольких наборов входных данных.       Первая строка содержит целое число $$$t$$$ ($$$1 \leq t \leq       1000$$$) — количество наборов входных данных. Следующие $$$t$$$       строк содержат описание наборов входных данных.</p>     <p>Первая и единственная строка каждого набора входных данных       содержит целые числа $$$a$$$ и $$$b$$$ ($$$1 \leq a, b \leq       10^{18}$$$) — исходное значение и желаемое итоговое значение, соответственно.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$t$$$ строк, каждая строка должна содержать одно целое       число, обозначающее минимальное количество операций, которое       Джонни должен выполнить. Если Джонни не сможет получить значение       $$$b$$$ в конце, выведите $$$-1$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
10
10 5
11 44
17 21
1 1
96 3
2 128
1001 1100611139403776
1000000000000000000 1000000000000000000
7 1
10 8
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
1
-1
0
2
2
14
0
-1
-1
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных, Джонни может получить $$$5$$$ из       $$$10$$$ сделав один сдвиг вправо на один (т.е. поделив на $$$2$$$).</p>     <p>Во втором наборе входных данных, Джонни может получить $$$44$$$       из $$$11$$$ сделав один сдвиг влево на два (т.е. умножив на $$$4$$$).</p>     <p>В третьем наборе входных данных, Джонни не может получить       значение $$$21$$$ из значения $$$17$$$.</p>     <p>В четвертом наборе входных данных, исходное и желаемое значения       совпадают, поэтому Джонни придется сделать $$$0$$$ операций.</p>     <p>В пятом наборе входных данных, Джонни может получить $$$3$$$ из       $$$96$$$ сделав два сдвига вправо: один на $$$2$$$, и другой на       $$$3$$$ (т.е. поделив на $$$4$$$ и $$$8$$$).</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1362/problem/A' title='Codeforces Round 647 (Div. 2) - Thanks, Algo Muse!'>1362A - Johnny and Ancient Computer</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let us write $$$a$$$ as $$$r_a \cdot 2^x$$$ and $$$b$$$ as $$$r_b       \cdot 2^y$$$, where $$$r_a$$$ and $$$r_b$$$ are odd. The only       operation we have changes $$$x$$$ by $$$\{-3, -2, -1, 1, 2, 3\}$$$       so $$$r_a$$$ must be equal to $$$r_b$$$, otherwise the answer is       $$$-1$$$. It is easy to notice that we can greedily move $$$x$$$       toward $$$y$$$ so the answer is equal to $$$\lceil \frac{|x -       y|}{3} \rceil$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long LL;

LL getR(LL a){
	while(a % 2 == 0)
		a /= 2;
	return a;
}

void solve(){
	LL a, b;
	scanf(&#34;%lld %lld&#34;, &amp;a, &amp;b);
	if(a &gt; b)	swap(a, b);
	
	LL r = getR(a);
	if(getR(b) != r){
		puts(&#34;-1&#34;);
		return;
	}
	
	int ans = 0;
	b /= a;
	
	while(b &gt;= 8)
		b /= 8, ++ans;
	if(b &gt; 1)	++ans;
	printf(&#34;%d\n&#34;, ans);
}

int main(){
	int quest;
	scanf(&#34;%d&#34;, &amp;quest);
	
	while(quest--)
		solve();
	return 0;
}

</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long LL;

LL getR(LL a){
	while(a % 2 == 0)
		a /= 2;
	return a;
}

void solve(){
	LL a, b;
	scanf(&#34;%lld %lld&#34;, &amp;a, &amp;b);
	if(a &gt; b)	swap(a, b);
	
	LL r = getR(a);
	if(getR(b) != r){
		puts(&#34;-1&#34;);
		return;
	}
	
	int ans = 0;
	b /= a;
	
	while(b &gt;= 8)
		b /= 8, ++ans;
	if(b &gt; 1)	++ans;
	printf(&#34;%d\n&#34;, ans);
}

int main(){
	int quest;
	scanf(&#34;%d&#34;, &amp;quest);
	
	while(quest--)
		solve();
	return 0;
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #647 (Div. 2) - Thanks, Algo Muse!
    1362B
    Джонни и его хобби </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Джонни и его хобби</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Среди многочисленных хобби Джонни, есть два, казалось бы,       безвредных: применение побитовых операций и прокрадывание в офис       его отца. Как это обычно и бывает у маленьких детей, Джонни не       подозревает, что комбинирование этих двух занятий может доставить       ему много неприятностей.</p>     <p>На столе его отца хранится множество $$$S$$$, содержащее очень       важные числа. В момент, когда Джонни узнал об этом, он решил, что       это хорошая идея выбрать <span class="tex-font-style-bf">положительное</span> целое число $$$k$$$       и заменить все элементы $$$s$$$ из множества $$$S$$$ на $$$s       \oplus k$$$ ($$$\oplus$$$ обозначает операцию <a href="https://en.wikipedia.org/wiki/Exclusive_or#Computer_science">исключающего или</a>).</p>     <p>Помогите Джонни выбрать такое $$$k$$$, что его отец не заметит       никакой разницы после того, как Джонни закончит играть (т.е.       Джонни должен получить такое же множество, какое было изначально).       Возможно, что ни одного такого числа не существует. Также,       возможно, что существует несколько подходящих чисел. В таком       случае, выведите минимальное из них. Обратите внимание, что       порядок элементов в множестве не имеет значения, т.е. множество       $$$\{1, 2, 3\}$$$ равно множеству $$$\{2, 1, 3\}$$$.</p>     <p>Формально, требуется найти минимальное положительное целое число       $$$k$$$, такое что $$$\{s \oplus k | s \in S\} = S$$$ или       сообщить, что ни одного подходящего числа не существует.</p>     <p>Например, если $$$S = \{1, 3, 4\}$$$ и $$$k = 2$$$, новое       множество будет равно $$$\{3, 1, 6\}$$$. Если $$$S = \{0, 1, 2,       3\}$$$ и $$$k = 1$$$, после игры множество останется таким же.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке дано одно целое число $$$t$$$ ($$$1 \leq t \leq       1024$$$) — количество наборов входных данных. В следующих строках       даны $$$t$$$ наборов входных данных, каждый из них занимает две строки.</p>     <p>В первой строке набора входных данных дано одно целое число       $$$n$$$ ($$$1 \leq n \leq 1024$$$), обозначающее количество       элементов в множестве $$$S$$$. Вторая строка содержит $$$n$$$         <span class="tex-font-style-bf">различных</span> целых чисел       $$$s_i$$$ ($$$0 \leq s_i &lt; 1024$$$) — элементы $$$S$$$.</p>     <p>Гарантируется, что сумма $$$n$$$ по всем наборам входных данных       не превышает $$$1024$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$t$$$ строк, $$$i$$$-я из них должна содержать ответ       на $$$i$$$-й набор входных данных — минимальное положительное       целое число $$$k$$$, удовлетворяющее условиям, или $$$-1$$$, если       ни одного подходящего $$$k$$$ не существует.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
4
1 0 2 3
6
10 7 14 8 3 12
2
0 2
3
1 2 3
6
1 4 6 10 11 12
2
0 1023
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
4
2
-1
-1
1023
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных, ответ $$$1$$$, потому что это       минимальное положительное целое число и оно удовлетворяет всем условиям.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1362/problem/B' title='Codeforces Round 647 (Div. 2) - Thanks, Algo Muse!'>1362B - Johnny and His Hobbies</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Consider $$$i$$$-th least significant bit ($$$0$$$ indexed). If       it is set in $$$k$$$, but not in $$$s$$$, it will be set in $$$k       \oplus s$$$. Hence $$$k \oplus s \geq 2^i$$$.</p>     <p>Consider such minimal positive integer $$$m$$$, that $$$2^m &gt;       s$$$ holds for all $$$s \in S$$$. $$$k$$$ cannot have the       $$$i$$$-th bit set for any $$$i \geq m$$$. From this follows that       $$$k &lt; 2^m$$$. So there are only $$$2^m$$$ feasible choices of       $$$k$$$. We can verify if a number satisfies the condition from       the statement in $$$ \mathcal{O} \left(n \right) $$$ operations.       This gives us a solution with complexity $$$\mathcal{O} \left(n       \cdot 2^m \right)$$$. Note that in all tests $$$m$$$ is at most $$$10$$$.</p>     <p>There is also another solution possible. It uses the observation       that if $$$k$$$ satisfies the required conditions, then for every       $$$s \in S$$$ there exists such $$$t \in S$$$ ($$$t \neq s$$$) ,       that $$$t \oplus s = k$$$. This gives us $$$n-1$$$ feasible       choices of $$$k$$$ and thus the complexity of this solution is       $$$\mathcal{O} \left( n^2 \right)$$$.</p></div></div></div>

           
            <pre><code>//O(n * maxA) solution

#include &lt;bits/stdc++.h&gt;

using namespace std;

const int N = 1025;

int n;
int in[N];
bool is[N];

bool check(int k){
	for(int i = 1; i &lt;= n; ++i)
		if(!is[in[i] ^ k])
			return false;
	return true;
}

void solve(){
	for(int i = 0; i &lt; N; ++i)
		is[i] = false;
	
	scanf(&#34;%d&#34;, &amp;n);
	for(int i = 1; i &lt;= n; ++i){
		scanf(&#34;%d&#34;, &amp;in[i]);
		is[in[i]] = true;
	}
	
	for(int k = 1; k &lt; 1024; ++k)
		if(check(k)){
			printf(&#34;%d\n&#34;, k);
			return;
		}
	
	puts(&#34;-1&#34;);
}

int main(){
	int cases;
	scanf(&#34;%d&#34;, &amp;cases);
	
	while(cases--)
		solve();
	return 0;
}

</code></pre>
           
            <pre><code>//O(n * maxA) solution

#include &lt;bits/stdc++.h&gt;

using namespace std;

const int N = 1025;

int n;
int in[N];
bool is[N];

bool check(int k){
	for(int i = 1; i &lt;= n; ++i)
		if(!is[in[i] ^ k])
			return false;
	return true;
}

void solve(){
	for(int i = 0; i &lt; N; ++i)
		is[i] = false;
	
	scanf(&#34;%d&#34;, &amp;n);
	for(int i = 1; i &lt;= n; ++i){
		scanf(&#34;%d&#34;, &amp;in[i]);
		is[in[i]] = true;
	}
	
	for(int k = 1; k &lt; 1024; ++k)
		if(check(k)){
			printf(&#34;%d\n&#34;, k);
			return;
		}
	
	puts(&#34;-1&#34;);
}

int main(){
	int cases;
	scanf(&#34;%d&#34;, &amp;cases);
	
	while(cases--)
		solve();
	return 0;
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #647 (Div. 2) - Thanks, Algo Muse!
    1362C
    Джонни и ещё одно падение рейтинга </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Джонни и ещё одно падение рейтинга</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Последний контест, проведённый на любимой Джонни платформе по       спортивному программированию, был встречен довольно позитивно.       Однако, рейтинг Джонни снова упал! Он думает, что хотя задачи были       неплохие, они не показывают истинный уровень участников.</p>     <p>Теперь мальчик смотрит на рейтинги соседних участников,       записанные в двоичной системе счисления. Он считает, что чем       больше эти рейтинги различаются, тем более нечестно, что эти       участники расположены на соседних позициях. Он определяет различие       между двумя числами как количество позиций битов, на которых одно       из чисел содержит ноль, а другое — единицу (мы считаем, что числа       дополнены ведущими нулями до одинаковой длины). Например, различие       между числами $$$5 = 101_2$$$ и $$$14 = 1110_2$$$ равно $$$3$$$,       так как $$$0101$$$ и $$$1110$$$ отличаются в $$$3$$$ позициях.       Джонни определяет нечестность контеста как сумму таких различий       для всех пар соседних участников.</p>     <p>Джонни только что прислал вам последовательность рейтингов и       хочет, чтобы вы вычислили нечестность контеста. Вы заметили, что       вы получили последовательные целые числа от $$$0$$$ до $$$n$$$.       Это странно, но мальчик упорно твердит, что все правильно.       Поэтому, помогите ему и вычислите желаемую нечестность для       полученной последовательности чисел.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Входные данные состоят из нескольких наборов входных данных.       Первая строка содержит одно целое число $$$t$$$ ($$$1 \leq t \leq       10\,000$$$) — количество наборов входных данных. Следующие $$$t$$$       строк содержат описание наборов входных данных.</p>     <p>Первая и единственная строка каждого набора входных данных       содержит одно целое число $$$n$$$ ($$$1 \leq n \leq 10^{18})$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$t$$$ строк. Для каждого набора входных данных, вы       должны вывести одну строку, содержащую одно целое число —       нечестность контеста, если последовательность рейтингов равна       $$$0$$$, $$$1$$$, ..., $$$n - 1$$$, $$$n$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
5
7
11
1
2000000000000
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
8
11
19
1
3999999999987
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Для $$$n = 5$$$, мы вычисляем нечестность следующей       последовательности (числа от $$$0$$$ до $$$5$$$, записанные в       двоичной системе счисления и дополненные ведущими нулями до       одинаковой длины): </p>     <ul> <li> $$$000$$$ </li>       <li> $$$001$$$ </li>       <li> $$$010$$$ </li>       <li> $$$011$$$ </li>       <li> $$$100$$$ </li>       <li> $$$101$$$ </li></ul>          <p>Различия равны $$$1$$$, $$$2$$$, $$$1$$$, $$$3$$$, $$$1$$$,       соответственно. Поэтому, нечестность равна $$$1 + 2 + 1 + 3 + 1 = 8$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1362/problem/C' title='Codeforces Round 647 (Div. 2) - Thanks, Algo Muse!'>1362C - Johnny and Another Rating Drop</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let us start by calculating the result for $$$n = 2^k$$$. It can       be quickly done by calculating the results for each bit separately       and summing these up. For $$$i$$$-th bit, the result is equal to       $$$\frac{2^k}{2^{i}}$$$ as this bit is different in $$$d-1$$$ and       $$$d$$$ iff $$$d$$$ is a multiple of $$$2^i$$$. Summing these up       we get that the result for $$$n = 2^k$$$ is equal to $$$2^{k + 1}       - 1 = 2n - 1$$$.</p>     <p>How to compute the answer for arbitrary $$$n$$$? Let us denote       $$$b_1 &gt; b_2 &gt; \ldots &gt; b_k$$$ as set bits in the binary       representation of $$$n$$$. I claim that the answer is equal to the       sum of answers for $$$2^{b_1}, 2^{b_2}, \ldots, 2^{b_k}$$$. Why?</p>     <p>We can compute results for intervals $$$[0, 2^{b_1}], [2^{b_1},       2^{b_1} + 2^{b_2}], \ldots, [n - 2^{b_k}, n]$$$. We can notice       that the result for interval $$$[s, s + 2^i]$$$, where $$$s$$$ is       a multiple of $$$2^i$$$, is equal to the answer for $$$[0, 2^i]$$$       so we can just compute the results for intervals $$$[0, 2^{b_1}],       [0, 2^{b_2}], \ldots, [0, 2^{b_k}]$$$!</p>     <p>This allows us to compute the answer for arbitrary $$$n$$$ in       $$$\mathcal{O}(\log n)$$$ – just iterate over all bits $$$b$$$ and       add $$$2^{b + 1} - 1$$$ if $$$b$$$ is set. Equivalently we can       just write down $$$2n - \texttt{#bits set}$$$ as the answer.</p>     <p>Final complexity is $$$\mathcal{O}(t \log n)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long LL;

void solve(){
	LL a;
	scanf(&#34;%lld&#34;, &amp;a);
	
	LL ans = 0;
	for(int i = 0; i &lt; 60; ++i)
		if(a &amp; (1LL &lt;&lt; i))
			ans += (1LL &lt;&lt; (i + 1)) - 1;
	printf(&#34;%lld\n&#34;, ans);
}

int main(){
	int quest;
	scanf(&#34;%d&#34;, &amp;quest);
	
	while(quest--)
		solve();
	return 0;
}

</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long LL;

void solve(){
	LL a;
	scanf(&#34;%lld&#34;, &amp;a);
	
	LL ans = 0;
	for(int i = 0; i &lt; 60; ++i)
		if(a &amp; (1LL &lt;&lt; i))
			ans += (1LL &lt;&lt; (i + 1)) - 1;
	printf(&#34;%lld\n&#34;, ans);
}

int main(){
	int quest;
	scanf(&#34;%d&#34;, &amp;quest);
	
	while(quest--)
		solve();
	return 0;
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #646 (Div. 2)
    1363A
    Выбор нечетных </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Выбор нечетных</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У Shubham есть массив $$$a$$$ размера $$$n$$$, и он хочет выбрать       из него ровно $$$x$$$ элементов так, чтобы их сумма была нечетной.       Эти элементы не обязаны быть последовательными. Элементы массива       не обязательно различны.</p>     <p>Скажите ему, может ли он сделать это.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке входных данных содержится одно целое число       $$$t$$$ $$$(1\le t \le 100)$$$ — количество наборов входных       данных. Далее следуют описания наборов входных данных.</p>     <p>Первая строка каждого набора входных данных содержит два целых       числа $$$n$$$ и $$$x$$$ $$$(1 \le x \le n \le 1000)$$$ — длину       массива и количество элементов, которые нужно выбрать соответственно.</p>     <p>Следующая строка каждого набора входных данных содержит $$$n$$$       целых чисел $$$a_1, a_2, \dots, a_n$$$ $$$(1 \le a_i \le       1000)$$$ — элементы массива.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите «<span class="tex-font-style-tt">Yes</span>» или «<span class="tex-font-style-tt">No</span>» в зависимости от того, можно       ли выбрать ровно $$$x$$$ элементов, чтобы их сумма была нечетной.</p>     <p>Вы можете выводить буквы в любом регистре.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
1 1
999
1 1
1000
2 1
51 50
2 2
51 50
3 3
101 102 103
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
Yes
No
Yes
Yes
No
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В $$$1$$$-м наборе входных данных: мы должны выбрать элемент       $$$999$$$, и сумма будет нечетной.</p>     <p>В $$$2$$$-м наборе входных данных: мы должны выбрать элемент       $$$1000$$$, поэтому сумма не будет нечетной.</p>     <p>В $$$3$$$-м наборе входных данных: мы можем выбрать элемент $$$51$$$.</p>     <p>В $$$4$$$-м наборе входных данных: мы должны выбрать оба элемента       $$$50$$$ и $$$51$$$ — так что общая сумма нечетна.</p>     <p>В $$$5$$$-м наборе входных данных: мы должны выбрать все       элементы — но общая сумма не является нечетной.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1363/problem/A' title='Codeforces Round 646 (Div. 2)'>1363A - Odd Selection</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>       <span class="tex-font-style-bf">Key Idea</span>: The sum of       $$$x$$$ numbers can only be odd if we have an odd number of       numbers which are odd. (An odd statement, indeed).</p>     <p>       <span class="tex-font-style-bf">Detailed Explanation</span>: We       first maintain two variables, <span class="tex-font-style-tt">num_odd</span> and <span class="tex-font-style-tt">num_even</span>, representing the number       of odd and even numbers in the array, respectively. We then       iterate over the number of odd numbers we can choose; which are       $$$1,3,5,...$$$ upto <span class="tex-font-style-tt">min(num_odd,x)</span>, and see if <span class="tex-font-style-tt">num_even</span> $$$\geq x - i$$$ where       $$$i$$$ is the number of odd numbers we have chosen. </p>     <p>       <span class="tex-font-style-bf">Time complexity</span>: $$$O(N)$$$</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define endl &#34;\n&#34;
#define int long long
 
const int N = 2e5 + 5;
 
int n, x;
int a[N], f[2];
 
int32_t main()
{
	IOS;
	int t;
	cin &gt;&gt; t;
	while(t--)
	{
	    f[0] = f[1] = 0;
    	cin &gt;&gt; n &gt;&gt; x;
    	for(int i = 1; i &lt;= n; i++)
    	{
    		cin &gt;&gt; a[i];
    		f[a[i] % 2]++;
    	}
    	bool flag = 0;
    	for(int i = 1; i &lt;= f[1] &amp;&amp; i &lt;= x; i += 2) //Fix no of odd
    	{
    		int have = f[0], need = x - i;
    		if(need &lt;= f[0])
    	        flag = 1;
    	}
    	if(flag)
    	    cout &lt;&lt; &#34;Yes&#34; &lt;&lt; endl;
    	else
    	    cout &lt;&lt; &#34;No&#34; &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #646 (Div. 2)
    1363B
    Ненависть к подпоследовальностям </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Ненависть к подпоследовальностям</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У Shubham есть бинарная строка $$$s$$$. Бинарная строка  — это       строка, содержащая только символы «<span class="tex-font-style-tt">0</span>» и «<span class="tex-font-style-tt">1</span>».</p>     <p>Он может выполнить следующую операцию над строкой любое       количество раз: </p>     <ul> <li> Выбрать индекс строки, и поменять символ с этим индексом.         Это означает, что если символ был «<span class="tex-font-style-tt">0</span>», он становится «<span class="tex-font-style-tt">1</span>», и наоборот. </li></ul>          <p>Строка называется хорошей, если она не содержит строк «<span class="tex-font-style-tt">010</span>» или «<span class="tex-font-style-tt">101</span>» в качестве       подпоследовательностей  — например, «<span class="tex-font-style-tt">1001</span>» содержит «<span class="tex-font-style-tt">101</span>» как подпоследовательность,       следовательно, это не хорошая строка, а «<span class="tex-font-style-tt">1000</span>» не содержит ни «<span class="tex-font-style-tt">010</span>» ни «<span class="tex-font-style-tt">101</span>» как подпоследовательностей,       поэтому это хорошая строка.</p>     <p>Какое минимальное количество операций ему придется выполнить,       чтобы строка стала хорошей? Можно показать, что с помощью данных       операций можно сделать любую строку хорошей.</p>     <p>Строка $$$a$$$ является подпоследовательностью строки $$$b$$$,       если $$$a$$$ может быть получена из $$$b$$$ удалением нескольких       (возможно, ни одного или всех) символов.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке входных данных содержится одно целое число       $$$t$$$ $$$(1\le t \le 100)$$$ — количество наборов входных данных.</p>     <p>Каждая из следующих $$$t$$$ строк содержит бинарную строку       $$$s$$$ $$$(1 \le |s| \le 1000)$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждой строки выведите минимальное количество операций       необходимых для того, чтобы сделать ее хорошей.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
7
001
100
101
010
0
1
001100
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
0
1
1
0
0
2
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В наборах входных данных $$$1$$$, $$$2$$$, $$$5$$$, $$$6$$$       строки уже являются хорошими  — поэтому никаких операций не требуется.</p>     <p>Для набора $$$3$$$: «<span class="tex-font-style-tt">001</span>»       можно получить, поменяв первый символ, и это один из возможных       способов получить хорошую строку.</p>     <p>Для набора $$$4$$$: «<span class="tex-font-style-tt">000</span>»       можно получить, поменяв второй символ, и это один из возможных       способов получить хорошую строку.</p>     <p>Для набора $$$7$$$: «<span class="tex-font-style-tt">000000</span>» можно получить, поменяв       третий и четвертый символы, и это один из возможных способов       получить хорошую строку.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1363/problem/B' title='Codeforces Round 646 (Div. 2)'>1363B - Subsequence Hate</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>       <span class="tex-font-style-bf">Key Idea</span>: There are two       types of good strings: Those which start with a series of       $$$1$$$'s followed by $$$0$$$'s (such as $$$1111100$$$) and those       which start with a series of $$$0$$$'s followed by $$$1$$$'s (such       as $$$00111$$$). Note that there are strings which do belong to       both categories (such as $$$000$$$). </p>     <p>       <span class="tex-font-style-bf">Detailed Explanation</span>: We       will use the key idea to compute the minimum change required to       achieve every possible string of each of the two types, and then       take the minimum across them.</p>     <p>First, let us compute the total number of $$$1$$$'s and $$$0$$$'s       in the string, denoted by <span class="tex-font-style-tt">num_ones</span> and <span class="tex-font-style-tt">num_zeros</span>. Now, as we iterate       through the string, let us also maintain <span class="tex-font-style-tt">done_ones</span> and <span class="tex-font-style-tt">done_zeros</span>, which denote the       number of $$$1$$$'s and $$$0$$$'s encountered so far.</p>     <p>Let us iterate through the string. When we are at position       $$$i$$$ (indexed from $$$1$$$), we want to answer two questions:       what is the cost for changing the string into $$$11..000$$$ (where       number of $$$1$$$'s = $$$i$$$) and what is the cost for changing       the string into $$$00..111$$$ (where number of $$$0$$$'s =       $$$i$$$). </p>     <p>Assuming that <span class="tex-font-style-tt">done_zeros</span>       and <span class="tex-font-style-tt">done_ones</span> also consider       the current index, the answer to the first question is <span class="tex-font-style-tt">done_zeros + num_ones -       done_ones</span>. This is because <span class="tex-font-style-tt">done_zeros</span> $$$0$$$'s must be       converted to $$$1$$$'s, and <span class="tex-font-style-tt">num_ones - done_ones</span> $$$1$$$'s       must be converted to $$$0$$$'s. Similarly, the answer for the       second question is <span class="tex-font-style-tt">done_ones +         num_zeros - done_zeros</span>.</p>     <p>The answer is the minimum over all such changes possible. Please       do not forget to consider the all $$$1$$$'s and all $$$0$$$'s       string in the above solution.</p>     <p>       <span class="tex-font-style-bf">Time Complexity</span>: $$$O(N)$$$</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define endl &#34;\n&#34;
#define int long long
 
const int N = 1e5 + 5;
 
int32_t main()
{
	IOS;
	int t;
	cin &gt;&gt; t;
	while(t--)
	{
		string s;
		cin &gt;&gt; s;
		int suf0 = 0, suf1 = 0;
		for(auto &amp;it:s)
		{
			suf0 += (it == &#39;0&#39;);
			suf1 += (it == &#39;1&#39;);
		}
		int ans = min(suf0, suf1); //Make whole string 0/1
		int pref0 = 0, pref1 = 0;
		for(auto &amp;it:s)
		{
			pref0 += (it == &#39;0&#39;), suf0 -= (it == &#39;0&#39;);
			pref1 += (it == &#39;1&#39;), suf1 -= (it == &#39;1&#39;);
			//Cost of making string 0*1*
			ans = min(ans, pref1 + suf0);
			//Cost of making string 1*0*
			ans = min(ans, pref0 + suf1);
		}
		cout &lt;&lt; ans &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #646 (Div. 2)
    1363C
    Игра на листьях </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Игра на листьях</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Ayush и Ashish играют в игру на некорневом дереве, состоящем из       $$$n$$$ вершин, пронумерованных от $$$1$$$ до $$$n$$$. Игроки       делают следующий ход по очереди: </p>     <ul>     <li> Выберите любой лист в дереве и удалите его вместе со         всеми ребрами, для которых этот лист является одним из концов.         Лист  — это вершина со степенью, не превосходящей $$$1$$$. </li></ul>          <p>Дерево  — это связный неориентированный граф без циклов.</p>     <p>Дана специальная вершина с номером $$$x$$$. Игрок, который       удаляет эту вершину, выигрывает игру.</p>     <p>Ayush ходит первым. Определите победителя игры, если каждый игрок       играет оптимально.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке входных данных содержится одно целое число       $$$t$$$ $$$(1 \leq t \leq 10)$$$ — количество наборов входных       данных. Далее следуют описания наборов входных данных.</p>     <p>Первая строка каждого набора входных данных содержит два целых       числа $$$n$$$ и $$$x$$$ $$$(1\leq n \leq 1000, 1 \leq x \leq       n)$$$ — количество вершин в дереве и специальную вершину, соответственно.</p>     <p>Каждая из следующих $$$n-1$$$ строк содержит два целых числа       $$$u$$$, $$$v$$$ $$$(1 \leq u, v \leq n, \text{ } u \ne v)$$$, что       означает, что между вершинами $$$u$$$ и $$$v$$$ есть ребро.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных, если побеждает Ayush, выведите         "<span class="tex-font-style-tt">Ayush</span>", иначе       выведите "<span class="tex-font-style-tt">Ashish</span>"       (без кавычек).</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
1
3 1
2 1
3 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
Ashish
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
1
3 2
1 2
1 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
Ayush
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных Ayush может удалить только вершину       $$$2$$$ или $$$3$$$, после чего вершина $$$1$$$ становится листом,       и Ashish может удалить ее в свою очередь.</p>     <p>Во втором наборе входных данных Ayush может удалить вершину       $$$2$$$ на самом первом шаге.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1363/problem/C' title='Codeforces Round 646 (Div. 2)'>1363C - Game On Leaves</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>       <span class="tex-font-style-bf">Key Idea</span>: The main idea of       this problem is to think backwards. Instead of thinking about how       the game will proceed, we think about how the penultimate state of       the game will look like, etc. Also, we take care of the cases       where the game will end immediately (i.e, when the special node is       a leaf node).</p>     <p>       <span class="tex-font-style-bf">Detailed Explanation</span>:       First, let us take care of the cases where the game ends       immediately. This only occurs when the special node $$$x$$$ is a       leaf node, so all we must do is check that <span class="tex-font-style-tt">deg[$$$x$$$] = 1</span>. Please note       that $$$n = 1$$$ must be handled seperately here (just output         <span class="tex-font-style-tt">Ayush</span>).</p>     <p>Now, in the case where $$$x$$$ is not a leaf node, the answer is       as follows: <span class="tex-font-style-tt">Ashish</span> wins if       $$$n$$$ is odd, and <span class="tex-font-style-tt">Ayush</span>       wins if $$$n$$$ is even. I will provide a short sketch of the       proof below.</p>     <p>With the hint from the key idea, let us analyze this game       backwards. (I will assume that $$$n&gt;10$$$ for the sake of a       clear explanation). When $$$x$$$ is removed from the game, it       cannot be the only node remaining (because then the previous       player could have also removed $$$x$$$, and thus he did not play       optimally). Assume the structure of the game is something like the       following WLOG at the last step (The tree attached to $$$x$$$       could be any tree):</p>          <center>       <img class="tex-graphics" src="https://espresso.codeforces.com/ee24a7b52cd2e7d642669bd398cfc2174a6a4a4b.png" style="max-width: 100.0%;max-height: 100.0%;" /></center>          <p>Consider also that <span class="tex-font-style-tt">Ayush</span>       won, and the last move was to remove $$$x$$$. Now, what could have       been the state before this move? If <span class="tex-font-style-tt">Ashish</span> had removed a node from       the tree, then he did not play optimally - since he could have       removed $$$x$$$! Thus, he must have removed something from       $$$x$$$, which looks like the following:</p>          <center>       <img class="tex-graphics" src="https://espresso.codeforces.com/94369c5be8cccf829c64c629e7240848a55418c2.png" style="max-width: 100.0%;max-height: 100.0%;" /></center>          <p>Considering this state, <span class="tex-font-style-tt">Ashish</span> should not infact remove       $$$6$$$, and instead remove something from the tree! Hence, the       state that we assumed the game should look like at the end is       impossible - and indeed, the tree attached to $$$x$$$ should only       consist of only one node (we already proved that $$$x$$$ cannot be       the only node remaining). </p>     <p>Thus, all we have to do is find who's turn it will be when the       structure of the tree is as follows:</p>          <center>       <img class="tex-graphics" src="https://espresso.codeforces.com/94d24c3811eea80c425fc0e608ce0b1ee9aaeb1f.png" style="max-width: 100.0%;max-height: 100.0%;" /></center>          <p>It is <span class="tex-font-style-tt">Ashish</span>'s turn if       $$$n$$$ is odd, and <span class="tex-font-style-tt">Ayush</span>'s       turn if $$$n$$$ is even. QED!</p>     <p>       <span class="tex-font-style-bf">Time complexity</span>: $$$O(N)$$$</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define endl &#34;\n&#34;
#define int long long
 
const int N = 2e5 + 5;
 
int n, x;
int deg[N];
vector&lt;int&gt; g[N];
 
int32_t main()
{
	IOS;
	int t;
	cin &gt;&gt; t;
	while(t--)
	{
		memset(deg, 0, sizeof(deg));
		cin &gt;&gt; n &gt;&gt; x;
		for(int i = 1; i &lt;= n - 1; i++)
		{
			int u, v;
			cin &gt;&gt; u &gt;&gt; v;
			deg[u]++, deg[v]++;
		}
		if(deg[x] &lt;= 1)
			cout &lt;&lt; &#34;Ayush&#34; &lt;&lt; endl;
		else
		{
			if(n % 2)
				cout &lt;&lt; &#34;Ashish&#34; &lt;&lt; endl;
			else
				cout &lt;&lt; &#34;Ayush&#34; &lt;&lt; endl;
		}
	}
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #646 (Div. 2)
    1363D
    Найдите максимумы </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Найдите максимумы</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>       <span class="tex-font-style-bf">Это интерактивная задача.</span></p>     <p>Ayush устал запоминать пароль от своего замка и разработал новую       схему для установки своего пароля. У замка есть $$$k$$$ позиций,       где каждая позиция может содержать целые числа от $$$1$$$ до       $$$n$$$. Пароль $$$P$$$ представляет собой последовательность из       $$$k$$$ целых чисел, каждое из которых находится в диапазоне       $$$[1, n]$$$, $$$i$$$-й элемент которой входит в $$$i$$$-ю позицию замка.</p>     <p>Чтобы установить пароль для своего замка, Ayush придумывает       массив $$$A$$$ из $$$n$$$ целых чисел в диапазоне $$$[1, n]$$$ (не       обязательно различных). Затем он выбирает $$$k$$$ <span class="tex-font-style-bf">непустых попарно       непересекающихся</span> подмножеств индексов $$$S_1, S_2, ...,       S_k$$$ $$$(S_i \underset{i \neq j} \cap S_j = \emptyset)$$$ и       устанавливает свой пароль как $$$P_i = \max\limits_{j \notin S_i}       A[j]$$$. Другими словами, $$$i$$$-я позиция пароля равна максимуму       по всем элементам $$$A$$$, индексы которых не принадлежат $$$S_i$$$.</p>     <p>Вам даны подмножества индексов, выбранных Ayush. Вам нужно       угадать пароль. Чтобы сделать запрос, вы можете выбрать непустое       подмножество индексов массива и узнать максимум по всем элементам       массива с индексами в этом подмножестве. <span class="tex-font-style-bf">Вы можете задать не более 12 запросов</span>.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке содержится одно целое число $$$t$$$ $$$(1 \leq t       \leq 10)$$$ — количество наборов входных данных. Далее следуют       описания наборов входных данных.</p>     <p>Первая строка каждого набора входных данных содержит два целых       числа: $$$n$$$ и $$$k$$$ $$$(2 \leq n \leq 1000, 1 \leq k \leq       n)$$$ — размер массива и количество подмножеств соответственно.       Далее следуют $$$k$$$ строк. $$$i$$$-я строка содержит целое число       $$$c$$$ $$$(1 \leq c \lt n)$$$ — размер подмножества $$$S_i$$$, за       которым следуют $$$c$$$ попарно различных целых чисел в диапазоне       $$$[1, n]$$$ — индексы, принадлежащие подмножеству $$$S_i$$$.</p>     <p>       <span class="tex-font-style-bf">Гарантируется, что пересечение         любых двух подмножеств пусто.</span></p></div>         <div>     <div class="section-title">Протокол взаимодействия</div>          <p>Чтобы задать запрос, выведите одну строку: </p>     <ul> <li> В начале выведите "<span class="tex-font-style-tt">?         c</span>" (без кавычек), где $$$c$$$ $$$(1 \leq c \leq         n)$$$ обозначает размер подмножества запрашиваемых индексов,         после чего выведите через пробел $$$c$$$ <span class="tex-font-style-bf">различных</span> целых чисел в         диапазоне $$$[1, n]$$$  — индексы, о которых вы хотите задать         запрос. </li></ul>          <p>Для каждого запроса вы получите целое число $$$x$$$ —       максимальное значение в массиве среди элементов с запрошенными       индексами. Если подмножество запрашиваемых индексов недопустимо       или вы превысили количество запросов (например, один из индексов       больше, чем $$$n$$$), то вы получите $$$x = -1$$$. В этом случае       вы должны немедленно прекратить программу.</p>     <p>Когда вы угадали пароль, выведите одну строку "<span class="tex-font-style-tt">!</span>" (Без кавычек), за которой       через пробел следуют $$$k$$$ целых чисел  — позиции пароля.</p>     <p>Угадывание пароля <span class="tex-font-style-bf">не</span>       учитывается при подсчете количества запросов.</p>     <p>После этого вы должны прочитать строку. Если вы угадаете пароль       правильно, вы получите строку "<span class="tex-font-style-tt">Correct</span>". В этом случае вам       следует продолжить решение оставшихся наборов входных данных. Если       предполагаемый пароль неверен, вы получите строку "<span class="tex-font-style-tt">Incorrect</span>". В этом случае вы       должны немедленно прекратить программу.</p>     <p>       <span class="tex-font-style-bf">Интерактор не адаптивный.</span>       Массив $$$A$$$ не изменяется с запросами.</p>     <p>После вывода запроса не забудьте вывести перевод строки и       сбросить буфер вывода. В противном случае вы получите вердикт         <span class="tex-font-style-tt">Решение «зависло»</span>. Для       сброса буфера используйте:</p>          <ul>                     <li> <span class="tex-font-style-tt">fflush(stdout)</span> или           <span class="tex-font-style-tt">cout.flush()</span> в C++;         </li>       <li> <span class="tex-font-style-tt">System.out.flush()</span> в Java;         </li>       <li> <span class="tex-font-style-tt">flush(output)</span> в Pascal;         </li>       <li> <span class="tex-font-style-tt">stdout.flush()</span> в Python;         </li>       <li> смотрите документацию для других языков.         </li></ul>          <p>       <span class="tex-font-style-bf">Формат взломов</span></p>     <p>Чтобы взломать решение, используйте следующий формат взломов:</p>     <p>В первой строке должно содержаться одно целое число $$$t$$$ $$$(1       \leq t \leq 10)$$$ — количество наборов входных данных.</p>     <p>Первая строка каждого набора входных данных должна содержать два       целых числа: $$$n$$$ и $$$k$$$ $$$(2 \leq n \leq 1000, 1 \leq k       \leq n)$$$ — размер массива и количество подмножеств       соответственно. Следующая строка должна состоять из $$$n$$$ целых       чисел в диапазоне $$$[1, n]$$$ — массива $$$A$$$. Далее должны       следовать $$$k$$$ строк. $$$i$$$-я строка должна содержать целое       число $$$c$$$ $$$(1 \leq c \lt n)$$$ — размер подмножества       $$$S_i$$$, за которым должны следовать $$$c$$$ различных целых       чисел в диапазоне $$$[1, n]$$$ — индексы, принадлежащие       подмножеству $$$S_i$$$.</p>     <p>       <span class="tex-font-style-bf">Пересечение любых двух подмножеств         должно быть пустым.</span></p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
1
4 2
2 1 3
2 2 4

1

2

3

4

Correct</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
? 1 1

? 1 2

? 1 3

? 1 4

! 4 3</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Массив $$$A$$$ в примере равен $$$[1, 2, 3, 4]$$$. Длина пароля       составляет $$$2$$$. Первый элемент пароля  — это максимум из       $$$A[2]$$$, $$$A[4]$$$ (поскольку первое подмножество содержит       индексы $$$1$$$ и $$$3$$$, мы берем максимум по остальным       индексам). Второй элемент пароля  — это максимум из $$$A[1]$$$,       $$$A[3]$$$ (поскольку второе подмножество содержит индексы       $$$2$$$, $$$4$$$).</p>     <p>       <span class="tex-font-style-bf">Не забудьте</span> считать строку         "<span class="tex-font-style-tt">Correct</span>" /         "<span class="tex-font-style-tt">Incorrect</span>"       после угадывания пароля.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1363/problem/D' title='Codeforces Round 646 (Div. 2)'>1363D - Guess The Maximums</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>       <span class="tex-font-style-bf">Key Idea</span>: The maximum of       the array is the password integer for all except atmost $$$1$$$       position. We find the subset (if the maximum is in a subset) in       which the maximum exists using binary search, and then query the       answer for this subset seperately. (For all the subsets, the       answer is the maximum for the whole array).</p>     <p>       <span class="tex-font-style-bf">Detailed Explanation</span>: I       will be working with an example in this explanation; let the array       be $$$ a = [1,1,2,3,2,5,7,8,9,11,4]$$$, and array of length       $$$11$$$, and let there be $$$10$$$ subsets, with first subset       being $$$[1]$$$, second being $$$[2]$$$, etc (every index except       $$$11$$$ is a subset). Thus, $$$a[1] = 1, a[3] = 2$$$, etc.</p>     <p>First, let us query the maximum of the whole array using $$$1$$$       query. This gives $$$11$$$ as the output in our case.</p>     <p>Now, we check if the maximum is present in the subsets. We do       this in the following manner: we query the first half of the       subsets. If the value returned here is not the maximum, then we       search in the second half - else, we know that the maximum must be       in the first half of subsets. Hence, we binary search in the first       half itself. </p>     <p>To proceed with our example, we query the maximum from subsets       $$$1$$$ to $$$5$$$, which turns out to be $$$3$$$. Thus, $$$11$$$       must be present in subsets $$$6$$$ to $$$10$$$. Then we will query       $$$6$$$ to $$$8$$$, which will return the value $$$8$$$ - thus,       the maximum may be present in subset $$$9$$$, or $$$10$$$. Thus,       we query subset $$$9$$$ and find that it does not contain the       maximum. This step will require at most $$$10$$$ queries, and we       will get a subset which (may or may not) contain the maximum       element (remember, it is possible that the maximum element was not       in any subset!)</p>     <p>Thus, in our final query we ask about the maximum over all       indices other than the canditate subset we found above. In our       example, We query every index except those in subset $$$10$$$       using $$$1$$$ query, which gives us the answer as $$$9$$$. Hence,       the password is $$$[11,11,11,11,11,11,11,11,11,9]$$$.</p>     <p>Note: The bound of $$$12$$$ queries is tight.</p>     <p>       <span class="tex-font-style-bf">Time complexity</span>: $$$O(N)$$$</p></div></div></div>

           
            <pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
 
#define vint vector&lt;int&gt;
 
int interact(vint S){
	cout &lt;&lt; &#34;? &#34; &lt;&lt; S.size() &lt;&lt; &#39; &#39;;
	for(int i : S)
		cout &lt;&lt; i &lt;&lt; &#39; &#39;;
	cout &lt;&lt; endl;
	int x;
	cin &gt;&gt; x;
	return x;
}
 
vint get_complement(vint v, int n){
	vint ask, occur(n + 1);
	for(int i : v)
		occur[i] = 1;
	for(int i = 1; i &lt;= n; i++)
		if(!occur[i])
			ask.push_back(i);
	return ask;
}
 
int main(){
	int tc;
	cin &gt;&gt; tc;
	while(tc--){
		int n, k;
		cin &gt;&gt; n &gt;&gt; k;
		vector&lt;vint&gt; S(k);
		vint ans(k);
		for(int i = 0; i &lt; k; i++){
			int c;
			cin &gt;&gt; c;
			S[i].resize(c);
			for(int j = 0; j &lt; c; j++)
				cin &gt;&gt; S[i][j];
		}
		vint ask;
		for(int i = 1; i &lt;= n; i++)
			ask.push_back(i);
		int max_element = interact(ask);
		//find subset with max element
		int st = 0, en = k - 1;
		while(st &lt; en){
			int mid = (st + en) / 2;
			ask.clear();
			for(int i = 0; i &lt;= mid; i++)
				for(int j : S[i])
					ask.push_back(j);
			int x = interact(ask);
			if(x == max_element)
				en = mid;
			else st = mid + 1;
		}
		ask = get_complement(S[st], n);
		for(int i = 0; i &lt; k; i++)
			if(i == st)
				ans[i] = interact(ask);
			else ans[i] = max_element;
		cout &lt;&lt; &#34;! &#34;;
		for(int i : ans)
			cout &lt;&lt; i &lt;&lt; &#39; &#39;;
		cout &lt;&lt; endl;
		string correct;
		cin &gt;&gt; correct;
	}
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #646 (Div. 2)
    1363E
    Перестановка дерева </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. Перестановка дерева</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У Ashish есть дерево, состоящее из $$$n$$$ вершин,       пронумерованных от $$$1$$$ до $$$n$$$, с корнем в вершине $$$1$$$.       $$$i$$$-я вершина дерева имеет стоимость $$$a_i$$$, и в ней       записана бинарная цифра $$$b_i$$$. Ashish хочет, чтобы в конце в       $$$i$$$-й вершине была записана бинарная цифра $$$c_i$$$.</p>     <p>Для этого, он может выполнить следующую операцию любое количество       раз: </p>     <ul> <li> Выберите любые $$$k$$$ вершин из поддерева любой вершины         $$$u$$$ и переставьте цифры в этих вершинах так, как пожелаете,         за стоимость $$$k \cdot a_u$$$. Здесь он может выбрать $$$k$$$ в         диапазоне от $$$1$$$ до размера поддерева $$$u$$$. </li></ul>          <p>Он хочет выполнить операции так, чтобы у каждой вершины в итоге       оказалась цифра, соответствующая желаемой цифре для этой вершины.</p>     <p>Помогите ему найти минимальную общую стоимость, за которую можно       сделать так, чтобы после проведения всех операций для каждого       $$$u$$$ в вершине $$$u$$$ была записана цифра $$$c_u$$$, или       определить, что это невозможно.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит одно целое число $$$n$$$ $$$(1 \le n \le 2       \cdot 10^5)$$$, обозначающее количество вершин в дереве.</p>     <p>$$$i$$$-я из следующих $$$n$$$ строк содержит 3 разделенных       пробелом целых числа $$$a_i$$$, $$$b_i$$$, $$$c_i$$$ $$$(1 \leq       a_i \leq 10^9, 0 \leq b_i, c_i \leq 1)$$$ — стоимость $$$i$$$-й       вершины, ее начальная цифра и желаемая цифра.</p>     <p>Каждая из следующих строк $$$n - 1$$$ содержит два целых числа       $$$u$$$, $$$v$$$ $$$(1 \leq u, v \leq n, \text{ } u \ne v)$$$, что       означает, что между вершинами $$$u$$$ и $$$v$$$ в дереве есть ребро.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите минимальную общую стоимость, за которую можно сделать       так, чтобы в каждой вершине была записана желаемая цифра для этой       вершины, или $$$-1$$$, если сделать это невозможно.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
1 0 1
20 1 0
300 0 1
4000 0 0
50000 1 0
1 2
2 3
2 4
1 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
4</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
10000 0 1
2000 1 0
300 0 1
40 0 0
1 1 0
1 2
2 3
2 4
1 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
24000</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
109 0 1
205 0 1
1 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
-1</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Дерево, соответствующие примерам $$$1$$$ и $$$2$$$:</p>          <center>       <img class="tex-graphics" src="https://espresso.codeforces.com/02ed56cecf6dea5880ad08c321cf503b04888bd7.png" style="max-width: 100.0%;max-height: 100.0%;"/></center>          <p>В примере $$$1$$$ мы можем выбрать вершину $$$1$$$ и $$$k = 4$$$       за стоимость $$$4 \times 1$$$ = $$$4$$$ и выбрать вершины $$${1,       2, 3, 5}$$$, переставить их цифры и получить желаемые цифры в       каждой позиции.</p>     <p>В примере $$$2$$$ мы можем выбрать вершину $$$1$$$ и $$$k = 2$$$       за стоимость $$$10000 \times 2$$$, выбрать вершины $$${1, 5}$$$,       обменять их цифры, после чего аналогичным образом выбрать вершину       $$$2$$$ и $$$k = 2$$$ за стоимость $$$2000 \times 2$$$ и вершины       $$${2, 3}$$$, обменять их цифры, чтобы получить нужные цифры в       каждой позиции.</p>     <p>В примере $$$3$$$ невозможно получить нужные цифры, потому что       среди начальных цифр нет цифры $$$1$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1363/problem/E' title='Codeforces Round 646 (Div. 2)'>1363E - Tree Shuffling</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>       <span class="tex-font-style-bf">Key Idea</span>: Let the parent of       node $$$i$$$ be $$$p$$$. If $$$a[i] \geq a[p]$$$, we can do the       shuffling which was done at $$$i$$$, at $$$p$$$ instead. Thus, we       can do the operation $$$a[i] = min(a[i],a[p])$$$.</p>     <p>       <span class="tex-font-style-bf">Detailed Explanation</span>: Let       us denote nodes that have $$$b_i = 1$$$ and $$$c_i = 0$$$ as type       $$$1$$$, and those that have $$$b_i = 0$$$ and $$$c_i = 1$$$ as       type $$$2$$$. Firstly, the answer is $$$-1$$$ if and only if the       number of nodes of type $$$1$$$ and type $$$2$$$ are unequal.</p>     <p>We also observe that only nodes of type $$$1$$$ and $$$2$$$       should be shuffled - it is unoptimal to shuffle those which       already have $$$b[i] = c[i]$$$. Thus, we should try to exchange       the values of type $$$1$$$ and type $$$2$$$ nodes.</p>     <p>We use the key idea by going down from the root, and at every       node $$$i$$$, setting $$$a[i] = min(a[i],a[p])$$$ where $$$p$$$ is       the parent node of $$$i$$$ in the tree. Thus, the $$$a[i]$$$'s now       follow a special structure: they are non-increasing from the root       to the leaves!</p>     <p>This paves the way for our greedy solution: we will go upwards       from the leaves, and at each node $$$i$$$ interchange type $$$1$$$       and type $$$2$$$ nodes until we have no nodes in one of these       types. Then, we pass on the remaining nodes to the parent to be shuffled.</p>     <p>       <span class="tex-font-style-bf">Time complexity</span>: $$$O(N)$$$</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define endl &#34;\n&#34;
#define int long long
 
const int N = 2e5 + 5;
 
int n, cost = 0;
int arr[N], b[N], c[N];
vector&lt;int&gt; g[N];
 
pair&lt;int, int&gt; dfs(int u, int par, int mn)
{
	pair&lt;int, int&gt; a = {0, 0};
	if(b[u] != c[u])
	{
		if(b[u])
			a.first++;
		else
			a.second++;
	}
	for(auto &amp;it:g[u])
	{
		if(it == par)
			continue;
		pair&lt;int, int&gt; p = dfs(it, u, min(mn, arr[u]));
		a.first += p.first;
		a.second += p.second;
	}
	if(arr[u] &lt; mn)
	{
		int take = min(a.first, a.second);
		cost += 2 * take * arr[u];
		a.first -= take;
		a.second -= take;
	}
	return a;
}
 
int32_t main()
{
	IOS;
	cin &gt;&gt; n;
	for(int i = 1; i &lt;= n; i++)
		cin &gt;&gt; arr[i] &gt;&gt; b[i] &gt;&gt; c[i];
	for(int i = 1; i &lt;= n - 1; i++)
	{
		int u, v;
		cin &gt;&gt; u &gt;&gt; v;
		g[u].push_back(v);
		g[v].push_back(u);
	}	
	pair&lt;int, int&gt; ans = dfs(1, 0, 2e9);
	if(ans.first || ans.second)
		cout &lt;&lt; -1;
	else
		cout &lt;&lt; cost;
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #646 (Div. 2)
    1363F
    Вращение подстрок </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Вращение подстрок</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам даны две строки $$$s$$$ и $$$t$$$, каждая из которых имеет       длину $$$n$$$ и состоит из строчных букв латинского алфавита. Вы       хотите сделать $$$s$$$ равной $$$t$$$.</p>     <p>Вы можете выполнить следующую операцию над $$$s$$$ любое       количество раз, чтобы достичь этого  — </p>     <ul>     <li> Выберите любую подстроку $$$s$$$ и поверните ее по         часовой стрелке один раз, то есть, если выбранная подстрока         равна $$$s[l,l+1...r]$$$, то она становится равной $$$s[r,l,l +         1 ... r - 1]$$$. Все остальные символы $$$s$$$ остаются на своих местах.         <p>Например, при вращении подстроки $$$[2,4]$$$ строка «<span class="tex-font-style-tt">abcde</span>» становится равной             «<span class="tex-font-style-tt">adbce</span>». </p></li></ul>          <p>Строка $$$a$$$ является подстрокой $$$b$$$, если $$$a$$$ может       быть получена из $$$b$$$ удалением нескольких (возможно, ни одного       или всех) символов из начала и нескольких (возможно, ни одного или       всех) символов из конца.</p>     <p>Найдите минимальное количество операций, необходимых для       преобразования $$$s$$$ в $$$t$$$, или определите, что это невозможно.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка входных данных содержит одно целое число $$$t$$$       $$$(1\leq t \leq 2000)$$$ — количество наборов входных данных.       Далее следуют описания наборов входных данных.</p>     <p>Первая строка каждого набора входных данных содержит одно целое       число $$$n$$$ $$$(1\leq n \leq 2000)$$$ — длину строк.</p>     <p>Вторая и третья строки содержат строки $$$s$$$ и $$$t$$$ соответственно.</p>     <p>Сумма $$$n$$$ по всем наборам входных данных не превышает $$$2000$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите минимальное количество       операций для преобразования $$$s$$$ в $$$t$$$. Если невозможно       преобразовать $$$s$$$ в $$$t$$$, вместо этого выведите $$$-1$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
1
a
a
2
ab
ba
3
abc
cab
3
abc
cba
4
abab
baba
4
abcc
aabc
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
1
1
2
1
-1
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Для первого набора входных данных, поскольку $$$s$$$ и $$$t$$$       равны, вам не нужно применять какие-либо операции.</p>     <p>Для второго набора входных данных вам нужно применить только одну       операцию ко всей строке <span class="tex-font-style-tt">ab</span>,       чтобы преобразовать ее в <span class="tex-font-style-tt">ba</span>.</p>     <p>Для третьего набора входных данных вам нужно только применить       одну операцию ко всей строке <span class="tex-font-style-tt">abc</span>, чтобы преобразовать ее в         <span class="tex-font-style-tt">cab</span>.</p>     <p>Для четвертого набора входных данных вам нужно применить операцию       дважды: сначала для всей строки <span class="tex-font-style-tt">abc</span>, чтобы преобразовать ее в         <span class="tex-font-style-tt">cab</span>, а затем для       подстроки длины $$$2$$$, начинающейся со второго символа для       преобразования ее в <span class="tex-font-style-tt">cba</span>.</p>     <p>Для пятого набора входных данных вам нужно применить только одну       операцию ко всей строке <span class="tex-font-style-tt">abab</span>, чтобы преобразовать ее в         <span class="tex-font-style-tt">baba</span>.</p>     <p>Для шестого набора входных данных превратить строку $$$s$$$ в       строку $$$t$$$ не является возможным.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1363/problem/F' title='Codeforces Round 646 (Div. 2)'>1363F - Rotating Substrings</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>       <span class="tex-font-style-bf">Key Idea</span>: We note that a       clockwise rotation is the same as taking a character at any       position in the string, and inserting it anywhere to it's left.       Thus, we process the strings from the end, build the suffixes and       move towards the prefix.</p>     <p>       <span class="tex-font-style-bf">Detailed Explanation</span>: The       answer is $$$-1$$$ if both <span class="tex-font-style-tt">s</span> and <span class="tex-font-style-tt">t</span> do not have the same count of       every character. Else, we can prove that it is always possible to       convert <span class="tex-font-style-tt">s</span> to <span class="tex-font-style-tt">t</span>.</p>     <p>Now, let us remove the largest common suffix of both <span class="tex-font-style-tt">s</span> and <span class="tex-font-style-tt">t</span>. Now, using the key idea, we       consider a move as picking a character at any position in <span class="tex-font-style-tt">s</span> and inserting it to it's left.       So, let us just &quot;pick up&quot; characters, and use them in       any order as we iterate through <span class="tex-font-style-tt">s</span>. Our total cost is equal to the       number of characters we picked overall.</p>     <p>After removing common suffixes, suppose the last character of         <span class="tex-font-style-tt">s</span> is <span class="tex-font-style-tt">c</span>. Since the last characters of         <span class="tex-font-style-tt">s</span> and <span class="tex-font-style-tt">t</span> differ, we can pick up this         <span class="tex-font-style-tt">c</span>. Now, we want to make         <span class="tex-font-style-tt">s[1,n-1]</span> equal to <span class="tex-font-style-tt">t[1,n]</span>, given that we can insert         <span class="tex-font-style-tt">c</span> anywhere in <span class="tex-font-style-tt">s</span>.</p>     <p>Let us consider <span class="tex-font-style-tt">dp[i][j]</span>       (only for when <span class="tex-font-style-tt">j $$$\geq$$$       i</span>, which means that we want to make <span class="tex-font-style-tt">s[1,i] = t[1,j]</span> by inserting       some characters that we have picked. What characters can we pick?       We can pick the characters whose count in <span class="tex-font-style-tt">s[i+1,n] &gt; t[j+1,n]</span>. The       base case is <span class="tex-font-style-tt">dp[0][i] = 0</span>.       Now, let us write the transitions for this dp solution. Suppose       that <span class="tex-font-style-tt">t[j] = x</span>. There are       three possible transitions from <span class="tex-font-style-tt">dp[i][j]</span>: </p>     <ol> <li> If the count of <span class="tex-font-style-tt">x</span>         in <span class="tex-font-style-tt">s[i+1.n]</span> is greater         than it's count in <span class="tex-font-style-tt">t[j+1,n]</span>, then we can reach the         state <span class="tex-font-style-tt">dp[i][j-1]</span>. </li>       <li> If <span class="tex-font-style-tt">s[i] = t[j]</span>, then         we can reach the state <span class="tex-font-style-tt">dp[i-1][j-1]</span>. </li>       <li> We can pick up the character at position <span class="tex-font-style-tt">i</span> (and insert it later) to         reach <span class="tex-font-style-tt">dp[i-1][j]</span> (with an         additional cost of $$$1$$$). </li></ol>          <p>The final answer is <span class="tex-font-style-tt">dp[n][n]</span>. </p>     <p>       <span class="tex-font-style-bf">Time complexity</span>: $$$O(N^2)$$$</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define endl &#34;\n&#34;
#define int long long
 
const int N = 2005;
 
int n;
string s, t;
int suf[26][N], suf2[26][N];
int cache[N][N];
 
int dp(int i, int j)
{
	if(j == 0)
		return 0;
	int &amp;ans = cache[i][j];
	if(ans != -1)
		return ans;
	ans = 2e9;
	if(i &gt; 0)
	{
		ans = 1 + dp(i - 1, j);
		if(s[i - 1] == t[j - 1])
			ans = min(ans, dp(i - 1, j - 1));
	}
	int ch = t[j - 1] - &#39;a&#39;;
	if(suf[ch][i + 1] - suf2[ch][j + 1] &gt; 0)
		ans = min(ans, dp(i, j - 1));
	return ans;
}
 
int32_t main()
{
	IOS;
	int tc;
	cin &gt;&gt; tc;
	while(tc--)
	{
		cin &gt;&gt; n &gt;&gt; s &gt;&gt; t;
		for(int i = 0; i &lt;= n; i++)
			for(int j = 0; j &lt;= n; j++)
				cache[i][j] = -1;
		for(int i = 0; i &lt;= 25; i++)
			for(int j = 0; j &lt;= n + 1; j++)
				suf[i][j] = suf2[i][j] = 0;
		for(int i = n; i &gt;= 1; i--)
		{
			for(int j = 0; j &lt; 26; j++)
			{
				suf[j][i] = suf[j][i + 1];
				suf2[j][i] = suf2[j][i + 1];
			}
			suf[s[i - 1] - &#39;a&#39;][i]++;
			suf2[t[i - 1] - &#39;a&#39;][i]++;
		}
		int ans = dp(n, n);
		if(ans &gt; 1e9)
			ans = -1;
		cout &lt;&lt; ans &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #649 (Div. 2)
    1364A
    XXXXX </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. XXXXX</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Ехаб любит теорию чисел, но по какой-то причине он ненавидит       число $$$x$$$. Для данного массива $$$a$$$ найдите длину самого       длинного его подмассива, сумма элементов которого <span class="tex-font-style-bf">не</span> делится на $$$x$$$, или       определите, что такого подмассива не существует.</p>     <p>Массив $$$a$$$ является подмассивом массива $$$b$$$, если $$$a$$$       может быть получен из $$$b$$$ удалением нескольких (возможно, ни       одного или всех) элементов из начала и нескольких (возможно, ни       одного или всех) элементов из конца.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит целое число $$$t$$$ $$$(1 \le t \le       5)$$$ — количество наборов входных данных. Описание наборов       входных данных приведено ниже.</p>     <p>Первая строка каждого набора входных данных содержит два целых       числа $$$n$$$ и $$$x$$$ ($$$1 \le n \le 10^5$$$, $$$1 \le x \le       10^4$$$) — количество элементов в массиве $$$a$$$, и число,       которое Ехаб ненавидит.</p>     <p>Вторая строка каждого набора входных данных содержит $$$n$$$       целых чисел $$$a_1$$$, $$$a_2$$$, $$$\ldots$$$, $$$a_{n}$$$ ($$$0       \le a_i \le 10^4$$$) — элементы массива $$$a$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите длину самого длинного       подмассива, сумма элементов которого не делится на $$$x$$$. Если       такого подмассива не существует, выведите $$$-1$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
3 3
1 2 3
3 4
1 2 3
2 2
0 6
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
3
-1
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных подмассив $$$[2,3]$$$ имеет сумму       элементов $$$5$$$, которая не делится на $$$3$$$.</p>     <p>Во втором наборе входных данных сумма всего элементов всего       массива равна $$$6$$$, и не делится на $$$4$$$.</p>     <p>В третьем наборе входных данных все подмассивы имеют четную       сумму, поэтому ответ равен $$$-1$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #649 (Div. 2)
    1364B
    Наиболее социально-дистанцированная подпоследовательность </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Наиболее социально-дистанцированная подпоследовательность</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Для заданной перестановки $$$p$$$ длины $$$n$$$, найдите ее       подпоследовательность $$$s_1$$$, $$$s_2$$$, $$$\ldots$$$,       $$$s_k$$$ длины хотя бы $$$2$$$ такую, что:</p>          <ul> <li> $$$|s_1-s_2|+|s_2-s_3|+\ldots+|s_{k-1}-s_k|$$$ является         максимально возможным среди всех подпоследовательностей $$$p$$$         длины хотя бы $$$2$$$. </li>       <li> среди всех таких подпоследовательностей выберите ту, длина         которой $$$k$$$ как можно меньше. </li></ul>          <p>Если несколько подпоследовательностей удовлетворяют этим       условиям, вы можете найти любую из них.</p>     <p>Последовательность $$$a$$$ является подпоследовательностью       $$$b$$$, если $$$a$$$ может быть получена из $$$b$$$ удалением       нескольких (возможно, ни одного или всех) элементов.</p>     <p>Перестановка длины $$$n$$$ — это массив длины $$$n$$$, в котором       каждый элемент от $$$1$$$ до $$$n$$$ встречается ровно один раз.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано целое число $$$t$$$ ($$$1 \le t \le 2       \cdot 10^4$$$) — количество наборов входных данных. Описание       наборов входных данных приведено ниже.</p>     <p>Первая строка каждого набора входных данных содержит целое число       $$$n$$$ ($$$2 \le n \le 10^5$$$) — длину перестановки $$$p$$$.</p>     <p>Вторая строка каждого набора входных данных содержит $$$n$$$       целых чисел $$$p_1$$$, $$$p_2$$$, $$$\ldots$$$, $$$p_{n}$$$ ($$$1       \le p_i \le n$$$, $$$p_i$$$ попарно различны) — элементы       перестановки $$$p$$$.</p>     <p>       <span class="tex-font-style-bf">Сумма $$$n$$$ по всем наборам         входных данных не превышает $$$10^5$$$.</span></p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных первая строка должна содержать       длину найденной подпоследовательности, $$$k$$$. Вторая строка       должна содержать $$$s_1$$$, $$$s_2$$$, $$$\ldots$$$, $$$s_k$$$  —       ее элементы.</p>     <p>Если несколько подпоследовательностей удовлетворяют этим       условиям, вы можете найти любую из них.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
3
3 2 1
4
1 3 4 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
3 1 
3
1 4 2 
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом тестовом примере есть $$$4$$$ подпоследовательности       длиной не менее $$$2$$$:</p>          <ul> <li> $$$[3,2]$$$, что дает нам $$$|3-2|=1$$$. </li>       <li> $$$[3,1]$$$, что дает нам $$$|3-1|=2$$$. </li>       <li> $$$[2,1]$$$, что дает нам $$$|2-1|=1$$$. </li>       <li> $$$[3,2,1]$$$, что дает нам $$$|3-2|+|2-1|=2$$$. </li></ul>          <p>Таким образом, ответ либо $$$[3,1]$$$, либо $$$[3,2,1]$$$.       Поскольку мы хотим, чтобы подпоследовательность была как можно       короче, ответ будет $$$[3,1]$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #649 (Div. 2)
    1364C
    Ехаб и префиксные MEXы </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Ехаб и префиксные MEXы</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Для данного массива $$$a$$$ длины $$$n$$$ найдите другой массив       $$$b$$$ длины $$$n$$$ такой, что:</p>          <ul> <li> для каждого $$$i$$$ $$$(1 \le i \le n)$$$ $$$MEX(\{b_1$$$,         $$$b_2$$$, $$$\ldots$$$, $$$b_i\})=a_i$$$. </li></ul>          <p>$$$MEX$$$ множества целых чисел равен наименьшему       неотрицательному целому числу, которое не принадлежит этому множеству.</p>     <p>Если такого массива не существует, определите это.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано целое число $$$n$$$ ($$$1 \le n \le       10^5$$$) — длина массива $$$a$$$.</p>     <p>Вторая строка содержит $$$n$$$ целых чисел $$$a_1$$$, $$$a_2$$$,       $$$\ldots$$$, $$$a_n$$$ ($$$0 \le a_i \le i$$$) — элементы массива       $$$a$$$. <span class="tex-font-style-bf">Гарантируется, что $$$a_i         \le a_{i+1}$$$ для $$$1\le i &lt; n$$$.</span></p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Если такого массива нет, выведите одну строку, содержащую $$$-1$$$.</p>     <p>В противном случае выведите одну строку, содержащую $$$n$$$ целых       чисел $$$b_1$$$, $$$b_2$$$, $$$\ldots$$$, $$$b_n$$$ ($$$0 \le b_i       \le 10^6$$$).</p>     <p>Если есть несколько ответов, выведите любой.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
1 2 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0 1 2 </pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
0 0 0 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1 3 4 0 </pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
1 1 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0 2 1 </pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Во втором примере допустимы другие ответы, например, $$$[1,1,1,0]$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #649 (Div. 2)
    1364D
    Последнее следствие Ехаба </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Последнее следствие Ехаба</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Для связного неориентированного графа с $$$n$$$ вершинами и       целого числа $$$k$$$, вы должны, на ваш выбор:</p>          <ul> <li> или найти независимое множество с <span class="tex-font-style-bf">ровно</span>         $$$\lceil\frac{k}{2}\rceil$$$ вершинами.         </li>       <li> или найти <span class="tex-font-style-bf">простой</span> цикл         длины <span class="tex-font-style-bf">не более</span> $$$k$$$. </li></ul>          <p>Независимое множество  — это набор вершин такой, что никакие две       из них не связаны ребром. Простой цикл  — это цикл, который не       содержит ни одной вершины дважды. </p>     <p>У меня есть доказательство, что для любых входных данных вы       всегда можете решить по крайней мере одну из этих задач, но оно       слишком тривиально, чтобы поместиться здесь.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит три целых числа $$$n$$$, $$$m$$$, and       $$$k$$$ ($$$3 \le k \le n \le 10^5$$$, $$$n-1 \le m \le 2 \cdot       10^5$$$) — количество вершин и ребер в графе и параметр $$$k$$$ из условия.</p>     <p>Каждая из следующих $$$m$$$ строк содержит два целых числа       $$$u$$$ и $$$v$$$ ($$$1 \le u,v \le n$$$), которые обозначают, что       между вершинами $$$u$$$ и $$$v$$$ есть ребро. Гарантируется, что       граф связен и не содержит петель или кратных ребер.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Если вы решили решить первую задачу, то в первой строке выведите       $$$1$$$, а затем строку, содержащую $$$\lceil\frac{k}{2}\rceil$$$       различных целых чисел, не превышающих $$$n$$$  — вершины в       желаемом независимом наборе.</p>     <p>Если же вы решили решить вторую задачу, то в первой строке       выведите $$$2$$$, затем строку, содержащую одно целое число,       $$$c$$$, представляющее длину найденного цикла, а затем строку,       содержащую $$$c$$$ различных целых чисел, не превышающих $$$n$$$ —       вершины в нужном цикле, <span class="tex-font-style-bf">в порядке         их появления в цикле</span>.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4 4 3
1 2
2 3
3 4
4 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
1 3 </pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
4 5 3
1 2
2 3
3 4
4 1
2 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
3
2 3 4 </pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
4 6 3
1 2
2 3
3 4
4 1
1 3
2 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
3
1 2 3 </pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5 4 5
1 2
1 3
2 4
2 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
1 4 5 </pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере:</p>     <p>       <img class="tex-graphics" src="https://espresso.codeforces.com/30ec0d0b069debf55bfe3aba38c15fe035e200d6.png" style="max-width: 100.0%;max-height: 100.0%;"/></p>     <p>Обратите внимание, что вывод независимого множества $$$\{2,4\}$$$       тоже зачтется, но вывод цикла $$$1-2-3-4$$$ — нет, потому что его       длина должна быть не более $$$3$$$.</p>     <p>Во втором примере:</p>     <p>       <img class="tex-graphics" src="https://espresso.codeforces.com/49b31d8a4b5e8512fbcdd368e5a4a34445a020be.png" style="max-width: 100.0%;max-height: 100.0%;"/></p>     <p>Обратите внимание, что вывод независимого множества $$$\{1,3\}$$$       или цикла $$$2-1-4$$$ также зачтутся.</p>     <p>В третьем примере:</p>     <p>       <img class="tex-graphics" src="https://espresso.codeforces.com/45bb98eab0d3defca699e0516b015899cbd2225c.png" style="max-width: 100.0%;max-height: 100.0%;"/></p>     <p>В четвертом примере:</p>     <p>       <img class="tex-graphics" src="https://espresso.codeforces.com/0b423c3ffbcf9f02621ccf7efc14e8c656d80c8b.png" style="max-width: 100.0%;max-height: 100.0%;"/></p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #649 (Div. 2)
    1364E
    X-OR </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. X-OR</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>       <span class="tex-font-style-bf">Это интерактивная задача!</span></p>     <p>У Ехаба есть загаданная перестановка $$$p$$$ длины $$$n$$$,       состоящая из элементов от $$$0$$$ до $$$n-1$$$. По какой-то       причине вы хотите выяснить перестановку. Для этого вы можете       спросить у Ехаба $$$2$$$ <span class="tex-font-style-bf">разных</span> индекса $$$i$$$ и $$$j$$$,       и он ответит $$$(p_i|p_j)$$$, где $$$|$$$ обозначает операцию <a href="http://bitly.com/2JQkyd6">побитового ИЛИ</a>.</p>     <p>У Ехаба есть достаточно свободного времени, чтобы ответить на       $$$4269$$$ вопросов, и, несмотря на то, что ему несложно отвечать       на так много вопросов, ему лень играть в ваши глупые игры, поэтому       он заранее зафиксирует перестановку и <span class="tex-font-style-bf">не</span> изменит ее в зависимости от       ваших запросов. Можете ли вы угадать перестановку?</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В единственной строке записано целое число $$$n$$$ $$$(3 \le n       \le 2048)$$$ — длина перестановки.</p></div>         <div>     <div class="section-title">Протокол взаимодействия</div>          <p>Чтобы задать вопрос, выведите "<span class="tex-font-style-tt">? $$$i$$$ $$$j$$$</span>" (без       кавычек, $$$i \neq j$$$) Затем вы должны считать ответ, который       будет равен $$$(p_i|p_j)$$$.</p>     <p>Если мы ответим $$$-1$$$ вместо правильного ответа, это означает,       что вы превысили количество запросов или сделали неверный запрос.</p>     <p>Завершите программу сразу после получения $$$-1$$$, и вы увидите       вердикт <span class="tex-font-style-tt">Неправильный ответ</span>.       В противном случае вы можете получить произвольный вердикт, потому       что ваше решение будет продолжать читать из закрытого потока.</p>     <p>Чтобы дать ответ, выведите "<span class="tex-font-style-tt">! $$$p_1$$$ $$$p_2$$$ $$$\ldots$$$       $$$p_n$$$</span>" (без кавычек). <span class="tex-font-style-bf">Заметьте, что вывод ответа не         считается одним из $$$4269$$$ запросов</span>.</p>     <p>После вывода запроса не забудьте вывести перевод строки, и       сбросить буфер вывода. В противном случае вы получите вердикт         <span class="tex-font-style-tt">Решение «зависло»</span>. Для       сброса буфера используйте:</p>          <ul>                     <li> <span class="tex-font-style-tt">fflush(stdout)</span> или           <span class="tex-font-style-tt">cout.flush()</span> в C++;         </li>       <li> <span class="tex-font-style-tt">System.out.flush()</span> в Java;         </li>       <li> <span class="tex-font-style-tt">flush(output)</span> в Pascal;         </li>       <li> <span class="tex-font-style-tt">stdout.flush()</span> в Python;         </li>       <li> смотрите документацию для других языков.         </li></ul>          <p>       <span class="tex-font-style-bf">Взломы:</span></p>     <p>Первая строка должна содержать целое число $$$n$$$ ($$$3 \le n       \le 2^{11}$$$) — длину перестановки $$$p$$$.</p>     <p>Вторая строка должна содержать $$$n$$$ целых чисел, разделенных       пробелами $$$p_1$$$, $$$p_2$$$, $$$\ldots$$$, $$$p_n$$$ ($$$0 \le       p_i &lt; n$$$) — элементы перестановки $$$p$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
1
3
2</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
? 1 2
? 1 3
? 2 3
! 1 0 2</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере перестановка равна $$$[1,0,2]$$$. Вы начинаете с       вопроса $$$p_1|p_2$$$, а Ехаб отвечает $$$1$$$. Затем вы       спрашиваете $$$p_1|p_3$$$, а Ехаб отвечает $$$3$$$. Наконец, вы       спрашиваете о $$$p_2|p_3$$$, а Ехаб отвечает $$$2$$$. После этого       вы угадываете перестановку.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #648 (Div. 2)
    1365A
    Игра с таблицей </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Игра с таблицей</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Ashish и Vivek играют в игру на таблице с $$$n$$$ строками и       $$$m$$$ столбцами, захватывая клетки. Незахваченные клетки       обозначены $$$0$$$, а захваченные клетки обозначены $$$1$$$. Вам       дано исходное состояние таблицы.</p>     <p>На каждом ходу, игрок должен захватить одну клетку. Клетку можно       захватить, если она еще не захвачена, и она не находится в одной       строке или столбце с другой захваченной клеткой. Игра кончается,       когда игрок не может сделать ход, в таком случае, он проигрывает.</p>     <p>Если Ashish и Vivek ходят по очереди и Ashish ходит первым,       найдите победителя игры если они оба играют оптимально.</p>     <p>Оптимальная игра между двумя игроками означает, что оба игрока       выбирают лучшую возможную стратегию, чтобы получить наиболее       благоприятный для себя результат игры.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$t$$$ $$$(1 \le t \le       50)$$$ — количество наборов входных данных. Далее следуют описания       наборов входных данных.</p>     <p>В первой строке каждого набора входных данных записаны два целых       числа $$$n$$$, $$$m$$$ $$$(1 \le n, m \le 50)$$$ — количество       строк и столбцов в таблице.</p>     <p>В каждой из следующих $$$n$$$ строк записаны $$$m$$$ целых чисел,       $$$j$$$-е число на $$$i$$$-й строке описывает $$$a_{i,j}$$$       $$$(a_{i,j} \in \{0, 1\})$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных, если Ashish выиграет при       правильной игре, выведите «<span class="tex-font-style-tt">Ashish</span>», иначе выведите «<span class="tex-font-style-tt">Vivek</span>» (без кавычек).</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
2 2
0 0
0 0
2 2
0 0
0 1
2 3
1 0 1
1 1 0
3 3
1 0 0
0 0 0
1 0 0
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
Vivek
Ashish
Vivek
Ashish
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных: Один из возможных исходов игры       следующий: Ashish захватывает клетку $$$(1, 1)$$$, затем Vivek       захватывает клетку $$$(2, 2)$$$. Ashish не может захватить ни       клетку $$$(1, 2)$$$, ни клетку $$$(2, 1)$$$, так как клетки $$$(1,       1)$$$ и $$$(2, 2)$$$ уже захвачены. Таким образом, Ashish       проигрывает. Можно показать, что вне зависимости от ходов Ashish,       Vivek выиграет. Во втором наборе входных данных: Ashish       захватывает клетку $$$(1, 1)$$$, единственная клетка, которую       можно захватить. После этого у Vivek не будет возможных ходов.</p>     <p>В третьем наборе входных данных: Ashish не может сделать ход,       поэтому Vivek выиграет.</p>     <p>В четвертом наборе входных данных: Ashish захватывает клетку       $$$(2, 3)$$$, у Vivek не останется возможных ходов.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1365/problem/A' title='Codeforces Round 648 (Div. 2)'>1365A - Matrix Game</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>       <span class="tex-font-style-bf">Key Idea:</span></p>     <p>Vivek and Ashish can never claim cells in rows and columns which       already have at least one cell claimed. So we need to look at the       parity of minimum of the number of rows and columns which have no       cells claimed initially.</p>     <p>       <span class="tex-font-style-bf">Solution:</span></p>     <p>Let $$$a$$$ be the number of rows which do not have any cell       claimed in them initially and similarly $$$b$$$ be the number of       columns which do not have any cell claimed initially. Each time a       player makes a move both $$$a$$$ and $$$b$$$ decrease by $$$1$$$,       since they only claim cells in rows and columns with no claimed       cells. </p>     <p>If either one of $$$a$$$ or $$$b$$$ becomes $$$0$$$, the player       whose turn comes next loses the game. Since both $$$a$$$ and       $$$b$$$ decrease by $$$1$$$ after each move, $$$\min(a, b)$$$       becomes $$$0$$$ first. So, if $$$\min(a, b)$$$ is odd, Ashish wins       the game otherwise Vivek wins.</p>     <p>Time complexity: $$$O(n \cdot m)$$$</p></div></div></div>

           
            <pre><code>
#include 
using namespace std;
 
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define endl &#34;\n&#34;
#define int long long

const int N = 51;

int n, m;
int a[N][N];

int32_t main()
{
	IOS;
	int t;
	cin &gt;&gt; t;
	while(t--)
	{
		cin &gt;&gt; n &gt;&gt; m;
		set&lt; int &gt; r, c;
		for(int i = 1; i &lt;= n; i++)
		{
			for(int j = 1; j &lt;= m; j++)
			{
				cin &gt;&gt; a[i][j];
				if(a[i][j] == 1)
					r.insert(i), c.insert(j);
			}
		}
		int mn = min(n — r.size(), m — c.size());
		if(mn % 2)
			cout &lt;&lt; &#34;Ashish&#34; &lt;&lt; endl;
		else
			cout &lt;&lt; &#34;Vivek&#34; &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #648 (Div. 2)
    1365B
    Проблематичная сортировка </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Проблематичная сортировка</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У Ashish есть $$$n$$$ элементов, расположенных по порядку. </p>     <p>Каждый элемент задается двумя целыми числами $$$a_i$$$ — значение       элемента и $$$b_i$$$ — тип элемента (есть только два возможных       типа: $$$0$$$ и $$$1$$$). Он хочет отсортировать элементы в       порядке неубывания $$$a_i$$$.</p>     <p>Он может совершать следующую операцию произвольное число раз: </p>     <ul>                     <li> Выбрать любые два таких элемента $$$i$$$ и $$$j$$$, что         $$$b_i \ne b_j$$$ и поменять их местами. Таким образом, он может         за ход поменять местами два элемента разных типов.          </li></ul>          <p>Скажите ему, может ли он отсортировать массив в порядке       неубывания $$$a_i$$$, используя описанные операции.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$t$$$ $$$(1 \le t \le       100)$$$ — количество наборов входных данных.</p>     <p>В первой строке каждого набора входных данных записано одно целое       число $$$n$$$ $$$(1 \le n \le 500)$$$ — размеры массивов.</p>     <p>Во второй строке записаны $$$n$$$ целых чисел $$$a_i$$$ $$$(1 \le       a_i \le 10^5)$$$  — значение $$$i$$$-го элемента.</p>     <p>В третьей строке записаны $$$n$$$ целых чисел $$$b_i$$$ $$$(b_i       \in \{0, 1\})$$$  — тип $$$i$$$-го элемента.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных, выведите «<span class="tex-font-style-tt">Yes</span>» или «<span class="tex-font-style-tt">No</span>» (без кавычек) в зависимости       от того, возможно ли отсортировать массив в порядке неубывания       значений используя описанные операции.</p>     <p>Вы можете выводить каждый символ в любом регистре (верхнем или нижнем).</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
4
10 20 20 30
0 1 0 1
3
3 1 2
0 1 1
4
2 2 4 8
1 1 1 1
3
5 15 4
0 0 0
4
20 10 100 50
1 0 0 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
Yes
Yes
Yes
No
Yes
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных: элементы уже находятся в       отсортированном порядке.</p>     <p>Во втором наборе входных данных: Ashish сначала может поменять       местами элементы на позициях $$$1$$$ и $$$2$$$, затем поменять       местами элементы на позициях $$$2$$$ и $$$3$$$.</p>     <p>В четвертом наборе входных данных: Нельзя поменять местами       никакие два элемента, так как нет пары $$$i$$$ и $$$j$$$, что       $$$b_i \ne b_j$$$. Таким образом, элементы не могут быть отсортированы.</p>     <p>В пятом наборе входных данных: Ashish может поменять местами       элементы на позициях $$$3$$$ и $$$4$$$, а затем элементы на       позициях $$$1$$$ и $$$2$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1365/problem/B' title='Codeforces Round 648 (Div. 2)'>1365B - Trouble Sort</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>       <span class="tex-font-style-bf">Key Idea:</span></p>     <p>If there is at least one element of type $$$0$$$ and at least one       element of type $$$1$$$, we can always sort the array.</p>     <p>       <span class="tex-font-style-bf">Solution:</span></p>     <p>If all the elements are of the same type, we cannot swap any two       elements. So, in this case, we just need to check if given       elements are already in sorted order.</p>     <p>Otherwise, there is at least one element of type $$$0$$$ and at       least one element of type $$$1$$$. In this case, it is possible to       swap any two elements! We can swap elements of different types       using only one operation. Suppose we want to swap two elements       $$$a$$$ and $$$b$$$ of the same type. We can do it in $$$3$$$       operations. Let $$$c$$$ be an element of the type different from       $$$a$$$ and $$$b$$$. We can first swap $$$a$$$ and $$$c$$$, then       swap $$$b$$$ and $$$c$$$ and then swap $$$a$$$ and $$$c$$$ again.       In doing so, $$$c$$$ remains at its initial position and $$$a$$$,       $$$b$$$ are swapped. This is exactly how we swap two integers       using a temporary variable. Since we can swap any two elements, it       is always possible to sort the array in this case.</p>     <p>Time complexity: $$$O(n)$$$</p></div></div></div>

           
            <pre><code>
#include 
using namespace std;
 
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define endl &#34;\n&#34;
#define int long long

const int N = 1e3 + 5;

int n;
int a[N], b[N];

int32_t main()
{
	IOS;
	int t;
	cin &gt;&gt; t;
	while(t--)
	{
		cin &gt;&gt; n;
		bool sorted = 1, have0 = 0, have1 = 0;
		for(int i = 1; i &lt;= n; i++)
		{
			cin &gt;&gt; a[i];
			if(i &gt;= 2 &amp;&amp; a[i] &lt; a[i - 1])
				sorted = 0;
		}
		for(int i = 1; i &lt;= n; i++)
		{
			cin &gt;&gt; b[i];
			if(!b[i])
				have0 = 1;
			else
				have1 = 1;
		}
		if(have0 &amp;&amp; have1)
			cout &lt;&lt; &#34;Yes&#34; &lt;&lt; endl;
		else if(sorted)
			cout &lt;&lt; &#34;Yes&#34; &lt;&lt; endl;
		else
			cout &lt;&lt; &#34;No&#34; &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #648 (Div. 2)
    1365C
    Соответствия поворотом </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Соответствия поворотом</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>После мистического исчезнования Ashish, каждый из его любимых       учеников Ishika и Hriday, получил одну половину секретного       сообщения. Эти сообщения могут быть описаны перестановками размера       $$$n$$$. Назовем их $$$a$$$ и $$$b$$$.</p>     <p>Напомним, что перестановка из $$$n$$$ элементов это       последовательность чисел $$$a_1, a_2, \ldots, a_n$$$, в которой       каждое число от $$$1$$$ до $$$n$$$ встречается ровно один раз. </p>     <p>Сообщение может быть расшифровано из конфигурации перестановок       $$$a$$$ и $$$b$$$, в котором количество совпадающих пар элементов       максимально. Пара элементов $$$a_i$$$ и $$$b_j$$$ называется       совпадающей, если: </p>     <ul> <li> $$$i = j$$$, таким образом, у них один и тот же индекс. </li>       <li> $$$a_i = b_j$$$ </li></ul>          <p>Его ученикам разрешается совершать следующую операцию       произвольное число раз: </p>     <ul> <li> выбрать число $$$k$$$ и циклически сдвинуть одну из         перестановок влево или вправо $$$k$$$ раз. </li></ul>          <p>Циклический сдвиг перестановки $$$c$$$ влево это операция,       которая присваивает $$$c_1:=c_2, c_2:=c_3, \ldots, c_n:=c_1$$$       одновременно. Аналогично, циклический сдвиг перестановки $$$c$$$       вправо это операция, которая присваивает $$$c_1:=c_n, c_2:=c_1,       \ldots, c_n:=c_{n-1}$$$ одновременно.</p>     <p>Помогите Ishika и Hriday найти наибольшее возможное число       совпадающих пар в данных перестановках после применения описанных       операций несколько (возможно, ноль) раз.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$n$$$ $$$(1 \le n \le       2 \cdot 10^5)$$$ — размеры массивов.</p>     <p>Во второй строке записаны $$$n$$$ целых чисел $$$a_1$$$,       $$$a_2$$$, ..., $$$a_n$$$ $$$(1 \le a_i \le n)$$$ — элементы       первой перестановки.</p>     <p>В третьей строке записаны $$$n$$$ целых чисел $$$b_1$$$,       $$$b_2$$$, ..., $$$b_n$$$ $$$(1 \le b_i \le n)$$$ — элементы       второй перестановки.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите наибольшее возможное число совпадающих пар в данных       перестановках после применения описанных операций несколько       (возможно, ноль) раз.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
1 2 3 4 5
2 3 4 5 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
5</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
5 4 3 2 1
1 2 3 4 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
1 3 2 4
4 2 3 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере можно сдвинуть $$$b$$$ направо на $$$k = 1$$$.       Получившиеся перестановки будут $$$\{1, 2, 3, 4, 5\}$$$ и $$$\{1,       2, 3, 4, 5\}$$$.</p>     <p>Во втором примере не требуется совершать никаких операций. По       всем возможным сдвигам $$$a$$$ и $$$b$$$, число совпадающих пар не       будет превышать $$$1$$$.</p>     <p>В третьем примере можно сдвинуть $$$b$$$ влево на $$$k = 1$$$.       Получившиеся перестановки будут $$$\{1, 3, 2, 4\}$$$ и $$$\{2, 3,       1, 4\}$$$. Позиции $$$2$$$ и $$$4$$$ будут являться совпадающей       парой. По всем возможным циклическим сдвигам $$$a$$$ и $$$b$$$,       количество совпадающих пар не будет превышать $$$2$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1365/problem/C' title='Codeforces Round 648 (Div. 2)'>1365C - Rotation Matching</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>       <span class="tex-font-style-bf">Key Idea:</span></p>     <p>We only need to perform shifts on one of the arrays. Moreover,       all the shifts can be of the same type (right or left)!</p>     <p>       <span class="tex-font-style-bf">Solution:</span></p>     <p>First of all, a left cyclic shift is the same as $$$n - 1$$$       right cyclic shifts and vice versa. So we only need to perform       shifts of one type, say right.</p>     <p>Moreover, a right cyclic shift of $$$b$$$ is the same as       performing a left cyclic shift on $$$a$$$ and vice versa. So we       don't need to perform any shifts on $$$b$$$.</p>     <p>Now the problem reduces to finding the maximum number of matching       pairs over all right cyclic shifts of $$$a$$$. Since $$$n$$$ right       cyclic shifts on $$$a$$$ results in $$$a$$$ again, there are only       $$$n - 1$$$ right cyclic shifts possible. </p>     <p>Since both arrays are a permutation, each element in $$$a$$$       would match with its corresponding equal element in $$$b$$$ only       for one of the shifts. For example, if $$$a$$$ is $$$\{{2, 3,       1\}}$$$ and $$$b$$$ is $$$\{{3, 1, 2\}}$$$, the number $$$3$$$ in       $$$a$$$ would match with the number $$$3$$$ in $$$b$$$ only if one       right cyclic shift is performed. So for each element in $$$a$$$ we       can find the number of right cyclic shifts after which it would       match with its corresponding equal element in $$$b$$$. If       $$$a_i$$$ = $$$b_j$$$, then $$$a_i$$$ would match with $$$b_j$$$       after $$$k = j - i$$$ right cyclic shifts. If $$$j - i \lt 0$$$,       then $$$a_i$$$ would with $$$b_j$$$ after $$$n - j + i$$$ shifts.</p>     <p>Now for each shift, we can find the number of matching pairs and       take the maximum.</p>     <p>Time complexity: $$$O(n)$$$ or $$$O(n \cdot log(n))$$$ if you use       a map.</p></div></div></div>

           
            <pre><code>
#include 
using namespace std;
 
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define endl &#34;\n&#34;
#define int long long

const int N = 2e5 + 5;

int n;
int a[N], b[N], pos[N];
map&lt; int, int &gt; offset;

int32_t main()
{
	IOS;
	cin &gt;&gt; n;
	for(int i = 1; i &lt;= n; i++)
	{
		cin &gt;&gt; a[i];
		pos[a[i]] = i;
	}
	for(int i = 1; i &lt;= n; i++)
		cin &gt;&gt; b[i];
	for(int i = 1; i &lt;= n; i++)
	{
		int cur = pos[b[i]] - i;
		if(cur &lt; 0)
			cur += n;
		offset[cur]++;
	}
	int ans = 0;
	for(auto &amp;it:offset)
		ans = max(ans, it.second);
	cout &lt;&lt; ans;
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #648 (Div. 2)
    1365D
    Решить лабиринт </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Решить лабиринт</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Vivek столкнулся с интересной задачей. У него есть лабиринт,       который можно описать таблицей $$$n \times m$$$. Каждая клетка       может быть одного из следующих типов:</p>          <ul> <li> Пустая — '<span class="tex-font-style-tt">.</span>' </li>       <li> Стена — '<span class="tex-font-style-tt">#</span>' </li>       <li> Хороший человек  — '<span class="tex-font-style-tt">G</span>' </li>       <li> Плохой человек — '<span class="tex-font-style-tt">B</span>' </li></ul>          <p>Единственный выход из лабиринта находится в клетке $$$(n, m)$$$.</p>     <p>Человек может перейти в клетку если она не содержит стену и она       имеет общую сторону с его текущей клеткой. Vivek хочет       заблокировать (заменить на стены) некоторые пустые клетки, чтобы       все хорошие люди могли дойти до выхода из лабиринта, но чтобы все       плохие люди не могли. Клетку которая исходно содержит '<span class="tex-font-style-tt">G</span>' или '<span class="tex-font-style-tt">B</span>' нельзя блокировать, но через       нее можно проходить.</p>     <p>Ваша задача  — определить, можно ли заменить несколько (ноль или       более) пустых клеток на стены, чтобы удовлетворить описанным ограничениям.</p>     <p>Гарантируется, что клетка $$$(n,m)$$$ пустая. Vivek <span class="tex-font-style-bf">разрешается</span> ее блокировать.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$t$$$ $$$(1 \le t \le       100)$$$ — количество наборов входных данных. Далее следуют       описания наборов входных данных.</p>     <p>В первой строке каждого набора входных данных записаны два целых       числа $$$n$$$, $$$m$$$ $$$(1 \le n, m \le 50)$$$ — количество       строк и столбцов в лабиринте.</p>     <p>В каждой из следующих $$$n$$$ строк записаны $$$m$$$ символов.       Они описывают исходный лабиринт. Если символ в строке равен '<span class="tex-font-style-tt">.</span>', тогда соответствующая клетка       пустая, если символ равен '<span class="tex-font-style-tt">#</span>', тогда клетка содержит стену,       а '<span class="tex-font-style-tt">G</span>' и '<span class="tex-font-style-tt">B</span>' обозначают, что клетка       содержит хорошего или плохого человека, соответственно.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных, выведите «<span class="tex-font-style-tt">Yes</span>» или «<span class="tex-font-style-tt">No</span>», в зависимости от того, можно       ли заменить некоторые пустые клетки на стены, чтобы удовлетворить       описанным ограничениям.</p>     <p>Вы можете выводить каждую букву в любом регистре (верхнем или нижнем).</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
1 1
.
1 2
G.
2 2
#B
G.
2 3
G.#
B#.
3 3
#B.
#..
GG.
2 2
#B
B.
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
Yes
Yes
No
No
Yes
Yes
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом и во втором наборах входных данных все условия уже выполнены.</p>     <p>В третьем наборе входных данных есть только одна свободная клетка       $$$(2,2)$$$, и если мы заменим ее на стену, то хороший человек в       клетке $$$(1,2)$$$ не сможет выйти.</p>     <p>В четвертом наборе входных данных хороший человек в клетке       $$$(1,1)$$$ не может сбежать с самого начала, поэтому ответ «<span class="tex-font-style-tt">No</span>».</p>     <p>В пятом наборе входных данных можно заблокировать клетки       $$$(2,3)$$$ и $$$(2,2)$$$.</p>     <p>В последнем наборе входных данных можно заблокировать выход       $$$(2, 2)$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1365/problem/D' title='Codeforces Round 648 (Div. 2)'>1365D - Solve The Maze</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>       <span class="tex-font-style-bf">Key Idea:</span></p>     <p>We can block all empty neighbouring cells of bad people and then       check if all good people can escape and no bad people are able to escape.</p>     <p>       <span class="tex-font-style-bf">Solution:</span></p>     <p>Consider all the neighbouring cells of bad people. There       shouldn't be any path from these cells to the cell $$$(n, m)$$$.       If there is a path from any such cell, the bad person adjacent to       that cell can also then reach the cell $$$(n, m)$$$. So, if any       good and bad people are in adjacent cells, the answer is         &quot;<span class="tex-font-style-tt">No</span>&quot;.</p>     <p>Based on this idea, we can block any empty cell neighbouring a       bad person. Suppose there is another solution in which a cell       $$$(i, j)$$$ neighbouring a bad person does not need to be       blocked. There still won't be any path from $$$(i, j)$$$ to $$$(n,       m)$$$ in that solution. So we can block $$$(i, j)$$$ in that       solution too without affecting the solution itself.</p>     <p>It is sufficient to block only the empty neighbouring cells of       bad people and check the required conditions, which can be done       using a bfs on the grid.</p>     <p>Proof:</p>     <p>We will assume there are no adjacent good and bad people since in       that case, the answer is &quot;<span class="tex-font-style-tt">No</span>&quot;. There are three cases: </p>     <ul> <li> A bad person is adjacent to the cell $$$(n, m)$$$. In this         case, the cell $$$(n, m)$$$ must be blocked. Now no one will be         able to escape. If there is at least one good person present,         the answer is &quot;<span class="tex-font-style-tt">No</span>&quot;. </li>       <li> If after blocking the neighbouring cells of bad people, there         is some good person who is not able to escape, then the answer         is again &quot;<span class="tex-font-style-tt">No</span>&quot;. </li>       <li> Otherwise, the answer is always &quot;<span class="tex-font-style-tt">Yes</span>&quot;. Suppose there is         some path from a bad person at cell $$$(i, j)$$$ to the cell         $$$(n, m)$$$. One of the neighbours of this person must be         another bad person since the only other case is an adjacent good         person (which is already covered above). Extending this, all the         cells on the path from $$$(i, j)$$$ to $$$(n, m)$$$ must have         bad people. This is not possible since in this case, there must         be a bad person adjacent to $$$(n, m)$$$ and this case is         already covered above. </li></ul>          <p>Time complexity: $$$O(n \cdot m)$$$</p></div></div></div>

           
            <pre><code>
#include 
using namespace std;
#define int long long
typedef int ll;
typedef long double ld;
const ll N = 55;
char en = &#39;\n&#39;;
ll inf = 1e16;
ll mod = 1e9 + 7;
ll power(ll x, ll n, ll mod) {
  ll res = 1;
  x %= mod;
  while (n) {
    if (n &amp; 1)
      res = (res * x) % mod;
    x = (x * x) % mod;
    n &gt;&gt;= 1;
  }
  return res;
}
ll n, m;
char arr[N][N];
ll dir[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

bool valid(ll i, ll j) { return i &gt;= 1 &amp;&amp; i &lt;= n &amp;&amp; j &gt;= 1 &amp;&amp; j &lt;= m; }
int32_t main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);

  ll t;
  cin &gt;&gt; t;
  while (t--) {

    cin &gt;&gt; n &gt;&gt; m;

    for (ll i = 1; i &lt;= n; i++) {
      cin &gt;&gt; (arr[i] + 1);
    }

    for (ll i = 1; i &lt;= n; i++) {
      for (ll j = 1; j &lt;= m; j++) {
        if (arr[i][j] == &#39;B&#39;) {
          for (ll k = 0; k &lt; 4; k++) {
            ll ni = i + dir[k][0];
            ll nj = j + dir[k][1];
            if (valid(ni, nj) &amp;&amp; arr[ni][nj] == &#39;.&#39;)
              arr[ni][nj] = &#39;#&#39;;
          }
        }
      }
    }

    queue&gt; que;
    bool visited[n + 5][m + 5];
    memset(visited, false, sizeof(visited));
    if (arr[n][m] == &#39;.&#39;) {
      que.push({n, m});
      visited[n][m] = true;
    }
    while (!que.empty()) {
      pair curr = que.front();
      que.pop();
      for (ll k = 0; k &lt; 4; k++) {
        ll ni = curr.first + dir[k][0];
        ll nj = curr.second + dir[k][1];
        if (valid(ni, nj) &amp;&amp; !visited[ni][nj] &amp;&amp; arr[ni][nj] != &#39;#&#39;) {
          que.push({ni, nj});
          visited[ni][nj] = true;
        }
      }
    }
    bool good = true;
    for (ll i = 1; i &lt;= n; i++) {
      for (ll j = 1; j &lt;= m; j++) {
        if ((arr[i][j] == &#39;G&#39; &amp;&amp; !visited[i][j]) or
            (arr[i][j] == &#39;B&#39; &amp;&amp; visited[i][j])) {
          good = false;
          break;
        }
      }
    }
    cout &lt;&lt; (good ? &#34;Yes&#34; : &#34;No&#34;) &lt;&lt; en;
  }

  return 0;
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #648 (Div. 2)
    1365E
    Максимальное значение подпоследовательности  </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. Максимальное значение подпоследовательности </div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У Ashish есть массив $$$a$$$ длины $$$n$$$ состоящий из       положительных целых чисел.</p>     <p>Определим значение непустой подпоследовательности массива       $$$a$$$, состоящией из $$$k$$$ чисел, как $$$\sum 2^i$$$ по всем       целым $$$i \ge 0$$$ таким, что хотя бы $$$\max(1, k - 2)$$$ чисел       в этом подмножестве имеют $$$i$$$-й бит в своей двоичной записи       (число $$$x$$$ имеет $$$i$$$-й бит в двоичной записи если       $$$\lfloor \frac{x}{2^i} \rfloor \mod 2$$$ равно $$$1$$$). </p>     <p>Напомним, что $$$b$$$ является подпоследовательностью $$$a$$$,       если $$$b$$$ может быть получена удалением нескольких (возможно,       нуля) элементов из $$$a$$$.</p>     <p>Помогите ему найти наибольшее значение, которое он может       получить, выбрав некоторую подпоследовательность $$$a$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$n$$$ $$$(1 \le n \le       500)$$$ — размер массива $$$a$$$.</p>     <p>Во второй строке записаны $$$n$$$ целых чисел  — элементы массива       $$$(1 \le a_i \le 10^{18})$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одно целое число  — наибольшее значение, которое Ashish       может получить, выбрав некоторую подпоследовательность $$$a$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
2 1 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
3 1 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
7</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
1
1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
7 7 1 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
7</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере Ashish может выбрать подпоследовательность       $$$\{{2, 3}\}$$$ размера $$$2$$$. Двоичная запись $$$2$$$ это         <span class="tex-font-style-tt">10</span> а двоичная запись       $$$3$$$ это <span class="tex-font-style-tt">11</span>. Так как       $$$\max(k - 2, 1)$$$ равно $$$1$$$, значение подпоследовательности       равно $$$2^0 + 2^1$$$ (и у $$$2$$$ и у $$$3$$$ есть $$$1$$$-й бит       в двоичной записи, а у $$$3$$$ также есть $$$0$$$-й бит в двоичной       записи). Обратите внимание, что он также мог выбрать       подпоследовательность $$$\{{3\}}$$$ или $$$\{{1, 2, 3\}}$$$.</p>     <p>Во втором примере Ashish может выбрать подпоследовательность       $$$\{{3, 4\}}$$$ со значением $$$7$$$.</p>     <p>В третьем примере Ashish может выбрать подпоследовательность       $$$\{{1\}}$$$ со значением $$$1$$$.</p>     <p>В четвертом примере Ashish может выбрать подпоследовательность       $$$\{{7, 7\}}$$$ со значением $$$7$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1365/problem/E' title='Codeforces Round 648 (Div. 2)'>1365E - Maximum Subsequence Value</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>       <span class="tex-font-style-bf">Key Idea:</span></p>     <p>For subsets of size up to $$$3$$$, their value is the bitwise OR       of all elements in it. For any subset $$$s$$$ of size greater than       $$$3$$$, it turns out that if we pick any subset of $$$3$$$       elements within it, then its value is greater than or equal to the       value of $$$s$$$!</p>     <p>       <span class="tex-font-style-bf">Solution:</span></p>     <p>Let $$$k$$$ be the size of the chosen subset. For $$$k \le 3$$$,       $$$\max(k - 2, 1)$$$ is equal to $$$1$$$. This implies that their       value is equal to the bitwise OR of all the elements in it (since       we need to add $$$2^i$$$ for all $$$i$$$ such that at least       $$$1$$$ element in the subset has $$$i$$$-th bit set in its binary representation).</p>     <p>Consider any subset $$$s$$$ of size $$$k \gt 3$$$. Let $$$i$$$ be       any number such that the $$$i$$$-th bit is set in at least $$$k -       2$$$ elements of $$$s$$$. If we pick any $$$3$$$ elements of this       subset, then by <a href="https://en.wikipedia.org/wiki/Pigeonhole_principle">Pigeonhole       principle</a> the $$$i$$$-th bit would also be set in at least one       of these elements! If this is not true then the there are $$$3$$$       elements in $$$s$$$ which do not have the $$$i$$$-th bit set,       which is not possible.</p>     <p>So for any subset $$$s$$$ of size greater than $$$3$$$, its value       is less than or equal to the value of any subset consisting of       $$$3$$$ elements from $$$s$$$. Hence, we only need to check all       subsets of size up to $$$3$$$.</p>     <p>Time complexity: $$$O(n^3)$$$</p></div></div></div>

           
            <pre><code>
#include 
using namespace std;
 
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define endl &#34;\n&#34;
#define int long long

const int N = 505;

int n;
int a[N];

int32_t main()
{
	IOS;
	cin &gt;&gt; n;
	for(int i = 1; i &lt;= n; i++)
		cin &gt;&gt; a[i];
	int ans = 0;
	for(int i = 1; i &lt;= n; i++)
		for(int j = i; j &lt;= n; j++)
			for(int k = j; k &lt;= n; k++)
				ans = max(ans, (a[i] | a[j] | a[k]));
	cout &lt;&lt; ans;
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #648 (Div. 2)
    1365F
    Снова обмены </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Снова обмены</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Ayush, Ashish и Vivek заняты подготовкой задачи для следующего       Codeforces раунда и им нужно помочь проверить тесты на корректность.</p>     <p>Каждый набор входных данных состоит из $$$n$$$ и двух массивов       $$$a$$$ и $$$b$$$, длины $$$n$$$. Если после скольки-то (возможно,       нуля) операций описанных ниже, массив $$$a$$$ может стать равен       массиву $$$b$$$, тест считается <span class="tex-font-style-tt">корректным</span>. Иначе, он <span class="tex-font-style-tt">некорректный</span>.</p>     <p>Возможные операции на массиве $$$a$$$ следующие: </p>     <ul> <li> выберите целое число $$$k$$$ $$$(1 \le k \le         \lfloor\frac{n}{2}\rfloor)$$$ </li>       <li> поменяйте местами префикс длины $$$k$$$ с суффиксом длины         $$$k$$$ </li></ul>          <p>Например, если массив $$$a$$$ исходно равен $$$\{1, 2, 3, 4, 5,       6\}$$$, после выполнения операции с $$$k = 2$$$, он превратится в       $$$\{5, 6, 3, 4, 1, 2\}$$$.</p>     <p>Вам дано несколько наборов входных данных, помогите определить       про каждый из них, <span class="tex-font-style-tt">корректный</span> он или <span class="tex-font-style-tt">некорректный</span>.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$t$$$ $$$(1 \le t \le       500)$$$ — количество наборов входных данных. Далее следуют       описания наборов входных данных.</p>     <p>В первой строке каждого набора входных данных записано одно целое       число $$$n$$$ $$$(1 \le n \le 500)$$$ — размеры массивов.</p>     <p>Во второй строке записаны $$$n$$$ целых чисел $$$a_1$$$,       $$$a_2$$$, ..., $$$a_n$$$ $$$(1 \le a_i \le 10^9)$$$ — элементы       массива $$$a$$$.</p>     <p>В третьей строке записаны $$$n$$$ целых чисел $$$b_1$$$,       $$$b_2$$$, ..., $$$b_n$$$ $$$(1 \le b_i \le 10^9)$$$ — элементы       массива $$$b$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных, выведите «<span class="tex-font-style-tt">Yes</span>», если данный ввод <span class="tex-font-style-tt">корректный</span>. Иначе, выведите         «<span class="tex-font-style-tt">No</span>».</p>     <p>Вы можете выводить все символы в любом регистре.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
2
1 2
2 1
3
1 2 3
1 2 3
3
1 2 4
1 3 4
4
1 2 3 2
3 1 2 2
3
1 2 3
1 3 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
yes
yes
No
yes
No
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных можно поменять местами префикс       $$$a[1:1]$$$ с суффиксом $$$a[2:2]$$$, чтобы получить $$$a=[2, 1]$$$.</p>     <p>Во втором наборе входных данных $$$a$$$ уже равен $$$b$$$.</p>     <p>В третьем наборе входных данных невозможно получить $$$3$$$ в $$$a$$$.</p>     <p>В четвертом наборе входных данных сначала можно поменять местами       префикс $$$a[1:1]$$$ с суффиксом $$$a[4:4]$$$, чтобы получить       $$$a=[2, 2, 3, 1]$$$. После этого можно поменять местами префикс       $$$a[1:2]$$$ с суффиксом $$$a[3:4]$$$, чтобы получить $$$a=[3, 1,       2, 2]$$$.</p>     <p>В пятом наборе входных данных невозможно превратить $$$a$$$ в $$$b$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1365/problem/F' title='Codeforces Round 648 (Div. 2)'>1365F - Swaps Again</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>       <span class="tex-font-style-bf">Key Idea:</span></p>     <p>If we consider the unordered pair of elements $$$\{{a_i, a_{n - i       + 1}\}}$$$, then after any operation, the multiset of these pairs       (irrespective of the ordering of elements within the pair) stays       the same!</p>     <p>       <span class="tex-font-style-bf">Solution:</span></p>     <p>First of all, if the multiset of numbers in $$$a$$$ and $$$b$$$       are not the same, the answer is &quot;<span class="tex-font-style-tt">No</span>&quot;.</p>     <p>Moreover, if $$$n$$$ is odd, it is not possible to change the       middle element of $$$a$$$, i.e., $$$a_{(n + 1) / 2}$$$. So when       $$$n$$$ is odd and elements at the position $$$(n + 1) / 2$$$ do       not match in $$$a$$$ and $$$b$$$, the answer is again &quot;<span class="tex-font-style-tt">No</span>&quot;.</p>     <p>Suppose we pair up the elements at equal distance from the middle       element in $$$a$$$ (if $$$n$$$ is even, the middle element does       not exist but we can treat it as the one between positions $$$n /       2$$$ and $$$n / 2 + 1$$$). That is, we pair up $$$\{{a_i, a_{n - i       + 1}\}}$$$ (their individual order within the pair doesn't       matter). After any operation on $$$a$$$, the multiset of these       pairs does not change!</p>     <p>If we swap a prefix of length $$$l$$$ with the suffix of length       $$$l$$$, then consider any element at position $$$i \le l$$$       before the swap. It's new position is $$$n - l + i$$$ and the       element it was paired with, i.e. the element at position $$$n - i       + 1$$$ goes to the position $$$l - i + 1$$$. $$$(n - l + i) + (l -       i + 1) = n + 1$$$, so these two elements are still paired after       the swap.</p>     <p>For example, if $$$a$$$ is $$$[1, 4, 2, 3]$$$, then the pairs are       $$$\{{1, 3\}}$$$ and $$$\{{2, 4\}}$$$ (their individual ordering       in the pair doesn't matter). Suppose we first apply the operation       on the prefix of length $$$1$$$ and then the prefix of length       $$$2$$$. After the first operation, $$$a$$$ is $$$[3, 4, 2, 1]$$$       and after the second operation, $$$a$$$ is $$$[2, 1, 3, 4]$$$.       Note that in both these arrays, the pairings are still the same,       i.e., $$$\{{1, 3\}}$$$ and $$$\{{2, 4\}}$$$.</p>     <p>We conclude that in any array resulting after some number of       operations, these pairings do not change with respect to the       initial array. It turns out that all such arrays with same       pairings as the initial array can be formed by performing these       operations! So we only need to check if the multiset of these       pairs in $$$b$$$ is the same as the multiset of pairs in $$$a$$$.</p>     <p>Proof:</p>     <p>We will show that given any array $$$b$$$ such that the multiset       of pairs in $$$b$$$ is the same as the multiset of pairs in       $$$a$$$, then we can form $$$b$$$ from $$$a$$$ in atmost       $$$\lfloor{\frac{3 n}{2}}\rfloor$$$ operations. We will start       constructing the pairs in $$$b$$$ starting from $$$b_{n / 2}$$$ to       $$$b_{1}$$$, i.e., we first bring elements $$$b_{n / 2}$$$ and       $$$b_{n - n / 2 + 1}$$$ to their position in $$$a$$$ followed by       $$$b_{n / 2 - 1}$$$ and so on. </p>     <p>Note that if we bring the elements $$$b_{n / 2}$$$ and $$$b_{n -       n / 2 + 1}$$$ to their respective positions in $$$a$$$ then we can       delete them in both $$$a$$$ and $$$b$$$ and continue the       construction. Suppose we currently want to bring elements       $$$b_i$$$ and $$$b_{n - i + 1}$$$ $$$(i \le n/2)$$$ to their       respective positions in $$$a$$$. If $$$b_i$$$ is at position       $$$j$$$ in $$$a$$$, then $$$b_{n - i + 1}$$$ must be at the       position $$$n - j + 1$$$. There are three cases:</p>          <ol> <li> If $$$j = n$$$, then we can swap the prefix and suffix of         length $$$i$$$ in $$$a$$$ to achieve this.         </li>       <li> Otherwise if $$$j = 1$$$, then we can first swap prefix and         suffix of length $$$1$$$ and then swap prefix and suffix of         length $$$i$$$.         </li>       <li> Else we can swap prefix and suffix of length $$$j$$$ in         $$$a$$$ and proceed to steps $$$1$$$ and $$$2$$$. </li></ol>          <p>In atmost $$$3$$$ steps, we can bring each pair in $$$a$$$ to its       required position in $$$b$$$. So we need atmost $$$\lfloor{\frac{3       n}{2}}\rfloor$$$ operations overall.</p>     <p>Time complexity: $$$O(n \cdot \log{n})$$$</p></div></div></div>

           
            <pre><code>
#include
using namespace std;

int main(){
	ios_base::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	int tc;
	cin &gt;&gt; tc;
	while(tc--){
		int n;
		cin &gt;&gt; n;
		map&lt; pair &lt; int, int &gt;, int &gt; pairs;
		vector&lt; int &gt; a(n), b(n);
		bool possible = 1;

		for(int i = 0; i &lt; n; i++)
			cin &gt;&gt; a[i];

		for(int i = 0; i &lt; n; i++)
			cin &gt;&gt; b[i];

		if(n % 2 == 1 &amp;&amp; a[n / 2] != b[n / 2])
			possible = 0;

		for(int i = 0; i &lt; n / 2; i++){
			pair&lt; int, int &gt; p = {min(a[i], a[n — 1 — i]), max(a[i], a[n — 1 — i])};
			pairs[p]++;
		}

		for(int i = 0; i &lt; n / 2; i++){
			pair&lt; int, int &gt; p = {min(b[i], b[n — 1 — i]), max(b[i], b[n — 1 — i])};
			if(pairs[p] &lt;= 0)
				possible = 0;
			pairs[p]--;
		}

		if(possible)
			cout &lt;&lt; &#34;Yes&#34; &lt;&lt; endl;

		else cout &lt;&lt; &#34;No&#34; &lt;&lt; endl;
	}
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #648 (Div. 2)
    1365G
    Надежный пароль </h1>

    <div class="problemindexholder" problemindex="G">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">G. Надежный пароль</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>       <span class="tex-font-style-bf">Это интерактивная задача.</span></p>     <p>Ayush придумал еще один способ задать пароль для своего замка. В       замке есть $$$n$$$ слотов, в каждом слоте может находится любое       неотрицательное целое число. Пароль $$$P$$$ это последовательность       из $$$n$$$ целых чисел, $$$i$$$-й из которых соответствует       $$$i$$$-му слоту замка.</p>     <p>Чтобы задать пароль, Ayush придумал последовательность $$$A$$$ из       $$$n$$$ целых чисел из отрезка $$$[0, 2^{63}-1]$$$. Затем, он       определил $$$i$$$-й элемент $$$P$$$ как <a href="https://en.wikipedia.org/wiki/Bitwise_operation#OR">побитовое       ИЛИ</a> всех чисел в массиве кроме $$$A_i$$$.</p>     <p>Вам нужно отгадать пароль. Чтобы задать запрос, вы можете выбрать       непустое подмножество индексов массива и спросить <span class="tex-font-style-bf">побитовое ИЛИ</span> всех элементов       массива с индексами в этом подмножестве. <span class="tex-font-style-bf">Вы можете задать не более 13 запросов</span>.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$n$$$ $$$(2 \le n \le       1000)$$$ — количество слотов в замке.</p></div>         <div>     <div class="section-title">Протокол взаимодействия</div>          <p>Чтобы задать вопрос, в отдельной строке: </p>     <ul> <li> Сначала выведите «<span class="tex-font-style-tt">?         c</span>» (без кавычек), где $$$c$$$ $$$(1 \leq c \leq n)$$$         обозначает размер подмножества запроса, после чего выведите         $$$c$$$ <span class="tex-font-style-bf">различных</span> целых         чисел из отрезка $$$[1, n]$$$, разделенных пробелами. </li></ul>          <p>В ответ на каждый запрос, вы получите число $$$x$$$ — побитовое       ИЛИ чисел с выбранными индексами. Если вы спросили некорректное       множество индексом или вы превысили количество запросов, тогда вы       получите $$$x = -1$$$. В таком случае вы должны немедленно       завершить выполнение программы.</p>     <p>Если вы угадали пароль, в отдельной строке выведите «<span class="tex-font-style-tt">!</span>» (без кавычек), после чего       выведите $$$n$$$ целых чисел, разделенных пробелами  — последовательность-пароль.</p>     <p>Отгадывание пароля <span class="tex-font-style-bf">не</span>       считается в числе загаданных запросов.</p>     <p>       <span class="tex-font-style-bf">Интерактор не адаптивный.</span>       Массив $$$A$$$ не меняется с запросами.</p>     <p>После вывода запроса, не забывайте выводить конец строки и       сбрасывать поток вывода. Иначе, вы получите верикт <span class="tex-font-style-tt">Превышен лимит бездействия</span>.       Чтобы сделать это, используйте:</p>          <ul>                     <li> <span class="tex-font-style-tt">fflush(stdout)</span> или           <span class="tex-font-style-tt">cout.flush()</span> в C++;         </li>       <li> <span class="tex-font-style-tt">System.out.flush()</span> в Java;         </li>       <li> <span class="tex-font-style-tt">flush(output)</span> в Pascal;         </li>       <li> <span class="tex-font-style-tt">stdout.flush()</span> в Python;         </li>       <li> читайте документацию для остальных языков.         </li></ul>          <p>       <span class="tex-font-style-bf">Взломы</span></p>     <p>Чтобы взломать решение, используйте следующий формат:</p>     <p>В первой строке, выведите одно целое число $$$n$$$ $$$(2 \le n       \le 1000)$$$ — количество слотов в замке. Во второй строке       выведите $$$n$$$ целых чисел из отрезка $$$[0, 2^{63} - 1]$$$,       разделенных пробелами  — массив $$$A$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3

1

2

4

</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
? 1 1

? 1 2

? 1 3

! 6 5 3
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Массив $$$A$$$ в примере это $$$\{{1, 2, 4\}}$$$. Первый элемент       пароля это побитовое ИЛИ элементов $$$A_2$$$ и $$$A_3$$$, второй       элемент это побитовое ИЛИ элементов $$$A_1$$$ и $$$A_3$$$, а       третий элемент это побитовое ИЛИ элементов $$$A_1$$$ и $$$A_2$$$.       Таким образом, пароль равен $$$\{{6, 5, 3\}}$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1365/problem/G' title='Codeforces Round 648 (Div. 2)'>1365G - Secure Password</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>       <span class="tex-font-style-bf">Key Idea:</span></p>     <p>Unlike the last version of the problem, this is not doable using       a binary search.</p>     <p>       <span class="tex-font-style-bf">Solution using more queries</span>:</p>     <p>It is possible to solve the problem using $$$2\cdot \log{n}$$$       queries in the following way:</p>     <p>For each $$$i$$$, we ask the bitwise OR of all numbers at indices       which have the $$$i$$$-th bit set in their binary representation.       We also ask the bitwise OR of all numbers at indices which do not       have the $$$i$$$-th bit set in their binary representation.</p>     <p>Suppose we want to calculate the bitwise OR of all numbers except       the $$$i$$$-th number. Let the bitwise OR be equal to $$$a$$$       (initialize $$$a= 0$$$). We iterate on all indices $$$j$$$ from       $$$1$$$ to $$$n$$$ (except $$$i$$$). If $$$j$$$ is a submask of       $$$i$$$, that is $$$j \wedge i = j$$$ (where $$$\wedge$$$ is the       bitwise AND operator), then there must be some bit $$$k$$$ that is       set in $$$i$$$ but not in $$$j$$$ (since $$$i \ne j$$$). In this       case we replace $$$a$$$ by $$$a \vee x$$$ where $$$\vee$$$ is the       bitwise OR operator and $$$x$$$ is the bitwise OR of numbers at       indices that do no have the $$$k$$$-th bit set. Similarly, if       $$$j$$$ is not a submask of $$$i$$$ then there must be some bit       $$$k$$$ which is set in $$$j$$$ but not in $$$i$$$. In that case       we use the bitwise OR of numbers at indices that have the       $$$k$$$-th bit set.</p>     <p>In doing so, we included the contribution of each element except       $$$i$$$ at least once. Note that this works because taking the       bitwise OR with the same number more than once does not affect the answer.</p>     <p>For example, if $$$n=4$$$ and indices are number $$$0$$$ to       $$$3$$$, then we need to ask $$$4$$$ queries: $$$\{{0, 2\}}$$$       (bit $$$0$$$ not set), $$$\{{1, 3\}}$$$ (bit $$$0$$$ set),       $$$\{{0, 1\}}$$$ (bit $$$1$$$ not set), $$$\{{2, 3\}}$$$ (bit       $$$1$$$ set).</p>     <p>       <span class="tex-font-style-bf">Solution</span>:</p>     <p>Note that in the suboptimal solution, we assigned a bitmask to       each index (in that case bitmask for index $$$i$$$ was equal to       $$$i$$$). What if we assign these masks in a different way?</p>     <p>Suppose we are able to assign the masks in such a way that no two       masks assigned to two indices are submasks of each other. In this       case, we do not need to ask bitwise OR of indices which do not       have the $$$i$$$-th bit set since for each pair of indices, there       is a bit which is set in one but not in the other.</p>     <p>For example, if $$$n = 4$$$, we can assign masks <span class="tex-font-style-tt">1100</span>, <span class="tex-font-style-tt">1010</span>, <span class="tex-font-style-tt">1001</span> and <span class="tex-font-style-tt">0110</span> (in binary representation).       Now for each bit $$$i$$$, we will only query the indices which       have the $$$i$$$-th bit set. In this case, for bit $$$0$$$ we ask       $$$\{{3\}}$$$, for bit $$$1$$$ we ask $$$\{{2, 4\}}$$$, for bit       $$$2$$$ we ask $$$\{{1, 4\}}$$$ and for bit $$$3$$$ we ask       $$$\{{1, 2, 3\}}$$$. Let $$$x_0, x_1, x_2, x_3$$$ be bitwise OR of       these four subsets respectively. Then the elements of the password       are $$$x_0 \vee x_1$$$, $$$x_0 \vee x_2$$$, $$$x_1 \vee x_2$$$ and       $$$x_0 \vee x_3$$$ respectively.</p>     <p>What is the minimum number of bits we need to assign masks in       such a way?</p>     <p>We are given the bound of $$$13$$$ queries. There are $$$1716$$$       numbers upto $$$2^{13}$$$ which have $$$6$$$ bits set in their       binary representation. Clearly no two of these numbers would be       submaks of each other. So we can use them to assign the masks!</p>     <p>It can be shown using <a href="https://bit.ly/2XAUBoa">Sperner's       theorem</a> that we need at least $$$13$$$ queries to assign       submaks in the above manner.</p>     <p>Time complexity: $$$O(2^q + n \cdot q)$$$ where $$$q$$$ is the       number of queries asked.</p></div></div></div>

           
            <pre><code>
#include
using namespace std;

#define ll long long
#define vint vector&lt; int &gt;

const int Q = 13;

ll query(vint v){
	cout &lt;&lt; &#34;? &#34; &lt;&lt; v.size() &lt;&lt; &#39; &#39;;
	for(ll i : v)
		cout &lt;&lt; i + 1 &lt;&lt; &#39; &#39;;
	cout &lt;&lt; endl;
	fflush(stdout);
	ll or_value;
	cin &gt;&gt; or_value;
	return or_value;
}

int main(){
	int n;
	cin &gt;&gt; n;

	vector&lt; vint &gt; ask(Q);
	vint assign_mask(n);

	vector&lt; ll &gt; or_value(Q), answer(n);

	int assigned = 0;

	for(int i = 1; i &lt; (1 &lt;&lt; Q); i++){
		if(__builtin_popcount(i) != Q / 2)
			continue;
		assign_mask[assigned] = i;
		for(int j = 0; j &lt; Q; j++)
			if((i &gt;&gt; j &amp; 1) == 0)
				ask[j].push_back(assigned);
		assigned++;
		if(assigned == n)
			break;
	}

	for(int i = 0; i &lt; Q; i++)
		if(!ask[i].empty())
			or_value[i] = query(ask[i]);

	for(int i = 0; i &lt; n; i++)
		for(int j = 0; j &lt; Q; j++)
			if(assign_mask[i] &gt;&gt; j &amp; 1)
				answer[i] |= or_value[j];

	cout &lt;&lt; &#34;! &#34;;

	for(ll i : answer)
		cout &lt;&lt; i &lt;&lt; &#39; &#39;;

	cout &lt;&lt; endl;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 89 (рейтинговый для Див. 2)
    1366A
    Лопаты и мечи </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Лопаты и мечи</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Поликарп играет в известную компьютерную игру (мы не хотим       упоминать ее название). В этой игре он может создавать инструменты       двух видов — лопаты и мечи. На создание лопаты Поликарп тратит две       палки и один алмаз; на создание меча Поликарп тратит два алмаза и       одну палку.</p>     <p>Каждый инструмент может быть продан за один изумруд. Как много       изумрудов может заработать Поликарп, если у него есть $$$a$$$       палок и $$$b$$$ алмазов?</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит число $$$t$$$ ($$$1 \le t \le 1000$$$) —       количество наборов входных данных.</p>     <p>Единственная строка каждого набора входных данных содержит два       числа $$$a$$$ и $$$b$$$ ($$$0 \le a, b \le 10^9$$$) — количество       палок и алмазов соответственно.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>На каждый набор входных данных выведите число — максимальное       количество изумрудов, которое может заработать Поликарп.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
4 4
1000000000 0
7 15
8 7
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
0
7
5
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных Поликарп может заработать два       изумруда следующим образом: создать один меч и одну лопату.</p>     <p>Во втором наборе входных данных у Поликарпа нет алмазов, а       значит, он не сможет ничего создать.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1366/problem/A' title='Educational Codeforces Round 89 (Rated for Div. 2)'>1366A - Shovels and Swords</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>There are three constraints on the number of emeralds:</p>          <ol> <li> the number of emeralds can't be greater than $$$a$$$; </li>       <li> the number of emeralds can't be greater than $$$b$$$; </li>       <li> the number of emeralds can't be greater than         $$$\frac{a+b}{3}$$$. </li></ol>          <p>So the answer is $$$\min(a, b, \frac{a+b}{3})$$$.</p></div></div></div>

           
            <pre><code>for _ in range(int(input())):
    l, r = map(int, input().split())
    print(min(l, r, (l + r) // 3))
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 89 (рейтинговый для Див. 2)
    1366B
    Перемешивание </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Перемешивание</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам задан массив, состоящий из $$$n$$$ чисел $$$a_1$$$,       $$$a_2$$$, ..., $$$a_n$$$. Изначально $$$a_x = 1$$$, а остальные       элементы равны $$$0$$$.</p>     <p>Вы выполняете $$$m$$$ операций. Во время $$$i$$$-й операции вы       выбираете два индекса $$$c$$$ и $$$d$$$ таких, что $$$l_i \le c, d       \le r_i$$$, и меняете местами $$$a_c$$$ и $$$a_d$$$.</p>     <p>Посчитайте количество индексов $$$k$$$ таких, что существуют       возможность выбрать операции так, что в конце $$$a_k = 1$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит число $$$t$$$ ($$$1 \le t \le 100$$$) —       количество наборов входных данных. Затем следует описание каждого       из $$$t$$$ наборов входных данных.</p>     <p>Первая строка каждого набора входных данных содержит три целых       числа $$$n$$$, $$$x$$$ и $$$m$$$ ($$$1 \le n \le 10^9$$$; $$$1 \le       m \le 100$$$; $$$1 \le x \le n$$$).</p>     <p>Каждая из следующих $$$m$$$ строк содержит описание операций; а       именно — в $$$i$$$-й строке содержится два целых числа $$$l_i$$$ и       $$$r_i$$$ ($$$1 \le l_i \le r_i \le n$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>На каждый набор входных данных выведите одно число — количество       индексов $$$k$$$ таких, что существуют возможность выбрать       операции так, что в конце $$$a_k = 1$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
6 4 3
1 6
2 3
5 5
4 1 2
2 4
1 2
3 3 2
2 3
1 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
6
2
3
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных условие $$$a_k = 1$$$ выполняется       для любого $$$k$$$. Для этого, можно выполнить следующие операции:</p>          <ol> <li> поменять местами $$$a_k$$$ и $$$a_4$$$; </li>       <li> поменять местами $$$a_2$$$ и $$$a_2$$$; </li>       <li> поменять местами $$$a_5$$$ и $$$a_5$$$. </li></ol>          <p>Во втором наборе входных данных подходят только индексы $$$k =       1$$$ и $$$k = 2$$$. Для выполнения $$$a_1 = 1$$$, нужно поменять       местами $$$a_1$$$ и $$$a_1$$$ во второй операции. Для выполнения       $$$a_2 = 1$$$, нужно поменять местами $$$a_1$$$ и $$$a_2$$$ во       второй операции.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1366/problem/B' title='Educational Codeforces Round 89 (Rated for Div. 2)'>1366B - Shuffle</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's consider how the set of possible indices where the $$$1$$$       can be changes. Initially, only one index is correct — $$$x$$$.       After performing an operation $$$l, r$$$ such that $$$x &lt; l$$$       or $$$x &gt; r$$$ this set does not change. But after performing       an operation $$$l, r$$$ such that $$$l \le x \le r$$$ we should       insert the elements $$$\{l, l+1, l+2, \dots, r-1, r\}$$$ into this       set, if they are not present. </p>     <p>Now consider how the set $$$\{L, L+1, L+2, \dots, R-1, R\}$$$       changes. If segments $$$[l, r]$$$ and $$$[L, R]$$$ do not share       any indices, there are no changes — but if they do, the set turns       into $$$\{ \min(l, L), \min(l, L)+1, \min(l, L)+2, \dots, \max(r,       R)-1, \max(r, R) \}$$$.</p>     <p>So the set of reachable indices is always a segment of numbers,       and to process an operation, we should check whether the segment       from operation intersects with the segment of indices we have —       and if it is true, unite them.</p></div></div></div>

           
            <pre><code>for _ in range(int(input())):
    n, x, m = map(int, input().split())
    l, r = x, x
    for _ in range(m):
        L, R = map(int, input().split())
        if max(l, L) &lt;= min(r, R):
            l = min(l, L)
            r = max(r, R)
            
    print(r - l + 1)
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 89 (рейтинговый для Див. 2)
    1366C
    Палиндромные пути </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Палиндромные пути</div>     <div class="time-limit"><div class="property-title">ограничение по времени на       тест</div>1.5 секунд</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам задана матрица из $$$n$$$ строк (пронумерованных от $$$1$$$       до $$$n$$$) и $$$m$$$ столбцов (пронумерованных от $$$1$$$ до       $$$m$$$). Обозначим за $$$a_{i, j}$$$ число в клетке на       пересечении $$$i$$$-й строки и $$$j$$$-го столбца, каждое число       либо $$$0$$$, либо $$$1$$$.</p>     <p>Изначально в ячейке $$$(1, 1)$$$ находится фишка, которая будет       перемещена в ячейку $$$(n, m)$$$ при помощи последовательности       шагов. На каждом шаге фишка перемещается либо в ячейку справа от       текущей, либо в ячейку снизу (если фишка сейчас в ячейке $$$(x,       y)$$$, ее можно переместить либо в $$$(x + 1, y)$$$, либо в $$$(x,       y + 1)$$$). Фишка не может покидать матрицу.</p>     <p>Рассмотрим все пути фишки из ячейки $$$(1, 1)$$$ в ячейку $$$(n,       m)$$$. Назовем путь <span class="tex-font-style-it">палиндромным</span>, если число в первой       ячейке пути равно числу в последней ячейке пути, число во второй       ячейке равно числу в предпоследней ячейке, и так далее.</p>     <p>Ваша цель — заменить минимальное количество элементов матрицы       так, чтобы <span class="tex-font-style-bf">все</span> пути стали         <span class="tex-font-style-it">палиндромными</span>.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке задано одно целое число $$$t$$$ ($$$1 \le t \le       200$$$) — количество наборов входных данных.</p>     <p>В первой строке каждого набора заданы два целых числа $$$n$$$ и       $$$m$$$ ($$$2 \le n, m \le 30$$$) — размеры матрицы.</p>     <p>Затем следуют $$$n$$$ строк, $$$i$$$-я из которых содержит       $$$m$$$ целых чисел $$$a_{i, 1}$$$, $$$a_{i, 2}$$$, ..., $$$a_{i,       m}$$$ ($$$0 \le a_{i, j} \le 1$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите одно целое число —       минимальное количество элементов, которое надо заменить.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
2 2
1 1
0 1
2 3
1 1 0
1 0 0
3 7
1 0 1 1 1 1 1
0 0 0 0 0 0 0
1 1 1 1 1 0 1
3 5
1 0 1 0 0
1 1 1 1 0
0 0 1 0 0
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
3
4
4
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Итоговые матрицы в первых трех примерах:</p>          <center> $$$\begin{pmatrix} 1 &amp; 1\\ 0 &amp; 1 \end{pmatrix}$$$ </center>               <center> $$$\begin{pmatrix} 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0       \end{pmatrix}$$$ </center>               <center> $$$\begin{pmatrix} 1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp;       1 &amp; 1\\ 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0\\ 1       &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 \end{pmatrix}$$$ </center></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1366/problem/C' title='Educational Codeforces Round 89 (Rated for Div. 2)'>1366C - Palindromic Paths</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's group the cells by their distance from the starting point:       the group $$$0$$$ consists of a single cell $$$(1, 1)$$$; the       group $$$1$$$ consists of the cells $$$(1, 2)$$$ and $$$(2, 1)$$$,       and so on. In total, there are $$$n + m - 1$$$ groups.</p>     <p>Let's analyze the groups $$$k$$$ and $$$n + m - 2 - k$$$. There       are two cases:</p>          <ul> <li> if $$$k = 0$$$ or $$$n + m - 2 - k = 0$$$, then we are         looking at the starting cell and the ending cell, and their         contents should be equal; </li>       <li> otherwise, suppose two cells $$$(x, y)$$$ and $$$(x + 1, y -         1)$$$ belong to the same group. We can easily prove that the         contents of these two cells should be equal (for example, by         analyzing two paths that go through cell $$$(x + 1, y)$$$ and         coincide after this cell, but one goes to $$$(x + 1, y)$$$ from         $$$(x, y)$$$, and another — from $$$(x + 1, y - 1)$$$) — and,         using induction, we can prove that the contents of all cells in         a group should be equal. And since the paths should be         palindromic, the contents of the group $$$k$$$ should be equal         to the contents of the group $$$n + m - 2 - k$$$. </li></ul>          <p>So, in each pair of groups, we should calculate the number of       $$$1$$$'s and $$$0$$$'s, and choose which of them to change. Note       that if $$$n + m$$$ is even, the central group has no pair, so it       should not be modified.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

void solve()
{
	int n, m;
	cin &gt;&gt; n &gt;&gt; m;
	vector&lt;vector&lt;int&gt; &gt; a(n, vector&lt;int&gt;(m));
	for(int i = 0; i &lt; n; i++)
		for(int j = 0; j &lt; m; j++)
			cin &gt;&gt; a[i][j];
	vector&lt;vector&lt;int&gt; &gt; cnt(n + m - 1, vector&lt;int&gt;(2));
	for(int i = 0; i &lt; n; i++)
		for(int j = 0; j &lt; m; j++)
			cnt[i + j][a[i][j]]++;
	int ans = 0;
	for(int i = 0; i &lt;= n + m - 2; i++)
	{
		int j = n + m - 2 - i;
		if(i &lt;= j) continue;
		ans += min(cnt[i][0] + cnt[j][0], cnt[i][1] + cnt[j][1]);
	}
	cout &lt;&lt; ans &lt;&lt; endl;
}

int main() {
	int t;
	cin &gt;&gt; t;
	for(int i = 0; i &lt; t; i++)
		solve();
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 89 (рейтинговый для Див. 2)
    1366D
    Два делителя </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Два делителя</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам заданы $$$n$$$ целых чисел $$$a_1, a_2, \dots, a_n$$$.</p>     <p>Для каждого $$$a_i$$$ найдите <span class="tex-font-style-bf">два         его делителя</span> $$$d_1 &gt; 1$$$ и $$$d_2 &gt; 1$$$ такие,       что $$$\gcd(d_1 + d_2, a_i) = 1$$$ (где $$$\gcd(a, b)$$$ —       наибольший общий делитель $$$a$$$ и $$$b$$$) или скажите, что       такой пары нет.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке задано единственное целое число $$$n$$$ ($$$1 \le       n \le 5 \cdot 10^5$$$) — размер массива $$$a$$$.</p>     <p>Во второй строке заданы $$$n$$$ целых чисел $$$a_1, a_2, \dots,       a_n$$$ ($$$2 \le a_i \le 10^7$$$) — массив $$$a$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Ради ускорения вывода, выведите ответы в две строки по $$$n$$$       чисел в каждой.</p>     <p>В первой и второй строках $$$i$$$-ми по счету числами выведите       соответствующие делители $$$d_1 &gt; 1$$$ и $$$d_2 &gt; 1$$$       такие, что $$$\gcd(d_1 + d_2, a_i) = 1$$$ или $$$-1$$$ и $$$-1$$$,       если такой пары делителей нет. Если существует несколько       подходящих ответов, выведите любой из них.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
10
2 3 4 5 6 7 8 9 10 24
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
-1 -1 -1 -1 3 -1 -1 -1 2 2 
-1 -1 -1 -1 2 -1 -1 -1 5 3 
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Рассмотрим $$$a_7 = 8$$$. У него есть $$$3$$$ делителя больших,       чем $$$1$$$: $$$2$$$, $$$4$$$, $$$8$$$. Не сложно заметить, что       сумма любой пары делителей делится на $$$2$$$, также как и $$$a_7$$$.</p>     <p>Существуют и другие подходящие пары делителей $$$d_1$$$ и       $$$d_2$$$ для $$$a_{10}=24$$$, например, $$$(3, 4)$$$ или $$$(8,       3)$$$. Вы можете вывести любую из них.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1366/problem/D' title='Educational Codeforces Round 89 (Rated for Div. 2)'>1366D - Two Divisors</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Firstly, for the fast factorization of given $$$a_i$$$, let's use       Sieve of Eratosthenes: let's for each value $$$val \le 10^7$$$       calculate its minimum prime divisor $$$minDiv[val]$$$ in the same       manner as the sieve do. Now we can factorize each $$$a_i$$$ in       $$$O(\log{a_i})$$$ time by separating its prime divisors one by       one using precalculated array $$$minDiv$$$.</p>     <p>Suppose, we have a factorization $$$a_i = p_1^{s_1} p_2^{s_2}       \cdot \ldots \cdot p_k^{s_k}$$$. If $$$k = 1$$$ then any divisor       of $$$a_i$$$ is divisible by $$$p_1$$$ so do the sum of divisors.       Obviously, the answer is $$$-1$$$ $$$-1$$$.</p>     <p>Otherwise, we can divide all prime divisors $$$p_i$$$ into two       non-empty groups $$$\{p_1, p_2, \dots, p_x\}$$$ and $$$\{p_{x +       1}, \dots, p_k\}$$$ and take $$$d_1 = p_1 \cdot p_2 \cdot \ldots       \cdot p_x$$$ and $$$d_2 = p_{x + 1} \cdot \ldots \cdot p_k$$$. Any       division is valid (proof is below), so, for example, we can take       $$$d_1 = p_1$$$ and $$$d_2 = p_2 \cdot \ldots \cdot p_k$$$.</p>     <p>Let's prove that if $$$d_1 = p_1 \cdot p_2 \cdot \ldots \cdot       p_x$$$ and $$$d_2 = p_{x + 1} \cdot \ldots \cdot p_k$$$ then       $$$\gcd(d_1 + d_2, a_i) = 1$$$. Let's look at any $$$p_i$$$. We       can assume that $$$a_i \equiv 0 \mod p_i$$$ and (without loss of       generality) $$$d_1 \equiv 0 \mod p_i$$$. But it means that $$$d_2       \not\equiv 0 \mod p_i$$$, then $$$d_1 + d_2 \equiv 0 + d_2 \equiv       d_2 \not\equiv 0 \mod p_i$$$. In other words, there are no prime       divisor of $$$a_i$$$ which divides $$$d_1 + d_2$$$, so the       $$$\gcd(d_1 + d_2, a_i) = 1$$$.</p>     <p>Time complexity is $$$O(A \log{\log{A}} + n \log{A})$$$ for the       sieve and finding answers ($$$A \le 10^7$$$).</p></div></div></div>

           
            <pre><code>fun main() {
    val n = readLine()!!.toInt()
    val a = readLine()!!.split(&#39; &#39;).map { it.toInt() }

    val minDiv = IntArray(1e7.toInt() + 2) { it }
    for (i in 2 until minDiv.size) {
        if (minDiv[i] != i)
            continue
        for (j in i until minDiv.size step i)
            minDiv[j] = minOf(minDiv[j], i)
    }

    fun getPrimeDivisors(v: Int): ArrayList&lt;Int&gt; {
        val ans = ArrayList&lt;Int&gt;()
        var curVal = v
        while (curVal != 1) {
            if (ans.isEmpty() || ans.last() != minDiv[curVal])
                ans.add(minDiv[curVal])
            curVal /= minDiv[curVal]
        }
        return ans
    }

    val d1 = IntArray(n)
    val d2 = IntArray(n)
    for (id in a.indices) {
        val list = getPrimeDivisors(a[id])
        if (list.size &lt; 2) {
            d1[id] = -1
            d2[id] = -1
        } else {
            d1[id] = list[0]
            list.removeAt(0)
            d2[id] = list.reduce { s, t -&gt; s * t }
        }
    }
    println(d1.joinToString(&#34; &#34;))
    println(d2.joinToString(&#34; &#34;))
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 89 (рейтинговый для Див. 2)
    1366E
    Два массива </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. Два массива</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам даны два массива $$$a_1, a_2, \dots , a_n$$$ и $$$b_1, b_2,       \dots , b_m$$$. Массив $$$b$$$ отсортирован в порядке возрастания       ($$$b_i &lt; b_{i + 1}$$$ верно для любого $$$i$$$ от $$$1$$$ до       $$$m - 1$$$).</p>     <p>Вам нужно разбить массив $$$a$$$ на $$$m$$$ непрерывных       подмассивов так, чтобы для всех $$$i$$$ от $$$1$$$ до $$$m$$$       минимум в $$$i$$$-м подмассиве был равен $$$b_i$$$. Обратите       внимание, что каждый элемент должен принадлежать ровно одному       подмассиву, и они формируются следующим образом: первые несколько       элементов массива $$$a$$$ принадлежат первому подмассиву,       следующие несколько элементов массива $$$a$$$ принадлежат второму       подмассиву, и так далее.</p>     <p>Например, если $$$a = [12, 10, 20, 20, 25, 30]$$$, а $$$b = [10,       20, 30]$$$, то существует два подходящих разбиения массива       $$$a$$$: </p>     <ol> <li> $$$[12, 10, 20], [20, 25], [30]$$$; </li>       <li> $$$[12, 10], [20, 20, 25], [30]$$$. </li></ol>          <p>Вам нужно посчитать количество хороших разбиений массива $$$a$$$.       Так как это значение может быть слишком велико — выведите его по       модулю <span class="tex-font-style-tt">998244353</span>.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит два числа $$$n$$$ и $$$m$$$ ($$$1 \le n, m       \le 2 \cdot 10^5$$$) — длины массивов $$$a$$$ и $$$b$$$ соответственно.</p>     <p>Вторая строка содержит $$$n$$$ чисел $$$a_1, a_2, \dots , a_n$$$       ($$$1 \le a_i \le 10^9$$$) — массив $$$a$$$.</p>     <p>Третья строка содержит $$$m$$$ чисел $$$b_1, b_2, \dots , b_m$$$       ($$$1 \le b_i \le 10^9; b_i &lt; b_{i+1}$$$) — массив $$$b$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>В единственной строке выведите число — количество хороших       разбиений массива $$$a$$$ по модулю <span class="tex-font-style-tt">998244353</span>.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6 3
12 10 20 20 25 30
10 20 30
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
4 2
1 3 3 7
3 7
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
8 2
1 2 2 2 2 2 2 2
1 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
7
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1366/problem/E' title='Educational Codeforces Round 89 (Rated for Div. 2)'>1366E - Two Arrays</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>At first, let's reverse arrays $$$a$$$ and $$$b$$$. Now array       $$$b$$$ is sorted in descending order.</p>     <p>Now let's find minimum index $$$x$$$ such that $$$a_x = b_1$$$.       If there is no such index or if $$$\min\limits_{1 \le i \le x}a_i       &lt; b_1$$$ then the answer is $$$0$$$ (because minimum on any       prefix of array $$$a$$$ will never be equal to $$$b_1$$$).</p>     <p>Otherwise, let's find the minimum index $$$y &gt; x$$$ such that       $$$a_y = b_2$$$. If there is no such index or if $$$\min\limits_{x       \le i \le y}a_i &lt; b_2$$$ then the answer is $$$0$$$. Also let's       find the minimum index $$$mid &gt; x$$$ such that $$$a_{mid} &lt;       b_1$$$ (it can't be greater than $$$y$$$). The first subarray       starts in position $$$1$$$ and ends in any position $$$x, x + 1, x       + 2, \dots, mid - 1$$$ (because if it ends in position $$$mid$$$       or further, then the minimum in the first subarray is greater than       $$$b_1$$$). So there are $$$mid - x$$$ ways to split subarrays       $$$1$$$ and $$$2$$$.</p>     <p>A similar approach can be used to calculate the number of ways to       split the second and third subarrays and, so on.</p>     <p>After all, you have to check that minimum in the last subarray is       equal to $$$b_m$$$ (otherwise the answer is $$$0$$$).</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

const int N = 200005;
const int MOD = 998244353;

int mul(int a, int b) {
    return (a * 1LL * b) % MOD;
}

int n, m;
int a[N], b[N];

int main() {	
    scanf(&#34;%d %d&#34;, &amp;n, &amp;m);
    for (int i = 0; i &lt; n; ++i) scanf(&#34;%d&#34;, a + i);
    for (int i = 0; i &lt; m; ++i) scanf(&#34;%d&#34;, b + i);
    
    reverse(a, a + n);
    reverse(b, b + m);
    a[n] = -1;
    
    int mn = a[0];
    int pos = 0;
    while (pos &lt; n &amp;&amp; mn &gt; b[0]) {
        ++pos;
        mn = min(mn, a[pos]);
    }
    
    if (pos == n || mn &lt; b[0]) {
       puts(&#34;0&#34;);
       return 0;
    }
    
    assert(mn == b[0]);
    int res = 1;
    int ib = 0;
    while (true) {
        assert(mn == b[ib]);
        if (ib == m - 1){
            if(*min_element(a + pos, a + n) != b[ib]) {
               puts(&#34;0&#34;);
               return 0;
            }
            break;
        }
        
        bool f = true;
        int npos = pos;
        while (npos &lt; n &amp;&amp; mn != b[ib + 1]) {
            ++npos;
            mn = min(mn, a[npos]);
            
            if (f &amp;&amp; mn &lt; b[ib]){
                f = false;
                res = mul(res, npos - pos);
            }
        }
        
        if (npos == n || mn != b[ib + 1]) {
            puts(&#34;0&#34;);
            return 0;
        }
        
        ++ib;
        pos = npos;
    }
    
    printf(&#34;%d\n&#34;, res);
    return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 89 (рейтинговый для Див. 2)
    1366F
    Прогулка по графу </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Прогулка по графу</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Задан простой взвешенный связный неориентированный граф,       состоящий из $$$n$$$ вершин и $$$m$$$ ребер.</p>     <p>Путем длины $$$k$$$ в графе назовем последовательность из       $$$k+1$$$ вершины $$$v_1, v_2, \dots, v_{k+1}$$$ такую, что для       каждого $$$i$$$ $$$(1 \le i \le k)$$$ ребро $$$(v_i, v_{i+1})$$$       присутствует в графе. У пути из вершины $$$v$$$ вершина       $$$v_1=v$$$. Обратите внимание, что вершины и ребра могут входить       в путь по несколько раз.</p>     <p>Вес пути — это сумма весов ребер в нем.</p>     <p>Для каждого $$$i$$$ от $$$1$$$ до $$$q$$$ рассмотрим путь из       вершины $$$1$$$ длины $$$i$$$ максимального веса. Чему равна сумма       весов этих $$$q$$$ путей?</p>     <p>Ответ может быть довольно большим, поэтому выведите его по модулю $$$10^9+7$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записаны три целых числа $$$n$$$, $$$m$$$,       $$$q$$$ ($$$2 \le n \le 2000$$$; $$$n - 1 \le m \le 2000$$$; $$$m       \le q \le 10^9$$$) — количество вершин в графе, количество ребер в       графе и количество длин, которые надо учесть в ответе.</p>     <p>В каждой из следующих $$$m$$$ строк задано описание ребра: три       целых числа $$$v$$$, $$$u$$$, $$$w$$$ ($$$1 \le v, u \le n$$$;       $$$1 \le w \le 10^6$$$) — две вершины $$$v$$$ и $$$u$$$ соединены       неориентированным ребром веса $$$w$$$. Граф не содержит петель и       кратных ребер. Гарантируется, что данные ребра задают связный граф.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одно целое число — сумма весов путей максимального веса       из вершины $$$1$$$ длин $$$1, 2, \dots, q$$$ по модулю $$$10^9+7$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
7 8 25
1 2 1
2 3 10
3 4 2
1 5 2
5 6 7
6 4 15
5 3 1
1 7 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
4361
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
2 1 5
1 2 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
60
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
15 15 23
13 10 12
11 14 12
2 15 5
4 10 8
10 2 4
10 7 5
3 10 1
5 6 11
1 13 8
9 15 4
4 2 9
11 15 1
11 12 14
10 8 12
3 6 11
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3250
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5 10 10000000
2 4 798
1 5 824
5 2 558
4 1 288
3 4 1890
3 1 134
2 3 1485
4 5 284
3 5 1025
1 2 649
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
768500592
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Граф из первого примера:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/0ce6768b978fc39d22fac54ee93fa405336ccdf7.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>Некоторые максимальные пути: </p>     <ul> <li> длина $$$1$$$: ребра $$$(1, 7)$$$ — вес $$$3$$$; </li>       <li> длина $$$2$$$: ребра $$$(1, 2), (2, 3)$$$ — вес         $$$1+10=11$$$; </li>       <li> длина $$$3$$$: ребра $$$(1, 5), (5, 6), (6, 4)$$$ — вес         $$$2+7+15=24$$$; </li>       <li> длина $$$4$$$: ребра $$$(1, 5), (5, 6), (6, 4), (6, 4)$$$ —         вес $$$2+7+15+15=39$$$; </li>       <li> $$$\dots$$$ </li></ul>          <p>Поэтому ответ — это сумма $$$25$$$ слагаемых: $$$3+11+24+39+\dots$$$</p>     <p>Во втором примере веса у путей максимального веса равны $$$4$$$,       $$$8$$$, $$$12$$$, $$$16$$$ and $$$20$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1366/problem/F' title='Educational Codeforces Round 89 (Rated for Div. 2)'>1366F - Jog Around The Graph</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's observe what does the maximum weight of some fixed length       path look like. Among the edges on that path the last one has the       maximum weight. If it wasn't then the better total weight could be       achieved by choosing a bigger weight edge earlier and going back       and forth on it for the same number of steps. It actually helps us       arrive to a conclusion that all optimal paths look like that: some       simple path to an edge and then back and forth movement on it.</p>     <p>Any simple path in the graph has its length at most $$$m$$$.       Let's separate the queries into two parts.</p>     <p>$$$k &lt; m$$$ will be handled in a straightforward manner. Let       $$$dp[v][k]$$$ be the maximum weight of a path that ends in       $$$v$$$ and has exactly $$$k$$$ edges in it. That's pretty easy to       calculate in $$$(n+m) \cdot m$$$.</p>     <p>You can also think of this $$$dp$$$ as some kind of Ford-Bellman       algorithm — let $$$d_v$$$ on the $$$k$$$-th step be the maximum       weight of the path to $$$v$$$ of length $$$k$$$. Iterate over all       edges and try to update $$$d_v$$$ and $$$d_u$$$ for each edge       $$$(v, u)$$$ (that's what I do in my solution if you refer to it).</p>     <p>Now for $$$k \ge m$$$. There was a very common assumption that       after a bit more steps some edge will become the most optimal and       will stay the most optimal until the end of time. However, that       &quot;a bit&quot; cut-off is in fact too high to rely on (it must       be somewhere around $$$n \cdot max_w$$$).</p>     <p>So the best path of length exactly $$$m$$$ ending in each vertex       $$$v$$$ is $$$dp[v][m]$$$. Let the maximum weight adjacent edge to       vertex $$$v$$$ be $$$mx_v$$$. So the path of length $$$k$$$ will       have weight $$$mx_v \cdot (k - m) + dp[v][m]$$$. Treat it like a       line $$$kx + b$$$ with coefficients $$$mx_v$$$ and $$$dp[v][m]$$$.</p>     <p>How do determine which line is the best for some $$$k$$$? Sure,       experienced participants will immediately answer &quot;convex       hull&quot;. Build a lower envelope of the convex hull of these       lines. If $$$q$$$ was a little smaller than we could query with       binary search for each $$$k$$$, the same how convex hull is       usually used. </p>     <p>We have to examine the hull further. Each line in it becomes the       best in some point, then stays the best for some interval and then       never appears the best again. What are these line changing points?       Well, it's just the intersection point of the adjacent lines in       the hull. So having these points and the parameters of the line we       can calculate its contribution to the answer with a sum of       arithmetic progression formula.</p>     <p>There were just $$$n$$$ lines in the hull so you can build the       hull in any complexity, I think I saw up to $$$O(n^2 \log n)$$$       performances in the participants codes.</p>     <p>There is a cool solution that involves some kind of       Divide&amp;Conquer on these lines. I personally thought of it in a       sense of traversing a Li-Chao tree without actually building it.       If anyone wants to explain this solution, feel free to do it in comments.</p>     <p>Overall complexity: $$$O((n+m) \cdot m + n \log n)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

#define forn(i, n) for (int i = 0; i &lt; int(n); i++)

using namespace std;

const long long INF = 1e18;
const int MOD = 1000&#39;000&#39;007;
const int inv2 = (MOD + 1) / 2;

struct edge{
	int v, u, w;
};

struct frac{
	long long x, y;
	frac(long long a, long long b){
		if (b &lt; 0) a = -a, b = -b;
		x = a, y = b;
	}
};

bool operator &lt;=(const frac &amp;a, const frac &amp;b){
	return a.x * b.y &lt;= a.y * b.x;
}

struct line{
	long long m, c;
	frac intersectX(const line &amp;l) { return frac(c - l.c, l.m - m); }
};

int add(int a, int b){
	a += b;
	if (a &gt;= MOD)
		a -= MOD;
	if (a &lt; 0)
		a += MOD;
	return a;
}

int mul(int a, int b){
	return a * 1ll * b % MOD;
}

int calc(int a1, int d, int n){
	assert(n &gt;= 0);
	return mul(mul(n, inv2), add(mul(2, a1), mul(add(n, -1), d)));
}

int main() {
	int n, m;
	long long q;
	scanf(&#34;%d%d%lld&#34;, &amp;n, &amp;m, &amp;q);
	vector&lt;edge&gt; e(m);
	vector&lt;int&gt; hv(n);
	forn(i, m){
		scanf(&#34;%d%d%d&#34;, &amp;e[i].v, &amp;e[i].u, &amp;e[i].w);
		--e[i].v, --e[i].u;
		hv[e[i].v] = max(hv[e[i].v], e[i].w);
		hv[e[i].u] = max(hv[e[i].u], e[i].w);
	}
	
	int ans = 0;
	vector&lt;long long&gt; d(n, -INF), nd(n);
	d[0] = 0;
	forn(val, m){
		long long mx = 0;
		forn(i, n)
			mx = max(mx, d[i]);
		if (val)
			ans = add(ans, mx % MOD);
		nd = d;
		forn(i, m){
			nd[e[i].v] = max(nd[e[i].v], d[e[i].u] + e[i].w);
			nd[e[i].u] = max(nd[e[i].u], d[e[i].v] + e[i].w);
		}
		d = nd;
	}
	
	vector&lt;line&gt; fin;
	forn(i, n) fin.push_back({hv[i], d[i]});
	sort(fin.begin(), fin.end(), [](const line &amp;a, const line &amp;b){
		if (a.m != b.m)
			return a.m &lt; b.m;
		return a.c &gt; b.c;
	});
	fin.resize(unique(fin.begin(), fin.end(), [](const line &amp;a, const line &amp;b){
		return a.m == b.m;
	}) - fin.begin());
	
	vector&lt;line&gt; ch;
	for (auto cur : fin){
		while (ch.size() &gt;= 2 &amp;&amp; cur.intersectX(ch.back()) &lt;= ch.back().intersectX(ch[int(ch.size()) - 2]))
			ch.pop_back();
		ch.push_back(cur);
	}
	
	long long prv = 0;
	q -= m;
	forn(i, int(ch.size()) - 1){
		frac f = ch[i].intersectX(ch[i + 1]);
		if (f.x &lt; 0) continue;
		long long lst = min(q, f.x / f.y);
		if (lst &lt; prv) continue;
		ans = add(ans, calc((ch[i].c + ch[i].m * prv) % MOD, ch[i].m % MOD, lst - prv + 1));
		prv = lst + 1;
	}
	ans = add(ans, calc((ch.back().c + ch.back().m * prv) % MOD, ch.back().m % MOD, q - prv + 1));
	
	printf(&#34;%d\n&#34;, ans);
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 89 (рейтинговый для Див. 2)
    1366G
    Построй строку </h1>

    <div class="problemindexholder" problemindex="G">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">G. Построй строку</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>4 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Определим функцию $$$f(s)$$$, которая принимает строку $$$s$$$,       состоящую из строчных латинских букв и точек, и возвращает строку,       состоящую из строчных латинских букв следующим образом:</p>          <ol> <li> пусть $$$r$$$ пустая строка; </li>       <li> будем обрабатывать символы $$$s$$$ слева направо. Для каждого         символа $$$c$$$ выполним следующее: если $$$c$$$ является         строчной латинской буквой, то добавим $$$c$$$ в конец строки         $$$r$$$; в противном случае удалим последний символ из $$$r$$$         (если $$$r$$$ пустая — функция аварийно завершает работу); </li>       <li> вернуть $$$r$$$ как результат функции. </li></ol>          <p>Вам заданы две строки $$$s$$$ и $$$t$$$. Вы должны удалить       минимально возможное количество символов из $$$s$$$, чтобы $$$f(s)       = t$$$ (и функция не завершалась аварийно). Обратите внимание, что       вам не разрешается вставлять новые символы в $$$s$$$ или менять       порядок существующих.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Входные данные состоят из двух строк: первая содержит $$$s$$$ —       строку, состоящую из строчных латинских букв и точек, вторая       содержит $$$t$$$ — строку, состоящую из строчных латинских букв       ($$$1 \le |t| \le |s| \le 10000$$$).</p>     <p>Дополнительное ограничение на входные данные: можно удалить       некоторое количество символов из $$$s$$$ так, чтобы $$$f(s) = t$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одно целое число — минимально возможное количество       символов, которое необходимо удалить из $$$s$$$, чтобы $$$f(s)$$$       не завершалась аварийно и вернула $$$t$$$ в качестве результата выполнения.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
a.ba.b.
abb
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
.bbac..a.c.cd
bacd
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
c..code..c...o.d.de
code
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1366/problem/G' title='Educational Codeforces Round 89 (Rated for Div. 2)'>1366G - Construct the String</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>The core idea of the solution is the following dynamic       programming: $$$dp_{i, j}$$$ is the minimum number of characters       we have to delete if we considered a subsequence of $$$i$$$ first       characters of $$$s$$$, and it maps to $$$j$$$ first characters of $$$t$$$.</p>     <p>There are three obvious transitions in this dynamic programming:</p>          <ul> <li> we can go from $$$dp_{i, j}$$$ to $$$dp_{i + 1, j}$$$ by         skipping $$$s_i$$$; </li>       <li> if $$$s_i = t_j$$$, we can go from $$$dp_{i, j}$$$ to         $$$dp_{i + 1, j + 1}$$$; </li>       <li> if $$$s_i$$$ is a dot, we can go from $$$dp_{i, j}$$$ to         $$$dp_{i + 1, j - 1}$$$. </li></ul>          <p>Unfortunately, these transitions cannot fully handle the case       when we want to put some character and then delete it (these       transitions don't allow us to do it for any character, only for       some specific ones in specific situations). To handle it, suppose       we want to take the character $$$s_i$$$ and then delete it, and we       model it as follows: there exists the fourth transition from       $$$dp_{i,j}$$$ to $$$dp_{i+len_i, j}$$$ without deleting anything,       where $$$len_i$$$ is the length of the shortest substring of       $$$s$$$ starting from $$$i$$$ that becomes empty if we apply the       function $$$f$$$ to it. This substring can be described as a       regular bracket sequence, where opening brackets correspond to       letters, and closing brackets — to dots. We can precalculate this       substring for each $$$i$$$ in $$$O(n)$$$.</p>     <p>Why is this transition enough? Suppose we don't want to take some       letter from this shortest substring in the optimal answer; since       it is the shortest substring meeting these constraints, the number       of letters on each prefix of it (excluding the substring itself)       is greater than the number of dots, so we can instead skip the       first letter and try applying this transition from $$$dp_{i + 1,       j}$$$, so this case is handled. And skipping any dots from this       shortest substring is also suboptimal since we have to get rid of       the character $$$s_i$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

#define x first
#define y second
#define mp make_pair
#define pb push_back
#define sz(a) int((a).size())
#define forn(i, n) for (int i = 0; i &lt; int(n); ++i)
#define fore(i, l, r) for (int i = int(l); i &lt; int(r); ++i)

const int INF = 1e9;
const int N = 10010;

int n, m;
string s, t;
int dp[N][N];
int nxt[N];

int main() {
	cin &gt;&gt; s &gt;&gt; t;
	n = sz(s), m = sz(t);
	
	forn(i, n) if (s[i] != &#39;.&#39;) {
		int bal = 0;
		nxt[i] = -1;
		fore(j, i, n) {
			if (s[j] == &#39;.&#39;) --bal;
			else ++bal;
			if (bal == 0) {
				nxt[i] = j;
				break;
			}
		}
	}
	
	forn(i, n + 1) forn(j, m + 1)
		dp[i][j] = INF;
	dp[0][0] = 0;
	
	forn(i, n) forn(j, m + 1) {
		dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + 1);
		if (j &lt; m &amp;&amp; s[i] == t[j])
			dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j]);
		if (s[i] != &#39;.&#39; &amp;&amp; nxt[i] != -1)
			dp[nxt[i] + 1][j] = min(dp[nxt[i] + 1][j], dp[i][j]);
	}
	
	cout &lt;&lt; dp[n][m] &lt;&lt; endl;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #650 (Div. 3)
    1367A
    Короткие подстроки </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Короткие подстроки</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Алиса отгадывает строки, которые загадал ей Боб.</p>     <p>Сначала Боб придумал придумал секретную строку $$$a$$$, состоящую       из строчных букв латинского алфавита. Строка $$$a$$$ имеет длину       $$$2$$$ или более символов. Затем по строке $$$a$$$ он строит       новую строку $$$b$$$ и даёт Алисе строку $$$b$$$, чтобы она могла       угадать строку $$$a$$$.</p>     <p>Боб строит $$$b$$$ по $$$a$$$ следующим образом: он выписывает       все подстроки длины $$$2$$$ строки $$$a$$$ в порядке слева       направо, а потом соединяет их в том же порядке в строку $$$b$$$.</p>     <p>Например, если Боб загадал строку $$$a$$$=«<span class="tex-font-style-tt">abac</span>», то все подстроки длины       $$$2$$$ строки $$$a$$$ таковы: «<span class="tex-font-style-tt">ab</span>», «<span class="tex-font-style-tt">ba</span>», «<span class="tex-font-style-tt">ac</span>». Следовательно, строка         $$$b$$$=«<span class="tex-font-style-tt">abbaac</span>».</p>     <p>Вам задана строка $$$b$$$. Помогите Алисе определить строку       $$$a$$$, которую загадал Боб. Гарантируется, что $$$b$$$ была       построена по алгоритму, приведенному выше. Можно доказать, что       ответ на задачу единственный.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке находится одно целое положительное число $$$t$$$       ($$$1 \le t \le 1000$$$) — количество наборов тестовых данных в       тесте. Далее следуют $$$t$$$ наборов тестовых данных.</p>     <p>Каждый набор тестовых данных состоит из одной строки, в которой       записана строка $$$b$$$, состоящая из строчных букв латинского       алфавита ($$$2 \le |b| \le 100$$$) — строка, которую загадал Боб,       где $$$|b|$$$ — длина строки $$$b$$$. Гарантируется, что $$$b$$$       была построена по алгоритму, приведенному выше.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$t$$$ ответов на наборы тестовых данных. Каждый       ответ — это строка $$$a$$$, состоящая из строчных букв латинского       алфавита, которую загадал Боб.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
abbaac
ac
bccddaaf
zzzzzzzzzz
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
abac
ac
bcdaf
zzzzzz
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Первый набор тестовых данных разобран в условии.</p>     <p>Во втором наборе тестовых данных Боб загадал строку         $$$a$$$=«<span class="tex-font-style-tt">ac</span>», строка       $$$a$$$ имеет длину $$$2$$$, поэтому строка $$$b$$$ совпадает со       строкой $$$a$$$.</p>     <p>В третьем наборе тестовых данных Боб загадал строку         $$$a$$$=«<span class="tex-font-style-tt">bcdaf</span>»,       подстроки длины $$$2$$$ строки $$$a$$$ таковы: «<span class="tex-font-style-tt">bc</span>», «<span class="tex-font-style-tt">cd</span>», «<span class="tex-font-style-tt">da</span>», «<span class="tex-font-style-tt">af</span>», поэтому строка         $$$b$$$=«<span class="tex-font-style-tt">bccddaaf</span>».</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1367/problem/A' title='Codeforces Round 650 (Div. 3)'>1367A - Short Substrings</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Note that the first two characters of $$$a$$$ match the first two       characters of $$$b$$$. The third character of the string $$$b$$$       again matches the second character of $$$a$$$ (since it is the       first character in the second substring, which contains the second       and the third character of $$$a$$$). The fourth character $$$b$$$       matches with the third character of $$$a$$$.</p>     <p>It is easy to notice that such a pattern continues further. That       is, the string $$$a$$$ consists of the first character $$$b$$$ and       all characters at even positions in $$$b$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
	int t;
	cin &gt;&gt; t;

	for (int test = 1; test &lt;= t; test++) {
		string b;
		cin &gt;&gt; b;

		string a = b.substr(0, 2);

		for (int i = 3; i &lt; b.size(); i += 2) {
			a += b[i];
		}

		cout &lt;&lt; a &lt;&lt; endl;
	}

	return 0;
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #650 (Div. 3)
    1367B
    Четный массив </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Четный массив</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам дан массив $$$a[0 \ldots n-1]$$$ длины $$$n$$$, который       состоит из неотрицательных целых чисел. <span class="tex-font-style-bf">Обратите внимание: массив нумеруется с нуля.</span></p>     <p>Назовём массив <span class="tex-font-style-it">хорошим</span>,       если четность каждой позиции совпадает с четностью элемента в ней.       Более формально, массив является хорошим, если для всех $$$i$$$       ($$$0 \le i \le n - 1$$$) выполнено равенство $$$i \bmod 2 = a[i]       \bmod 2$$$, где $$$x \bmod 2$$$ — остаток от деления $$$x$$$ на 2.</p>     <p>Например, массивы [$$$0, 5, 2, 1$$$] и [$$$0, 17, 0, 3$$$] —       хорошие, а массив [$$$2, 4, 6, 7$$$] — плохой, потому что для       $$$i=1$$$ четность $$$i$$$ и $$$a[i]$$$ различна: $$$i \bmod 2 = 1       \bmod 2 = 1$$$, но $$$a[i] \bmod 2 = 4 \bmod 2 = 0$$$.</p>     <p>За один ход вы можете взять <span class="tex-font-style-bf">любые</span> два элемента массива и       поменять их местами (эти элементы не обязательно соседние).</p>     <p>Найдите минимальное количество ходов, за которое можно сделать       массив $$$a$$$ хорошим, либо укажите, что это сделать невозможно. </p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$t$$$ ($$$1 \le t \le       1000$$$) — количество наборов тестовых данных в тесте. Далее       следуют $$$t$$$ наборов тестовых данных.</p>     <p>Каждый набор начинается со строки, в которой записано целое число       $$$n$$$ ($$$1 \le n \le 40$$$) — размер массива $$$a$$$.</p>     <p>Далее следует строка, содержащая $$$n$$$ целых чисел $$$a_0, a_1,       \ldots, a_{n-1}$$$ ($$$0 \le a_i \le 1000$$$) — исходный массив.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите одно целое число —       минимальное количество ходов, за которое можно сделать заданный       массив $$$a$$$ хорошим, или <span class="tex-font-style-tt">-1</span>, если это сделать невозможно.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
4
3 2 7 6
3
3 2 6
1
7
7
4 9 2 1 18 3 0
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
1
-1
0
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе тестовых данных в первый ход можно поменять       местами элементы на позициях $$$0$$$ и $$$1$$$, а во второй ход       поменять местами элементы на позициях $$$2$$$ и $$$3$$$.</p>     <p>Во втором наборе тестовых данных в первый ход надо поменять       местами элементы на позициях $$$0$$$ и $$$1$$$.</p>     <p>В третьем наборе тестовых данных нельзя сделать массив хорошим.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1367/problem/B' title='Codeforces Round 650 (Div. 3)'>1367B - Even Array</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>We split all the positions in which the parity of the index does       not match with the parity of the element into two arrays. If there       is an odd number in the even index, add this index to the $$$e$$$       array. Otherwise, if there is an even number in the odd index, add       this index to the $$$o$$$ array. Note that if the sizes of the       $$$o$$$ and $$$e$$$ arrays are not equal, then there is no answer.       Otherwise, the array $$$a$$$ can be made <span class="tex-font-style-it">good</span> by doing exactly $$$|o|$$$       operations by simply swapping all the elements in the $$$o$$$ and       $$$e$$$ arrays.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;
using ld = long double;
using ll = long long;

void solve() {
    int n;
    cin &gt;&gt; n;
    int a = 0, b = 0;
    for (int i = 0; i &lt; n; i++) {
        int x;
        cin &gt;&gt; x;
        if (x % 2 != i % 2) {
            if (i % 2 == 0) {
                a++;
            } else {
                b++;
            }
        }
    }
    if (a != b) {
        cout &lt;&lt; -1 &lt;&lt; endl;
    } else {
        cout &lt;&lt; a &lt;&lt; endl;
    }
}

int main() {
    int n;
    cin &gt;&gt; n;
    while (n--) {
        solve();
    }
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #650 (Div. 3)
    1367C
    Социальная дистанция </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Социальная дистанция</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Поликарп с друзьями хочет сходить в новый ресторан. Ресторан       представляет из себя $$$n$$$ столиков, расставленных вдоль прямой.       За некоторыми столиками уже сидят люди. Столики пронумерованы от       $$$1$$$ до $$$n$$$ в порядке слева направо. Состояние ресторана       описывается строкой длины $$$n$$$, которая содержит символы '<span class="tex-font-style-tt">1</span>' (столик занят) и '<span class="tex-font-style-tt">0</span>' (столик свободен).</p>     <p>Правила ресторана запрещают людям садиться на расстоянии $$$k$$$       или меньше друг от друга. То есть, если человек сидит за столиком       номер $$$i$$$, то все столики с номерами от $$$i-k$$$ до $$$i+k$$$       (кроме $$$i$$$-го) должны быть свободны. Иными словами, разница       (то есть модуль разности) номеров между любыми двумя занятыми       столиками должна быть строго больше $$$k$$$.</p>     <p>Например, если $$$n=8$$$ и $$$k=2$$$, то:</p>          <ul> <li> строки «<span class="tex-font-style-tt">10010001</span>»,           «<span class="tex-font-style-tt">10000010</span>», «<span class="tex-font-style-tt">00000000</span>», «<span class="tex-font-style-tt">00100000</span>» соответствуют         правилам ресторана; </li>       <li> строки «<span class="tex-font-style-tt">10100100</span>»,           «<span class="tex-font-style-tt">10011001</span>», «<span class="tex-font-style-tt">11111111</span>» не соответствуют         правилам ресторана, так как в каждой из них есть пара единиц на         расстоянии меньшем или равном $$$k=2$$$. </li></ul>          <p>В частности, если состояние ресторана описывается строкой без       единиц или строкой с одной единицей, то требование ресторана выполнено.</p>     <p>Вам задана бинарная строка $$$s$$$, которая описывает текущее       состояние ресторана. Гарантируется, что для строки $$$s$$$ правила       ресторана выполнены.</p>     <p>Найдите максимальное количество свободных столиков, которые можно       занять, чтобы не нарушить правила ресторана. Формально, какое       максимальное количество нулей можно заменить на единицы так, что       требование все еще будет выполняться?</p>     <p>Например, если $$$n=6$$$, $$$k=1$$$, $$$s=$$$ «<span class="tex-font-style-tt">100010</span>», то ответ на задачу будет       $$$1$$$, так как есть только один свободный столик на позиции       $$$3$$$, который можно занять в соответствии с правилами ресторана.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$t$$$ ($$$1 \le t \le       10^4$$$) — количество наборов тестовых данных в тесте. Далее       следуют $$$t$$$ наборов тестовых данных.</p>     <p>Каждый набор начинается со строки, в которой записано два целых       числа $$$n$$$ и $$$k$$$ ($$$1 \le k \le n \le 2\cdot 10^5$$$) —       количество столиков в ресторане и минимальное разрешенное       расстояние между двумя людьми.</p>     <p>Во второй строке каждого набора записана строка $$$s$$$ длины       $$$n$$$, состоящая из нулей и единиц — описание свободных и       занятых столиков в ресторане. Заданная строка соответствует       правилам ресторана — разница индексов между любыми двумя единицами       строго больше $$$k$$$.</p>     <p>Сумма $$$n$$$ по всем наборам тестовых данных в одном тесте не       превосходит $$$2\cdot 10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого тестового набора выведите одно целое число —       количество столиков, которые можно дополнительно занять, чтобы не       нарушить правила ресторана. Если дополнительных столиков занять       нельзя, то, очевидно, надо вывести $$$0$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
6 1
100010
6 2
000000
5 1
10101
3 1
001
2 2
00
1 1
0
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
2
0
1
1
1
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Первый набор тестовых данных разобран в условии.</p>     <p>Во втором наборе тестовых данных ответ $$$2$$$, так как можно       выбрать первый и шестой столики.</p>     <p>В третьем наборе тестовых данных нельзя занять никакой свободный       столик, не нарушив правила ресторана.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1367/problem/C' title='Codeforces Round 650 (Div. 3)'>1367C - Social Distance</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's split a given string into blocks of consecutive zeros. Then       in each such block, you can independently put the maximum number       of people who fit in it. But there are three cases to consider. </p>     <ul> <li> If the current block is not the first and not the last,         then there are ones at the border and this means that the first         $$$k$$$ tables of the current block and the last $$$k$$$ are         prohibited. Therefore, remove these zeroes from the string. </li>       <li> If the current block is the first, then the one is at the end         and you need to delete the last $$$k$$$ zeros. </li>       <li> If the current block is the last, then in the beginning there         is one and you need to delete the first $$$k$$$ zeros.     </li></ul> Also, as a separate case, you need to consider — a string     consisting only of zeros. Then there is exactly one block from which     you do not need to remove zeros.     <p>Now all the tables in each block are free, then in each block we       can put $$$\lfloor \frac{\text{number of zeros}}{k} \rfloor$$$.       Sum these values over all blocks.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
	int t;
	cin &gt;&gt; t;

	for (int test = 1; test &lt;= t; test++) {
		int n, k;
		cin &gt;&gt; n &gt;&gt; k;
		string s;
		cin &gt;&gt; s;

		int res = 0;

		for (int i = 0; i &lt; n;) {
			int j = i + 1;

			for (; j &lt; n &amp;&amp; s[j] != &#39;1&#39;; j++);

			int left = s[i] == &#39;1&#39; ? k : 0;
			int right = j &lt; n &amp;&amp; s[j] == &#39;1&#39; ? k : 0;
			int len = j - i;

			if (left == k) {
				len--;
			}

			len -= left + right;

			if (len &gt; 0) {
				res += (len + k) / (k + 1);
			}

			i = j;
		}

		cout &lt;&lt; res &lt;&lt; endl;
	}

	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #650 (Div. 3)
    1367D
    Задача на доске </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Задача на доске</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Поликарп написал на доске некоторую строку $$$s$$$ из строчных       букв латинского алфавита ('<span class="tex-font-style-tt">a</span>'-'<span class="tex-font-style-tt">z</span>'). Эта строка вам известна и       задана во входных данных.</p>     <p>После этого он стёр какие-то буквы из строки $$$s$$$, а       оставшиеся буквы он переписал в <span class="tex-font-style-bf">произвольном</span> порядке. В       результате он получил некоторую новую строку $$$t$$$. Её вам и       предстоит найти по некоторой дополнительной информации.</p>     <p>Предположим, что длина строки $$$t$$$ равна $$$m$$$, а символы       пронумерованы слева направо от $$$1$$$ до $$$m$$$. В таком случае       вам задана последовательность из $$$m$$$ целых чисел: $$$b_1, b_2,       \ldots, b_m$$$, где $$$b_i$$$ равно сумме расстояний $$$|i-j|$$$       от индекса $$$i$$$ до всех таких индексов $$$j$$$, что $$$t_j &gt;       t_i$$$ (считайте, что '<span class="tex-font-style-tt">a</span>'&lt;'<span class="tex-font-style-tt">b</span>'&lt;...&lt;'<span class="tex-font-style-tt">z</span>'). Иными словами, для       вычисления $$$b_i$$$ Поликарп находит все такие индексы $$$j$$$,       что в индексе $$$j$$$ находится буква, которая стоит позже в       алфавите чем $$$t_i$$$, и суммирует все значения $$$|i-j|$$$.</p>     <p>Например, если $$$t$$$=«<span class="tex-font-style-tt">abzb</span>», то:</p>          <ul> <li> так как $$$t_1$$$='<span class="tex-font-style-tt">a</span>', то все остальные индексы         содержат буквы, которые позже в алфавите, то есть:         $$$b_1=|1-2|+|1-3|+|1-4|=1+2+3=6$$$; </li>       <li> так как $$$t_2$$$='<span class="tex-font-style-tt">b</span>',         то только индекс $$$j=3$$$ содержит букву, которая позже в         алфавите, то есть: $$$b_2=|2-3|=1$$$; </li>       <li> так как $$$t_3$$$='<span class="tex-font-style-tt">z</span>',         то индексов $$$j$$$, что $$$t_j&gt;t_i$$$ не существует:         $$$b_3=0$$$; </li>       <li> так как $$$t_4$$$='<span class="tex-font-style-tt">b</span>',         то только индекс $$$j=3$$$ содержит букву, которая позже в         алфавите, то есть: $$$b_4=|4-3|=1$$$. </li></ul>          <p>Таким образом, если $$$t$$$=«<span class="tex-font-style-tt">abzb</span>», то $$$b=[6,1,0,1]$$$.</p>     <p>По заданной строке $$$s$$$ и массиву $$$b$$$ найдите любую       возможную строку $$$t$$$, для которой выполняются следующие два       требования одновременно:</p>          <ul> <li> $$$t$$$ получается из $$$s$$$ путём стирания некоторых         букв (возможно, нуля) и потом записи оставшихся в <span class="tex-font-style-bf">произвольном</span> порядке; </li>       <li> по строке $$$t$$$ получается заданный во входных данных         массив $$$b$$$, если его построить по правилам, которые описаны         выше. </li></ul></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано целое число $$$q$$$ ($$$1 \le q \le       100$$$) — количество наборов входных данных в тесте. Далее следуют       $$$q$$$ наборов входных данных.</p>     <p>Каждый набор входных данных состоит из трех строк:</p>          <ul> <li> строки $$$s$$$, которая имеет длину от $$$1$$$ до $$$50$$$         и состоит из строчных букв латинского алфавита; </li>       <li> строки, которая содержит целое число $$$m$$$ ($$$1 \le m \le         |s|$$$), где $$$|s|$$$ — длина строки $$$s$$$, а $$$m$$$ — длина         массива $$$b$$$; </li>       <li> строки, которая содержит целые числа $$$b_1, b_2, \dots,         b_m$$$ ($$$0 \le b_i \le 1225$$$). </li></ul>          <p>Гарантируется, что в каждом наборе данных входные данные таковы,       что ответ существует.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$q$$$ строк: $$$k$$$-я из них должна содержать ответ       (строку $$$t$$$) на $$$k$$$-й набор входных данных. Гарантируется,       что ответ на каждый набор входных данных существует. Если ответов       несколько, то выведите любой.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
abac
3
2 1 0
abc
1
0
abba
3
1 0 1
ecoosdcefr
10
38 13 24 14 11 5 3 24 17 0
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
aac
b
aba
codeforces
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных подходят такие строки $$$t$$$:         «<span class="tex-font-style-tt">aac</span>», «<span class="tex-font-style-tt">aab</span>».</p>     <p>Во втором наборе входных данных подходят такие строки $$$t$$$:         «<span class="tex-font-style-tt">a</span>», «<span class="tex-font-style-tt">b</span>», «<span class="tex-font-style-tt">c</span>».</p>     <p>В третьем наборе входных данных подходит только строка $$$t$$$       равная «<span class="tex-font-style-tt">aba</span>», но символ         '<span class="tex-font-style-tt">b</span>' может быть со второй       или с третьей позиции.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1367/problem/D' title='Codeforces Round 650 (Div. 3)'>1367D - Task On The Board</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>We will construct the string $$$t$$$, starting with the largest       letters. Note that if $$$b_i = 0$$$, then the $$$i$$$-th letter of       the string $$$t$$$ is maximal, so we know that the $$$i$$$-th       letter affect all $$$b_j \ne 0$$$. While the string $$$t$$$ is not       completely constructed, we will do the following: </p>     <ul> <li> Find all $$$i$$$ such that $$$b_i = 0$$$ and the         $$$i$$$-th character of string $$$t$$$ is not placed; </li>       <li> Put on all these positions $$$i$$$ in the string $$$t$$$ the         maximum letter not used in the string $$$t$$$ (there should be a         sufficient number of letters in the string $$$s$$$); </li>       <li> Subtract $$$|i - j|$$$ from all $$$b_j \ne 0$$$. </li></ul></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

#define forn(i, n) for (int i = 0; i &lt; int(n); i++)

int main() {
    int q;
    cin &gt;&gt; q;
    forn(qq, q) {
        string s;
        cin &gt;&gt; s;
        int n;
        cin &gt;&gt; n;
        vector&lt;int&gt; b(n);
        forn(i, n)
            cin &gt;&gt; b[i];
        vector&lt;vector&lt;int&gt;&gt; groups;
        while (true) {
            vector&lt;int&gt; pos;
            forn(i, n)
                if (b[i] == 0)
                    pos.push_back(i);
            if (pos.empty())
                break;
            groups.push_back(pos);
            forn(i, n)
                if (b[i] == 0)
                    b[i] = INT_MAX;
                else
                    for (int pp: pos)
                        b[i] -= abs(i - pp);
        }
        map&lt;char, int&gt; cnts;
        forn(i, s.size())
            cnts[s[i]]++;
        auto j = cnts.rbegin();
        string t(n, &#39;?&#39;);
        for (auto g: groups) {
            while (j-&gt;second &lt; g.size())
                j++;
            for (int pp: g)
                t[pp] = j-&gt;first;
            j++;
        }
        cout &lt;&lt; t &lt;&lt; endl;
    }
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #650 (Div. 3)
    1367E
    Сборка ожерелья </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. Сборка ожерелья</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>В магазине продаются $$$n$$$ бусинок. Цвет каждой бусинки       описывается строчной буквой латинского алфавита («<span class="tex-font-style-tt">a</span>»–«<span class="tex-font-style-tt">z</span>»). Вы хотите купить какие-то       бусинки, чтобы собрать из них ожерелье.</p>     <p>Ожерелье — набор бусинок, соединенных по кругу. </p>     <p>Например, если в магазине продаются бусинки «<span class="tex-font-style-tt">a</span>», «<span class="tex-font-style-tt">b</span>», «<span class="tex-font-style-tt">c</span>», «<span class="tex-font-style-tt">a</span>», «<span class="tex-font-style-tt">c</span>», «<span class="tex-font-style-tt">c</span>», то вы можете собрать       следующие ожерелья (это не все возможные варианты):</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/489ef8e534a70fc3e0e5051863a91dd875fce89a.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>А следующие ожерелья нельзя собрать из бусинок, которые продаются       в магазине:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/35fbf7bd3f4923b6d7a03918403df2c496864799.png" style="max-width: 100.0%;max-height: 100.0%;"/>         <span class="tex-font-size-small">Первое ожерелье собрать не         получится, потому что в нем есть три бусинки «<span class="tex-font-style-tt">a</span>» (из двух доступных). Второе         ожерелье собрать не получится, потому что в нем есть бусинка           «<span class="tex-font-style-tt">d</span>», которой нет в       магазине.</span> </center>          <p>Назовем ожерелье $$$k$$$-красивым, если при его повороте по       часовой стрелке на $$$k$$$ бусинок ожерелье остается неизменным.       Например, вот последовательность из трех поворотов некоторого       ожерелья. </p>     <center> <img class="tex-graphics" src="https://espresso.codeforces.com/d00132704b1299bdef457071855b4150205c2447.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>Так как после трех поворотов по часовой стрелке ожерелье не       изменилось, то оно является $$$3$$$-красивым. Как можно заметить,       это ожерелье также является $$$6$$$-красивым, $$$9$$$-красивым и       так далее, но не является $$$1$$$-красивым или $$$2$$$-красивым.</p>     <p>В частности, ожерелье длины $$$1$$$ является $$$k$$$-красивым для       любого целого $$$k$$$. Ожерелье, которое состоит из бусинок       одинакового цвета, тоже является красивым для любого $$$k$$$.</p>     <p>Вам даны числа $$$n$$$ и $$$k$$$, а также строка $$$s$$$,       содержащая $$$n$$$ строчных букв латинского алфавита — каждая       буква задает бусинку в магазине. Вы можете купить любое       подмножество бусинок и соединить их в произвольном порядке.       Найдите максимальную длину $$$k$$$-красивого ожерелья, которое вы       можете собрать.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$t$$$ ($$$1 \le t \le       100$$$) — количество наборов тестовых данных в тесте. Далее       следуют $$$t$$$ наборов тестовых данных.</p>     <p>Первая строка каждого набора содержит два целых числа $$$n$$$ и       $$$k$$$ ($$$1 \le n, k \le 2000$$$).</p>     <p>Вторая строка каждого набора содержит строку $$$s$$$, содержащую       $$$n$$$ строчных букв латинского алфавита — набор бусинок в магазине.</p>     <p>Гарантируется, что сумма $$$n$$$ по всем наборам тестовых данных       в тесте не превосходит $$$2000$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$t$$$ ответов на наборы тестовых данных. Каждый ответ       является целым положительным числом — максимальной длиной       $$$k$$$-красивого ожерелья, которое вы можете собрать.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
6 3
abcbac
3 6
aaa
7 1000
abczgyo
5 4
ababa
20 10
aaebdbabdbbddaadaadc
20 5
ecbedececacbcbccbdec
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
6
3
5
4
15
10
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Первый набор тестовых данных разобран в условии.</p>     <p>Во втором наборе тестовых данных $$$6$$$-красивое ожерелье можно       собрать из всех букв.</p>     <p>В третьем наборе тестовых данных $$$1000$$$-красивое ожерельем       можно собрать, например, из бусинок «<span class="tex-font-style-tt">abzyo</span>».</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1367/problem/E' title='Codeforces Round 650 (Div. 3)'>1367E - Necklace Assembly</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's iterate over the $$$m$$$ — length of the $$$k$$$-beautiful       necklace. For each position $$$i$$$, make an edge to the position       $$$p[i] = (i + k) \bmod m$$$, where $$$a \bmod b$$$ — is the       remainder of dividing $$$a$$$ by $$$b$$$. What is a cyclic shift       by $$$k$$$ in this construction? A bead located at position       $$$i$$$ will go along the edge to position $$$p[i]$$$. Consider       all the cycles of a graph constructed on $$$p$$$. You may notice       that if only equal letters are found in each cycle, then with a       cyclic shift by $$$k$$$ the graph and the string will remain       unchanged. Thus, in order to check whether it is possible to make       a $$$k$$$-beautiful necklace of length $$$m$$$, you need to make a       graph $$$p$$$, find the cycles in it and check whether it is       possible to distribute the letters from the string $$$s$$$ in       cycles such that each cycle have equal letters. The last part of       the solution can be done with simple greedy.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int main() {
	int test;
	cin &gt;&gt; test;

	while (test--) {
		int n, k;
		cin &gt;&gt; n &gt;&gt; k;
		string s;
		cin &gt;&gt; s;

		vector&lt;int&gt; cnt(26);

		for (char c : s) {
			cnt[c - &#39;a&#39;]++;
		}

		for (int len = n; len &gt;= 1; len--) {
			vector&lt;bool&gt; used(len);
			vector&lt;int&gt; cycles;

			for (int i = 0; i &lt; len; i++) {
				if (used[i]) {
					continue;
				}

				int j = (i + k) % len;
				used[i] = true;
				cycles.push_back(0);
				cycles.back()++;

				while (!used[j]) {
					cycles.back()++;
					used[j] = true;
					j = (j + k) % len;
				}
			}

			vector&lt;int&gt; cur_cnt(cnt);

			sort(cycles.begin(), cycles.end());
			sort(cur_cnt.begin(), cur_cnt.end());

			bool can_fill = true;

			while (!cycles.empty()) {
				if (cur_cnt.back() &lt; cycles.back()) {
					can_fill = false;
					break;
				} else {
					cur_cnt.back() -= cycles.back();
					cycles.pop_back();
					sort(cur_cnt.begin(), cur_cnt.end());
				}
			}

			if (can_fill) {
				cout &lt;&lt; len &lt;&lt; endl;
				break;
			}
		}
	}
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #652 (Div. 2)
    1369A
    ПокупатеЛи </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. ПокупатеЛи</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>       <span class="tex-font-style-it">Ли собирается украсить свой дом к         вечеринке с помощью нескольких правильных многоугольников...</span></p>     <p>Ли считает правильный (выпуклый) $$$n$$$-угольник <span class="tex-font-style-it">красивым</span> тогда и только тогда,       когда он может повернуть многоугольник таким образом, чтобы хотя       бы одна из его сторон стала параллельна оси $$$OX$$$ и хотя бы       одна из его сторон стала параллельна оси $$$OY$$$ одновременно.</p>     <p>Напомним, что правильный $$$n$$$-угольник — это выпуклый       многоугольник из $$$n$$$ вершин такой, что все его стороны и углы равны.</p>     <p>Ли пришел в магазин: в магазине продаются $$$t$$$ правильных       многоугольников. Для каждого из них выведите <span class="tex-font-style-tt">YES</span>, если многоугольник красивый,       или <span class="tex-font-style-tt">NO</span> в противном случае.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке задано одно целое число $$$t$$$ ($$$1 \le t \le       10^4$$$) — количество многоугольников в магазине. </p>     <p>В каждой из следующих $$$t$$$ строк задано по одному целому числу       $$$n_i$$$ ($$$3 \le n_i \le 10^9$$$): то есть $$$i$$$-й       многоугольник является правильным $$$n_i$$$-угольником. </p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого многоугольника в магазине, выведите <span class="tex-font-style-tt">YES</span>, если он красивый, или <span class="tex-font-style-tt">NO</span> в противном случае (регистр       букв не важен).</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
3
4
12
1000000000
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
NO
YES
YES
YES
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В примере, в магазине продаются $$$4$$$ многоугольника. Несложно       определить, что равносторонний треугольник (правильный       $$$3$$$-угольник) не является красивым, квадрат (правильный       $$$4$$$-угольник) является красивым, и правильный       $$$12$$$-угольник (изображен ниже) также является красивым.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/1fb7c77820d27b1f996dbe8b237957113d122864.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1369/problem/A' title='Codeforces Round 652 (Div. 2)'>1369A - FashionabLee</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>$$$\mathcal Complete\;\mathcal Proof :$$$</p>     <p>Proof by contradiction :</p>     <p>One can prove that if two edges in a regular polygon make a $$$x       &lt; 180$$$ degrees angle, then for each edge $$$a$$$ there exist       two another edges $$$b$$$ and $$$c$$$ such that $$$a$$$ and       $$$b$$$ make a $$$x$$$ degrees angle as well as $$$a$$$ and       $$$c$$$. (proof is left as an exercise for the reader)</p>     <p>Consider a rotation such that an edge $$$a$$$ is parallel to       $$$OX$$$-axis and an edge $$$b$$$ is parallel to $$$OY$$$-axis,       then $$$a \perp b$$$ ($$$a$$$ and $$$b$$$ are perpendicular, i. e.       the angle between them is $$$90$$$ degrees), we can see that there       exist a third edge $$$c$$$ such that it's also parallel to       $$$OX$$$-axis and a forth edge $$$d$$$ such that it's also       parallel to $$$OY$$$-axis, so $$$a \perp d$$$ and $$$b \perp c$$$       and $$$c \perp d$$$. </p>     <p>Our polygon is regular so all the angles are equal, so that the       number of angles between $$$a$$$ and $$$b$$$ is equal to the       number of angles between $$$b$$$ and $$$c$$$ and so on, also we       know that a regular $$$n$$$-sided convex polygon has $$$n$$$       angles, so $$$n$$$ is divisible by $$$4$$$, contradiction!</p></div></div></div>

           
            <pre><code>t = int(input())
for testcase in range(t):
    n = int(input())
    if(n%4 == 0) :
        print(&#34;Yes&#34;)
    else :
        print(&#34;No&#34;)

</code></pre>
           
            <pre><code>#include &lt;iostream&gt;
 
using namespace std;
 
int main(){
    int t;
    cin &gt;&gt; t;
    while(t--){
        int n;
        cin &gt;&gt; n;
        if(n % 4 == 0){
            cout &lt;&lt; &#34;YES\n&#34;;
        }
        else cout &lt;&lt; &#34;NO\n&#34;;
    }
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #652 (Div. 2)
    1369B
    ОчиститеЛи </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. ОчиститеЛи</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>       <span class="tex-font-style-it">Ли убирался у себя в дома перед         вечеринкой, когда нашел под ковром «грязную» строку. Теперь он         хочет очистить строку, но сделать это стильно...</span></p>     <p>Строка $$$s$$$, которую нашел Ли, является двоичной строкой длины       $$$n$$$ (т. е. строка состоит только из символов <span class="tex-font-style-tt">0</span> и <span class="tex-font-style-tt">1</span>).</p>     <p>За один шаг, он может выбрать два последовательных символа       $$$s_i$$$ и $$$s_{i+1}$$$ и, если символ $$$s_i$$$ равен <span class="tex-font-style-tt">1</span> и $$$s_{i + 1}$$$ равен <span class="tex-font-style-tt">0</span>, он может удалить <span class="tex-font-style-bf">ровно один из символов</span> (Ли       может выбрать какой удалить, но не может удалить оба символа       одновременно). После удаления строка сжимается.</p>     <p>Ли может сделать произвольное количество шагов (возможно, ни       одного шага) и он хочет сделать строку $$$s$$$ как можно более         <span class="tex-font-style-it">чистой</span>. Он считает, что       из двух различных строк $$$x$$$ и $$$y$$$ <span class="tex-font-style-bf">более короткая</span> строка чище, а       если они равны по длине, то чище та, что <span class="tex-font-style-it">лексикографически меньше</span>.</p>     <p>Сейчас же вам необходимо ответить на $$$t$$$ наборов входных       данных: для $$$i$$$-го набора, выведите самую чистую строку,       которую может получить Ли за произвольное количество шагов.</p>     <p>Небольшое напоминание: если у нас есть две строки $$$x$$$ и       $$$y$$$ равной длины, то $$$x$$$ лексикографически меньше чем       $$$y$$$, если существует такая позиция $$$i$$$, что $$$x_1 =       y_1$$$, $$$x_2 = y_2$$$,..., $$$x_{i - 1} = y_{i - 1}$$$ и $$$x_i       &lt; y_i$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке задано одно целое число $$$t$$$ ($$$1 \le t \le       10^4$$$) — количество наборов входных данных.</p>     <p>В следующих $$$2t$$$ строках заданы сами наборы входных данных —       по одному на две строки.</p>     <p>В первой строке каждого набора задано одно целое число $$$n$$$       ($$$1 \le n \le 10^5$$$) — длина строки $$$s$$$.</p>     <p>Во второй строке задана сама бинарная строка $$$s$$$. Строка       $$$s$$$ — это строка длины $$$n$$$, состоящая только из нулей и единиц.</p>     <p>Гарантируется, что сумма $$$n$$$ по всем наборам не превосходит $$$10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$t$$$ ответов — по одному на набор входных данных.</p>     <p>Ответом на $$$i$$$-й набор является самая чистая строка, которую       может получить Ли за произвольное (возможно, нулевое) количество шагов.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
10
0001111111
4
0101
8
11001101
10
1110000000
1
1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0001111111
001
01
0
1
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных, Ли не может сделать ни одного шага.</p>     <p>Во втором наборе, Ли должен удалить $$$s_2$$$.</p>     <p>В третьем наборе, Ли может, например, выполнить следующие шаги:         11001<span class="tex-font-style-underline">10</span>1 $$$\rightarrow$$$         1<span class="tex-font-style-underline">10</span>0101 $$$\rightarrow$$$         1<span class="tex-font-style-underline">10</span>101 $$$\rightarrow$$$         <span class="tex-font-style-underline">10</span>101 $$$\rightarrow$$$         1<span class="tex-font-style-underline">10</span>1 $$$\rightarrow$$$         <span class="tex-font-style-underline">10</span>1 $$$\rightarrow$$$ 01.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1369/problem/B' title='Codeforces Round 652 (Div. 2)'>1369B - AccurateLee</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>$$$\mathcal Complete\; \mathcal Proof$$$ :</p>     <p>Realize that the answer is always non-descending, and we can't       perform any operations on non-descending strings.</p>     <p>First we know that we can't perform any operations on       non-descending strings, so the answer to a non-descending string       is itself. From now we consider our string $$$s$$$ to not to be       non-descending. (i.e. there exist index $$$i$$$ such that $$$1 \le       i \le n-1$$$ and $$$s_i &gt; s_{i+1}$$$)</p>     <p>Also realize that the remaining string wont be empty, so       &quot;0&quot; is the cleanest possible answer, but we can't reach       it probable.</p>     <p>Now realize that leading zeroes and trailing ones can't be       present in any operation. So they have to be in the answer, erase       them from $$$s$$$, and add them to the answer for the modified       $$$s$$$. From now we know that the string $$$s$$$ has no leading       zeroes and/or trailing ones, and is not non-descending, so it       starts with $$$1$$$ and ends with $$$0$$$. (why?)</p>     <p>With some small paperwork, we will realize that the answer to a       string that starts with $$$1$$$ and ends with $$$0$$$ is a single       $$$0$$$(proof is bellow). So if the string $$$s$$$ is       non-descending and it has $$$x$$$ leading zeroes and $$$y$$$       trailing ones($$$x$$$ and $$$y$$$ can be equal to zero), then the       answer is       $$$\underbrace{0\,0\dots0}_{x}\,0\,\underbrace{1\,1\dots1}_{y}$$$       (its $$$x+1$$$ zeroes and $$$y$$$ ones in order)</p>     <p>$$$\mathcal The\;\mathcal Small\;\mathcal Paperwork:$$$</p>     <p>We will randomly perform operations until we can't do any more or       the string's length is equal to $$$2$$$, but we wont erase the       first $$$1$$$ and the last $$$0$$$, we want to prove that the       remaining string's length is exactly $$$2$$$ after the process       ends, proof by contradiction :</p>     <p>So it's length is at least $$$3$$$, so we have at least two       $$$1$$$ or at least two $$$0$$$. If we had two or more $$$0$$$       then the string $$$[s_1\,s_2\dots s_{n-1}]$$$ will not be       non-descending(so we can perform more operations as we proved in         <span class="tex-font-style-tt">STAR</span>, but the process       have ended, contradiction!) and if we had two or more $$$1$$$ then       the string $$$[s_2\,s_3\dots s_n]$$$ will not be non-descending.       So the length of the remaining string is exactly $$$2$$$, and we       haven't erased first '1' and last '0', so the string is equal to       &quot;10&quot;, now erase '1' to get the cleanest string.</p>     <p>Sorry if the proof seems too long and hard, i wanted to explain       it accurately. ^-^</p></div></div></div>

           
            <pre><code>t = int(input())
for testcase in range(t):
    n = int(input())
    s = input()
    lef, rig, sw = 1, 1, 0
    for i in range(n-1):
        if(s[i] &gt; s[i+1]):
            sw = 1
            break
    if(sw == 0):
        print(s)
        continue
    for i in range(n):
        if (s[i] == &#39;1&#39;):
            lef = i
            break
    for i in range(n-1, 0, -1):
        if (s[i] == &#39;0&#39;):
            rig = i
            break
    st = s[:lef] + &#39;0&#39; + s[rig+1:]
    print(st)

</code></pre>
           
            <pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
 
using namespace std;
 
int main(){
    
    int t;
    cin &gt;&gt; t;
    while(t--){
        int n;
        cin &gt;&gt; n;
        string s;
        cin &gt;&gt; s;
        int sw = 1;
        for(int i = 1; i &lt; s.size(); i++){
            if(s[i] &lt; s[i-1])sw = 0;
        }
        if(sw){
            cout &lt;&lt; s &lt;&lt; &#39;\n&#39;;
            continue;
        }
        string ans;
        for(int i = 0; i &lt; s.size(); i++){
            if(s[i] == &#39;1&#39;)break;
            ans.push_back(&#39;0&#39;);
        }
        ans.push_back(&#39;0&#39;);
        for(int i = s.size()-1; i &gt;= 0; i--){
            if(s[i] == &#39;0&#39;)break;
            ans.push_back(&#39;1&#39;);
        }
        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
    }
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #652 (Div. 2)
    1369C
    ПриятеЛи </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. ПриятеЛи</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>       <span class="tex-font-style-it">Ли наконец стал мастером на         Codeforces, и потому решил сходить за подарками своим друзьям.         Он приобрел $$$n$$$ целых чисел, и теперь настало время         распределить их между друзьями...</span></p>     <p>У Ли есть $$$n$$$ целых чисел $$$a_1, a_2, \ldots, a_n$$$ в своем       рюкзаке, а также у него $$$k$$$ друзей. Ли хочет распределить         <span class="tex-font-style-bf">все</span> целые числа из       рюкзака между друзьями так, чтобы $$$i$$$-му другу досталось ровно       $$$w_i$$$ чисел и каждое число досталось ровно одному другу.</p>     <p>Назовем <span class="tex-font-style-it">уровнем счастья</span>       друга сумму максимального и минимального числа, которое он получит.</p>     <p>Ли хочет сделать друзей как можно более счастливыми, другими       словами, он хочет максимизировать суммарный уровень счастья       друзей. Конечно же, Ли просит вас помочь ему посчитать этот       максимальный суммарный уровень счастья.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке задано единственное число $$$t$$$ ($$$1 \le t \le       10^4$$$) — количество наборов входных данных.</p>     <p>В следующих $$$3t$$$ строках заданы сами наборы — по одному на       три строки.</p>     <p>В первой строке каждого набора входных данных заданы два целых       числа $$$n$$$ и $$$k$$$ ($$$1 \le n \le 2 \cdot 10^5$$$; $$$1 \le       k \le n$$$) — количество целых чисел в рюкзаке Ли и количество его друзей.</p>     <p>Во второй строке каждого набора заданы $$$n$$$ целых чисел       $$$a_1, a_2, \ldots, a_n$$$ ($$$-10^9 \le a_i \le 10^9$$$) — сами       числа в рюкзаке.</p>     <p>В третьей строке заданы $$$k$$$ целых чисел $$$w_1, w_2, \ldots,       w_k$$$ ($$$1 \le w_i \le n$$$; $$$w_1 + w_2 + \ldots + w_k =       n$$$) — количество чисел, которое Ли собирается дать каждому       другу. </p>     <p>Гарантируется, что сумма $$$n$$$ по всем наборам не превосходит       $$$2 \cdot 10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите по одному числу —       максимальный суммарный уровень счастья, который сможет достигнуть Ли.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
4 2
1 13 7 17
1 3
6 2
10 10 10 10 11 11
3 3
4 4
1000000000 1000000000 1000000000 1000000000
1 1 1 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
48
42
8000000000
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных, Ли нужно отдать наибольшее число       первому другу (его уровень счастья будет равен $$$17 + 17$$$) и       остальные числа — второму (его уровень счастья будет равен $$$13 + 1$$$).</p>     <p>В втором наборе, Ли нужно отдать $$$\{10, 10, 11\}$$$ и первому и       второму другу, тогда суммарный уровень счастья будет равен $$$(11       + 10) + (11 + 10)$$$</p>     <p>В третьем наборе, у Ли четыре друга и четыре числа. Не важно, как       он распределит числа между ними.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1369/problem/C' title='Codeforces Round 652 (Div. 2)'>1369C - RationalLee</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>$$$\mathcal Complete\; \mathcal Proof$$$ :</p>     <p>First if $$$w_i = 1$$$ for some $$$i$$$, then assign the greatest       element to $$$i$$$-th friends, it's always better obviously.</p>     <p>Sort the elements in non-descending order and sort the friends in       non-ascending order of $$$w_i$$$. Define $$$v_i$$$ the set of       indices of elements to give to $$$i$$$-th friend. Also define       $$$l_i$$$ the minimum element to give to $$$i$$$-th friend and       $$$r_i$$$ the maximum element to give to $$$i$$$-th friend, and       define $$$m = \max\limits_{1\,\le\,i\,\le\,k} w_i$$$.</p>     <p>Now it's easy to see that the first element of $$$a$$$(the       smallest element) is always equal to $$$l_i$$$ for some $$$i$$$,       Indeed it's better to have the rest of $$$v_i$$$ equal to a small       number except one of them, which should be equal to a very large       number. So we can greedily assign $$$a_1$$$, $$$a_2$$$ ...       $$$a_{{w_i}-1}$$$ to $$$v_i$$$, and then assign $$$a_n$$$ to it,       also it's better to have $$$w_i = m$$$. One can prove that there       exist an optimal distributing such that the set($$$\{a_1, a_2       \ldots a_{m-1}, a_n\}$$$) is equal to one of $$$v_i$$$-s(proof is       blow). So add $$$a_1 + a_n$$$ to the answer for remaining elements       of $$$a$$$(excluding the set) and remaining friends(excluding one       of the friends with maximum $$$w_i$$$) and so, it will be optimal.</p>     <p>Look at an optimal distributing (which maximizes sum of       happiness), first element of $$$a$$$ is in $$$v_i$$$ for example,       we want to prove that in at least one of the optimal distributings       $$$w_i-1$$$ smallest elements of $$$a$$$ are in $$$v_i$$$       (including the first element), proof by contradiction:</p>     <p>If at least one of the smallest $$$w_i-1$$$ elements is not in       $$$v_i$$$, then call the smallest of them $$$x$$$, lets say it's       in $$$v_j$$$, now add $$$x$$$ to $$$v_i$$$(and erase it from       $$$v_j$$$), instead add a greater number than $$$x$$$ in $$$v_i$$$       to $$$v_j$$$ (it's at least two of them, and one of them is       $$$r_i$$$, so there exist another one, erase it from $$$v_i$$$ and       add it to $$$v_j$$$), it's easy to see that sum of happiness won't       decrease that way, continue the process until all $$$w_i-1$$$       smallest elements are in $$$v_i$$$, so we have an optimal answer       which has all $$$w_i-1$$$ smallest elements in $$$v_i$$$, contradiction!</p>     <p>As we proved above, we have an optimal distributing such that all       $$$w_i-1$$$ smallest elements are in $$$v_i$$$(for some $$$i$$$),       now we want to prove that the greatest element is in $$$v_i$$$ in       at least one of the optimal distributings, again proof by contradiction.</p>     <p>Lets say it's not that way, so look at an optimal distributing       such that first $$$w_i-1$$$ elements are in $$$v_i$$$ and       $$$r_i$$$ is not equal to the greatest element(for some $$$i$$$),       if there exist such $$$j$$$ that $$$r_i &lt; l_j$$$, then swap       $$$r_i$$$ and $$$l_j$$$, the resulting distributing has the same       happiness, continue it until no such $$$j$$$ exist, now lets say       the greatest element of $$$a$$$ is in $$$v_j$$$ for some $$$j$$$,       also we know that $$$r_j$$$ is equal to the greatest element of       $$$a$$$ and $$$l_j \le r_i$$$(if $$$r_i &lt; l_j$$$ then the       process of swapping is not finished, which is contradiction). So       now we can swap $$$r_i$$$ and $$$r_j$$$, again the resulting       distributing has happiness greater than or equal to the happiness       of the optimal distributing(the one we chose in the beginning),       and so, its also an optimal distributing, and $$$r_i$$$ is equal       to the greatest element, we have found an optimal distributing       such that first $$$w_i-1$$$ elements of $$$a$$$ and $$$a_n$$$ are       in $$$v_i$$$(for some $$$i$$$), contradiction!</p>     <p>Now we have proved that there exist an optimal distributing such       that first $$$w_i-1$$$ elements of $$$a$$$ and $$$a_n$$$ are in       $$$v_i$$$(for some $$$i$$$), call such optimal distributing <span class="tex-font-style-tt">STAR</span>, and now the only remaining       part is to prove that there exist an optimal distributing such       that first $$$m-1$$$ elements of $$$a$$$ and $$$a_n$$$ are in       $$$v_i$$$(for some $$$i$$$). See the whole algorithm, its like       &quot;we choose a permutation of friends then we do that greedy       assignment to them one by one from left to right&quot;, now we       want to prove that there exist an optimal distributing such that       it's <span class="tex-font-style-tt">STAR</span> and it's       permutation is sorted in non-descending order of $$$w$$$, call       them <span class="tex-font-style-tt">GOOD</span> distributings.       Again, proof by contradiction :</p>     <p>Choose a distributing such that it's a <span class="tex-font-style-tt">STAR</span>, it's permutation(called       $$$p$$$) is not sorted in non-descending order of       $$$w$$$(otherwise it's a <span class="tex-font-style-tt">GOOD</span> distributing,       contradiction!), so there exist an $$$i$$$ such that $$$w_{p_i}       &gt; w_{p_{i+1}}$$$, now swap them(i. e. swap $$$p_i$$$ and       $$$p_{i+1}$$$ and then do the same greedy assignment using the       modified permutation of friends), it's easy to see that happiness       of friends after $$$i+1$$$ in permutation $$$p$$$ wont change,       also happiness of friends before $$$i$$$ in the permutation wont       change as well.</p>     <p>Now look at the happiness of $$$p_i$$$ and $$$p_{i+1}$$$, you can       realize that sum of happiness will increase.</p>     <p>You really don't need to prove it like that, it's not time       friendly at all. ^-^</p></div></div></div>

           
            <pre><code>t = int(input())
for tc in range(t):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    w = list(map(int, input().split()))
    a.sort(reverse = True)
    w.sort()
    ii, l, r = k, 0, n-1
    ans = 0
    for i in range(k):
        if(w[i] &gt; 1):
            ii = i
            break
        ans = ans+a[l]*2
        l = l+1
    for u in range(k-1, ii-1, -1):
        i = w[u]
        ans = ans + a[l] + a[r]
        r = r-i+1
        l = l+1
    print(ans)

</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;
#define ll long long
#define fr first
#define sc second
#define int ll

using namespace std;
const int MN = 2e5+7;

vector&lt;int&gt; v[MN];

signed main(){
    ios::sync_with_stdio(false);
    cin.tie();
    cout.tie();

    int t;
    cin &gt;&gt; t;
    while(t--){
        int n, k;
        cin &gt;&gt; n &gt;&gt; k;
        for(int i = 0; i &lt;= n; i++)v[i].clear();
        ll a[n], w[k];
        for(int i = 0; i &lt; n; i++){
            cin &gt;&gt; a[i];
        }
        for(int i = 0; i &lt; k; i++){
            cin &gt;&gt; w[i];
        }
        sort(w, w+k);
        sort(a, a+n);
        for(int i = 0; i &lt; k/2; i++)swap(w[i], w[k-i-1]);
        int po = 0;
        for(int i = 0; i &lt; n-k; i++){
            while(w[po] == v[po].size()+1)po++;
            v[po].push_back(a[i]);
        }
        ll ans = 0;
        int qf = 1;
        for(int i = 0; i &lt; k; i++){
            ans += a[n-i-1];
            if(v[i].size())ans += v[i][0];
            else ans += a[n-qf], qf++;
        }
        
        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
    }
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #652 (Div. 2)
    1369D
    СоздатеЛи </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. СоздатеЛи</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>       <span class="tex-font-style-it">Ли потратил так много времени на         создание хорошей div.2 D задачи, чтобы сбалансировать недавний         контест, но задача продолжает ощущаться неподходящей. Ли         придумывал ее так мучительно долго, что заработал фобию div.2 D         задач. И теперь он прячется в кустах...</span></p>     <p>Назовем <span class="tex-font-style-it">Корневым Сухим       Кустом</span> (КСК) уровня $$$n$$$ корневое дерево, построенное       согласно правилам ниже.</p>     <p>Корневой Сухой Куст уровня $$$1$$$ — это одна вершина. Для       построения КСК уровня $$$i$$$, сначала построим КСК уровня       $$$i-1$$$ и далее для каждой вершины $$$u$$$: </p>     <ul> <li> если у $$$u$$$ нет детей, то подвесим к ней одного сына; </li>       <li> если у $$$u$$$ есть один сын, то подвесим к ней еще двух         детей; </li>       <li> если у $$$u$$$ есть более одного сына, то пропустим ее. </li></ul>               <center> <img class="tex-graphics" src="https://espresso.codeforces.com/bc12fd72ff405f3dcf8fe43f587b14f1c73980df.png" style="max-width: 100.0%;max-height: 100.0%;"/>         <span class="tex-font-size-small">Корневые Сухие Кусты уровня         $$$1$$$, $$$2$$$ и $$$3$$$.</span> </center>          <p>Назовем <span class="tex-font-style-it">лапой</span> корневое       дерево из четырех вершин: одна корневая вершина (также называется       центром) и три ребенка. Оно напоминает лапу:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/2fa28290a38e1783879aa47b2d323f1eef3d32cc.png" style="max-width: 100.0%;max-height: 100.0%;"/>         <span class="tex-font-size-small">Центром лапы является вершина         с номером $$$1$$$.</span> </center>          <p>У Ли есть Корневой Сухой Куст уровня $$$n$$$. Первоначально все       вершины КСК зеленого цвета.</p>     <p>За один шаг, он может выбрать лапу в КСК и, если все вершины в       ней <span class="tex-font-style-it">зеленые</span> и все вершины       лапы являются детьми ее центра, покрасить вершины лапы в в желтый.</p>     <p>Ли хочет узнать максимальное количество желтых вершин, которое он       сможет получить. Так как ответ может быть очень большим, выведите       его по модулю $$$10^9+7$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке задано одно число $$$t$$$ ($$$1 \le t \le       10^4$$$) — количество наборов входных данных.</p>     <p>В следующих $$$t$$$ строках заданы сами наборы — по одному в строке.</p>     <p>В первой строке каждого набора задано одно целое число $$$n$$$       ($$$1 \le n \le 2 \cdot 10^6$$$) — уровень КСК Ли.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите единственное целое       число — максимальное количество желтых вершин, которые может       получить Ли, по модулю $$$10^9 + 7$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
7
1
2
3
4
5
100
2000000
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
0
4
4
12
990998587
804665184
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Несложно заметить, что ответ для КСК уровня $$$1$$$ или $$$2$$$       равен $$$0$$$.</p>     <p>Ответ для КСК уровня $$$3$$$ равен $$$4$$$, так как есть только       одна лапа, которую можно выбрать: $$$\{1, 2, 3, 4\}$$$.</p>     <p>Ответ для КСК уровня $$$4$$$ равен $$$4$$$, так как мы можем       выбрать либо одну лапу $$$\{1, 3, 2, 4\}$$$ или одну лапу $$$\{2,       7, 5, 6\}$$$. Других лап в КСК уровня $$$4$$$ нет (например, мы не       можем выбрать $$$\{2, 1, 7, 6\}$$$, так как $$$1$$$ не является       ребенком вершины-центра $$$2$$$).</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/e328eb531653ffb0449ef2ae13f3d80242b3c8af.png" style="max-width: 100.0%;max-height: 100.0%;"/>         <span class="tex-font-size-small">Корневой Сухой Куст уровня       4.</span> </center></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1369/problem/D' title='Codeforces Round 652 (Div. 2)'>1369D - TediousLee</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>$$$\mathcal Complete \mathcal Proof$$$ :</p>     <p>First realize that a RDB of level $$$i$$$ is consisted of a       vertex (the root of the RDB of level $$$i$$$) connected to the       roots of two RDBs of level $$$i-2$$$ and a RDB of level $$$i-1$$$. </p>     <p>Now define $$$dp_i$$$ equal to the answer for a RDB of level       $$$i$$$. Also define $$$r_i$$$ equal to $$$1$$$ if Lee can achieve       $$$dp_i$$$ yellow vertices in a RDB of level $$$i$$$ such that the       root is green, and $$$0$$$ otherwise. It's easy to see that       $$$dp_i$$$ is equal to either $$$2 \cdot dp_{i-2} + dp_{i-1}$$$ or       $$$2 \cdot dp_{i-2} + dp_{i-1} + 4$$$. If both $$$r_{i-1}$$$ and       $$$r_{i-2}$$$ are equal to $$$1$$$, then we can color the claw       rooted at the root of the RDB, then $$$r_i = 0$$$ and $$$dp_i = 2       \cdot dp_{i-2} + dp_{i-1} + 4$$$. Also if either $$$r_{i-2}$$$ or       $$$r_{i-1}$$$ is equal to $$$0$$$ then $$$r_i = 1$$$ and $$$dp_i =       2 \cdot dp_{i-2} + dp_{i-1}$$$.</p></div></div></div>

           
            <pre><code>v = []
v.append(0)
v.append(0)
v.append(0)
v.append(4)
v.append(4)
mod = int(1e9+7)
for i in range (5, 2000010):
    v.append(max(((2*v[i-2])+v[i-1])%mod,((4*v[i-4])+4*v[i-3]+v[i-2]+4)%mod))
t = int(input())
for _ in range(t):
    print(v[int(input())])

</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;
#define ll long long
using namespace std;

const int mod = int(1e9+7);
const int MN = int(2e6+7);

int dp[MN];

signed main(){
    ios::sync_with_stdio(false);
    cin.tie();
    cout.tie();
    dp[0] = dp[1] = 0;
    dp[2] = 4;
    for(int i = 3; i &lt; MN; i++){
        long long w = dp[i-1];
        w += 2*dp[i-2] + (i % 3 == 2)*4;
        w %= mod;
        dp[i] = w;
    }

    int t;
    cin &gt;&gt; t;
    while(t--){
        int n;
        cin &gt;&gt; n;
        n--;
        cout &lt;&lt; dp[n]%mod &lt;&lt; &#39;\n&#39;;
    }
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #652 (Div. 2)
    1369E
    ВыживатеЛи </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. ВыживатеЛи</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>       <span class="tex-font-style-it">Ли приобрел некоторой еды на обед,         но приглашать друзей Ли на обед смертельно опасно. Ли напуган,         он не хочет умирать, хотя бы пока не увидит Online IOI 2020...</span></p>     <p>Всего есть $$$n$$$ различных видов еды и $$$m$$$ лучших друзей       Ли. У Ли есть $$$w_i$$$ тарелок $$$i$$$-го вида еды, и у каждого       друга Ли есть два любимых вида еды: любимые блюда $$$i$$$-го       друга — это $$$x_i$$$ и $$$y_i$$$ ($$$x_i \ne y_i$$$).</p>     <p>Ли начнет вызывать своих друзей по одному. Каждый, кого вызвали,       пойдет на кухню и попытается съесть по <span class="tex-font-style-bf">одной тарелке каждого из его любимых         видов еды</span>. Каждый друг зайдет на кухню ровно один раз.</p>     <p>Но проблема в следующем: если друг съест хотя бы одну тарелку еды       (суммарно), то он станет абсолютно безвреден. Но если другу нечего       есть (не осталось ни $$$x_i$$$, ни $$$y_i$$$), то он съест самого       Ли $$$\times\_\times$$$.</p>     <p>Ли может выбрать, в каком порядке приглашать друзей, а потому Ли       хочет понять, может ли он пережить ужин или нет. Также его       интересует непосредственно сам порядок.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке заданы два целых числа $$$n$$$ и $$$m$$$ ($$$2       \le n \le 10^5$$$; $$$1 \le m \le 2 \cdot 10^5$$$) — количество       видов еды и количество друзей Ли. </p>     <p>Во второй строке заданы $$$n$$$ целых чисел $$$w_1, w_2, \ldots,       w_n$$$ ($$$0 \le w_i \le 10^6$$$) — количество тарелок с едой       каждого вида.</p>     <p>В $$$i$$$-й строке из следующих $$$m$$$ строк заданы два целых       числа $$$x_i$$$ и $$$y_i$$$ ($$$1 \le x_i, y_i \le n$$$; $$$x_i       \ne y_i$$$) — любимые виды еды $$$i$$$-го друга. </p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Если Ли может пережить обед, выведите <span class="tex-font-style-tt">ALIVE</span> (регистр букв не важен),       иначе выведите <span class="tex-font-style-tt">DEAD</span>       (регистр не важен).</p>     <p>Также, если он может пережить обед, выведите порядок, в котором       Ли следует вызывать друзей. Если существует несколько возможных       порядков, выведите любой из них.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3 3
1 2 1
1 2
2 3
1 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
ALIVE
3 2 1 
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
3 2
1 1 0
1 2
1 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
ALIVE
2 1 
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
4 4
1 2 0 1
1 3
1 2
2 3
2 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
ALIVE
1 3 2 4 
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5 5
1 1 1 2 1
3 4
1 2
2 3
4 5
4 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
ALIVE
5 4 1 3 2 
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
4 10
2 4 1 4
3 2
4 2
4 1
3 1
4 1
1 3
3 2
2 1
3 1
2 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
DEAD
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере, любой из следующих порядков друзей будет       корректным: $$$[1, 3, 2]$$$, $$$[3, 1, 2]$$$, $$$[2, 3, 1]$$$,       $$$[3, 2, 1]$$$.</p>     <p>Во втором примере, Ли следует вызвать второго друга первым (тогда       он съест тарелку еды $$$1$$$), а потом и первого друга (этот друг       съесть тарелку еды $$$2$$$). Если же Ли вызовет сначала первого       друга, то он съесть по одной тарелке еды $$$1$$$ и $$$2$$$, а       следовательно другому другу ничего не останется.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1369/problem/E' title='Codeforces Round 652 (Div. 2)'>1369E - DeadLee</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>$$$\mathcal Complete\;\mathcal Solution$$$ :</p>     <p>Define $$$s_i$$$ equal to the number of friends who likes food       $$$i$$$. We want to proof that if $$$\forall 1 \le i \le m       \Rightarrow s_i &gt; w_i\, \text{or} \, s_i = 0$$$ then no answer       exist, it can be proved easily by contradiction, just look at the       last friend in any suitable permutation, he will eat Lee as there       is no food for him.</p>     <p>So if it was the case, then print <span class="tex-font-style-tt">Dead</span> and terminate, otherwise       place all the guys who likes food $$$i$$$ in the end of the       permutation, they wont eat Lee as they can always eat food       $$$i$$$, also it's always better to place them in the end, as if       we place them in the end, then they wont eat two plates. Continue       the process until no friends exist or no $$$i$$$ exist such that       $$$w_i \ge s_i &gt; 0$$$.</p>     <p>Note that when we erase the friends, we have to update $$$s_i$$$,       also if $$$s_i = 0$$$ we should erase food $$$i$$$ from the set of foods.</p>     <p>$$$\mathcal Implementation\;\mathcal Details$$$ :</p>     <p>Instead of erasing friends/foods, just remember if a friend/food       is erased or not using another array. Also updating $$$s$$$ should       not be that much hard(when marking $$$i$$$-th friend, decrease       $$$s_{x_i}$$$ and $$$s_{y_i}$$$ by one, if there exist any), also       you can have the food $$$i$$$ with maximum $$$w_i-s_i$$$ with a       priority queue, or any other data structure in $$$O(\log_2{n})$$$.</p>     <p>The whole solution will work in $$$O((n+m)\cdot \log_2{(n+m)}$$$       time, you can also try achieving $$$O(n+m)$$$ and then show-off it       in the comment section ^_^.</p></div></div></div>

           
            <pre><code>import sys
import heapq

inputarray = [int(x) for x in sys.stdin.read().split()]

n, m = inputarray[0], inputarray[1]

s, w = [], []
for i in range(2, n+2):
    w.append(inputarray[i])

g, eg, foodm, friendm, x, y = [], [], [], [], [], []

for i in range(n):
    s.append(0)
    foodm.append(0)
    g.append([])

for i in range(m):
    friendm.append(0)
    x.append(0)
    y.append(0)
    
inppo = n+2
for i in range(m):
    x[i], y[i] = inputarray[inppo], inputarray[inppo+1]
    inppo = inppo+2
    x[i] = x[i]-1
    y[i] = y[i]-1
    u = x[i]
    v = y[i]
    s[u] = s[u]+1
    s[v] = s[v]+1
    g[u].append(i)
    g[v].append(i)
    eg.append((v, u))

myq = []

ans = []

for i in range(n):
    heapq.heappush(myq, (-w[i]+s[i], i))

while len(myq): 
    u = myq[0]
    heapq.heappop(myq)
    if u[0] != -w[u[1]]+s[u[1]]:
        continue
    if(u[0] &gt; 0):
        print(&#34;DEAD&#34;)
        sys.exit()
    foodm[u[1]] = 1
    sw = 1
    for i in g[u[1]]:
        if friendm[i] == 0:
            friendm[i] = 1
            if y[i] == u[1]:
                x[i], y[i] = y[i], x[i]
            s[x[i]] = s[x[i]]-1
            s[y[i]] = s[y[i]]-1
            heapq.heappush(myq, (-w[y[i]]+s[y[i]], y[i]))
            ans.append(i)
            if(len(ans) == m):
                sw = 0
                break;
    if(sw == 0):
        break
print(&#34;ALIVE&#34;)
for i in ans[::-1]:
    print(i+1, end=&#34; &#34;)

</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;

#define ll long long
#define fr first
#define sc second
#define pii pair&lt;int, int&gt;
#define all(v) v.begin(), v.end()

using namespace std;
const int MN = 2e5+7;

int x[MN], y[MN], s[MN], w[MN], mark[MN], colmark[MN];

vector&lt;int&gt; v[MN], a;
vector&lt;pii&gt; f;

priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;

signed main(){
    ios::sync_with_stdio(false);
    cin.tie();
    cout.tie();
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i++)cin &gt;&gt; w[i];
    for(int i = 0; i &lt; m; i++){
        cin &gt;&gt; x[i] &gt;&gt; y[i];
        s[x[i]]++;
        s[y[i]]++;
        v[x[i]].push_back(i);
        v[y[i]].push_back(i);
    }
    for(int i = 1; i &lt;= n; i++){
        if(s[i])pq.push({max(0, s[i]-w[i]), i});
        else colmark[i] = 1;
    }

    while(pq.size()){
        auto q = pq.top();
        pq.pop();
        if(q.fr != max(0, s[q.sc]-w[q.sc]))continue;
        if(q.fr &gt; 0){
            cout &lt;&lt; &#34;DEAD\n&#34;;
            exit(0);
        }
        int id = q.sc;
        vector&lt;int&gt; wt;
        for(auto u : v[id]){
            if(mark[u])continue;
            a.push_back(u);
            if(x[u] == id)
                swap(x[u], y[u]);
            if(!colmark[x[u]])wt.push_back(x[u]);
            mark[u] = 1;
        }
        sort(all(wt));
        for(int i = 0; i &lt; wt.size(); i++){
            s[wt[i]]--;
            if(i == wt.size()-1 || wt[i+1] != wt[i]){
                if(s[wt[i]]){
                    if(max(0, s[wt[i]]-w[wt[i]]) == 0)colmark[wt[i]] = 1;
                    pq.push({max(0, s[wt[i]]-w[wt[i]]), wt[i]});
                }
            }
        }
    }
    cout &lt;&lt; &#34;ALIVE\n&#34;;
    for(int i = 0; i &lt; a.size()/2; i++)swap(a[i], a[a.size()-i-1]);
    for(auto u : a){
        cout &lt;&lt; u+1 &lt;&lt; &#39; &#39;;
    }
    cout &lt;&lt; &#39;\n&#39;;
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #652 (Div. 2)
    1369F
    ПобедитеЛи </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. ПобедитеЛи</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>       <span class="tex-font-style-it">Ли предпочитает завершать свои         истории стильно, но не в этот раз. Благо, Белый Медведь успел         придти к нему на помощь. В благодарность, Ли решил показать         Белому его новую игру под названием «Critic»...</span></p>     <p>Данная игра — один на один. Она состоит из $$$t$$$ раундов,       каждый раунд определяется двумя целыми числами $$$s_i$$$ и       $$$e_i$$$ (которые определены заранее и известны перед началом       игры, $$$s_i$$$ и $$$e_i$$$ могут отличаться от раунда к раунду).       В начале соответствующего раунда число $$$s_i$$$ написано на       доске. </p>     <p>Игроки ходят по очереди. Каждый игрок стирает число на доске       (назовем его $$$a$$$) и выбирает, что написать: $$$2 \cdot a$$$       или $$$a + 1$$$. Тот, кто напишет на доске число строго больше чем       $$$e_i$$$, проигрывает.</p>     <p>Сейчас Ли хочет сыграть в «Critic» против Белого, и для каждого       раунда он уже выбрал соответствующие $$$s_i$$$ и $$$e_i$$$. Ли       начинает первый раунд, и проигравший текущего раунда будет       начинать в следующем раунде.</p>     <p>Победитель последнего раунда считается победителем всей игры, а       проигравший, соответственно, проигравшим всей игры.</p>     <p>Определите, может ли Ли победить независимо от действий Белого.       Также, определите, может ли он проиграть независимо от действий Белого.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке задано единственное целое число $$$t$$$ ($$$1 \le       t \le 10^5$$$) — количество раундов в игре.</p>     <p>В следующих $$$t$$$ строках заданы по два целых числа $$$s_i$$$ и       $$$e_i$$$ ($$$1 \le s_i \le e_i \le 10^{18}$$$) — информация про       $$$i$$$-й раунд.</p>     <p>Раунды играются в том порядке, как они заданы во входных данных,       $$$s_i$$$ и $$$e_i$$$ для всех раундов известны всем до начала игры.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите два числа.</p>     <p>Первым числом выведите <span class="tex-font-style-tt">1</span>,       если Ли может победить независимо от действий Белого, иначе       выведите <span class="tex-font-style-tt">0</span>.</p>     <p>Вторым числом выведите <span class="tex-font-style-tt">1</span>,       если Ли может проиграть независимо от действий Белого, иначе       выведите <span class="tex-font-style-tt">0</span>.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
5 8
1 4
3 10
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1 1
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
1 2
2 3
3 4
4 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0 0
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
1
1 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0 1
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
1 9
4 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0 0
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
1 2
2 8
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1 0
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
216986951114298167 235031205335543871
148302405431848579 455670351549314242
506251128322958430 575521452907339082
1 768614336404564650
189336074809158272 622104412002885672
588320087414024192 662540324268197150
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1 0
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Напоминаем, проигрывает тот, кто напишет число строго больше чем $$$e_i$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1369/problem/F' title='Codeforces Round 652 (Div. 2)'>1369F - BareLee</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>$$$\mathcal Complete \mathcal Proof$$$ :</p>     <p>Define $$$w_{s,\,e}$$$ ($$$s \le e$$$) equal to $$$1$$$ if Lee       can win the game when $$$s$$$ is written on the board, and equal       to $$$0$$$ otherwise, also define $$$l_{s,\,e}$$$ the same way.       This leads to a simple dp. Forget $$$l$$$ for now.</p>     <p>Recall that a state $$${i,\,j}$$$ of our dp is a <span class="tex-font-style-it">losing state</span> if $$$w_{i,\,j} =       0$$$, and is a <span class="tex-font-style-it">winning       state</span> otherwise.</p>     <p>You can guess $$$w_{s,\,e}$$$ for all $$$s$$$ in range $$$\frac e       4 &lt; s \le e$$$ in $$$O(1)$$$, you don't have to store them :</p>     <p>If $$$e$$$ is odd then it will be $$$w_{1,\,e} = 1, w{2,\,e} = 0,       w{3,\,e} = 1 \dots w{e,\,e} = 0$$$, in other words if $$$e$$$ is       odd, then if $$$s$$$ is odd too $$$w{s,\,e} = 0$$$, otherwise       $$$w{s,\,e} = 1$$$. Prove it by induction, for $$$s = e$$$ it's       correct, assume that for an integer $$$i$$$ ($$$1 \le i &lt; e$$$)       we have proved that the statement is correct for all $$$j$$$ where       $$$i &lt; j \le e$$$, now we want to prove the statement for       $$$i$$$ :</p>     <p>If $$$i$$$ is odd then both $$$i + 1$$$ and $$$2 \cdot i$$$ are         <span class="tex-font-style-it">winning states</span> (as they       are even), also if $$$i$$$ is even then $$$i + 1$$$ is odd,       $$$i+1$$$ is smaller than $$$e$$$ so it's a losing state(induction assumption).</p>     <p>From now we consider $$$e$$$ to be even. Also $$$\times 2$$$       operation is replacing $$$a$$$, the number on the board, with $$$2       \cdot a$$$, and $$$+ 1$$$ operation is the other move.</p>     <p>For $$$\frac e 2 &lt; s \le e$$$ whoever uses $$$\times 2$$$       operation will lose. So they all have to use $$$+ 1$$$ operation,       so for $$${e \over 2} &lt; s \le e$$$ if $$$w$$$ is odd, then       $$$w_{s,\,e} = 1$$$, otherwise $$$w_{s,\,e} = 0$$$. (it's obvious,       it can be proved with a simple induction like the one in previous part)</p>     <p>For $$${e \over 4} &lt; s \le {e \over 2}$$$, Lee can do a       $$$\times 2$$$ operation in the first turn and he will win because       his opponent is starting a <span class="tex-font-style-it">losing state</span>.</p>     <p>For $$$s \le {e \over 4}$$$, $$$w_{s,\,e}$$$ is equal to       $$$\displaystyle w_{s,\,\lfloor {e \over 4} \rfloor}$$$. (why?)</p>     <p>Now it's time to calculate $$$l_{s,\,e}$$$.</p>     <p>Remember, whoever writes an integer greater than $$$e$$$ will       lose, so if $$$e &lt; 2 \cdot s$$$ then the first guy can       immediately lose. So $$$l_{s,\,e}$$$ for $$${e \over 2} &lt; s \le       e$$$ is equal to $$$1$$$. And $$$l_{s,\,e}$$$ for $$$s \le {e       \over 2}$$$ is equal to $$$\displaystyle w_{s,\,{\lfloor {e \over       2} \rfloor}}$$$. (why?)</p></div></div></div>

           
            <pre><code>import sys

inpy = [int(x) for x in sys.stdin.read().split()]

def win(s, e) :
    if e == s :
        return False
    if e == s+1 :
        return True
    if e % 2 == 1 :
        if s % 2 == 1 :
            return False
        return True
    q = e//4
    
    if s &lt;= q :
        return win(s, q)
    q = e//2
    if(s &gt; q) :
        return (e-s) % 2 == 1
    return True

def lose(s, e) :
    q = e//2
    if(s &gt; q) :
        return True
    else :
        return win(s, q)

t = inpy[0]
start = (True, False)
inpo = 1
v = (True, True)

for tc in range(t):
    if(inpo+1 &gt;= len(inpy)) :
        print(&#39;wtf&#39;)
    s, e = inpy[inpo], inpy[inpo+1]
    inpo = inpo+2
    v = ((win(s, e), lose(s, e)))
    if start[0] and start[1] :
        break
    if (not start[0]) and (not start[1]) :
        break
    if start[1] :
        v = (not v[0], not v[1])
    start = (v[1], v[0])

if((start[0] != True and start[0] != False) or (start[1] != True and start[1] != False)) :
    print(&#39;wtf&#39;)
sw = 2
if start[1] :
    sw = sw-1
    print(1, end = &#39; &#39;)
else :
    sw = sw-1
    print(0, end = &#39; &#39;)
if start[0] :
    print(1)
    sw = sw-1
else :
    print(0)
    sw = sw-1
if sw :
    print(wtf)

</code></pre>
           
            <pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#define fr first
#define sc second
#define ll long long
#define int ll

using namespace std;

const int MN = 1e5+7;

pair&lt;int, int&gt; c[MN];

int chk(ll s, ll e){
    if(e == s)return 0;
    if(e == s+1)return 1;
    if(e &amp; 1){
        if(s &amp; 1)return 0;
        return 1;
    }
    if(s &lt;= e/4)
        return chk(s, e/4);
    if(s &gt; (e/4)*2)return ((e-s)&amp;1);
    else return 1;
}

int lck(ll s, ll e){
    if(s*2 &gt; e)return 1;
    int w = e/2 + 3;
    while(w*2 &gt; e)w--;
    return chk(s, w);
}

signed main(){
    ios::sync_with_stdio(false);
    cin.tie();
    cout.tie();

    int n;
    cin &gt;&gt; n;

    for(int i = 0; i &lt; n; i++){
        ll x, y;
        cin &gt;&gt; x &gt;&gt; y;
        c[i] = {chk(x, y), lck(x, y)};
    }

    int f = 1;
    int s = 0;
    for(int i = 0; i &lt; n; i++){
        if(f == 1 &amp;&amp; s == 1)break;
        if(f == 0 &amp;&amp; s == 0)break;
        if(s == 1) c[i].fr^=1, c[i].sc^=1;
        f = c[i].sc;
        s = c[i].fr;
    }
    cout &lt;&lt; s &lt;&lt; &#39; &#39; &lt;&lt; f &lt;&lt; &#39;\n&#39;;
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #651 (Div. 2)
    1370A
    Максимальный НОД </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Максимальный НОД</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Рассмотрим все целые числа в промежутке от $$$1$$$ до $$$n$$$ (включительно).</p>     <p>По всем парам <span class="tex-font-style-bf">различных</span>       целых чисел из этого промежутка, найдите максимальное возможное       значение наибольшего общего делителя чисел в паре. Более       формально, найдите максимальное значение $$$\mathrm{gcd}(a, b)$$$       по всем $$$1 \leq a &lt; b \leq n$$$.</p>     <p>Наибольшим общим делителем $$$\mathrm{gcd}(a, b)$$$ пары       положительных целых чисел $$$a$$$ и $$$b$$$ называется наибольшее       целое число, являющееся делителем числа $$$a$$$ и делителем числа $$$b$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке находится единственное целое число $$$t$$$ ($$$1       \leq t \leq 100$$$)  — количество наборов входных данных. Описание       наборов входных данных следует.</p>     <p>В единственной строке описания каждого набора входных данных       находится единственное целое число $$$n$$$ ($$$2 \leq n \leq 10^6$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных, выведите максимальное значение       $$$\mathrm{gcd}(a, b)$$$ по всем $$$1 \leq a &lt; b \leq n$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
3
5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
2
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных $$$\mathrm{gcd}(1, 2) =       \mathrm{gcd}(2, 3) = \mathrm{gcd}(1, 3) = 1$$$.</p>     <p>Во втором наборе входных данных $$$2$$$ является максимальным       возможным значением, соответствующим $$$\mathrm{gcd}(2, 4)$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1370/problem/A' title='Codeforces Round 651 (Div. 2)'>1370A - Maximum GCD</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>       <span class="tex-font-style-bf">Key Idea</span>:</p>     <p>Answer for any $$$n \ge 2$$$ is equal to       $$$\lfloor{\frac{n}{2}}\rfloor$$$ .</p>     <p>       <span class="tex-font-style-bf">Solution</span>:</p>     <p>Let the maximum gcd be equal to $$$g$$$. Since the two numbers in       a pair are distinct, one of them must be $$$\gt g$$$ and both of       them must be divisible by $$$g$$$. The smallest multiple of       $$$g$$$, greater than $$$g$$$, is $$$2 \cdot g$$$. Since each       number in the pair must be $$$\le n$$$, we must have $$$2 \cdot g       \le n$$$, or $$$g \le \lfloor{\frac{n}{2}}\rfloor$$$. We can       achieve $$$g = \lfloor{\frac{n}{2}}\rfloor$$$, by choosing $$$       \lfloor{\frac{n}{2}}\rfloor$$$ and $$$2 \cdot \lfloor{\frac{n}{2}}\rfloor$$$.</p>     <p>Time Complexity: $$$O(1)$$$</p></div></div></div>

           
            <pre><code>
#include &lt; bits/stdc++.h &gt;
using namespace std;
 
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define endl &#34;\n&#34;
#define int long long

const int N = 1e5 + 5;

int32_t main()
{
	IOS;
	int t;
	cin &gt;&gt; t;
	while(t--)
	{
		int n;
		cin &gt;&gt; n;
		cout &lt;&lt; n / 2 &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #651 (Div. 2)
    1370B
    Сжатие массива и НОД </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Сжатие массива и НОД</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У Ashish есть массив $$$a$$$, состоящий из $$$2n$$$ положительных       целых чисел. Он хочет сжать массив $$$a$$$ в массив $$$b$$$       размера $$$n-1$$$. Чтобы это сделать, он сначала выбирает ровно       $$$2$$$ (любые два) элемента массива $$$a$$$ и удаляет их из       массива. После этого он выполняет следующую операцию, пока массив       $$$a$$$ не пустой:</p>          <ul> <li> удалить любые два элемента из массива $$$a$$$ и добавить         их сумму в массив $$$b$$$. </li></ul>          <p>Получившийся массив $$$b$$$ должен удовлетворять одному условию.       Наибольший общий делитель ($$$\mathrm{gcd}$$$) всех элементов       массива должен быть больше $$$1$$$.</p>     <p>Напомним, что наибольший общий делитель ($$$\mathrm{gcd}$$$)       массива положительных целых чисел равен наибольшему целому числу,       которое является делителем всех элементов массива.</p>     <p>Можно доказать, что всегда можно таким образом сжать массив       $$$a$$$ в массив $$$b$$$ размера $$$n-1$$$, так что $$$gcd(b_1,       b_2..., b_{n-1}) &gt; 1$$$.</p>     <p>Помогите Ashish найти способ это сделать.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке находится единственное целое число $$$t$$$ ($$$1       \leq t \leq 10$$$)  — количество наборов входных данных. Описание       наборов входных данных следует.</p>     <p>В первой строке описания каждого набора входных данных находится       единственное целое число $$$n$$$ ($$$2 \leq n \leq 1000$$$).</p>     <p>Во второй строке описания каждого набора входных данных находится       $$$2n$$$ целых чисел $$$a_1, a_2, \ldots, a_{2n}$$$ ($$$1 \leq a_i       \leq 1000$$$)  — элементы массива $$$a$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных, выведите $$$n-1$$$ строку  —       выполненные операции, чтобы сжать массив $$$a$$$ в массив $$$b$$$.         <span class="tex-font-style-bf">Изначальное удаление двух         элементов не является операцией и про это действие не нужно         ничего выводить.</span></p>     <p>В $$$i$$$-й из этих строк должно находиться два целых числа,       индексы (нумерация с $$$1$$$) двух элементов массива $$$a$$$,       которые используются в $$$i$$$-й операции. Все $$$2n-2$$$       выведенных индекса должны быть различными целыми числами от       $$$1$$$ до $$$2n$$$.</p>     <p>Вам не нужно выводить индексы двух изначально удаленных элементов       из массива $$$a$$$.</p>     <p>Если есть несколько возможных ответов, вы можете найти любой.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
3
1 2 3 4 5 6
2
5 7 9 10
5
1 3 3 4 5 90 100 101 2 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3 6
4 5
3 4
1 9
2 3
4 5
6 10
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных $$$b = \{3+6, 4+5\} = \{9, 9\}$$$       и $$$\mathrm{gcd}(9, 9) = 9$$$.</p>     <p>Во втором наборе входных данных $$$b = \{9+10\} = \{19\}$$$ и       $$$\mathrm{gcd}(19) = 19$$$.</p>     <p>В третьем наборе входных данных $$$b = \{1+2, 3+3, 4+5, 90+3\} =       \{3, 6, 9, 93\}$$$ и $$$\mathrm{gcd}(3, 6, 9, 93) = 3$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1370/problem/B' title='Codeforces Round 651 (Div. 2)'>1370B - GCD Compression</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>       <span class="tex-font-style-bf">Key Idea</span>:</p>     <p>It is always possible to form $$$n-1$$$ pairs of elements such       that their gcd is divisible by $$$2$$$.</p>     <p>       <span class="tex-font-style-bf">Solution</span>:</p>     <p>We can pair up the odd numbers and even numbers separately so       that the sum of numbers in each pair is divisible by $$$2$$$. Note       that we can always form $$$n - 1$$$ pairs in the above manner       because in the worst case, we would discard one odd number and one       even number from $$$a$$$. If we discarded more than one even or       odd numbers, we could instead form another pair with even sum.</p>     <p>Time Complexity: $$$O(n)$$$</p></div></div></div>

           
            <pre><code>
#include &lt; bits/stdc++.h &gt;
using namespace std;
 
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define endl &#34;\n&#34;
#define int long long

const int N = 2e5 + 5;

int n;
int a[N];

int32_t main()
{
	IOS;
	int t;
	cin &gt;&gt; t;
	while(t--)
	{
		cin &gt;&gt; n;
		vector&lt; int &gt; even, odd;
		for(int i = 1; i &lt;= 2 * n; i++)
		{
			cin &gt;&gt; a[i];
			if(a[i] % 2)
				odd.push_back(i);
			else
				even.push_back(i);
		}
		vector&lt; pair&lt; int, int &gt; &gt; ans;
		for(int i = 0; i + 1 &lt; odd.size(); i += 2)
			ans.push_back({odd[i], odd[i + 1]});
		for(int i = 0; i + 1 &lt; even.size(); i += 2)
			ans.push_back({even[i], even[i + 1]});
		for(int i = 0; i &lt; n - 1; i++)
			cout &lt;&lt; ans[i].first &lt;&lt; &#34; &#34; &lt;&lt; ans[i].second &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #651 (Div. 2)
    1370C
    Игра с числом </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Игра с числом</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Ashishgup и FastestFinger играют в игру. </p>     <p>Они начинают с целого числа $$$n$$$ и начинают делать ходы по       очереди. На каждом ходу игрок может сделать <span class="tex-font-style-bf">любой из</span> следующих двух ходов:</p>          <ul> <li> Разделить $$$n$$$ на один из его нечетных делителей,         который больше чем $$$1$$$. </li>       <li> Вычесть $$$1$$$ из $$$n$$$, если $$$n$$$ больше чем $$$1$$$. </li></ul>          <p>Обратите внимание, что множество делителей числа включает само число.</p>     <p>Если игрок <span class="tex-font-style-bf">не может сделать       ход</span> он проигрывает игру.</p>     <p>Ashishgup ходит первым. Определите победителя игры, если оба       игрока играют оптимально.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке находится единственное целое число $$$t$$$ ($$$1       \leq t \leq 100$$$)  — количество наборов входных данных. Описание       наборов входных данных следует.</p>     <p>В единственной строке описания каждого набора входных данных       находится единственное целое число $$$n$$$ ($$$1 \leq n \leq 10^9$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных, выведите «<span class="tex-font-style-tt">Ashishgup</span>», если он побеждает в       игре и «<span class="tex-font-style-tt">FastestFinger</span>»       иначе (без кавычек).</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
7
1
2
3
4
5
6
12
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
FastestFinger
Ashishgup
Ashishgup
FastestFinger
Ashishgup
FastestFinger
Ashishgup
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных $$$n = 1$$$ и Ashishgup не может       сделать ход. Он проигрывает.</p>     <p>Во втором наборе входных данных $$$n = 2$$$ и Ashishgup вычитает       $$$1$$$ на первом ходу. Теперь $$$n = 1$$$ и FastestFinger не       может сделать ход, поэтому он проигрывает.</p>     <p>В третьем наборе входных данных $$$n = 3$$$ и Ashishgup делит на       $$$3$$$ на первом ходу. Теперь $$$n = 1$$$ и FastestFinger не       может сделать ход, поэтому он проигрывает.</p>     <p>В последнем наборе входных данных $$$n = 12$$$ и Ashishgup делит       на $$$3$$$ на первом ходу. Теперь $$$n = 4$$$, FastestFinger может       только вычесть $$$1$$$ и Ashishgup получает число $$$3$$$.       Наконец, он побеждает после деления этого числа на $$$3$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1370/problem/C' title='Codeforces Round 651 (Div. 2)'>1370C - Number Game</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>       <span class="tex-font-style-bf">Key Idea</span>:</p>     <p>       <span class="tex-font-style-tt">FastestFinger</span> wins for       $$$n=1$$$ , $$$n=2^x$$$ where ($$$x&gt;1$$$) and $$$n= 2 \cdot       p$$$ where $$$p$$$ is a prime $$$\ge 3$$$ else <span class="tex-font-style-tt">Ashishgup</span> wins.</p>     <p>       <span class="tex-font-style-bf">Solution</span>:</p>     <p>Let's analyse the problem for the following $$$3$$$ cases: </p>     <ul>                     <li> Case $$$1$$$: n is odd         <p>Here <span class="tex-font-style-tt">Ashishgup</span> can           divide $$$n$$$ by itself, since it is odd and hence           $$$\frac{n}{n} = 1$$$, and <span class="tex-font-style-tt">FastestFinger</span> loses. Here           $$$n = 1$$$ is an exception.</p>         </li>       <li> Case $$$2$$$: $$$n$$$ is even and has no odd divisors greater         than $$$1$$$         <p>Here $$$n$$$ is of the form $$$2^x$$$. As $$$n$$$ has no odd           divisors greater than $$$1$$$, <span class="tex-font-style-tt">Ashishgup</span> is forced to           subtract it by $$$1$$$ making $$$n$$$ odd. So if $$$x &gt;           1$$$, <span class="tex-font-style-tt">FastestFinger</span>           wins. For $$$x = 1$$$, $$$n - 1$$$ is equal to $$$1$$$, so             <span class="tex-font-style-tt">Ashishgup</span> wins. </p>         </li>       <li> Case $$$3$$$: $$$n$$$ is even and has odd divisors         <p>If $$$n$$$ is divisible by $$$4$$$ then <span class="tex-font-style-tt">Ashishgup</span> can divide $$$n$$$           by its largest odd factor after which $$$n$$$ becomes of the           form $$$2^x$$$ where $$$x \gt 1$$$, so <span class="tex-font-style-tt">Ashishgup</span> wins. </p>         <p>Otherwise $$$n$$$ must be of the form $$$2 \cdot p$$$, where           $$$p$$$ is odd. If $$$p$$$ is prime, <span class="tex-font-style-tt">Ashishgup</span> loses since he can           either reduce $$$n$$$ by $$$1$$$ or divide it by $$$p$$$ both           of which would be losing for him. If $$$p$$$ is not prime then           $$$p$$$ must be of the form $$$p_1 \cdot p_2$$$ where           $$$p_1$$$ is prime and $$$p_2$$$ is any odd number $$$\gt           1$$$. <span class="tex-font-style-tt">Ashishgup</span> can win           by dividing $$$n$$$ by $$$p_2$$$. </p></li></ul></div></div></div>

           
            <pre><code>
#include&lt; bits/stdc++.h &gt;
using namespace std;

const int N = 50000;

void player_1(){
	cout &lt;&lt; &#34;Ashishgup&#34; &lt;&lt; endl;
}

void player_2(){
	cout &lt;&lt; &#34;FastestFinger&#34; &lt;&lt; endl;
}

bool check_prime(int n){
	for(int i = 2; i &lt; min(N, n); i++)
		if(n % i == 0)
			return 0;
	return 1;
}

int main(){
	int tc;
	cin &gt;&gt; tc;
	while(tc--){
		int n;
		cin &gt;&gt; n;
		bool lose = (n == 1);
		if(n &gt; 2 &amp;&amp; n % 2 == 0){
			if((n &amp; (n — 1)) == 0)
				lose = 1;
			else if(n % 4 != 0 &amp;&amp; check_prime(n / 2))
				lose = 1;
		}
		if(lose)
			player_2();
		else player_1();
	}
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #651 (Div. 2)
    1370D
    Чет-нечет подпоследовательность </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Чет-нечет подпоследовательность</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У Ashish есть массив $$$a$$$ размера $$$n$$$.</p>     <p>Подпоследовательность массива $$$a$$$ определяется, как       последовательность, которая может быть получена из $$$a$$$ с       помощью удаления некоторых элементов (возможно нуля) без изменения       порядка оставшихся элементов.</p>     <p>Рассмотрим подпоследовательность $$$s$$$ массива $$$a$$$. Он       определяет цену подпоследовательности $$$s$$$ как минимум между:</p>          <ul> <li> Максимумом по всем числам, стоящим на нечетных позициях в         $$$s$$$. </li>       <li> Максимумом по всем числам, стоящим на четных позициях в         $$$s$$$. </li></ul>          <p>Обратите внимание, что индекс числа определяется, как его индекс       в $$$s$$$, независимо от его индекса в $$$a$$$. Все позиции       нумеруются с $$$1$$$. Другими словами, цена $$$s$$$ равна       $$$min(max(s_1, s_3, s_5, \ldots), max(s_2, s_4, s_6, \ldots))$$$.</p>     <p>Например, цена последовательности $$$\{7, 5, 6\}$$$ равна $$$min(       max(7, 6), max(5) ) = min(7, 5) = 5$$$.</p>     <p>Помогите ему найти минимальную цену какой-то       подпоследовательности размера $$$k$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке находится два целых числа $$$n$$$ и $$$k$$$ ($$$2       \leq k \leq n \leq 2 \cdot 10^5$$$)  — размер массива $$$a$$$ и       размер подпоследовательности.</p>     <p>В следующей строке находится $$$n$$$ целых чисел $$$a_1, a_2,       \ldots, a_n$$$ ($$$1 \leq a_i \leq 10^9$$$)  — элементы массива $$$a$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите единственное целое число  — минимальную цену       подпоследовательности размера $$$k$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4 2
1 2 3 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
4 3
1 2 3 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5 3
5 3 4 2 6
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
6 4
5 3 50 2 4 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом тесте, рассмотрим подпоследовательность $$$s$$$ =       $$$\{1, 3\}$$$. Здесь цена подпоследовательности равна       $$$min(max(1), max(3)) = 1$$$.</p>     <p>Во втором тесте, рассмотрим подпоследовательность $$$s$$$ =       $$$\{1, 2, 4\}$$$. Здесь цена подпоследовательности равна       $$$min(max(1, 4), max(2)) = 2$$$.</p>     <p>В четвертом тесте, рассмотрим подпоследовательность $$$s$$$ =       $$$\{3, 50, 2, 4\}$$$. Здесь цена подпоследовательности равна       $$$min(max(3, 2), max(50, 4)) = 3$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1370/problem/D' title='Codeforces Round 651 (Div. 2)'>1370D - Odd-Even Subsequence</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>       <span class="tex-font-style-bf">Key Idea</span>:</p>     <p>Binary search over the answer and check if given $$$x$$$, it is       possible to form a subsequence of length at least $$$k$$$ such       that either all elements at odd indices or even indices are $$$\le x$$$.</p>     <p>       <span class="tex-font-style-bf">Solution</span>:</p>     <p>Let us binary search over the answer and fix if the answer comes       from elements at odd or even indices in the subsequence. Suppose       we want to find if there exists a subsequence of length at least       $$$k$$$ such that the elements at odd indices are $$$\le x$$$. We       will construct the subsequence greedily. </p>     <p>Let's iterate on the array from left to right. Suppose we are at       index $$$i$$$ in the array and the current length of the       subsequence formed is $$$l$$$. If $$$l$$$ is odd, the next added       element would be at an even index. In this case, we do not care       about what this element is as we only want elements at odd indices       to be $$$\le x$$$. So, in this case, we add $$$a_i$$$ to the       subsequence. If $$$l$$$ is even, then the next added element would       be at an odd index, so, it must be $$$\le x$$$. If $$$a_i \le       x$$$, we can add $$$a_i$$$ to the subsequence, otherwise we do not       add $$$a_i$$$ to the subsequence and continue to the next element       in $$$a$$$.</p>     <p>Note that we can do a similar greedy construction for elements at       even indices. If the length of the subsequence formed is $$$\ge       k$$$ (either by construction from odd indices or even indices),       then the answer can be equal to $$$x$$$ and we can reduce the       upper bound of the binary search otherwise we increase the lower bound.</p>     <p>Time Complexity - $$$O(n \cdot log_2 (A_i))$$$ or $$$O(n \cdot       log_2 (n))$$$</p></div></div></div>

           
            <pre><code>

#include &lt; bits/stdc++.h &gt;
using namespace std;
 
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define endl &#34;\n&#34;
#define int long long

const int N = 2e5 + 5;

int n, k;
int a[N];

bool check(int x, int cur)
{
	int ans = 0;
	for(int i = 1; i &lt;= n; i++)
	{
		if(!cur)
		{
			ans++;
			cur ^= 1;
		}
		else
		{
			if(a[i] &lt;= x)
			{
				ans++;
				cur ^= 1;
			}
		}
	}
	return ans &gt;= k;
}

int binsearch(int lo, int hi)
{
	while(lo &lt; hi)
	{
		int mid = (lo + hi) / 2;
		if(check(mid, 0) || check(mid, 1))
			hi = mid;
		else
			lo = mid + 1;
	}
	return lo;
}

int32_t main()
{
	IOS;
	cin &gt;&gt; n &gt;&gt; k;
	for(int i = 1; i &lt;= n; i++)
		cin &gt;&gt; a[i];
	int ans = binsearch(1, 1e9);
	cout &lt;&lt; ans;
	return 0;
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #651 (Div. 2)
    1370E
    Сдвиги подпоследовательностей </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. Сдвиги подпоследовательностей</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У Naman есть две бинарные строки $$$s$$$ и $$$t$$$ длины $$$n$$$       (бинарной строкой называется строка, состоящая из символов «<span class="tex-font-style-tt">0</span>» и «<span class="tex-font-style-tt">1</span>»). Он хочет сделать из строки       $$$s$$$ строку $$$t$$$ используя следующую операцию как можно       меньшее количество раз.</p>     <p>За одну операцию, он может выбрать некоторую       подпоследовательность $$$s$$$ и сдвинуть символы на позициях этой       подпоследовательности по часовой стрелке один раз.</p>     <p>Например, если $$$s = 1\textbf{1}101\textbf{00}$$$, он может       выбрать подпоследовательность, соответствущую позициям (нумерация       с $$$1$$$) $$$\{2, 6, 7 \}$$$ и сдвинуть символы на этих позициях       один раз по часовой стрелке. В результате строка, которая       получится, будет $$$s = 1\textbf{0}101\textbf{10}$$$.</p>     <p>Строка $$$a$$$ называется подпоследовательностью строки $$$b$$$,       если $$$a$$$ может быть получена из $$$b$$$ с помощью удаления       некоторых символов без изменения порядка оставшихся символов.</p>     <p>Для того, чтобы сделать сдвиг последовательности $$$c$$$ размера       $$$k$$$ по часовой стрелке один раз, нужно сделать следующие       замены символов $$$c_1:=c_k, c_2:=c_1, c_3:=c_2, \ldots,       c_k:=c_{k-1}$$$ одновременно.</p>     <p>Определите минимальное число операций, которое необходимо сделать       Naman, чтобы получить из строки $$$s$$$ строку $$$t$$$ или       определите, что это сделать невозможно.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке находится единственное целое число $$$n$$$ $$$(1       \le n \le 10^6)$$$ — длина строк.</p>     <p>Во второй строке находится бинарная строка $$$s$$$ длины $$$n$$$.</p>     <p>В третьей строке находится бинарная строка $$$t$$$ длины $$$n$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Если невозможно получить из строки $$$s$$$ строку $$$t$$$ после       применения любого числа операций, выведите $$$-1$$$.</p>     <p>Иначе выведите минимальное количество операций, которое для этого требуется.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
010000
000001
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
10
1111100000
0000011111
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
5</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
8
10101010
01010101
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
10
1111100000
1111100001
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
-1</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом тесте, Naman может выбрать подпоследовательность,       соответствующую позициям $$$\{2, 6\}$$$ и сдвинуть символы строки,       на этих позициях один раз по часовой стрелке. В результате, он       сможет получить из строки $$$s$$$ строку $$$t$$$ за одну операцию.</p>     <p>Во втором тесте, он может сделать операцию на       подпоследовательности из всех индексов $$$5$$$ раз подряд. Можно       доказать, что это минимальное необходимое количество операций.</p>     <p>В последнем тесте, невозможно получить из строки $$$s$$$ строку $$$t$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1370/problem/E' title='Codeforces Round 651 (Div. 2)'>1370E - Binary Subsequence Rotation</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>       <span class="tex-font-style-bf">Key Idea:</span></p>     <p>Firstly, if $$$s$$$ is not an anagram of $$$t$$$, it is       impossible to convert $$$s$$$ to $$$t$$$ - since total number of       $$$0$$$s and $$$1$$$s are conserved. However, if they are       anagrams, we can always convert $$$s$$$ to $$$t$$$.</p>     <p>We can ignore all the indices where $$$s_i = t_i$$$ as it is       never optimal to include those indices in a rotation. The       remaining indices must be satisfy $$$s_i = 0, t_i = 1$$$ or $$$s_i       = 1, t_i = 0$$$. In the optimal answer, the chosen subsequences       should be of the form <span class="tex-font-style-tt">01010101...</span> or <span class="tex-font-style-tt">10101010..</span>.</p>     <p>       <span class="tex-font-style-bf">Solution:</span></p>     <p>There are many approaches to solving the problem, all revolving       around the key idea. We can greedily find the minimum number of       chains of alternating <span class="tex-font-style-tt">0</span> and         <span class="tex-font-style-tt">1</span> that the string can be       broken down into  — using faster ways of simulation, such as a       counter-based for loop or using sets and deleting successive       indices, etc.</p>     <p>However, we will discuss an elegant approach which allows us to       solve the problem and also prove its optimality. Moreover, it       allows us to solve the problem for queries of the form $$$(l,       r)$$$ - which denotes the answer for the strings $$$s[l,r]$$$ and       $$$t[l,r]$$$ respectively.</p>     <p>Logic: Let's create an array $$$a$$$ with values from $$$(-1, 0,       1)$$$ as follows: </p>     <ul> <li> If $$$s_i = t_i$$$, $$$a_i = 0$$$ </li>       <li> Else if $$$s_i = 1$$$, $$$a_i = 1$$$ </li>       <li> Else $$$a_i = -1$$$         </li></ul> Then the answer is equal to the maximum     absolute value of the sum of any subarray in $$$a$$$, that is,     $$$\max(|$$$ $$$\sum\limits_{i = l}^r a_i$$$ $$$ |)$$$ $$$(1 \le l     \le r \le n$$$).     <p>Proof: </p>     <ul> <li> The chosen subsequences must be of the form <span class="tex-font-style-tt">01010101</span> or <span class="tex-font-style-tt">10101010</span> (alternating <span class="tex-font-style-tt">0</span>s and <span class="tex-font-style-tt">1</span>s). If there are two         consecutive $$$0$$$s or $$$1$$$s we can remove any one of them         as applying the rotation operation could only affect one of them.         </li>       <li> The maximum absolute value of subarray sum in $$$a$$$ is a         lower bound on the answer. Let the sum of any subarray in         $$$a$$$ be $$$c$$$. We can assume that $$$c \ge 0$$$ (otherwise         we can interchange $$$1$$$ and $$$-1$$$). In any move, $$$c$$$         cannot be reduced by more than $$$1$$$, since we must choose         subsequences of the form <span class="tex-font-style-tt">010101</span> or <span class="tex-font-style-tt">101010</span>.          </li>       <li> We can achieve the above lower bound, and hence it is the         answer. To prove the claim, we just need to show that in every         operation, we can reduce the value of maximum absolute subarray         sum by $$$1$$$ (if there are multiple such subarrays, then we         must reduce all of them by $$$1$$$).          </li>       <li> For the above, a key realization is: suppose the maximum         comes from a subarray $$$(l, r)$$$ with a positive sum. Then it         is necessary that on both sides of its endpoints if there is an         element, it must be $$$-1$$$ (we can ignore the $$$0$$$s), since         if either side had a $$$+1$$$, we would have a higher valued         subarray. Now we can pick any $$$1$$$ from this subarray and a         $$$-1$$$ either from its left or right to reduce its sum by         $$$1$$$, thus completing the proof. (Note that any subarray with         maximum absolute sum must have at least one element with sign         opposite to its sum either to its left or right.) </li></ul>          <p>Time complexity: $$$O(n)$$$</p></div></div></div>

           
            <pre><code>
#include &lt; bits/stdc++.h &gt;
using namespace std;
 
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define endl &#34;\n&#34;
#define int long long

const int N = 1e6 + 5;

int n;
string s, t;
int a[N];

int get(int x)
{
	int cur = 0, mx = 0;
	for(int i = 1; i &lt;= n; i++)
	{
		cur += x * a[i];
		mx = max(mx, cur);
		if(cur &lt; 0)
			cur = 0;
	}
	return mx;
}

int32_t main()
{
	IOS;
	cin &gt;&gt; n &gt;&gt; s &gt;&gt; t;
	int sum = 0;
	for(int i = 1; i &lt;= n; i++)
	{
		if(s[i - 1] != t[i - 1])
		{
			if(s[i - 1] == &#39;1&#39;)
				a[i] = -1;
			else
				a[i] = 1;
		}
		sum += a[i];
	}
	if(sum != 0)
	{
		cout &lt;&lt; -1;
		return 0;
	}
	int ans = max(get(1), get(-1));
	cout &lt;&lt; ans;
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #654 (Div. 2)
    1371A
    Волшебные палочки </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Волшебные палочки</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У пингвина Rocher есть $$$n$$$ палочек — у него ровно одна       палочка длины $$$i$$$ для всех $$$1 \le i \le n$$$.</p>     <p>Он может соединять некоторые палочки. Если он соединяет две       палочки, которые имеют длины $$$a$$$ и $$$b$$$, он получает одну       палочку длины $$$a + b$$$. Две палочки, которые были использованы       в этой операции, пропадают из его множества. Новая соединенная       палочка появляется в его множестве и может быть использована в       следующих соединениях.</p>     <p>Он хочет создать максимальное количество палочек, имеющих       одинаковую длину. Не обязательно при этом, чтобы в итоге все       палочки имели одинаковую длину — некоторые палочки могут иметь       другие длины. Какое максимальное количество палочек одинаковой       длины он может получить в итоге?</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Каждый тест состоит из нескольких наборов входных данных. В       первой строке находится единственное целое число $$$t$$$ ($$$1 \le       t \le 1000$$$) — количество наборов входных данных. Следующие       $$$t$$$ строк содержат описания наборов входных данных.</p>     <p>Для каждого набора входных данных в единственной строке находится       единственное целое число $$$n$$$ ($$$1 \le n \le 10^{9}$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите единственное целое       число  — ответ на задачу.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
1
2
3
4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
1
2
2
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В третьем наборе входных данных он может соединить две палочки       длины $$$1$$$ и $$$2$$$ и он получит одну палочку длины $$$3$$$.       Так он получит две палочки одинаковой длины $$$3$$$.</p>     <p>В четвертом наборе входных данных он может соединить две палочки       длины $$$1$$$ и $$$3$$$ и он получит одну палочку длины $$$4$$$.       После этого у него будет три палочки, имеющие длины $$$\{2, 4,       4\}$$$. Две палочки имеют одинаковую длину и она палочка будет       иметь другую длину.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1371/problem/A' title='Codeforces Round 654 (Div. 2)'>1371A - Magical Sticks</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Output $$$\lceil \frac{n}{2} \rceil$$$.</p>          <ul> <li> When $$$n$$$ is even, we can create $$$1+n = 2+(n-1) =         3+(n-2) = ...$$$ </li>       <li> When $$$n$$$ is odd, we can create $$$n = 1+(n-1) = 2+(n-2) =         ...$$$ </li></ul>          <p>Initially, there are only $$$1$$$ stick which has length $$$i (1       \le i \le n)$$$. If we connect $$$2$$$ sticks $$$s_1$$$ and       $$$s_2$$$, after that, there is a stick which has a different       length from $$$s_1$$$ and $$$s_2$$$. Then, we can create at most       $$$1 + \lfloor \frac{n-1}{2} \rfloor$$$ sticks that have the same       length. The value is equal to $$$\lceil \frac{n}{2} \rceil$$$.</p>     <p>Total complexity: $$$O(1)$$$</p></div></div></div>

           
            <pre><code>#include&lt;stdio.h&gt;

int main(){
  long long n,t;
  scanf(&#34;%lld&#34;,&amp;t);
  while(t&gt;0){
    t--;
    scanf(&#34;%lld&#34;,&amp;n);
    if(n%2){printf(&#34;%lld\n&#34;,(n/2)+1);}
    else{printf(&#34;%lld\n&#34;,n/2);}
  }
  return 0;
}</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #654 (Div. 2)
    1371B
    Магический календарь </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Магический календарь</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Профессиональный едок Алиса ставит в расписание в своем       магическом календаре тренировки для подготовки к очередному       контесту по поеданию. Календарь необычен тем, что неделя не       обязательно может состоять из $$$7$$$ дней!</p>     <p>Более точно, она может выбрать целое число $$$k$$$, которое       удовлетворяет $$$1 \leq k \leq r$$$ и выставить, что неделя       состоит из $$$k$$$ дней.</p>     <p>Алиса собирается закрасить некоторые $$$n$$$ последовательных       дней в календаре. В этом календаре недели соответсвуют строкам и       идут подряд слева направо. Для последнего дня недели первая клетка       следующей (снизу) строки соотвествует следующему дню.</p>     <p>Она хочет, чтобы <span class="tex-font-style-bf">все закрашенные         клетки были связны по сторонам</span>. Это означает, что для       любых двух закрашенных клеток, должна существовать как минимум       одна последовательность закрашенных клеток, начинающаяся в одной       из этих клеток и заканчивающаяся в другой, что любые две соседние       клетки в этой последовательности имеют общую сторону.</p>     <p>Алиса рассматривает форму закрашенных клеток. Две формы являются       одинаковыми, если можно совместить их <span class="tex-font-style-bf">только с помощью параллельных         переносов, паралельных сторонам календаря (то есть перемещая         вверх-вниз и вправо-влево)</span>.</p>     <p>Например, на картинке неделя состоит из $$$4$$$ дней и Алиса       закрашивает $$$5$$$ последовательных дней. [1] и [2] имеют       различную форму, но [1] и [3] имеют одинаковую форму.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/b8aba909c2b00c956b657be3cd83668d52b3cc9e.png" style="max-width: 100.0%;max-height: 100.0%;"/>   </center>          <p>Алисе интересно узнать <span class="tex-font-style-bf">какое         количество различных форм</span> существует <span class="tex-font-style-bf">если она установит из скольки дней         состоит неделя и выберет последовательные $$$n$$$ дней и         закрасит их в календаре, начиная в какой-то день недели</span>.       Как уже было сказано до этого, она рассматривает только формы, где       все закрашенные клетки связны по сторонам.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Каждый тест состоит из нескольких наборов входных данных. В       первой строке находится единственное целое число $$$t$$$ ($$$1 \le       t \le 1000$$$) — количество наборов входных данных. Следующие       $$$t$$$ строк содержат описания набов входных данных.</p>     <p>Для каждого набора входных данных в единственной строке находится       два целых числа $$$n$$$, $$$r$$$ ($$$1 \le n \le 10^9, 1 \le r \le 10^9$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите единственное целое       число  — ответ на задачу.</p>     <p>Обратите внимание, что ответ на некоторые наборы входных данных       не влезает в $$$32$$$-битный целочисленный тип, поэтому вы должны       использовать как минимум $$$64$$$-битный целочисленный тип вашего       языка программирования.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
3 4
3 2
3 1
13 7
1010000 9999999
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
4
3
1
28
510049495001
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных Алиса может выбрать $$$1,2,3$$$       или $$$4$$$ дня, как количество дней, которое будет в неделе.</p>     <p>Всего есть $$$6$$$ возможных раскрасок, которые изображены на       рисунке, но среди них есть только $$$4$$$ различные формы.       Поэтому, ответ равен $$$4$$$. Обратите внимание, что <span class="tex-font-style-bf">последний пример на картинке это         некорректная раскраска</span>, потому что не все клетки связны       по сторонам.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/400bb1c5b641e72da448c36d8c87308dfe29233c.png" style="max-width: 100.0%;max-height: 100.0%;"/>   </center>          <p>В последнем наборе входных данных будьте аккуратны с возможным       переполнением, описанном в формате выходных данных.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1371/problem/B' title='Codeforces Round 654 (Div. 2)'>1371B - Magical Calendar</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>First, let's consider in case of a week has exactly $$$w$$$ days.</p>          <ul> <li> If $$$w&lt;n$$$ , the length of painted cells is strictly         more than one week. So there are $$$w$$$ valid shapes. (The         first week contains $$$1,2,...,w$$$ days) The shapes have         $$$w$$$-day width, then if the value of $$$w$$$ are different,         the shapes are also different. </li>       <li> Otherwise $$$(n \le w)$$$ , there is only one valid liner         pattern. The shape is insensitive to the chosen value of         $$$w$$$. </li></ul>          <p>We can sum up this for $$$1 \le w \le r$$$, by using following       well-known formula: $$$a+(a+1)+(a+2)+...+b = \frac{(a+b)*(b-a+1)}{2}$$$</p>     <p>Total complexity : $$$O(1)$$$</p></div></div></div>

           
            <pre><code>#include&lt;stdio.h&gt;

int main(){
  long long n,l=1,r,t,res;
  scanf(&#34;%lld&#34;,&amp;t);
  while(t&gt;0){
    t--;
    res=0;
    scanf(&#34;%lld%lld&#34;,&amp;n,&amp;r);
    if(n&lt;=l){printf(&#34;1\n&#34;);continue;}
    if(n&lt;=r){r=n-1;res=1;}
    printf(&#34;%lld\n&#34;,res+((l+r)*(r-l+1))/2);
  }
  return 0;
}</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #654 (Div. 2)
    1371C
    Печенье для тебя </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Печенье для тебя</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Анна очень смелая девочка, ее любят все в городе. Также все       горожане обожают ее печенье. Она планирует провести вечеринку с       печеньем. Сейчас у нее есть $$$a$$$ единиц ванильного печенья и       $$$b$$$ единиц шоколадного печенья для вечеринки.</p>     <p>Она пригласит $$$n$$$ гостей первого типа и $$$m$$$ гостей       второго типа на вечеринку. Они придут на вечеринку в некотором       порядке. После того, как они придут на вечеринку, каждый гость       выберет один из двух типов печенья (ванильное или шоколадное),       чтобы съесть. Есть различие в том, как гости выбирают тип печенья:</p>     <p>Если всего $$$v$$$ единиц ванильного печенья и $$$c$$$ единиц       шоколадного печенья в момент, когда гость приходит, тогда</p>          <ul> <li> если гость первого типа: если $$$v&gt;c$$$ гость выбирает           <span class="tex-font-style-bf">ванильное</span> печенье.         Иначе, гость выбирает <span class="tex-font-style-bf">шоколадное</span> печенье. </li>       <li> если гость второго типа: если $$$v&gt;c$$$ гость выбирает           <span class="tex-font-style-bf">шоколадное</span> печенье.         Иначе, гость выбирает <span class="tex-font-style-bf">ванильное</span> печенье. </li></ul>          <p>После этого:</p>          <ul> <li> Если есть хотя бы одна единица выбранного типа печенья,         гость съедает одну. </li>       <li> Иначе (если не осталось печенья выбранного типа), гость         остается голодным и уходит домой. </li></ul>          <p>Анна хочет узнать, существует ли какой-то порядок гостей, такой       что <span class="tex-font-style-bf">ни один гость не останется       голодным</span>. Ваша задача состоит в том, чтобы ответить на ее вопрос.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Каждый тест состоит из нескольких наборов входных данных. В       первой строке находится единственное целое число $$$t$$$ ($$$1 \le       t \le 1000$$$) — количество наборов входных данных. Следующие       $$$t$$$ строк содержат описания набов входных данных.</p>     <p>Для каждого набора входных данных в единственной строке находится       четыре целых числа $$$a$$$, $$$b$$$, $$$n$$$, $$$m$$$ ($$$0 \le       a,b,n,m \le 10^{18}, n+m \neq 0$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных, выведите ответ в одной строке.       Если есть хотя бы один подходящий порядок гостей, выведите «<span class="tex-font-style-tt">Yes</span>». Иначе, выведите «<span class="tex-font-style-tt">No</span>».</p>     <p>Вы можете выводить каждый символ в любом регистре (верхнем или нижнем).</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
2 2 1 2
0 100 0 1
12 13 25 1
27 83 14 25
0 0 1 0
1000000000000000000 1000000000000000000 1000000000000000000 1000000000000000000
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
Yes
No
No
Yes
No
Yes
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных рассмотрим порядок $$$\{1, 2,       2\}$$$ типов гостей. Тогда:</p>          <ul> <li> Первый гость съедает шоколадное печенье. После этого         остается $$$2$$$ единицы ванильного печенья и $$$1$$$ единица         шоколадного печенья. </li>       <li> Второй гость съедает шоколадное печенье. После этого остается         $$$2$$$ единицы ванильного печенья и $$$0$$$ единиц шоколадного         печенья. </li>       <li> Последний гость выбирает шоколадное печенье, чтобы съесть, но         больше не осталось шоколадного печенья. Поэтому гость остается         голодным. </li></ul>          <p>Поэтому такой порядок гостей Анна выбрать не может.</p>     <p>Рассмотрим порядок $$$\{2, 2, 1\}$$$ типов гостей. Тогда:</p>          <ul> <li> Первый гость съедает ванильное печенье. После этого         остается $$$1$$$ единица ванильного печенья и $$$2$$$ единицы         шоколадного печенья. </li>       <li> Второй гость съедает ванильное печенье. После этого остается         $$$0$$$ единиц ванильного печенья и $$$2$$$ единицы шоколадного         печенья. </li>       <li> Последний гость съедает шоколадное печенье. После этого         остается $$$0$$$ единиц ванильного печенья и $$$1$$$ единица         шоколадного печенья. </li></ul>          <p>Поэтому ответ для этого набора входных данных «<span class="tex-font-style-tt">Yes</span>».</p>     <p>В пятом наборе входных данных можно увидеть, что количество       единиц печенья ($$$a + b$$$) может быть равно нулю, но количество       гостей ($$$n + m$$$) никогда не равно нулю.</p>     <p>В шестом наборе входных данных будьте осторожны с переполнением       $$$32$$$-битного целочисленного типа.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1371/problem/C' title='Codeforces Round 654 (Div. 2)'>1371C - A Cookie for You</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>If $$$m &lt; \min (a,b) , n+m \le a+b$$$ are satisfied, the       answer is &quot;<span class="tex-font-style-tt">Yes</span>&quot;.       Otherwise, the answer is &quot;<span class="tex-font-style-tt">No</span>&quot;. Let's proof it.</p>     <p>Of course, $$$n+m \le a+b$$$ must be satisfied, because violating       this inequality means lack of cookies.</p>     <p>When a type $$$2$$$ guest comes, or when $$$a=b$$$, the value of       $$$\min(a,b)$$$ is decremented by $$$1$$$. </p>     <p>You need to consider only about the case that all type $$$2$$$       guests come first and after that all type $$$1$$$ guests come,       because if there is a type $$$1$$$ guest before a type $$$2$$$       guest, swapping them is better to make no one angry. (Because if       there is a type $$$1$$$ guest before a type $$$2$$$ guest, the       type $$$1$$$ guest have a possibility to decrease the value of       $$$min(a,b)$$$ unnecessarily.)</p>     <p>At last, all of type $$$1$$$ guests eat one cookie when there is       at least one cookie(both types are ok).</p>     <p>Total complexity: $$$O(1)$$$</p></div></div></div>

           
            <pre><code>#include&lt;stdio.h&gt;

int main(){
  long long t,a,b,n,m,k;
  scanf(&#34;%lld&#34;,&amp;t);
  while(t&gt;0){
    t--;
    scanf(&#34;%lld%lld%lld%lld&#34;,&amp;a,&amp;b,&amp;n,&amp;m);
    if(a&gt;b){k=a;a=b;b=k;}
    if(a&lt;m){printf(&#34;No\n&#34;);continue;}
    if(a+b&lt;n+m){printf(&#34;No\n&#34;);continue;}
    printf(&#34;Yes\n&#34;);
  }
}</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #654 (Div. 2)
    1371D
    Таблица-00100 </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Таблица-00100</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Безумный ученый Dr.Jubal придумал задачу по программированию.       Попробуйте решить ее!</p>     <p>Вам даны целые числа $$$n,k$$$. Постройте таблицу $$$A$$$,       имеющую размер $$$n \times n$$$ и <span class="tex-font-style-bf">состоящую из целых чисел $$$0$$$ или       $$$1$$$</span>. Должно быть выполнено очень важное условие: сумма       всех элементов в таблице равна $$$k$$$. Другими словами,       количество чисел $$$1$$$ в таблице равно $$$k$$$.</p>     <p>Давайте определим:</p>          <ul> <li> $$$A_{i,j}$$$ как число, стоящее в $$$i$$$-й строке и         $$$j$$$-м столбце. </li>       <li> $$$R_i = A_{i,1}+A_{i,2}+...+A_{i,n}$$$ (для всех $$$1 \le i         \le n$$$). </li>       <li> $$$C_j = A_{1,j}+A_{2,j}+...+A_{n,j}$$$ (для всех $$$1 \le j         \le n$$$). </li>       <li> Другими словами, $$$R_i$$$ это суммы чисел в строках и         $$$C_j$$$ это суммы чисел в столбцах таблицы $$$A$$$. </li>       <li> Для таблицы $$$A$$$ определим значение $$$f(A) =         (\max(R)-\min(R))^2 + (\max(C)-\min(C))^2$$$ (здесь для         последовательности целых чисел $$$X$$$ мы определяем         $$$\max(X)$$$ как максимальное число в $$$X$$$ и $$$\min(X)$$$         как минимальное число в $$$X$$$). </li></ul>          <p>Найдите любую таблицу $$$A$$$, удовлетворяющую описанному       условию. Среди всех таких таблиц найдите такую, для которой       значение $$$f(A)$$$ минимально возможное. Среди всех таких таблиц       найдите любую.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Каждый тест состоит из нескольких наборов входных данных. В       первой строке находится единственное целое число $$$t$$$ ($$$1 \le       t \le 100$$$) — количество наборов входных данных. Следующие       $$$t$$$ строк содержат описания набов входных данных.</p>     <p>Для каждого набора входных данных в единственной строке находится       два целых числа $$$n$$$, $$$k$$$ $$$(1 \le n \le 300, 0 \le k \le n^2)$$$.</p>     <p>Гарантируется, что сумма $$$n^2$$$ по всем наборам входных данных       не превосходит $$$10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных сначала выведите минимальное       возможное значение $$$f(A)$$$ среди всех таблиц, для которых       условие выполнено.</p>     <p>После этого, выведите $$$n$$$ строк, каждая содержит по $$$n$$$       символов. $$$j$$$-й символ в $$$i$$$-й строке должен быть равен $$$A_{i,j}$$$.</p>     <p>Если есть несколько возможных решений, вы можете вывести любое.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
2 2
3 8
1 0
4 16
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
10
01
2
111
111
101
0
0
0
1111
1111
1111
1111
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных сумма всех чисел таблицы равна       $$$2$$$, поэтому условие выполнено. $$$R_1 = 1, R_2 = 1$$$ и       $$$C_1 = 1, C_2 = 1$$$. Тогда $$$f(A) = (1-1)^2 + (1-1)^2 = 0$$$,       что является минимальным возможным значением $$$f(A)$$$.</p>     <p>Во втором наборе входных данных сумма всех чисел таблицы равна       $$$8$$$, значит условие выполнено. $$$R_1 = 3, R_2 = 3, R_3 = 2$$$       и $$$C_1 = 3, C_2 = 2, C_3 = 3$$$. Тогда $$$f(A) = (3-2)^2 +       (3-2)^2 = 2$$$. Можно доказать, что это минимальное возможное       значение $$$f(A)$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1371/problem/D' title='Codeforces Round 654 (Div. 2)'>1371D - Grid-00100</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>We can construct a grid $$$A$$$ which has $$$f(A)=0$$$ if       $$$k\%n=0$$$ , $$$f(A)=2(1^2+1^2)$$$ otherwise (the values are       smallest almost obviously.) in following method:</p>     <p>First, initialize $$$A_{i,j}=0$$$ for all $$$i,j$$$. Then, change       a $$$0$$$ into $$$1$$$ $$$k$$$ times by using following pseudo code:</p>     <p> <span class="tex-font-style-tt">let p=0 , q=0</span></p>     <p>     <span class="tex-font-style-tt">for i = 1..k</span></p>     <p>         <span class="tex-font-style-tt">Change A[p+1][q+1] into 1</span></p>     <p>         <span class="tex-font-style-tt">let p=(p+1) , q=(q+1)%n</span></p>     <p>         <span class="tex-font-style-tt">if(p==n)</span></p>     <p>             <span class="tex-font-style-tt">let p=0 , q=(q+1)%n</span></p>     <p> Total complexity : $$$O(n^2)$$$</p></div></div></div>

           
            <pre><code>#include&lt;stdio.h&gt;

int main(){
  int n,k,t,i,j,p,q;
  char res[305][305];
  scanf(&#34;%d&#34;,&amp;t);
  while(t&gt;0){
    t--;
    scanf(&#34;%d%d&#34;,&amp;n,&amp;k);
    if(k%n==0){printf(&#34;0\n&#34;);}
    else{printf(&#34;2\n&#34;);}
    for(i=0;i&lt;n;i++){
      for(j=0;j&lt;n;j++){
        res[i][j]=&#39;0&#39;;
      }
      res[i][n]=0;
    }
    p=0;q=0;
    while(k&gt;0){
      k--;
      res[p][q]=&#39;1&#39;;
      p++;q++;q%=n;
      if(p==n){
        p=0;q++;q%=n;
      }
    }
    for(i=0;i&lt;n;i++){
      printf(&#34;%s\n&#34;,res[i]);
    }
  }
}</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #654 (Div. 2)
    1371F
    Яростный гром </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Яростный гром</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>3 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вы воин, который собирается победить бога Тора.</p>     <p>Тор бросил вам вызов, предложив вам решить следующую задачу:</p>     <p>В ряд находится $$$n$$$ конвееров, пронумерованных целыми числами       от $$$1$$$ до $$$n$$$ слева направо. Каждый конвеер показывает       один из двух символов «<span class="tex-font-style-tt">&lt;</span>» или «<span class="tex-font-style-tt">&gt;</span>». Начальное состояние       конвеера $$$i$$$ задается $$$i$$$-м символом строки $$$s$$$. Всего       есть $$$n+1$$$ ямка. Они пронумерованы целыми числами от $$$0$$$       до $$$n$$$. Ямка $$$0$$$ находится слева от конвеера $$$1$$$, для       всех $$$i \geq 1$$$ ямка $$$i$$$ находится справа от конвеера $$$i$$$.</p>     <p>Когда мячик попадает на конвеер с номером $$$i$$$, он       перемещается по следующим правилам:</p>     <p>Если на конвеере $$$i$$$ символ «<span class="tex-font-style-tt">&lt;</span>», тогда:</p>          <ul> <li> Если $$$i=1$$$, то мячик падает в ямку $$$0$$$. </li>       <li> Если на конвеере $$$i-1$$$ символ «<span class="tex-font-style-tt">&lt;</span>», то мячик перемещается на         конвеер $$$i-1$$$. </li>       <li> Если на конвеере $$$i-1$$$ символ «<span class="tex-font-style-tt">&gt;</span>», то мячик падает в ямку         $$$i-1$$$. </li></ul>          <p>Если на конвеере $$$i$$$ символ «<span class="tex-font-style-tt">&gt;</span>», тогда:</p>          <ul> <li> Если $$$i=n$$$, то мячик падает в ямку $$$n$$$. </li>       <li> Если на конвеере $$$i+1$$$ символ «<span class="tex-font-style-tt">&gt;</span>», то мячик перемещается на         конвеер $$$i+1$$$. </li>       <li> Если на конвеере $$$i+1$$$ символ «<span class="tex-font-style-tt">&lt;</span>», то мячик падает в ямку         $$$i$$$. </li></ul>          <p>Вы должны ответить на следующие $$$q$$$ запросов, каждый из       которых задается парой целых чисел $$$l, r$$$ ($$$1 \leq l \leq r       \leq n$$$): </p>     <ul> <li> Сначала, на всех конвеерах $$$l,l+1,...,r$$$ символ «<span class="tex-font-style-tt">&lt;</span>» изменяется на «<span class="tex-font-style-tt">&gt;</span>» и наоборот. <span class="tex-font-style-bf">Эти изменения сохраняются в           следующих запросах.</span> </li>       <li> После этого, положите <span class="tex-font-style-bf">один         мячик</span> на каждый конвеер $$$l,l+1,...,r$$$. Затем, каждый         мячик упадет в какую-то ямку. Найдите максимальное количество         мячиков, которое окажется в какой-то ямке. <span class="tex-font-style-bf">После ответа на запрос, мячики           пропадают и не учитываются в следующих запросах.</span> </li></ul></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке находится два целых числа $$$n$$$, $$$q$$$ ($$$1       \le n \le 5 \times 10^5 , 1 \le q \le 10^5$$$).</p>     <p>Во второй строке находится строка $$$s$$$ длины $$$n$$$. Она       состоит их символов «<span class="tex-font-style-tt">&lt;</span>»       и «<span class="tex-font-style-tt">&gt;</span>».</p>     <p>В следующих $$$q$$$ строках содержится описание запросов,       $$$i$$$-я из этих строк содержит два целых числа $$$l$$$, $$$r$$$       $$$(1 \le l \le r \le n)$$$, описывающих $$$i$$$-й запрос.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$q$$$ строк, в $$$i$$$-й строке выведите ответ на       $$$i$$$-й запрос.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5 6
&gt;&lt;&gt;&gt;&lt;
2 4
3 5
1 5
1 3
2 4
1 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
3
5
3
2
3
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>               <ul> <li> В первом запросе, состояния конвееров меняются на «<span class="tex-font-style-tt">&gt;&gt;&lt;&lt;&lt;</span>». После         этого, мы кладем по одному мячику на конвееры $$$\{2,3,4\}$$$.         Все три мячика упадут в ямку $$$2$$$. Поэтому ответ равен         $$$3$$$. </li>       <li> Во втором запросе, состояния конвееров меняются на «<span class="tex-font-style-tt">&gt;&gt;&gt;&gt;&gt;</span>». После         этого, мы кладем по одному мячику на конвееры $$$\{3,4,5\}$$$.         Все три мячика упадут в ямку $$$5$$$. Поэтому ответ равен         $$$3$$$. </li>       <li> В третьем запросе, состояния конвееров меняются на «<span class="tex-font-style-tt">&lt;&lt;&lt;&lt;&lt;</span>». После         этого, мы кладем по одному мячику на конвееры         $$$\{1,2,3,4,5\}$$$. Все пять мячиков упадут в ямку $$$0$$$.         Поэтому ответ равен $$$5$$$. </li>       <li> В четвертом запросе, состояния конвееров меняются на «<span class="tex-font-style-tt">&gt;&gt;&gt;&lt;&lt;</span>». После         этого, мы кладем по одному мячику на конвееры $$$\{1,2,3\}$$$.         Все три мячика упадут в ямку $$$3$$$. Поэтому ответ равен         $$$3$$$. </li>       <li> В пятом запросе, состояния конвееров меняются на «<span class="tex-font-style-tt">&gt;&lt;&lt;&gt;&lt;</span>». После         этого, мы кладем по одному мячику на конвееры $$$\{2,3,4\}$$$.         Тогда два мячика упало в ямку $$$1$$$ и один мячик упал в ямку         $$$4$$$. Поэтому ответ равен $$$2$$$. </li>       <li> В шестом запросе, состояния конвееров меняются на «<span class="tex-font-style-tt">&lt;&gt;&gt;&lt;&gt;</span>». После         этого, мы кладем по одному мячику на конвееры         $$$\{1,2,3,4,5\}$$$. Тогда три мячика упало в ямку $$$3$$$, один         мячик упал в ямку $$$0$$$ и еще один мячик упал в ямку $$$5$$$.         Поэтому ответ равен $$$3$$$. </li></ul></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1371/problem/F' title='Codeforces Round 654 (Div. 2)'>1371F - Raging Thunder</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>First, observe where the balls fall. When there is a &quot;<span class="tex-font-style-tt">&gt;&gt;&gt;...&gt;&gt;&lt;&lt;...&lt;&lt;&lt;</span>&quot;       structure, the balls on there will fall into one hole. So, our       goal is handling this structure.</p>     <p>Each query is asking about a segment. Then, to solve this       problem, we can use segment tree.</p>     <p>Each node maintains following:</p>          <ul> <li> Prefix structure </li>       <li> Suffix structure </li>       <li> The answer for between above structures </li></ul>          <p>For example, a string &quot;<span class="tex-font-style-tt">&gt;&lt;&lt;&gt;&gt;&lt;&gt;&gt;&lt;&lt;&gt;&gt;&gt;&gt;</span>&quot;       will be converted to the following data:</p>          <ul> <li> Prefix structure : &quot;<span class="tex-font-style-tt">&gt;&lt;&lt;</span>&quot; </li>       <li> Suffix structure : &quot;<span class="tex-font-style-tt">&gt;&gt;&gt;&gt;</span>&quot; </li>       <li> The answer for between above structures : take the answer of           &quot;<span class="tex-font-style-tt">&gt;&gt;&lt;</span>&quot; or           &quot;<span class="tex-font-style-tt">&gt;&gt;&lt;&lt;</span>&quot;. the         largest answer is $$$4$$$. </li></ul>          <p>And we need to implement that combining two data ( [left data] +       [right data] ). Mainly we should merge left suffix and right       prefix, and calculate the answer for the segment, but notice that       there are some exceptions. The exceptions are in case of there are       only one structure in the merged node, like &quot;<span class="tex-font-style-tt">&gt;&gt;&gt;&lt;&lt;</span>&quot; or         &quot;<span class="tex-font-style-tt">&lt;&lt;&lt;</span>&quot;.       (You may maintain other flags for your implement.)</p>     <p>Then, how to handling each queries? We also keep above data for       when '<span class="tex-font-style-tt">&gt;</span>' are changed       into '<span class="tex-font-style-tt">&lt;</span>' and vice versa       on each node of the segment tree. And when a change query actually       comes to some nodes, swap these data. Apply lazy propagation for       handling this. When calculate the answer for a query, don't forget       to consider about the prefix(or the suffix).</p>     <p>Total complexity : $$$O(n + q \log n)$$$</p></div></div></div>

           
            <pre><code>#include&lt;stdio.h&gt;
#include&lt;stdbool.h&gt;
#define ssize 1048576

int max(int a,int b){if(a&gt;b){return a;}return b;}

typedef struct{
  //str[0] = prefix
  //str[1] = suffix
  //str[][0] = &gt;&gt;&gt;&gt;
  //str[][1] = &lt;&lt;&lt;&lt;
  int str[2][2];
  int res;
  int dvd;
}stnode;

stnode stree[2*ssize][2],vd;
int fl[2*ssize];

void stnpr(stnode x,int br){
  printf(&#34;&lt;%d %d %d %d %d : %d&gt;&#34;,x.str[0][0],x.str[0][1],x.str[1][0],x.str[1][1],x.dvd,x.res);
  if(br){printf(&#34;\n&#34;);}
}

stnode merge(stnode l,stnode r){
  stnode res;
  //stnpr(l,0);printf(&#34;+&#34;);stnpr(r,1);
  res.res=max(l.res,r.res);
  if(l.dvd==1&amp;&amp;r.dvd==1){
    res.str[0][0]=l.str[0][0];
    res.str[0][1]=l.str[0][1];
    if(l.str[1][1]!=0 &amp;&amp; r.str[0][0]!=0){
      res.res=max(max(l.str[1][0]+l.str[1][1],r.str[0][0]+r.str[0][1]),res.res);
    }
    else{
      res.res=max(l.str[1][0]+l.str[1][1]+r.str[0][0]+r.str[0][1],res.res);
    }
    res.str[1][0]=r.str[1][0];
    res.str[1][1]=r.str[1][1];
    res.dvd=1;
  }
  else if(l.dvd==1&amp;&amp;r.dvd==0){
    res.str[0][0]=l.str[0][0];
    res.str[0][1]=l.str[0][1];
    if(l.str[1][1]!=0 &amp;&amp; r.str[0][0]!=0){
      res.res=max(l.str[1][0]+l.str[1][1],res.res);
      res.str[1][0]=r.str[0][0];
      res.str[1][1]=r.str[0][1];
    }
    else{
      res.str[1][0]=l.str[1][0]+r.str[0][0];
      res.str[1][1]=l.str[1][1]+r.str[0][1];
    }
    res.dvd=1;
  }
  else if(l.dvd==0&amp;&amp;r.dvd==1){
    if(l.str[0][1]!=0 &amp;&amp; r.str[0][0]!=0){
      res.res=max(r.str[0][0]+r.str[0][1],res.res);
      res.str[0][0]=l.str[0][0];
      res.str[0][1]=l.str[0][1];
    }
    else{
      res.str[0][0]=l.str[0][0]+r.str[0][0];
      res.str[0][1]=l.str[0][1]+r.str[0][1];
    }
    res.str[1][0]=r.str[1][0];
    res.str[1][1]=r.str[1][1];
    res.dvd=1;
  }
  else{
    if(l.str[0][1]!=0&amp;&amp;r.str[0][0]!=0){
      res.str[0][0]=l.str[0][0];
      res.str[0][1]=l.str[0][1];
      res.str[1][0]=r.str[0][0];
      res.str[1][1]=r.str[0][1];
      res.dvd=1;
    }
    else{
      res.str[0][0]=l.str[0][0]+r.str[0][0];
      res.str[0][1]=l.str[0][1]+r.str[0][1];
      res.str[1][0]=0;
      res.str[1][1]=0;
      res.dvd=0;
    }
  }
  //stnpr(res,1);
  return res;
}

void stinit(){
  int i;
  for(i=(ssize-2);i&gt;=0;i--){
    stree[i][0]=merge(stree[i*2+1][0],stree[i*2+2][0]);
    stree[i][1]=merge(stree[i*2+1][1],stree[i*2+2][1]);
  }
  for(i=0;i&lt;2*ssize;i++){
    fl[i]=0;
  }
}

void eval(int k){
  if(fl[k]%2==1){
    //printf(&#34;rev %d\n&#34;,k);
    stnode c;
    c=stree[k][0];
    stree[k][0]=stree[k][1];
    stree[k][1]=c;
    if(k&lt;(ssize-1)){
      fl[k*2+1]++;
      fl[k*2+2]++;
    }
  }
  fl[k]=0;
}

void revquery(int a,int b,int k,int l,int r){
  eval(k);
  if(r&lt;=a || b&lt;=l){return;}
  if(a&lt;=l &amp;&amp; r&lt;=b){
    fl[k]++;
    eval(k);
    return;
  }
  else{
    eval(k*2+1);
    eval(k*2+2);
    revquery(a,b,k*2+1,l,(l+r)/2);
    revquery(a,b,k*2+2,(l+r)/2,r);
    stree[k][0]=merge(stree[k*2+1][0],stree[k*2+2][0]);
    stree[k][1]=merge(stree[k*2+1][1],stree[k*2+2][1]);
    fl[k]=0;
  }
}

stnode getquery(int a,int b,int k,int l,int r){
  //printf(&#34;call %d : [%d , %d) vs [%d , %d)\n&#34;,k,l,r,a,b);
  eval(k);
  if(r&lt;=a || b&lt;=l){return vd;}
  if(a&lt;=l &amp;&amp; r&lt;=b){
    //printf(&#34;%d back:&lt;%d %d %d %d %d : %d&gt;\n&#34;,k,stree[k][0].str[0][0],stree[k][0].str[0][1],stree[k][0].str[1][0],stree[k][0].str[1][1],stree[k][0].dvd,stree[k][0].res);
    return stree[k][0];
  }
  stnode ld,rd;
  ld=getquery(a,b,k*2+1,l,(l+r)/2);
  rd=getquery(a,b,k*2+2,(l+r)/2,r);
  //printf(&#34;%d l:&lt;%d %d %d %d %d : %d&gt;\n&#34;,k,ld.str[0][0],ld.str[0][1],ld.str[1][0],ld.str[1][1],ld.dvd,ld.res);
  //printf(&#34;%d r:&lt;%d %d %d %d %d : %d&gt;\n&#34;,k,rd.str[0][0],rd.str[0][1],rd.str[1][0],rd.str[1][1],rd.dvd,rd.res);
  return merge(ld,rd);
}

int main(){
  vd.str[0][0]=0;vd.str[0][1]=0;
  vd.str[1][0]=0;vd.str[1][1]=0;
  vd.res=0;vd.dvd=0;
  stnode tl,tr;
  tl.str[0][0]=0;tl.str[0][1]=1;
  tl.str[1][0]=0;tl.str[1][1]=0;
  tl.res=0;tl.dvd=0;
  tr.str[0][0]=1;tr.str[0][1]=0;
  tr.str[1][0]=0;tr.str[1][1]=0;
  tr.res=0;tr.dvd=0;
  int n,q,i;
  int l,r,ans;
  stnode res;
  char s[ssize];
  scanf(&#34;%d%d%s&#34;,&amp;n,&amp;q,&amp;s[1]);
  for(i=0;i&lt;2*ssize;i++){
    stree[i][0]=vd;
    stree[i][1]=vd;
  }
  for(i=1;i&lt;=n;i++){
    if(s[i]==&#39;&lt;&#39;){
      stree[i+(ssize-1)][0]=tl;
      stree[i+(ssize-1)][1]=tr;
    }
    else{
      stree[i+(ssize-1)][0]=tr;
      stree[i+(ssize-1)][1]=tl;
    }
  }
  stinit();
  while(q&gt;0){
    q--;
    scanf(&#34;%d%d&#34;,&amp;l,&amp;r);
    revquery(l,r+1,0,0,ssize);
    res=getquery(l,r+1,0,0,ssize);
    //stnpr(res,1);
    ans=max(res.str[0][0]+res.str[0][1],res.str[1][0]+res.str[1][1]);
    ans=max(res.res,ans);
    printf(&#34;%d\n&#34;,ans);
  }
  return 0;
}</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #655 (Div. 2)
    1372A
    Омкар и полнота </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Омкар и полнота</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вы были благословлены как дитя Омкара. Чтобы выразить свою       благодарность, пожалуйста, решите для Омкара эту задачу!</p>     <p>Массив $$$a$$$ длины $$$n$$$ называется <span class="tex-font-style-bf">полным</span>, если все его элементы       положительны, не превышают $$$1000$$$, и для любых трех индексов       $$$x$$$, $$$y$$$, $$$z$$$ ($$$1 \leq x,y,z \leq n$$$),       $$$a_{x}+a_{y} \neq a_{z}$$$ (не обязательно различных).</p>     <p>Вам дано одно целое число $$$n$$$. Найдите <span class="tex-font-style-bf">полный</span> массив длины $$$n$$$.       Гарантируется, что при данных ограничениях решение существует.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Каждый тест содержит несколько наборов входных данных. Первая       строка содержит $$$t$$$ ($$$1 \le t \le 1000$$$)  — количество       наборов входных данных. Описание наборов входных данных приведено ниже.</p>     <p>Единственная строка каждого набора входных данных содержит одно       целое число $$$n$$$ ($$$1 \leq n \leq 1000$$$).</p>     <p>Гарантируется, что сумма $$$n$$$ по всем наборам входных данных       не превышает $$$1000$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите <span class="tex-font-style-bf">полный</span> массив в отдельной строке.       Все элементы должны быть целыми числами между $$$1$$$ и $$$1000$$$       и для любых трех индексов $$$x$$$, $$$y$$$, $$$z$$$ ($$$1 \leq       x,y,z \leq n$$$) (не обязательно различных), должно выполняться       $$$a_{x}+a_{y} \neq a_{z}$$$. </p>     <p>Если существует несколько решений, вы можете вывести любое.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
5
4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1 5 3 77 12
384 384 44 44
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Можно показать, что массивы с примера являются <span class="tex-font-style-bf">полными</span> массивами. Например,       $$$44+44 \neq 384$$$.</p>     <p>Ниже приведены некоторые примеры массивов, которые НЕ <span class="tex-font-style-bf">полные</span> для 1-го теста:</p>     <p>$$$[1,2,3,4,5]$$$ </p>     <p>Обратите внимание, что $$$a_{1}+a_{2} = a_{3}$$$.</p>     <p>$$$[1,3000,1,300,1]$$$ </p>     <p>Обратите внимание, что $$$a_{2} = 3000 &gt; 1000$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1372/problem/A' title='Codeforces Round 655 (Div. 2)'>1372A - Omkar and Completion</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Notice that since all elements must be positive, $$$k \neq 2k$$$.       The most simple construction of this problem is to simply make all       elements equal to $$$1$$$.</p></div></div></div>

           
            <pre><code>import java.util.*

fun main() {
    val jin = Scanner(System.`in`)
    for (c in 1..jin.nextInt()) {
        val n = jin.nextInt()
        for (j in 1..n) {
            print(&#34;1 &#34;)
        }
        println()
    }
}</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #655 (Div. 2)
    1372B
    Омкар и последний урок математики </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Омкар и последний урок математики</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>На последнем уроке математики Омкар он узнал о наименьшем общем       кратном, или $$$HOK$$$. $$$HOK(a, b)$$$  — это наименьшее       положительное целое число $$$x$$$, которое делится и на $$$a$$$ и       на $$$b$$$.</p>     <p>Омкар, обладающий похвально любопытным умом, сразу же подумал о       задаче, связанной с операцией $$$HOK$$$: по целому числу $$$n$$$       найдите положительные целые числа $$$a$$$ и $$$b$$$ такие, что       $$$a + b = n$$$ и $$$HOK(a, b)$$$ принимает минимально возможное значение.</p>     <p>Можете ли вы помочь Омкару решить его смешную математическую задачу?</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Каждый тест содержит несколько наборов входных данных. Первая       строка содержит количество наборов входных данных $$$t$$$ ($$$1       \leq t \leq 10$$$). Описание наборов входных данных приведено ниже.</p>     <p>Каждый набор входных данных состоит из одного целого числа       $$$n$$$ ($$$2 \leq n \leq 10^{9}$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите два положительных       целых числа $$$a$$$ и $$$b$$$ такие, что $$$a + b = n$$$ и       $$$HOK(a, b)$$$ минимально возможный.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
4
6
9
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2 2
3 3
3 6
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Для первого набора входных данных мы можем выбрать числа $$$1,       3$$$ или $$$2, 2$$$. $$$HOK(1, 3) = 3$$$ и $$$HOK(2, 2) = 2$$$,       поэтому мы выводим $$$2 \ 2$$$.</p>     <p>Для второго набора входных данных мы можем выбрать числа $$$1,       5$$$, $$$2, 4$$$ или $$$3, 3$$$. $$$HOK(1, 5) = 5$$$, $$$HOK(2, 4)       = 4$$$ и $$$HOK(3, 3) = 3$$$, поэтому мы выводим $$$3 \ 3$$$.</p>     <p>Для третьего набора входных данных $$$HOK(3, 6) = 6$$$. Можно       показать, что нет других пар чисел с суммой $$$9$$$, имеющих       меньший $$$HOK$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1372/problem/B' title='Codeforces Round 655 (Div. 2)'>1372B - Omkar and Last Class of Math</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Short Solution: The two integers are $$$k$$$ and $$$n-k$$$, where       $$$k$$$ is the largest proper factor of $$$n$$$.</p>     <p>Proof: Let the two integers be $$$k$$$ and $$$n-k$$$. Assume WLOG       that $$$k \leq n-k$$$. Notice that this implies that $$$n - k \geq       \frac n 2$$$.</p>     <p>We first claim that $$$LCM(k, n-k) = n-k &lt; n$$$ if $$$k \mid       n$$$, and we prove this as follows: if $$$k \mid n$$$, then there       exists some integer $$$m$$$ such that $$$m \cdot k = n$$$. The       integer $$$n-k$$$ can then be written as $$$(m-1) \cdot k$$$,       which is a multiple of $$$k$$$. Thus, $$$LCM(k, n-k) = n-k $$$ if       $$$k \mid n$$$.</p>     <p>We now show that $$$LCM(k, n-k) \geq n$$$ if $$$k \nmid n$$$. We       show this by using the fact that $$$LCM(a, b) = b$$$ iff $$$a \mid       b$$$, so if $$$k \nmid n$$$, $$$k \nmid n - k$$$, and so $$$LCM(k,       n-k) \neq n-k$$$. And since $$$LCM(k, n - k)$$$ must be a multiple       of both $$$k$$$ and $$$n - k$$$, it follows that $$$LCM(k, n-k)       \geq 2 \cdot (n-k) \geq 2 \cdot \frac n 2 = n$$$.</p>     <p>We have now established that to minimize $$$LCM(k, n-k)$$$,       $$$k$$$ must be a factor of $$$n$$$. And, since $$$LCM(k, n-k) =       n-k$$$ when $$$k$$$ is a factor of $$$n$$$, we need to minimize       $$$n-k$$$, so we must maximize $$$k$$$ by choosing it to be the       largest proper factor of $$$n$$$ (i. e. the largest factor of       $$$n$$$ other than $$$n$$$).</p>     <p>We then simply need to find $$$k$$$, the largest proper factor of       $$$n$$$. If $$$p$$$ is the smallest prime dividing $$$n$$$, then       $$$k = \frac n p$$$, so it suffices to find the smallest prime       factor of $$$n$$$. We can do this by simply checking all values of       $$$p$$$ such that $$$2 \leq p \leq \sqrt n$$$. If $$$n$$$ is not       prime, then it must have a prime factor not exceeding       $$$\sqrt{n}$$$. Furthermore, if we do not find a factor of $$$n$$$       between $$$2$$$ and $$$\sqrt n$$$, then $$$n$$$ must be prime so       we simply get $$$p = n$$$ and $$$k = \frac n p = 1$$$.</p>     <p>We're given that $$$n \leq 10^9$$$, so $$$\sqrt n \leq 10^{\frac       9 2} &lt; 10^5$$$. $$$t \leq 10$$$, meaning that we will check       less than $$$10^6$$$ numbers, which runs well under the time limit.</p></div></div></div>

           
            <pre><code>fun main() {
    for (c in 1..readLine()!!.toInt()) {
        val n = readLine()!!.toInt()
        var p = 0
        for (m in 2..100000) {
            if (n % m == 0) {
                p = m
                break
            }
        }
        if (p == 0) {
            p = n
        }
        println(&#34;${n / p} ${n - (n / p)}&#34;)
    }
}</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #655 (Div. 2)
    1372C
    Омкар и бейсбол </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Омкар и бейсбол</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Патрик любит играть в бейсбол, но иногда он тратит так много       часов на пробежки, что его разум начинает затуманиваться! Патрик       уверен, что его набранные очки за $$$n$$$ игр соответствуют       тождественной перестановке (т.е. в первой игре он набирает       $$$1$$$, во второй игре он набирает $$$2$$$ и так далее). Однако,       когда он посмотрел на свои записи, он увидел, что все значения перепутаны!</p>     <p>Определим специальный обмен следующим образом: выберите любой       подмассив очков и переставьте местами его элементы так, чтобы ни       один элемент не оказался в той же позиции, где он был до обмена.       Например, выполнение специального обмена на $$$[1,2,3]$$$ может       дать $$$[3,1,2]$$$, но не может дать $$$[3,2,1]$$$, так как       $$$2$$$ находится в той же позиции.</p>     <p>Вам дана перестановка из $$$n$$$ целых чисел. Пожалуйста,       помогите Патрику найти минимальное количество специальных обменов,       необходимых для того, чтобы сделать ее отсортированной! Можно       доказать, что при данных ограничениях это число не превышает $$$10^{18}$$$.</p>     <p>Массив $$$a$$$ является подмассивом массива $$$b$$$, если $$$a$$$       можно получить из $$$b$$$, удалив несколько (возможно, ноль или       все) элементов из начала и несколько (возможно, ноль или все)       элементов с конца.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Каждый тест содержит несколько наборов входных данных. Первая       строка содержит количество наборов входных данных $$$t$$$ ($$$1       \le t \le 100$$$). Описание наборов входных данных приведено ниже.</p>     <p>Первая строка каждого набора входных данных содержит целое число       $$$n$$$ ($$$1 \leq n \leq 2 \cdot 10^5$$$)  — длину данной перестановки.</p>     <p>Вторая строка каждого набора входных данных содержит $$$n$$$       целых чисел $$$a_{1},a_{2},...,a_{n}$$$ ($$$1 \leq a_{i} \leq       n$$$)  — начальную перестановку.</p>     <p>Гарантируется, что сумма $$$n$$$ по всем наборам входных данных       не превышает $$$2 \cdot 10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите одно целое число:       минимальное количество специальных обменов, необходимых для       сортировки перестановки.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
5
1 2 3 4 5
7
3 2 4 5 1 6 7
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
2
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Первая перестановка она уже отсортирована, поэтому обмены не нужны.</p>     <p>Можно показать, что для сортировки второй перестановки нужно как       минимум $$$2$$$ обмена.</p>     <p>$$$[3, 2, 4, 5, 1, 6, 7]$$$</p>     <p>Сделаем специальный обмен для диапазона ($$$1, 5$$$)</p>     <p>$$$[4, 1, 2, 3, 5, 6, 7]$$$</p>     <p>Сделаем специальный обмен для диапазона ($$$1, 4$$$)</p>     <p>$$$[1, 2, 3, 4, 5, 6, 7]$$$</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1372/problem/C' title='Codeforces Round 655 (Div. 2)'>1372C - Omkar and Baseball</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>You need at most $$$2$$$ special exchanges to sort the       permutation. Obviously, $$$0$$$ special exchanges are needed if       the array is already sorted. Let's look into cases in which you       need $$$1$$$ special exchange to sort the array.</p>     <p>Refer to i as a matching index if $$$a_i = i$$$. If there are no       matching indices, then you can just use one special exchange to       sort the entire thing. Otherwise, you can use the location of       matching indices to determine whether you need more than $$$1$$$       special exchange. If all matching indices are located in some       prefix of the permutation, you can sort the permutation with one       special exchange. The same is true for a suffix. In other words,       if you can choose a subarray in the permutation such that all       elements contained in the subarray are NOT matching and the       elements outside of this subarray are matching, then one special       exchange is needed to sort the array.</p>     <p>Otherwise, you need $$$2$$$ special exchanges to sort the       permutation. Let's prove why you do not need more than $$$2$$$       special exchanges. You can quickly check that you need at most       $$$2$$$ special exchanges for all permutations of length $$$\leq       3$$$. For permutations of length $$$\geq 4$$$, I claim that we can       perform $$$2$$$ special exchanges on the whole array; to show this       it suffices to construct a permutation $$$p$$$ that has no       matching indices with either the given permutation or the identity       permutation $$$1, 2, \ldots, n$$$. We can do this as follows:</p>     <p>For simplicity, assume that $$$n$$$ is even. We will assign the       numbers $$$\frac n 2 + 1, \frac n 2 + 2, \ldots, n$$$ to the first       $$$\frac n 2$$$ positions of our permutation $$$p$$$ and the       numbers $$$1, 2, \ldots, \frac n 2$$$ to the last $$$\frac n 2$$$       positions of $$$p$$$. This ensures that $$$p$$$ has no matching       indices with the identity permutation. Then, for all integers       $$$b$$$ such that their position $$$i$$$ in $$$a$$$ (i. e. the       $$$j$$$ such that $$$a_j = b$$$) is in the appropriate half of       $$$p$$$, assign $$$p_i = b$$$; assign other $$$b$$$ to arbitrary       positions in the appropriate half of $$$p$$$. Finally, cyclically       rotate each half of $$$p$$$ – this ensures that $$$p$$$ has no       matching indices with $$$a$$$.</p>     <p>As an example, let's take $$$a = [3, 6, 2, 4, 5, 1]$$$. You can       quickly check that this cannot be done in less than $$$2$$$       special exchanges. The construction of $$$p$$$ goes as follows:</p>     <p>First, we move all numbers to the proper half of $$$p$$$, so that       $$$p = [4, 5, 6, 1, 2, 3]$$$.</p>     <p>Observing that $$$a_2 = 6$$$ and $$$a_6 = 1$$$, we set $$$p_2 =       6$$$ and $$$p_6 = 1$$$ then replace the remaining elements       arbitrarily into the correct half, so we can get, for example,       $$$p = [4, 6, 5, 2, 3, 1]$$$.</p>     <p>Finally, we cyclically rotate each half of $$$p$$$, obtaining       $$$p = [5, 4, 6, 1, 2, 3]$$$, which has no matching indexes with       either $$$a = [3, 6, 2, 4, 5, 1]$$$ or $$$[1, 2, 3, 4, 5, 6]$$$.</p>     <p>This can be extended to odd $$$n$$$ by first choosing some       element other than $$$1$$$ and $$$a_1$$$ to be $$$p_1$$$ (this       works for $$$n \geq 3$$$ and we must have $$$n \geq 5$$$ anyway in       this case), and then running the same algorithm on the rest of $$$p$$$.</p></div></div></div>

           
            <pre><code>import java.io.BufferedReader
import java.io.InputStreamReader

fun main() {
    val jin = BufferedReader(InputStreamReader(System.`in`))
    for (c in 1..jin.readLine().toInt()) {
        val n = jin.readLine().toInt()
        val scores = jin.readLine().split(&#34; &#34;).map { it.toInt() - 1 }
        if ((1 until n).all { scores[it - 1] &lt; scores[it] }) {
            println(0)
        } else {
            var stage = 0
            var answer = 1
            for (j in 0 until n) {
                if (scores[j] == j) {
                    if (stage == 1) {
                        stage = 2
                    }
                } else {
                    if (stage == 0) {
                        stage = 1
                    } else if (stage == 2) {
                        answer = 2
                        break
                    }
                }
            }
            println(answer)
        }
    }
}</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #655 (Div. 2)
    1372D
    Омкар и круг </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Омкар и круг</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Дэнни, местный математик-маньяк, очарован кругами, самым       последним творением Омкара. Помогите ему решить эту задачу о круге!</p>     <p>Вам даны $$$n$$$ неотрицательных целых чисел $$$a_1, a_2, \dots,       a_n$$$, расположенных по кругу, где $$$n$$$ гарантированно будет       нечетным (т.е. $$$n-1$$$ делится на $$$2$$$). Формально для всех       $$$i$$$ таких, что $$$2 \leq i \leq n$$$, элементы $$$a_{i - 1}$$$       и $$$a_i$$$ считаются соседними, а $$$a_n$$$ и $$$a_1$$$ также       рассматриваются как соседние. За одну операцию вы выбираете число       в круге, заменяете его суммой двух соседних элементов, а затем       удаляете два соседних элемента из круга. Это повторяется до тех       пор, пока в круге не останется только одно число, которое мы       называем круговым значением.</p>     <p>Помогите Дэнни найти максимально возможное круговое значение       после некоторой последовательности операций.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит одно нечетное целое число $$$n$$$ ($$$1       \leq n &lt; 2 \cdot 10^5$$$, $$$n$$$ нечетно)  — начальный размер круга.</p>     <p>Вторая строка содержит $$$n$$$ целых чисел       $$$a_{1},a_{2},\dots,a_{n}$$$ ($$$0 \leq a_{i} \leq 10^9$$$)  —       начальные числа в круге.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите максимально возможное круговое значение после применения       некоторой последовательности операций к данному кругу.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
7 10 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
17
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
1
4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
4
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Для первого примера круговое значение $$$17$$$ получается так:</p>     <p>Выберите число с индексом $$$3$$$. Сумма соседних элементов равна       $$$17$$$. Удалите $$$7$$$ и $$$10$$$ из круга и замените $$$2$$$       на $$$17$$$.</p>     <p>Обратите внимание, что ответ может выйти за пределы       $$$32$$$-разрядного целого числа.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1372/problem/D' title='Codeforces Round 655 (Div. 2)'>1372D - Omkar and Circle</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>First note that any possible circular value consists of the sum       of some $$$(n+1)/2$$$ elements. Now let's think about how these       $$$(n+1)/2$$$ values would look like in the circle. </p>     <p>Let's consider any one move on index $$$i$$$. $$$a_i$$$ will be       replaced with the sum of $$$a_{i-1}$$$ and $$$a_{i+1}$$$ (wrap       around to index $$$1$$$ or $$$n$$$ if needed). Then let's consider       making a move on $$$i+2$$$, since it will be adjacent to $$$i$$$       after the first move. Then its value will become       $$$a_{i-1}+a_{i+1}+a_{i+3}$$$. This implies that alternating       values play a role in the construction of the $$$(n+1)/2$$$ values       contained in the final circular value. </p>     <p>Now let's consider the final move when there's $$$3$$$ elements       left in the circle. This is the only move that takes the sum of       two adjacent elements in the initial circle. With this       observation, we can achieve our final construction as follows:</p>     <p>Choose any $$$(n+1)/2$$$ elements in the initial circle such that       exactly one pair of chosen numbers are adjacent to each other. The       answer will be the maximum of the circular value over all possible constructions.</p>     <p>While there are ways involving complicated prefix sums/segment       trees, the cleanest implementation is as follows: create an array       whose values consists of $$$[a_1, a_3, ..., a_n, a_2, a_4, ...,       a_{n-1}]$$$. Append this new array to itself to account for the       circular structure. Now all you simply have to do is to find the       maximum sum over all subarrays of length $$$(n+1)/2$$$. This can       be done with sliding window in $$$O(n)$$$ time.</p></div></div></div>

           
            <pre><code>import kotlin.math.max

fun main() {
    val n = readLine()!!.toInt()
    val m = (n + 1) / 2
    val array = readLine()!!.split(&#34; &#34;).map { it.toLong() }
    var curr = 0L
    for (j in 0 until m) {
        curr += array[2 * j]
    }
    var answer = curr
    for (j in 0..n - 2) {
        curr -= array[(2 * j) % n]
        curr += array[(2 * (j + m)) % n]
        answer = max(answer, curr)
    }
    println(answer)
}</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #655 (Div. 2)
    1372E
    Омкар и последний этаж </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. Омкар и последний этаж</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Омкар строит дом. Он хочет решить, как составить план пола на       последнем этаже.</p>     <p>Пол Омкара изначально выглядит как $$$n$$$ строк по $$$m$$$       нолей. ($$$1 \le n,m \le 100$$$). Каждая строка разделена на       отрезки, причем каждый $$$0$$$ в строке находится ровно в $$$1$$$       отрезке. Для каждого отрезка для каждой строки Омкар может       заменить ровно один из $$$0$$$, содержащихся в этом отрезке, на       $$$1$$$. Омкар определяет качество пола как сумму квадратов сумм       значений в каждом столбце, т.е. если сумма значений в $$$i$$$-м       столбце равна $$$q_i$$$, то качество пола равно $$$\sum_{i = 1}^m q_i^2$$$.</p>     <p>Помогите Омкару найти максимальное качество, которое может иметь пол.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит два целых числа, $$$n$$$ и $$$m$$$ ($$$1       \le n,m \le 100$$$), которые являются количеством строк и       количеством столбцов соответственно.</p>     <p>Затем вы получите описание отрезков в каждой строке. Для каждой       строки $$$i$$$ от $$$1$$$ до $$$n$$$: Первая строка содержит одно       целое число $$$k_i$$$ ($$$1 \le k_i \le m$$$)  — которое является       количеством отрезков в строке $$$i$$$. $$$j$$$-я из следующих       $$$k_i$$$ строк содержит два целых числа $$$l_{i,j}$$$ и       $$$r_{i,j}$$$, которые являются левой и правой границей (обе       включительно), соответственно, $$$j$$$-го отрезка $$$i$$$-й       строки. Гарантируется, что $$$l_{i,1} = 1$$$, $$$l_{i,j} \leq       r_{i,j}$$$ для всех $$$1 \le j \le k_i$$$, $$$r_{i,j-1} + 1 =       l_{i,j}$$$ для всех $$$2 \le j \le k_i$$$, и $$$r_{i,k_i} = m$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одно целое число, которое является максимально возможным       качеством пола.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4 5
2
1 2
3 5
2
1 3
4 5
3
1 1
2 4
5 5
3
1 1
2 2
3 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
36
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Данный пример соответствует следующей диаграмме. Ячейки в одном       ряду с одинаковым номером являются частью одного и того же отрезка.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/652a91508305e2613a1dc094702c8257b7c0044d.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>Наиболее оптимальным планом является:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/a9d11ea18390bcb2e88758185605c5bd5f8010da.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>Сумма $$$1$$$-го столбца равна $$$4$$$, сумма $$$2$$$-го столбца       равна $$$2$$$, сумма $$$3$$$-го и $$$4$$$-го столбцов равна       $$$0$$$, а сумма $$$5$$$-го столбца равна $$$4$$$.</p>     <p>Качество этого плана этажа составляет $$$4^2 + 2^2 + 0^2 + 0^2 +       4^2 = 36$$$. Можно показать, что нет плана пола с более высоким качеством.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1372/problem/E' title='Codeforces Round 655 (Div. 2)'>1372E - Omkar and Last Floor</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let $$$dp_{l,r}$$$ be the answer for the columns from $$$l$$$ to $$$r$$$.</p>     <p>To solve $$$dp_{l,r}$$$, it is optimal to always fill some column       within $$$l$$$ to $$$r$$$ to the max. Let's call this column       $$$k$$$. The transition is thus $$$dp_{l,k-1} + ($$$ number of       intervals that are fully within $$$l$$$ and $$$r$$$ and include       $$$k)^2 + dp_{k+1,r}$$$. For every $$$dp_{l,r}$$$ loop through all       possible columns to be $$$k$$$ and take the max. </p>     <p>The answer is $$$dp_{1,m}$$$. </p>     <p>The efficiency is $$$O(N \cdot M^3)$$$. There are $$$M^2$$$ dp       states. For every state, you transition based on $$$M$$$ cases of       $$$k$$$, and it takes $$$O(N)$$$ to determine how much the max       column contributes.</p>     <p>Proof: Consider an optimal arrangement and the column with the       most 1's in that arrangement. If there is an interval intersecting       that column whose 1 isn't in that column, then moving the 1 to       that column would not decrease (and possibly would increase) the       quality of that arrangement. Thus, it's optimal for the column       with the most 1s to have all the possible 1s that it can have.</p></div></div></div>

           
            <pre><code>import java.io.BufferedReader
import java.io.InputStreamReader
import kotlin.math.max

fun main() {
    val jin = BufferedReader(InputStreamReader(System.`in`))
    val (n, m) = jin.readLine().split(&#34; &#34;).map { it.toInt() }
    val left = Array(n + 1) { IntArray(m + 1) }
    val right = Array(n + 1) { IntArray(m + 1) }
    for (y in 1..n) {
        val k = jin.readLine().toInt()
        for (j in 1..k) {
            val (l, r) = jin.readLine().split(&#34; &#34;).map { it.toInt() }
            for (x in l..r) {
                left[y][x] = l
                right[y][x] = r
            }
        }
    }
    val dp = Array(m + 2) { IntArray(m + 2) }
    for (l in m downTo 1) {
        for (r in l..m) {
            for (x in l..r) {
                var amt = 0
                for (y in 1..n) {
                    if (left[y][x] &gt;= l &amp;&amp; right[y][x] &lt;= r) {
                        amt++
                    }
                }
                dp[l][r] = max(dp[l][r], dp[l][x - 1] + (amt * amt) + dp[x + 1][r])
            }
        }
    }
    println(dp[1][m])
}</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #655 (Div. 2)
    1372F
    Омкар и моды </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Омкар и моды</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>3 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Рэй потерял свой массив и должен найти его, спросив Омкара. Омкар       готов раскрыть, что массив обладает следующими качествами:</p>          <ol> <li> Массив содержит $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$)         элементов. </li>       <li> Каждый элемент в массиве $$$a_i$$$ является целым числом в         диапазоне $$$1 \le a_i \le 10^9.$$$ </li>       <li> Массив отсортирован в порядке неубывания. </li></ol>          <p>Рэй может отправить Омкару серию запросов. Запрос состоит из двух       целых чисел, $$$l$$$ и $$$r$$$, таких, что $$$1 \le l \le r \le       n$$$. Омкар ответит двумя целыми числами, $$$x$$$ и $$$f$$$.       $$$x$$$  — мода подмассива от индекса $$$l$$$ до индекса $$$r$$$       включительно. Модой массива называют число, которое встречается в       нем чаще всего. Если есть несколько чисел, которые встречаются       наибольшее количество раз, модой считается наименьшее из них.       $$$f$$$  — это количество раз, которое $$$x$$$ встречается в       запрашиваемом подмассиве.</p>     <p>Массив имеет $$$k$$$ ($$$1 \le k \le \min(25000,n)$$$) различных       элементов. Однако из-за грехов Рэя Омкар не скажет Рэю, чему равно       $$$k$$$. Рэю разрешено отправить не более $$$4k$$$ запросов.</p>     <p>Помогите Рэю найти его потерянный массив.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Единственная строка входных данных содержит одно целое число       $$$n$$$ ($$$1 \le n \le 2 \cdot 10^5$$$), равное длине массива,       который вы пытаетесь найти.</p></div>         <div>     <div class="section-title">Протокол взаимодействия</div>          <p>Взаимодействие начинается с чтения $$$n$$$.</p>     <p>Затем вы можете сделать один тип запроса:</p>          <ul> <li> "$$$? \enspace l \enspace r$$$" ($$$1 \le l \le         r \le n$$$) где $$$l$$$ и $$$r$$$ это границы подмассива,         который вы хотите запросить. </li></ul>          <p>Ответ на каждый запрос будет иметь вид "$$$x \enspace       f$$$", где $$$x$$$  — это мода подмассива, а $$$f$$$  —       количество раз, которое $$$x$$$ встречается в подмассиве.</p>          <ul> <li> $$$x$$$ удовлетворяет ($$$1 \leq x \leq 10^9$$$). </li>       <li> $$$f$$$ удовлетворяет ($$$1 \leq f \leq r-l+1$$$). </li>       <li> Если вы делаете более $$$4k$$$ запросов или нарушаете         диапазон номеров в запросе, вы получите вывод "<span class="tex-font-style-tt">-1</span>." </li>       <li> Если вы прекратите работу после получения ответа         "$$$-1$$$", вы получите вердикт "<span class="tex-font-style-tt">Неправильный ответ</span> ". В         противном случае вы можете получить произвольный вердикт, потому         что ваше решение будет продолжать читать из закрытого потока. </li></ul>          <p>Чтобы вывести ответ, выведите:</p>          <ul> <li> "$$$! \enspace a_1 \enspace a_2 \enspace \ldots         \enspace a_{n-1} \enspace a_n$$$", который является         восклицательным знаком, за которым следует массив с пробелом         между каждым элементом. </li></ul>          <p>После этого завершите программу. Этот запрос не учитывается в       лимит запросов $$$4k$$$.</p>     <p>После вывода запроса не забудьте вывести перевод строки, и       сбросить буфер вывода. В противном случае вы получите вердикт         <span class="tex-font-style-tt">Решение «зависло»</span>. Для       сброса буфера используйте:</p>          <ul>                     <li> <span class="tex-font-style-tt">fflush(stdout)</span> или           <span class="tex-font-style-tt">cout.flush()</span> в C++;         </li>       <li> <span class="tex-font-style-tt">System.out.flush()</span> в Java;         </li>       <li> <span class="tex-font-style-tt">flush(output)</span> в Pascal;         </li>       <li> <span class="tex-font-style-tt">stdout.flush()</span> в Python;         </li>       <li> смотрите документацию для других языков.         </li></ul>          <p>       <span class="tex-font-style-bf">Формат взломов</span></p>     <p>Для взлома выведите $$$1$$$ целое число в первой строке: $$$n$$$       ($$$1 \le n \le 2 \cdot 10^5$$$). Во второй строке выведите       $$$n$$$ целых чисел $$$a_1, a_2, \ldots, a_{n-1}, a_n$$$,       разделенных пробелами. Среди них должно быть не более $$$25000$$$       различных чисел и $$$a_j \le a_{j+1}$$$ должно выполняться для       всех $$$j$$$ от $$$1$$$ до $$$n-1$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6

2 2

2 2

3 2

2 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
? 1 6

? 1 3

? 4 6

? 3 4

! 1 2 2 3 3 4</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Первый запрос: $$$l=1$$$ и $$$r=6$$$. Мода равна $$$2$$$, а       $$$2$$$ встречается $$$2$$$ раза, поэтому $$$x=2$$$ и $$$f=2$$$.       Обратите внимание, что $$$3$$$ также встречается два раза, но       выводится $$$2$$$, потому что $$$2$$$ меньше.</p>     <p>Второй запрос: $$$l=1$$$ и $$$r=3$$$. Мода равна $$$2$$$ и       $$$2$$$ встречается дважды в подмассиве с границами $$$[1,3]$$$.</p>     <p>Третий запрос: $$$l=4$$$ и $$$r=6$$$. Мода равна $$$3$$$ и       $$$3$$$ встречается дважды в подмассиве с границами $$$[4,6]$$$.</p>     <p>Четвертый запрос: $$$l=3$$$ и $$$r=4$$$. Мода равна $$$2$$$, и       встречается один раз в подмассиве с границами $$$[3,4]$$$.       Обратите внимание, что $$$3$$$ также встречается всего один раз в       этом диапазоне, но $$$2$$$ меньше, чем $$$3$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1372/problem/F' title='Codeforces Round 655 (Div. 2)'>1372F - Omkar and Modes</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>For both solutions, we must first make the critical observation       that because the array is sorted, all occurrences of a value       $$$x$$$ occur as a single contiguous block.</p>     <p>       <span class="tex-font-style-bf">Solution 1</span></p>     <p>We will define a recursive function $$$determine(l, r)$$$ which       will use queries to determine the array. We will also store an       auxiliary list of previously returned query values $$$(x, f)$$$ –       not the queries themselves, but only the values returned, so that       we know that if $$$(x, f)$$$ is in the list then some previous       query revealed that there were $$$f$$$ instances of $$$x$$$ in       some query, and that we haven't already determined exactly where       in the array those $$$f$$$ instances of $$$x$$$ are.</p>     <p>The execution of $$$determine(l, r)$$$ will proceed as follows:       first, query the interval $$$[l, r]$$$, and let the result be       $$$(x_1, f_1)$$$. </p>     <p>If there exists some previous query result $$$(x_1, f_2)$$$ in       our auxiliary list, then we will guarantee by details yet to be       explained of $$$determine(l, r)$$$ that the interval that produced       that result contained $$$[l, r]$$$ and that no part of those       $$$f_2$$$ occurrences of $$$x_1$$$ occurred to the left of $$$[l,       r]$$$. This allows us to exactly determine the location of those       $$$f_2$$$ occurrences of $$$x_1$$$. We mark these occurrences in       our answer, and then remove $$$(x_1, f_2)$$$ from our auxiliary       list and <span class="tex-font-style-it">do not</span> add       $$$(x_1, f_1)$$$. If $$$[l, r]$$$ is not entirely composed of       occurrences of $$$x_1$$$, then the remaineder of the interval must       be $$$[l, r']$$$ for some $$$r'$$$, and in that case we then call       $$$determine(l, r')$$$.</p>     <p>If there does not exist some previous query result $$$(x_1,       f_2)$$$ in our auxiliary list, then we add $$$(x_1, f_1)$$$ to the       list and do as follows: while the exact locations of those       $$$f_1$$$ occurrences of $$$x_1$$$ have not been determined, call       $$$determine(l', l' + f_1 - 1)$$$, where $$$l'$$$ is the leftmost       index in $$$[l, r]$$$ which has not yet been determined. Once       those locations have been determined, call $$$determine(l', r)$$$.</p>     <p>To determine the entire array we simply call $$$determine(1,       n)$$$. It is clear that this will correctly determine the array.       We can see that it uses at most $$$4k$$$ queries as follows: for       each block of integers of the same value represented by a query       result $$$(x, f)$$$ that we add to our auxiliary list, we use       $$$2$$$ queries to determine the exact location of those integers:       one when added $$$(x, f)$$$ to the list, and one when removing       $$$(x, f)$$$ from the list. </p>     <p>This does not guarantee that the algorithm uses $$$2k$$$ queries       because some calls of $$$determine$$$ can split a block of       integers of the same value into two blocks. However, we can show       that any blocks formed by splitting a single block into two cannot       be further split as they occur either at the beginning or end of a       queried interval (the full proof is left as an exercise to the       reader), so each distinct value in the array will produce at most       $$$2$$$ blocks, each of which will be determined in $$$2$$$       queries, meaning that the algorithm uses at most $$$4k$$$ queries.</p>     <p>Side note: you can in fact further show that the algorithm always       uses at most $$$4k - 4$$$ queries and that there exists an array       for all $$$k \geq 2$$$ which forces the algorithm to use $$$4k -       4$$$ queries.</p>     <p>       <span class="tex-font-style-bf">Solution 2</span></p>     <p>Again, we will define a recursive function $$$determine(l, r)$$$,       but this time we will only additionally maintain the currently       known values in the answer.</p>     <p>The execution of $$$determine(l, r)$$$ will proceed as follows:       first, query the interval $$$[l, r]$$$ and let the result be       $$$(x, f)$$$. Then, find the largest integer $$$k$$$ such that       $$$2^k \leq f$$$ and then for all $$$j$$$ in $$$[l, r]$$$ that are       multiples of $$$2^k$$$, determine the value located at index       $$$j$$$, either by querying $$$[j, j]$$$ or by using already known values.</p>     <p>By the definition of $$$k$$$, there will be either one or two       such indexes $$$j$$$ such that the values at those indexes are       equal to $$$x$$$.</p>     <p>If there is only one such index, let this index be $$$j_1$$$.       Make two queries $$$[j_1 - 2^k + 1, j_1]$$$ and $$$[j_1, j_1 + 2^k       - 1]$$$ and let the results of these queries be $$$(x_1, f_1)$$$       and $$$(x_2, f_2)$$$ respectively. We can show that at least one       of $$$x_1$$$ and $$$x_2$$$ must be equal to $$$x$$$. If $$$x_1 =       x$$$, then we see that the $$$f$$$ occurrences of $$$x$$$ must be       precisely the interval $$$[j_1 - f_1 + 1, j_1 - f_1 + f]$$$. If       $$$x_2 = x$$$, then we see that the $$$f$$$ occurrences of $$$x$$$       must be precisely the interval $$$[j_1 + f_2 - f, j_1 + f_2 - 1]$$$.</p>     <p>If there are two such indexes, let these indexes be $$$j_1$$$ and       $$$j_2$$$ so that $$$j_1 &lt; j_2$$$. Note that it must be true       that $$$j_1 + 2^k = j_2$$$. Make a single query $$$[j_1 - 2^k + 1,       j_2]$$$ and let the result be $$$(x_1, f_1)$$$. We can show that       $$$x_1$$$ must be equal to $$$x$$$, so we can then conclude that       the $$$f$$$ occurrences fo $$$x$$$ must be precisely the interval       $$$[j_2 - f_1 + 1, j_2 - f_1 + f]$$$.</p>     <p>After the interval containing the $$$f$$$ occurrences of $$$x$$$       has been determined, mark these occurrences in our answer and then       call $$$determine$$$ on the remaining not-fully-determined       interval to the left if it exists and the remaining       not-fully-determined interval to the right if it exists.</p>     <p>To determine the entire array we simply call $$$determine(1,       n)$$$. It is clear that this will correctly determine the array.       We can see that it uses at most $$$4k$$$ queries as follows: Each       call to $$$determine$$$ finds all occurrences of a distinct value       $$$x$$$. We will refer to the queries of single indexes $$$j$$$       that were multiples of some $$$2^k$$$ as $$$j$$$-queries. For each       $$$x$$$, we perform the following queries other than       $$$j$$$-queries: the first query in $$$determine$$$, and then       either two additional queries if only one $$$j$$$-query was found       to equal $$$x$$$, or a single additional query if two       $$$j$$$-queries were found to equal $$$x$$$. This means that if we       group each $$$j$$$-query with the value $$$x$$$ that it equaled,       then we will have performed exactly $$$4$$$ queries for each       $$$x$$$, and so the algorithm must therefore use exactly $$$4k$$$ queries.</p></div></div></div>

           
            <pre><code>fun main() {
    val n = readLine()!!.toInt()
    val answer = IntArray(n + 1)
    val length = mutableMapOf&lt;Int, Int&gt;()
    fun calc(l: Int, r: Int): Int {
        if (l &lt;= r) {
            println(&#34;? $l $r&#34;)
            val line = readLine()!!.split(&#34; &#34;)
            val a = line[0].toInt()
            val f = line[1].toInt()
            if (a in length) {
                val end = r - f + length[a]!!
                for (j in end - length[a]!! + 1..end) {
                    answer[j] = a
                }
                length.remove(a)
                calc(l, r - f)
                return end
            } else {
                length[a] = f
                var j = l
                while (a in length) {
                    j = calc(j, j + f - 1) + 1
                }
                return calc(j, r)
            }
        } else {
            return l - 1
        }
    }
    calc(1, n)
    println(&#39;!&#39; + answer.joinToString(&#34; &#34;).substring(1))
}
</code></pre>
           
            <pre><code>import kotlin.math.max
import kotlin.math.min

fun main() {
    val n = readLine()!!.toInt()
    val answer = IntArray(n + 1)
    val occurrences = mutableMapOf&lt;Int, MutableList&lt;Int&gt;&gt;()
    fun query(l: Int, r: Int): Pair&lt;Int, Int&gt; {
        println(&#34;? $l $r&#34;)
        val line = readLine()!!.split(&#34; &#34;)
        return Pair(line[0].toInt(), line[1].toInt())
    }
    fun calc(l: Int, r: Int, ePrev: Int) {
        if (l &gt; r) {
            return
        }
        var q = query(l, r)
        val x = q.first
        val f = q.second
        var e = ePrev
        while (1 shl e &gt; f) {
            e--
        }
        if (e &lt; ePrev) {
            var j = l - (l % (1 shl e))
            if (j &lt; l) {
                j += 1 shl e
            }
            while (j &lt;= r) {
                if (j % (1 shl ePrev) != 0) {
                    q = query(j, j)
                    occurrences.computeIfAbsent(q.first) { mutableListOf() }.add(j)
                }
                j += 1 shl e
            }
        }
        val ixs = occurrences[x]!!
        var leftBound = 0
        if (ixs.size == 1) {
            q = query(max(l, ixs[0] - (1 shl e) + 1), ixs[0])
            if (q.first == x) {
                leftBound = ixs[0] - q.second + 1
            } else {
                q = query(ixs[0], min(r, ixs[0] + (1 shl e) - 1))
                leftBound = ixs[0] + q.second - f
            }
        } else {
            q = query(max(l, ixs.min()!! - (1 shl e) + 1), ixs.max()!!)
            leftBound = ixs.max()!! - q.second + 1
        }
        for (j in leftBound until leftBound + f) {
            answer[j] = x
        }
        calc(l, leftBound - 1, e)
        calc(leftBound + f, r, e)
    }
    calc(1, n, 20)
    println(&#39;!&#39; + answer.joinToString(&#34; &#34;).substring(1))
}</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 90 (рейтинговый для Див. 2)
    1373A
    Магазины пончиков </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Магазины пончиков</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Существует два конкурирующих магазина пончиков.</p>     <p>Первый магазин продает пончики в розницу: каждый пончик стоит       $$$a$$$ долларов.</p>     <p>Второй магазин продает пончики оптом: коробка из $$$b$$$ пончиков       стоит $$$c$$$ долларов. То есть если вы хотите купить $$$x$$$       пончиков в этом магазине, то вам придется купить минимальное       количество коробок такое, что суммарное количество пончиков больше       или равно $$$x$$$.</p>     <p>Вы хотите определить два <span class="tex-font-style-bf">положительных целых</span> значения: </p>     <ol> <li> сколько пончиков можно купить, чтобы они стоили дешевле в         первом магазине, чем во втором? </li>       <li> сколько пончиков можно купить, чтобы они стоили дешевле во         втором магазине, чем в первом? </li></ol>          <p>Если какое-то из значений не существует, то оно должно быть равно       $$$-1$$$. Если существует несколько решений, выведите любое из них.</p>     <p>       <span class="tex-font-style-bf">Выведенные значения должны быть         меньше или равны $$$10^9$$$. Можно показать, что в данных         ограничениях такие значения всегда существуют, если значения         существуют вообще.</span></p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое $$$t$$$ ($$$1 \le t \le       1000$$$) — количество наборов входных данных.</p>     <p>В каждой из следующих $$$t$$$ строк записаны по три целых числа       $$$a$$$, $$$b$$$ и $$$c$$$ ($$$1 \le a \le 10^9$$$, $$$2 \le b \le       10^9$$$, $$$1 \le c \le 10^9$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>На каждый набор входных данных выведите два <span class="tex-font-style-bf">положительных</span> целых числа. Для       обоих магазинов выведите такой $$$x$$$, что купить $$$x$$$       пончиков в этом магазине строго дешевле, чем купить $$$x$$$       пончиков в другом магазине. $$$x$$$ должно быть больше $$$0$$$ и       меньше или равно, чем $$$10^9$$$.</p>     <p>Если такого $$$x$$$ не существует, то выведите $$$-1$$$. Если       существует несколько решений, выведите любое из них.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
5 10 4
4 5 20
2 2 3
1000000000 1000000000 1000000000
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
-1 20
8 -1
1 2
-1 1000000000
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных любое количество пончиков будет       дешевле во втором магазине. Например, для $$$3$$$ или $$$5$$$       пончиков придется купить коробку из $$$10$$$ пончиков за $$$4$$$       доллара. Однако $$$3$$$ или $$$5$$$ пончиков будут стоить $$$15$$$       или $$$25$$$ долларов, соответственно. Для $$$20$$$ пончиков       придется купить две коробки за $$$8$$$ долларов суммарно. Обратите       внимание, что $$$3$$$ и $$$5$$$ также являются правильными       ответами для второго магазина вместе со многими другими ответами.</p>     <p>Во втором наборе входных данных любое количество пончиков будет       либо дешевле в первом магазине, либо по одинаковой цене. $$$8$$$       пончиков стоят $$$32$$$ доллара в первом магазине и $$$40$$$       долларов во втором магазине (потому что придется купить две       коробки). $$$10$$$ пончиков будут стоить $$$40$$$ долларов в обоих       магазинах, поэтому $$$10$$$ не будет правильным ответом ни для       одного из магазинов.</p>     <p>В третьем наборе входных данных $$$1$$$ пончик стоит $$$2$$$ и       $$$3$$$ доллара, соответственно. $$$2$$$ пончика стоят $$$4$$$ и       $$$3$$$ доллара. Поэтому $$$1$$$ является правильным ответом для       первого магазина, а $$$2$$$ является правильным ответом для       второго магазина.</p>     <p>В четвертом наборе входных данных $$$10^9$$$ пончиков стоят       $$$10^{18}$$$ долларов в первом магазине и $$$10^9$$$ долларов во       втором магазине.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1373/problem/A' title='Educational Codeforces Round 90 (Rated for Div. 2)'>1373A - Donut Shops</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>At first notice that if there exists a value for the second shop,       then the value divisible by $$$b$$$ also exists. For any $$$x$$$       you can round it up to the nearest multiple of $$$b$$$. That won't       change the price for the second shop and only increase the price       for the first shop.</p>     <p>You can also guess that if there exists a value for the first       shop, then the value with $$$1$$$ modulo $$$b$$$ also exists       (exactly $$$1$$$ donut on top of some number of full boxes).       Following the same logic — the second shop needs an entire new box       and the first shop needs only an extra donut.</p>     <p>So let's take a look at the smallest values of two kinds: </p>     <ul> <li> $$$x = b$$$: this value is valid for the second shop if         one box is cheaper than $$$b$$$ donuts in the first shop.         Otherwise, no matter how many boxes will you take, they will         never be cheaper than the corresponding number of donuts. </li>       <li> $$$x = 1$$$: this value is valid for the first shop if one         donut is cheaper than one box in the second shop. Apply the same         idea — otherwise no value for the first shop is valid. </li></ul>          <p>Overall complexity: $$$O(1)$$$ per testcase.</p></div></div></div>

           
            <pre><code>for tc in range(int(input())):
	a, b, c = map(int, input().split())
	print(1 if a &lt; c else -1, end=&#34; &#34;)
	print(b if c &lt; a * b else -1)
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 90 (рейтинговый для Див. 2)
    1373B
    01-игра </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. 01-игра</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Алиса и Боб играют в игру.</p>     <p>Изначально у них есть строка $$$s$$$, состоящая только из       символов <span class="tex-font-style-tt">0</span> и <span class="tex-font-style-tt">1</span>.</p>     <p>Алиса и Боб ходят по очереди: Алиса делает первый ход, второй       делает Боб, третий ход делает Алиса, и так далее. Во время своего       хода игрок должен выбрать два <span class="tex-font-style-bf">соседних различных</span> символа       строки $$$s$$$ и удалить их. Например, если $$$s = 1011001$$$,       тогда возможны следующие ходы: </p>     <ol> <li> удалить $$$s_1$$$ и $$$s_2$$$: $$$\textbf{10}11001         \rightarrow 11001$$$; </li>       <li> удалить $$$s_2$$$ и $$$s_3$$$: $$$1\textbf{01}1001         \rightarrow 11001$$$; </li>       <li> удалить $$$s_4$$$ и $$$s_5$$$: $$$101\textbf{10}01         \rightarrow 10101$$$; </li>       <li> удалить $$$s_6$$$ и $$$s_7$$$: $$$10110\textbf{01}         \rightarrow 10110$$$. </li></ol>          <p>Если игрок не может сделать ход — он проигрывает. Оба игрока       играют оптимально. Вам нужно определить, сможет ли Алиса выиграть.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит число $$$t$$$ ($$$1 \le t \le 1000$$$) —       количество наборов входных данных.</p>     <p>Единственная строка каждого набора входных данных содержит строку       $$$s$$$ ($$$1 \le |s| \le 100$$$), состоящую только из символов         <span class="tex-font-style-tt">0</span> и <span class="tex-font-style-tt">1</span>.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>На каждый набор входных данных выведите ответ в отдельной строке.</p>     <p>Если Алиса может выиграть, выведите <span class="tex-font-style-tt">DA</span> в любом регистре. Иначе       выведите <span class="tex-font-style-tt">NET</span> в любом регистре.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
01
1111
0011
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
DA
NET
NET
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных после хода Алисы строка $$$s$$$       станет пустой и Боб не сможет сделать ход.</p>     <p>Во втором наборе входных данных Алиса не может сделать ход изначально.</p>     <p>В третьем наборе входных данных после хода Алисы строка $$$s$$$       превратится в $$$01$$$. А после хода Боба строка $$$s$$$ станет       пустой и Алиса не сможет сделать ход.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1373/problem/B' title='Educational Codeforces Round 90 (Rated for Div. 2)'>1373B - 01 Game</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>If there is at least one character <span class="tex-font-style-tt">0</span> and at least one character         <span class="tex-font-style-tt">1</span>, then current player       can always make a move. After the move the number of character         <span class="tex-font-style-tt">0</span> decreases by one, and       the number of character <span class="tex-font-style-tt">1</span>       decreases by one too. So the number of moves is always $$$min(c0,       c1)$$$, where $$$c0$$$ is the number of characters <span class="tex-font-style-tt">0</span> in string $$$s$$$, and $$$c1$$$       is the number of characters <span class="tex-font-style-tt">1</span> in string $$$s$$$.</p>     <p>So if $$$min(c0, c1)$$$ is odd then Alice wins, otherwise Bob       wins. </p></div></div></div>

           
            <pre><code>for _ in range(int(input())):
    s = input()
    print(&#39;DA&#39; if min(s.count(&#39;0&#39;), s.count(&#39;1&#39;)) % 2 == 1 else &#39;NET&#39;)
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 90 (рейтинговый для Див. 2)
    1373C
    Плюсы и минусы </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Плюсы и минусы</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам задана строка $$$s$$$ состоящая только из символов <span class="tex-font-style-tt">+</span> и <span class="tex-font-style-tt">-</span>. Вы выполняете некоторый       процесс с этой строкой. Этот процесс можно описать следующим       псевдокодом: </p>     <pre class="lstlisting"><code class="prettyprint">res = 0<br/>for init = 0 to inf<br/>    cur = init<br/>    ok = true<br/>    for i = 1 to |s|<br/>        res = res + 1<br/>        if s[i] == '+'<br/>            cur = cur + 1<br/>        else<br/>            cur = cur - 1<br/>        if cur &lt; 0<br/>            ok = false<br/>            break<br/>    if ok<br/>        break<br/></code></pre>          <p>Обратите внимание, что $$$inf$$$ обозначает бесконечность, а       символы строки пронумерованы от $$$1$$$ до $$$|s|$$$.</p>     <p>Вам нужно определить значение переменной $$$res$$$ после       выполнения процесса.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит целое число $$$t$$$ ($$$1 \le t \le       1000$$$) — количество наборов входных данных.</p>     <p>Единственная строка каждого набора входных данных содержит строку       $$$s$$$ ($$$1 \le |s| \le 10^6$$$), состоящую только из символов         <span class="tex-font-style-tt">+</span> и <span class="tex-font-style-tt">-</span>.</p>     <p>Гарантируется, что сумма $$$|s|$$$ по всем наборам входных данных       не превосходит $$$10^6$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>На каждый набор входных данных выведите ответ — значение       переменной $$$res$$$ после завершения процесса.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
--+-
---
++--+-
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
7
9
6
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1373/problem/C' title='Educational Codeforces Round 90 (Rated for Div. 2)'>1373C - Pluses and Minuses</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's replace all <span class="tex-font-style-tt">+</span> with         <span class="tex-font-style-tt">1</span>, and all <span class="tex-font-style-tt">-</span> with <span class="tex-font-style-tt">-1</span>. After that let's create a       preffix-sum array $$$p$$$ ($$$p_i = \sum\limits_{j=1}^{i} s_j$$$).       Also lets create array $$$f$$$ such that $$$f_i$$$ is equal       minimum index $$$j$$$ such that $$$p_j = -i$$$ (if there is no       such index $$$p_i = -1$$$).</p>     <p>Let's consider the first iteration of loop $$$for ~ init ~ = ~ 0       ~ to ~ inf$$$. If $$$f_1 = -1$$$ then process ends and $$$res =       |s|$$$. Otherwise the condition $$$if ~ cur ~ &lt; ~ 0$$$       fulfilled then the value of $$$i$$$ will be equal to $$$f_1$$$.       So, the value of $$$res$$$ is equal to $$$f_1$$$ after first iteration.</p>     <p>Now, let's consider the second iteration of loop $$$for ~ init ~       = ~ 0 ~ to ~ inf$$$. If $$$f_2 = -1$$$ then process ends and       $$$res = f_1 + |s|$$$. Otherwise the condition $$$if ~ cur ~ &lt;       ~ 0$$$ fulfilled then the value of $$$i$$$ will be equal to       $$$f_2$$$. So, the value of $$$res$$$ is equal to $$$f_1 + f_2$$$       after second iteration.</p>     <p>In this way we can calculate the value of $$$res$$$ after the       process ends.</p></div></div></div>

           
            <pre><code>for _ in range(int(input())):
    s = input()
    cur, mn, res = 0, 0, len(s)
    for i in range(len(s)):
        cur += 1 if s[i] == &#39;+&#39; else -1
        if cur &lt; mn:
            mn = cur
            res += i + 1
        
    print(res)
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 90 (рейтинговый для Див. 2)
    1373D
    Максимальная сумма на четных позициях </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Максимальная сумма на четных позициях</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам задан массив $$$a$$$, состоящий из $$$n$$$ целых чисел.       Индексы элементов массива начинаются с нуля (то есть первый       элемент — это $$$a_0$$$, второй — $$$a_1$$$, и так далее).</p>     <p>Вы можете развернуть <span class="tex-font-style-bf">не более       одного</span> подмассива (последовательного отрезка) этого       массива. Напомним, что подмассив $$$a$$$ с границами $$$l$$$ и       $$$r$$$ равен $$$a[l; r] = a_l, a_{l + 1}, \dots, a_{r}$$$.</p>     <p>Ваша задача — развернуть такой подмассив, чтобы сумма элементов       на <span class="tex-font-style-bf">четных</span> позицияx       получившегося массива была <span class="tex-font-style-bf">максимально возможной</span> (то есть       сумма элементов $$$a_0, a_2, \dots, a_{2k}$$$ для целого числа       $$$k = \lfloor\frac{n-1}{2}\rfloor$$$ должна быть максимально возможной).</p>     <p>Вам необходимо ответить на $$$t$$$ независимых наборов тестовых данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка входных данных содержит одно целое число $$$t$$$       ($$$1 \le t \le 2 \cdot 10^4$$$) — количество наборов тестовых       данных. Затем следуют $$$t$$$ наборов тестовых данных.</p>     <p>Первая строка набора содержит одно целое число $$$n$$$ ($$$1 \le       n \le 2 \cdot 10^5$$$) — длину $$$a$$$. Вторая строка набора       содержит $$$n$$$ целых чисел $$$a_0, a_1, \dots, a_{n-1}$$$ ($$$1       \le a_i \le 10^9$$$), где $$$a_i$$$ — это $$$i$$$-й элемент $$$a$$$.</p>     <p>Гарантируется, что сумма $$$n$$$ не превосходит $$$2 \cdot       10^5$$$ ($$$\sum n \le 2 \cdot 10^5$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите ответ на отдельной       строке — <span class="tex-font-style-bf">максимально</span>       возможная сумма элементов на <span class="tex-font-style-bf">четных</span> позициях после разворота         <span class="tex-font-style-bf">не более одного</span>       подмассива (последовательного отрезка) $$$a$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
8
1 7 3 4 7 6 2 9
5
1 2 1 2 1
10
7 8 4 5 7 6 8 9 7 3
4
3 1 2 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
26
5
37
5
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1373/problem/D' title='Educational Codeforces Round 90 (Rated for Div. 2)'>1373D - Maximum Sum on Even Positions</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Firstly, we can notice that the reverse of of odd length subarray       does nothing because it doesn't change parities of indices of       affected elements. Secondly, we can consider the reverse of the       subarray of length $$$2x$$$ as $$$x$$$ reverses of subarrays of       length $$$2$$$ (i.e. it doesn't matter for us how exactly the       subarray will be reversed, we can only consider changing parities).</p>     <p>Now, there are two ways: the first one is smart and the second       one is dynamic programming.</p>     <p>Consider the first way. Calculate the initial sum of elements on       even positions $$$sum$$$. Then let's create two arrays $$$v_1$$$       and $$$v_2$$$. There $$$v_1[i]$$$ is $$$a[2i+1] - a[2i]$$$ for all       $$$i$$$ from $$$0$$$ to $$$\lfloor\frac{n}{2}\rfloor - 1$$$ and       $$$v_2[i]$$$ is $$$a[2i] - a[2i+1]$$$ for all $$$i$$$ from $$$0$$$       to $$$\lfloor\frac{n}{2}\rfloor - 1$$$. Elements of the first       array deonte the profit if we reverse the subarray tarting from       the even position, and elemnts of the second array denote the       profit if we reverse the subarray starting from the odd position.       Now we need to find the subarray with the maximum sum in both       arrays (this will maximize overall profit) and add this value to       $$$sum$$$ to get the answer. This problem can be solved easily:       consider the sum of the subarray $$$[l; r]$$$ as the difference of       two prefix sums $$$pref_{r} - pref_{l-1}$$$. To maximize it,       consider all right borders and minimize the value       $$$pref_{l-1}$$$. Iterate over all positions of the array,       maintaining the current prefix sum $$$csum$$$ and the minimum       prefix sum we meet $$$msum$$$. Update $$$csum := csum + a_i$$$,       then update $$$msum := min(msum, csum)$$$ and then update the       answer with the value $$$csum - msum$$$.</p>     <p>And the second way is author's solution and it is dynamic       programming. This idea can be transformed to solve such problems       in which you need to apply some function to some small number of       subsegments (of course, under some constraints on functions).       State of our dynamic programming is $$$dp_{i, j}$$$ where $$$i \in       [0; n]$$$ and $$$j \in [0; 2]$$$. $$$dp_{i, 0}$$$ denotes the       answer on the prefix of length $$$i$$$ if we didn't start       reversing the subarray, $$$dp_{i, 1}$$$ denotes the answer if we       started reversing the subarray but didn't end it and $$$dp_{i,       2}$$$ denotes the answer if we ended reversing the subarray.       Transitions are pretty easy:</p>          <ul> <li> $$$dp_{i + 1, 0} = max(dp_{i + 1, 0}, dp_{i, 0} + [i \% 2         == 0? a_i : 0])$$$; </li>       <li> $$$dp_{i + 2, 1} = max(dp_{i + 2, 1}, max(dp_{i, 0}, dp_{i,         1}) + [i \% 2 == 0 ? a_{i + 1} : a_i])$$$; </li>       <li> $$$dp_{i + 1, 2} = max(dp_{i + 1, 2}, max(dp_{i, 0}, dp_{i,         1}, dp_{i, 2}) + [i \% 2 == 0? a_i : 0])$$$. </li></ul>          <p>The value $$$x ? y : z$$$ is just a ternary if statement. If       $$$x$$$ is true then return $$$y$$$ otherwise return $$$z$$$.</p>     <p>The answer is $$$max(dp_{n, 0}, dp_{n, 1}, dp_{n, 2})$$$.</p>     <p>Time complexity with both approaches is $$$O(n)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
	
	int t;
	cin &gt;&gt; t;
	while (t--) {
		int n;
		cin &gt;&gt; n;
		vector&lt;int&gt; a(n);
		for (auto &amp;it : a) cin &gt;&gt; it;
		vector&lt;vector&lt;long long&gt;&gt; dp(n + 1, vector&lt;long long&gt;(3));
		for (int i = 0; i &lt; n; ++i) {
			dp[i + 1][0] = max(dp[i + 1][0], dp[i][0] + (i &amp; 1 ? 0 : a[i]));
			if (i + 2 &lt;= n) dp[i + 2][1] = max(dp[i + 2][1], max(dp[i][0], dp[i][1]) + (i &amp; 1 ? a[i] : a[i + 1]));
			dp[i + 1][2] = max(dp[i + 1][2], max({dp[i][0], dp[i][1], dp[i][2]}) + (i &amp; 1 ? 0 : a[i]));
		}
		cout &lt;&lt; max({dp[n][0], dp[n][1], dp[n][2]}) &lt;&lt; endl;
	}
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 90 (рейтинговый для Див. 2)
    1373E
    Сумма цифр </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. Сумма цифр</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Пусть $$$f(x)$$$ — сумма цифр числа $$$x$$$.</p>     <p>Найдите минимальное неотрицательное целое $$$x$$$, для которого       $$$f(x) + f(x + 1) + \dots + f(x + k) = n$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке задано одно целое число $$$t$$$ ($$$1 \le t \le       150$$$) — количество наборов входных данных.</p>     <p>Каждый набор входных данных состоит из двух чисел $$$n$$$ и       $$$k$$$ ($$$1 \le n \le 150$$$, $$$0 \le k \le 9$$$). </p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите одно число без       ведущих нулей. Если такого $$$x$$$, что $$$f(x) + f(x + 1) + \dots       + f(x + k) = n$$$, не существует, выведите $$$-1$$$; иначе       выведите минимальное $$$x$$$, соответствующее этому условию.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
7
1 0
1 1
42 7
13 7
99 1
99 0
99 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
0
4
-1
599998
99999999999
7997
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1373/problem/E' title='Educational Codeforces Round 90 (Rated for Div. 2)'>1373E - Sum of Digits</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>There are many ways to solve this problem (including       precalculating all answers), but the model solution is based on       the following:</p>     <p>In most cases, $$$f(x + 1) = f(x) + 1$$$. It is not true only       when the last digit of $$$x$$$ is $$$9$$$ (and if we know the       number of $$$9$$$-digits at the end of $$$x$$$, we can easily       derive the formula for $$$f(x + 1)$$$). And since $$$k \le 9$$$,       there will be at most one number with last digit equal to $$$9$$$       in $$$[x, x + 1, \dots, x + k]$$$.</p>     <p>Let's iterate on the last digit of $$$x$$$ and the number of       $$$9$$$-digits before it. Suppose the fixed $$$x$$$ has no other       digits other than the last one and several $$$9$$$-digits before       it. Let's calculate $$$s = f(x) + f(x + 1) + f(x + 2) \dots + f(x       + k)$$$.</p>     <p>Here goes the trick. If we prepend $$$x$$$ with several digits       such that the last of them is not $$$9$$$, and the sum of those       digits is $$$d$$$, then $$$f(x) + f(x + 1) + f(x + 2) \dots + f(x       + k) = s + d(k + 1)$$$. So we can easily derive the value of       $$$d$$$ we need and construct the smallest number with sum of       digits equal to $$$d$$$ (don't forget that the last digit should       not be $$$9$$$).</p></div></div></div>

           
            <pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;

int n, k;

bool decimalLess(const string&amp; s, const string&amp; t)
{
	if(s.size() != t.size())
		return s.size() &lt; t.size();
	for(int i = 0; i &lt; s.size(); i++)
		if(s[i] != t[i])
			return s[i] &lt; t[i];
	return false;
}

void upd(string&amp; ans, const string&amp; cur)
{
	if(ans == &#34;-1&#34; || decimalLess(cur, ans))
		ans = cur;
}

void read()
{
	cin &gt;&gt; n &gt;&gt; k;
}

void solve()
{
	string ans = &#34;-1&#34;;
	for(int i = 0; i &lt;= 9; i++)
	{
		int cnt9 = n / 9;
		if(i + k &lt; 10)
			cnt9 = 0;
		for(int j = 0; j &lt;= cnt9; j++)
		{
		    if(i + k &gt;= 10 &amp;&amp; j == 0)
		        continue;
			int curSum = (i + (i + k)) * (k + 1) / 2;
			if(j != 0)
			{
				int cntBefore = 10 - i;
				int cntAfter = k + 1 - cntBefore;
				curSum = (i + 9) * cntBefore / 2 + cntBefore * 9 * (j - 1) + (1 + cntAfter) * cntAfter / 2;
			}
			curSum = n - curSum;
			if(curSum &lt; 0 || curSum % (k + 1) != 0)
				continue;
			string curNum = {char(&#39;0&#39; + i)};
			for(int z = 0; z &lt; j - 1; z++)
				curNum += &#34;9&#34;;
			int maxNum = 9;
			if(i + k &gt;= 10)
				maxNum = 8;
			curSum /= (k + 1);
			while(curSum != 0)
			{
				int d = min(curSum, maxNum);
				maxNum = 9;
				curSum -= d;
				curNum.push_back(char(&#39;0&#39; + d));
			}
			reverse(curNum.begin(), curNum.end());
			upd(ans, curNum);
		}
	}
	cout &lt;&lt; ans &lt;&lt; endl;
}

int main()
{
	int t;
	cin &gt;&gt; t;
	for(int i = 0; i &lt; t; i++)
	{
		read();
		solve();
	}
}
</code></pre>
           
            <pre><code>def get(s):
	return str(s % 9) + &#39;9&#39; * (s // 9)

for tc in range(int(input())):
	n, k = map(int, input().split())
	k += 1
	bst = 10**100
	for d in range(10):
		ends = 0
		for i in range(k):
			ends += (d + i) % 10
		if ends &gt; n:
			continue
		if d + k &gt; 10:
			for cnt in range(12):
				s = 9 * cnt * (10 - d)
				if s &gt; n - ends:
					break
				for nd in range(9):
					ns = s + (10 - d) * nd + (k - (10 - d)) * (nd + 1)
					if ns &gt; n - ends:
						break
					if (n - ends - ns) % k == 0:
						bst = min(bst, int(get((n - ends - ns) // k) + str(nd) + &#39;9&#39; * cnt + str(d)))
		elif (n - ends) % k == 0:
			bst = min(bst, int(get((n - ends) // k) + str(d)))
	print(-1 if bst == 10**100 else bst)
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 90 (рейтинговый для Див. 2)
    1373F
    Покрытие Интернетом </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Покрытие Интернетом</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Правительство Берляндии наконец-то решило улучшить покрытие сетью       Интернет в своей стране. Берляндия имеет уникальную структуру: в       самом центре находится столица, а $$$n$$$ городов расположены       вокруг нее <span class="tex-font-style-it">по кругу</span>. В       столице нет проблем с Интернетом (поэтому правительство игнорирует       ее), но в $$$i$$$-м городе необходимо провести соединение в       $$$a_i$$$ домов.</p>     <p>Правительство разработало план постройки $$$n$$$ базовых станций       между каждой парой соседних городов, которые будут обслуживать       только эти города. Другими словами, $$$i$$$-я базовая станция       будет обслуживать только $$$i$$$-й и $$$(i + 1)$$$-й город       ($$$n$$$-я станция будет обслуживать $$$n$$$-й и $$$1$$$-й город).</p>     <p>Все базовые станции имеют ограниченную мощность: к $$$i$$$-й       станции может быть подключено не более $$$b_i$$$ домов.</p>     <p>Сейчас же правительство просит вас проверить: могут ли       спроектированные станции удовлетворить потребности всех городов       или нет; то есть можно ли каждый дом подключить к базовой станции       так, что к каждой станции $$$i$$$ подключено не более $$$b_i$$$ домов.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке задано единственное число $$$t$$$ ($$$1 \le t \le       10^4$$$) — количество наборов входных данных.</p>     <p>В первой строке каждого набора задано единственное целое число       $$$n$$$ ($$$2 \le n \le 10^6$$$) — количество городов и станций.</p>     <p>Во второй строке каждого набора заданы $$$n$$$ целых чисел ($$$1       \le a_i \le 10^9$$$) — количество необходимых соединений для       $$$i$$$-го города.</p>     <p>В третьей строке каждого набора заданы $$$n$$$ целых чисел ($$$1       \le b_i \le 10^9$$$) — мощности планируемых базовых станций.</p>     <p>Гарантируется, что сумма $$$n$$$ по наборам входных данных не       превосходит $$$10^6$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных, выведите <span class="tex-font-style-tt">YES</span>, если спроектированные       станции смогут удовлетворить потребности всех городов, или <span class="tex-font-style-tt">NO</span> в противном случае (регистр       букв не важен).</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
3
2 3 4
3 3 3
3
3 3 3
2 3 4
4
2 3 4 5
3 7 2 2
4
4 5 2 3
2 3 2 7
2
1 1
10 10
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
YES
YES
NO
YES
YES
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных: </p>     <ul> <li> первая базовая станция может предоставить $$$2$$$         соединения первому городу и $$$1$$$ соединение второму городу; </li>       <li> вторая станция может предоставить $$$2$$$ соединения второму         городу и $$$1$$$ соединение третьему городу; </li>       <li> третья станция может предоставить $$$3$$$ соединения третьему         городу. </li></ul>          <p>Во втором наборе: </p>     <ul> <li> $$$1$$$-я станция может предоставить $$$2$$$ соединения         $$$1$$$-му городу; </li>       <li> $$$2$$$-я станция может предоставить $$$3$$$ соединения         $$$2$$$-му городу; </li>       <li> $$$3$$$-я станция может предоставить $$$3$$$ соединения         $$$3$$$-му городу и $$$1$$$ соединение $$$1$$$-му городу. </li></ul>          <p>В третьем примере, четвертому городу необходимо $$$5$$$       соединений, но третья и четвертая станции могут предоставить       только $$$4$$$ соединения суммарно.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1373/problem/F' title='Educational Codeforces Round 90 (Rated for Div. 2)'>1373F - Network Coverage</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>There are plenty of different solutions to this problem. Here is       one that doesn't use Hall's theorem.</p>     <p>Let's look at pair $$$(a_i, b_i)$$$ as fuction $$$f_i(in) =       out$$$: how many connections $$$out$$$ will be left for the $$$(i       + 1)$$$-th city if we take $$$in$$$ connections from the $$$(i -       1)$$$-th station. This function has the following structure: there       is a minimum required $$$in$$$ (let's name it $$$minx_i$$$) to       meet the needs of the $$$i$$$-th city and with $$$minx_i$$$       borrowed connections there will be $$$f_i(minx_i) = mink_i$$$ free       connections to the $$$(i + 1)$$$-th city. Increasing $$$minx_i$$$       by some $$$x$$$ we can get $$$f_i(minx_i + x) = mink_i + x$$$ free       connections, but there is upper bound to number of free       connections $$$maxk_i$$$. In other words, the function       $$$f_i(minx_i + x) = \min(mink_i + x, maxk_i)$$$ where $$$x \ge 0$$$.</p>     <p>For example, let's calculate the corresponding coefficients for       the $$$i$$$-th function: </p>     <ul> <li> if $$$a_i \le b_i$$$ then $$$minx_i = 0$$$, $$$mink_i =         b_i - a_i$$$ and $$$maxk_i = b_i$$$; </li>       <li> if $$$a_i &gt; b_i$$$ then $$$minx_i = a_i - b_i$$$,         $$$mink_i = 0$$$ and $$$maxk_i = b_i$$$. </li></ul>          <p>Why did we define such functions? If we can calculate result       function $$$f_{[1,n]}(in) = f_n(f_{n - 1}(\dots       f_2(f_1(in))\dots))$$$ then we can check the possibility of       meeting all needs by checking that this fuction exists and       $$$minx_{[1,n]} \le mink_{[1,n]}$$$, i. e. the minimum free       $$$mink_{[1,n]}$$$ can be used as borrowed $$$minx_{[1,n]}$$$.</p>     <p>Fortunately, it turns out that the superposition       $$$f_{i+1}(f_i(in))$$$ is either don't exists (if, for example,       $$$maxk_i &lt; minx_{i + 1}$$$) or it has the same structure as       any function $$$f_i$$$. So we can calculate $$$f_{[1,n]}$$$ in one       pass and find the answer.</p>     <p>We will skip the detailed formulas to calculate       $$$f_{i+1}(f_i(in))$$$: you can either find them by yourself or       look at function $$$merge()$$$ in author's solution.</p>     <p>The resulting complexity is $$$O(n)$$$.</p></div></div></div>

           
            <pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;

#define fore(i, l, r) for(int i = int(l); i &lt; int(r); i++)
#define sz(a) int((a).size())

#define x first
#define y second

typedef long long li;
typedef pair&lt;int, int&gt; pt;

const int INF = int(1e9);
const li INF64 = li(1e18);

int n;
vector&lt;int&gt; a, b;

inline bool read() {
	if(!(cin &gt;&gt; n))
		return false;
	a.resize(n);
	fore(i, 0, n)
		cin &gt;&gt; a[i];
	b.resize(n);
	fore(i, 0, n)
		cin &gt;&gt; b[i];
	return true;
}

struct func {
	int minx, mink, maxk;
	func() : minx(0), mink(0), maxk(0) {}
	func(int minx, int mink, int maxk) : minx(minx), mink(mink), maxk(maxk) {}
};

func getFunc(int a, int b) {
	if (a &lt;= b)
		return func(0, b - a, b);
	else
		return func(a - b, 0, b);
}

func merge(func a, func b) {
	if (a.minx == -1 || b.minx == -1)
		return func(-1, -1, -1);
	
	if (a.maxk &lt; b.minx)
		return func(-1, -1, -1);
	if (a.mink &gt;= b.minx)
		return func(a.minx, min(b.maxk, b.mink + (a.mink - b.minx)), min(b.maxk, b.mink + (a.maxk - b.minx)));
	else {
		int add = b.minx - a.mink;
		return func(a.minx + add, b.mink, min(b.maxk, b.mink + (a.maxk - b.minx)));
	}
}

inline void solve() {
	func total = getFunc(a[0], b[0]);
	fore(i, 1, n)
		total = merge(total, getFunc(a[i], b[i]));
	
	if (total.minx != -1 &amp;&amp; total.minx &lt;= total.mink)
		cout &lt;&lt; &#34;YES\n&#34;;
	else
		cout &lt;&lt; &#34;NO\n&#34;;
}

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
	int tt = clock();
#endif
	ios_base::sync_with_stdio(false);
	cin.tie(0), cout.tie(0);
	cout &lt;&lt; fixed &lt;&lt; setprecision(15);
	
	int tc; cin &gt;&gt; tc;
	
	while(tc--) {
		read();
		solve();
		
#ifdef _DEBUG
		cerr &lt;&lt; &#34;TIME = &#34; &lt;&lt; clock() - tt &lt;&lt; endl;
		tt = clock();
#endif
	}
	return 0;
}
</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;
 
using namespace std;

typedef long long li;
const int N = 1000 * 1000 + 13;

int n;
int a[N], b[N];
 
void solve() {
	scanf(&#34;%d&#34;, &amp;n);
	for (int i = 0; i &lt; n; ++i) scanf(&#34;%d&#34;, &amp;a[i]);
	for (int i = 0; i &lt; n; ++i) scanf(&#34;%d&#34;, &amp;b[i]);
	
	li need = 0, add = 0, extra = 2e9;
	for (int i = n - 1; i &gt;= 0; --i) {
		if (b[i] &lt; need) {
			puts(&#34;NO&#34;);
			return;
		}
		
		li val = b[i] - a[i];
		li to_add = min(extra, max(0LL, val - need));
		add += to_add;
		extra = min(extra - to_add, b[i] - need - to_add);
		need = max(0LL, need - val);
	}
	
	puts(add &gt;= need ? &#34;YES&#34; : &#34;NO&#34;);
}
 
int main() {
	int t;
	scanf(&#34;%d&#34;, &amp;t);
	for (int i = 0; i &lt; t; ++i)
		solve();
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 90 (рейтинговый для Див. 2)
    1373G
    Пешки </h1>

    <div class="problemindexholder" problemindex="G">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">G. Пешки</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>3 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У вас есть шахматная доска состоящая из $$$n$$$ строк и $$$n$$$       столбцов. Строки пронумерованы снизу вверх от $$$1$$$ до $$$n$$$.       Столбцы пронумерованы слева направо от $$$1$$$ до $$$n$$$. Поле       находящееся на пересечении $$$x$$$-го столбца и $$$y$$$-й строки       обозначается как $$$(x, y)$$$. Кроме того, $$$k$$$-й столбец       является специальным столбцом. </p>     <p>Изначально доска пуста. Есть $$$m$$$ изменений; $$$i$$$-е       изменение добавляет или удаляет одну пешку. Текущая доска       называется хорошей если мы можем переместить все пешки на       специальный столбец по следующим правилам:</p>          <ul> <li> Пешку на поле $$$(x, y)$$$ можно переместить на поля         $$$(x, y + 1)$$$, $$$(x - 1, y + 1)$$$ или $$$(x + 1, y + 1)$$$; </li>       <li> Вы можете сделать сколько угодно таких ходов; </li>       <li> Пешки нельзя перемещать за пределы доски; </li>       <li> В каждом поле не может находится более одной пешки. </li></ul>          <p>Текущая доска может и не быть хорошей. Чтобы исправить это, вы       можете добавить дополнительные строки. Эти строки добавляются       сверху, т. е. они будут иметь номера $$$n+1, n+2, n+3, \dots$$$.</p>     <p>После каждого из $$$m$$$ изменений выведите одно число —       минимальное количество строк, которые нужно добавить, чтобы доска       стала хорошей.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит три числа $$$n$$$, $$$k$$$ and $$$m$$$       ($$$1 \le n, m \le 2 \cdot 10^5; 1 \le k \le n$$$) — размер доски,       индекс специального столбца и количество изменений соответственно.</p>     <p>Затем следует $$$m$$$ строк. В $$$i$$$-й строке содержится два       числа $$$x$$$ и $$$y$$$ ($$$1 \le x, y \le n$$$) — индексы столбца       и строки соответственно. Если в поле $$$(x, y)$$$ нет пешки — то       вы добавляете туда пешку, иначе — удаляете ее.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>После каждого изменения выведите число — минимальное количество       строк, которые нужно добавить, чтобы доска стала хорошей.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5 3 5
4 4
3 5
2 4
3 4
3 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
1
2
2
1
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1373/problem/G' title='Educational Codeforces Round 90 (Rated for Div. 2)'>1373G - Pawns</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>For each pawn with initial position $$$(x, y)$$$ there exists a       minimum index of row $$$i$$$ such that the pawn can reach the cell       $$$(k, i)$$$, but cannot reach the cell $$$(k, i - 1)$$$. It's       easy to see that $$$i = |k - x| + y$$$. In the resulting       configuration, this pawn can occupy the cell $$$(k, i)$$$, $$$(k,       i + 1)$$$, $$$(k, i + 2)$$$ or any other cell $$$(k, j)$$$ having       $$$j \ge i$$$.</p>     <p>Suppose the board consists of $$$r$$$ rows. For each row, the       number of rows above it should be not less than the number of       pawns that occupy the cells above it (that is, having $$$i$$$       greater than the index of that row) — because, if this condition       is not fulfilled, we can't assign each pawn a unique cell. If we       denote the number of pawns that should go strictly above the       $$$j$$$-th row as $$$f(j)$$$, then for every row, the condition       $$$f(j) \le r - j$$$ must be met.</p>     <p>To prove that this condition is sufficient, we may, for example,       use Hall's theorem. Okay, now what about finding the minimum       $$$r$$$ satisfying it? Let's initially set $$$r$$$ to $$$n$$$, and       for each row maintain the value of $$$j + f(j) - n$$$ — the       minimum number of rows we have to add to our board so that the       condition for the row $$$j$$$ is met (we also have to maintain       this value for $$$n - 1$$$ auxiliary rows from $$$n + 1$$$ to       $$$2n - 1$$$, since some pawns cannot fit in the initial board at       all). Finding the minimum value we have to add to $$$r$$$ equals       finding the maximum of all these values on some prefix (we don't       need to look at the values on some rows with large indices, if       there are no pawns after them, so we need a maximum query on the       segment $$$[1, \max_i]$$$, where $$$\max_i$$$ is the maximum index       $$$i$$$ among all pawns); and when a pawn is added or removed, we       should add $$$+1$$$ or $$$-1$$$ to all values on some suffix. A       segment tree with lazy propagation will do the trick, solving the       problem for us in $$$O(m \log n)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

const int N = int(2e5) + 9;

int n, k;
int m;
int t[8 * N];
int add[8 * N];
int cnt[2 * N];

void push(int v, int l, int r) {
    if (r - l != 1 &amp;&amp; add[v] != 0) {
        t[v * 2 + 1] += add[v];
        t[v * 2 + 2] += add[v];
        add[v * 2 + 1] += add[v];
        add[v * 2 + 2] += add[v];
        add[v] = 0;
    }
}

void upd(int v, int l, int r, int L, int R, int x) {
    if (L &gt;= R) return;
    if(l == L &amp;&amp; r == R) {
        t[v] += x;
        add[v] += x;
        return;
    } 
    
    push(v, l, r);
    int mid = (l + r) / 2;
    upd(v * 2 + 1, l, mid, L, min(R, mid), x);
    upd(v * 2 + 2, mid, r, max(L, mid), R, x);
    t[v] = max(t[v * 2 + 1], t[v * 2 + 2]);
}

void upd(int l, int r, int x) {
    upd(0, 0, n + n, l, r, x);
}

int get(int v, int l, int r, int L, int R) {
    if (L &gt;= R) return 0;
    if (l == L &amp;&amp; r == R) return t[v];
    
    push(v, l, r);
    int mid = (l + r) &gt;&gt; 1;
    return max(get(v * 2 + 1, l, mid, L, min(R, mid))
    		 , get(v * 2 + 2, mid, r, max(L, mid), R));
}

int get(int l, int r) {
    return get(0, 0, n + n, l, r);
}

int getAns(set &lt;int&gt; &amp;smx) {
    if (smx.empty()) return 0;
    return max(0, get(0, *smx.rbegin() + 1) - n);
}

void build(int v, int l, int r) {
    if (r - l == 1) {
        t[v] = l;
        return;
    }
    
    int mid = (l + r) &gt;&gt; 1;
    build(v * 2 + 1, l, mid);
    build(v * 2 + 2, mid, r);
    t[v] = max(t[v * 2 + 1], t[v * 2 + 2]);
}

int main(){
    scanf(&#34;%d %d %d&#34;, &amp;n, &amp;k, &amp;m);
    
    build(0, 0, n + n);
    set &lt;pair&lt;int, int&gt; &gt; s;
    set &lt;int&gt; smx;
    for (int i = 0; i &lt; m; ++i) {
        int x, y;
        scanf(&#34;%d %d&#34;, &amp;x, &amp;y);
        int pos = abs(x - k) + y - 1;
        pair &lt;int, int&gt; p = make_pair(x, y);
        if (s.count(p)) {
            --cnt[pos];
            if (cnt[pos] == 0) smx.erase(pos);
            upd(0, pos + 1, -1);
            s.erase(p);
        } else {
            ++cnt[pos];
            if (cnt[pos] == 1) smx.insert(pos);
            upd(0, pos + 1, 1);
            s.insert(p);
        }
        
        printf(&#34;%d\n&#34;, getAns(smx));
    }
    return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #653 (Div. 3)
    1374A
    Необходимый остаток </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Необходимый остаток</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам даны три целых числа $$$x, y$$$ и $$$n$$$. Ваша задача —       найти <span class="tex-font-style-bf">максимальное</span> целое       число $$$k$$$, такое что $$$0 \le k \le n$$$ и $$$k \bmod x =       y$$$, где $$$\bmod$$$ — операция взятия остатка от деления. Во       многих языков программирования для нахождения остатка используется       оператор процент <span class="tex-font-style-tt">%</span>.</p>     <p>Другими словами, по заданным $$$x, y$$$ и $$$n$$$ вам нужно найти       максимальное возможное целое число от $$$0$$$ до $$$n$$$, имеющее       остаток $$$y$$$ при делении на $$$x$$$.</p>     <p>Вам нужно ответить на $$$t$$$ независимых наборов тестовых       данных. Гарантируется, что для каждого набора тестовых данных       искомое $$$k$$$ существует.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка теста содержит одно целое число $$$t$$$ ($$$1 \le t       \le 5 \cdot 10^4$$$) — количество наборов тестовых данных. Затем       следуют $$$t$$$ наборов тестовых данных.</p>     <p>Единственная строка набора входных данных содержит три целых       числа $$$x, y$$$ и $$$n$$$ ($$$2 \le x \le 10^9;~ 0 \le y &lt; x;~       y \le n \le 10^9$$$).</p>     <p>Можно показать, что при заданных выше ограничениях искомое       $$$k$$$ всегда существует.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите ответ — <span class="tex-font-style-bf">максимальное неотрицательное</span>       целое число $$$k$$$, что $$$0 \le k \le n$$$ и $$$k \bmod x =       y$$$. Гарантируется, что ответ всегда существует.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
7
7 5 12345
5 0 4
10 5 15
17 8 54321
499999993 9 1000000000
10 5 187
2 0 999999999
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
12339
0
15
54306
999999995
185
999999998
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных примера ответ равен $$$12339 = 7       \cdot 1762 + 5$$$ (следовательно, $$$12339 \bmod 7 = 5$$$).       Очевидно, что не существует большего целого числа, не       превосходящего $$$12345$$$ и имеющего остаток $$$5$$$ при делении       на $$$7$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1374/problem/A' title='Codeforces Round 653 (Div. 3)'>1374A - Required Remainder</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>There are two cases in this problem. If we try to maximize the       answer, we need to consider only two integers: $$$n - n \bmod x +       y$$$ and $$$n - n \bmod x - (x - y)$$$. Of course, the first one       is better (we get rid of the existing remainder and trying to add       $$$y$$$ to this number). If it's too big, then we can and need to       take the second one (this number is just the first one but       decreased by $$$x$$$). The answer can be always found between       these numbers.</p>     <p>Time complexity: $$$O(1)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
	
	int t;
	cin &gt;&gt; t;
	while (t--) {
		int x, y, n;
		cin &gt;&gt; x &gt;&gt; y &gt;&gt; n;
		if (n - n % x + y &lt;= n) {
			cout &lt;&lt; n - n % x + y &lt;&lt; endl;
		} else {
			cout &lt;&lt; n - n % x - (x - y) &lt;&lt; endl;
		}
	}
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #653 (Div. 3)
    1374B
    Умножай на 2, дели на 6 </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Умножай на 2, дели на 6</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам дано целое число $$$n$$$. За один ход вы можете или умножить       $$$n$$$ на 2, или разделить $$$n$$$ на $$$6$$$ (если оно делится       на $$$6$$$ без остатка).</p>     <p>Ваша задача — найти минимальное количество ходов, необходимое,       чтобы получить $$$1$$$ из $$$n$$$ или определить, что это невозможно.</p>     <p>Вам нужно ответить на $$$t$$$ независимых наборов тестовых данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка теста содержит одно целое число $$$t$$$ ($$$1 \le t       \le 2 \cdot 10^4$$$) — количество наборов тестовых данных. Затем       следуют $$$t$$$ наборов тестовых данных. </p>     <p>Единственная строка набора тестовых данных содержит одно целое       число $$$n$$$ ($$$1 \le n \le 10^9$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите ответ на него —       минимальное количество ходов, необходимое, чтобы получить $$$1$$$       из $$$n$$$, если это возможно, или <span class="tex-font-style-tt">-1</span>, если невозможно получить       $$$1$$$ из $$$n$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
7
1
2
3
12
12345
15116544
387420489
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
-1
2
-1
-1
12
36
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Рассмотрим шестой набор тестовых данных примера. Ответ может быть       получен следующей последовательностью ходов из заданного числа $$$15116544$$$:</p>          <ol> <li> Разделим на $$$6$$$ и получим $$$2519424$$$; </li>       <li> разделим на $$$6$$$ и получим $$$419904$$$; </li>       <li> разделим на $$$6$$$ и получим $$$69984$$$; </li>       <li> разделим на $$$6$$$ и получим $$$11664$$$; </li>       <li> умножим на $$$2$$$ и получим $$$23328$$$; </li>       <li> разделим на $$$6$$$ и получим $$$3888$$$; </li>       <li> разделим на $$$6$$$ и получим $$$648$$$; </li>       <li> разделим на $$$6$$$ и получим $$$108$$$; </li>       <li> умножим на $$$2$$$ и получим $$$216$$$; </li>       <li> разделим на $$$6$$$ и получим $$$36$$$; </li>       <li> разделим на $$$6$$$ и получим $$$6$$$; </li>       <li> разделим на $$$6$$$ и получим $$$1$$$. </li></ol></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1374/problem/B' title='Codeforces Round 653 (Div. 3)'>1374B - Multiply by 2, divide by 6</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>If the number consists of other primes than $$$2$$$ and $$$3$$$       then the answer is <span class="tex-font-style-tt">-1</span>.       Otherwise, let $$$cnt_2$$$ be the number of twos in the       factorization of $$$n$$$ and $$$cnt_3$$$ be the number of threes       in the factorization of $$$n$$$. If $$$cnt_2 &gt; cnt_3$$$ then       the answer is <span class="tex-font-style-tt">-1</span> because we       can't get rid of all twos. Otherwise, the answer is $$$(cnt_3 -       cnt_2) + cnt_3$$$.</p>     <p>Time complexity: $$$O(\log{n})$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
	
	int t;
	cin &gt;&gt; t;
	while (t--) {
		int n;
		cin &gt;&gt; n;
		int cnt2 = 0, cnt3 = 0;
		while (n % 2 == 0) {
			n /= 2;
			++cnt2;
		}
		while (n % 3 == 0) {
			n /= 3;
			++cnt3;
		}
		if (n == 1 &amp;&amp; cnt2 &lt;= cnt3) {
			cout &lt;&lt; 2 * cnt3 - cnt2 &lt;&lt; endl;
		} else {
			cout &lt;&lt; -1 &lt;&lt; endl;
		}
	}
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #653 (Div. 3)
    1374C
    Перемещай скобки </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Перемещай скобки</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам задана скобочная последовательность $$$s$$$ длины $$$n$$$,       где $$$n$$$ четное (без остатка делится на 2). Строка $$$s$$$       состоит из $$$\frac{n}{2}$$$ открывающих скобок '<span class="tex-font-style-tt">(</span>' и $$$\frac{n}{2}$$$       закрывающих скобок '<span class="tex-font-style-tt">)</span>'.</p>     <p>За один ход вы можете выбрать <span class="tex-font-style-bf">ровно одну скобку</span> и передвинуть       ее в начало или в конец строки (т.е. вы можете выбрать некоторый       индекс $$$i$$$, удалить $$$i$$$-й символ из $$$s$$$ и вставить его       перед или после всех остальных символов в $$$s$$$).</p>     <p>Ваша задача — найти минимальное количество ходов, необходимое,       чтобы получить <span class="tex-font-style-bf">правильную         скобочную последовательность</span> из $$$s$$$. Можно доказать,       что ответ всегда существует при данных ограничениях.</p>     <p>Напомним, что такое правильная скобочная последовательность:</p>          <ul> <li> «<span class="tex-font-style-tt">()</span>» — правильная         скобочная последовательность; </li>       <li> если $$$s$$$ — правильная скобочная последовательность, то           «<span class="tex-font-style-tt">(</span>» + $$$s$$$ + «<span class="tex-font-style-tt">)</span>» — правильная скобочная         последовательность; </li>       <li> если $$$s$$$ и $$$t$$$ — правильные скобочные         последовательности, то $$$s$$$ + $$$t$$$ — правильная скобочная         последовательность. </li></ul>          <p>Например, «<span class="tex-font-style-tt">()()</span>», «<span class="tex-font-style-tt">(())()</span>», «<span class="tex-font-style-tt">(())</span>» и «<span class="tex-font-style-tt">()</span>» являются правильными       скобочными последовательностями, а «<span class="tex-font-style-tt">)(</span>», «<span class="tex-font-style-tt">()(</span>» и «<span class="tex-font-style-tt">)))</span>» — нет.</p>     <p>Вам нужно ответить на $$$t$$$ независимых наборов тестовых данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка теста содержит одно целое число $$$t$$$ ($$$1 \le t       \le 2000$$$) — количество наборов тестовых данных. Затем следуют       $$$t$$$ наборов тестовых данных.</p>     <p>Первая строка набора тестовых данных содержит одно целое число       $$$n$$$ ($$$2 \le n \le 50$$$) — длину $$$s$$$. Гарантируется, что       $$$n$$$ четное. Вторая строка набора тестовых данных содержит       строку $$$s$$$, состоящую из $$$\frac{n}{2}$$$ открывающих и       $$$\frac{n}{2}$$$ закрывающих скобок.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите ответ на него —       минимальное количество ходов, необходимое, чтобы получить <span class="tex-font-style-bf">правильную скобочную       последовательность</span> из $$$s$$$. Можно доказать, что ответ       всегда существует при данных ограничениях.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
2
)(
4
()()
8
())()()(
10
)))((((())
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
0
1
3
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе тестовых данных примера достаточно передвинуть       первую скобку в конец строки.</p>     <p>В третьем наборе тестовых данных примера достаточно передвинуть       последнюю скобку в начало строки.</p>     <p>В четвертом наборе тестовых данных примера мы можем выбрать три       последние открывающие скобки, переместить их в начало строки и       получить «<span class="tex-font-style-tt">((()))(())</span>».</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1374/problem/C' title='Codeforces Round 653 (Div. 3)'>1374C - Move Brackets</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's go from left to right over characters of $$$s$$$       maintaining the current bracket balance (for the position $$$i$$$       the balance is the number of opening brackets on the prefix till       the $$$i$$$-th character minus the number of closing brackets on       the same prefix).</p>     <p>If the current balance becomes less than zero, then let's just       take some opening bracket after the current position (it obviously       exists because the number of opening equals the number of closing       brackets) and move it to the beginning (so the negative balance       becomes zero again and the answer increases by one). Or we can       move the current closing bracket to the end of the string because       it leads to the same result.</p>     <p>Time complexity: $$$O(n)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
	
	int t;
	cin &gt;&gt; t;
	while (t--) {
		int n;
		string s;
		cin &gt;&gt; n &gt;&gt; s;
		int ans = 0;
		int bal = 0;
		for (int i = 0; i &lt; n; ++i) {
			if (s[i] == &#39;(&#39;) ++bal;
			else {
				--bal;
				if (bal &lt; 0) {
					bal = 0;
					++ans;
				}
			}
		}
		cout &lt;&lt; ans &lt;&lt; endl;
	}
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #653 (Div. 3)
    1374D
    Массив с нулевым остатком </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Массив с нулевым остатком</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам задан массив $$$a$$$, состоящий из $$$n$$$ положительных       целых чисел.</p>     <p>Изначально у вас есть целое число $$$x = 0$$$. За один ход вы       можете совершить одну из следующих двух операций:</p>          <ol> <li> Выбрать <span class="tex-font-style-bf">ровно один         индекс</span> $$$i$$$ от $$$1$$$ до $$$n$$$ и увеличить         $$$a_i$$$ на $$$x$$$ ($$$a_i := a_i + x$$$), затем увеличить         $$$x$$$ на $$$1$$$ ($$$x := x + 1$$$). </li>       <li> Просто увеличить $$$x$$$ на $$$1$$$ ($$$x := x + 1$$$). </li></ol>          <p>Первая операция может быть применена <span class="tex-font-style-bf">не более одного раза</span> для       каждого $$$i$$$ от $$$1$$$ до $$$n$$$.</p>     <p>Ваша задача — найти минимальное количество ходов, необходимое,       чтобы получить такой массив, что каждый его элемент <span class="tex-font-style-bf">без остатка делится на</span> $$$k$$$       (значение $$$k$$$ задано).</p>     <p>Вам нужно ответить на $$$t$$$ независимых наборов тестовых данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка теста содержит одно целое число $$$t$$$ ($$$1 \le t       \le 2 \cdot 10^4$$$) — количество наборов тестовых данных. Затем       следуют $$$t$$$ наборов тестовых данных.</p>     <p>Первая строка набора тестовых данных содержит два целых числа       $$$n$$$ и $$$k$$$ ($$$1 \le n \le 2 \cdot 10^5; 1 \le k \le       10^9$$$) — длину массива $$$a$$$ и заданный делитель. Вторая       строка набора содержит $$$n$$$ целых чисел $$$a_1, a_2, \dots,       a_n$$$ ($$$1 \le a_i \le 10^9$$$), где $$$a_i$$$ — $$$i$$$-й       элемент $$$a$$$.</p>     <p>Гарантируется, что сумма всех $$$n$$$ не превосходит $$$2 \cdot       10^5$$$ ($$$\sum n \le 2 \cdot 10^5$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите ответ на него —       минимальное количество ходов, необходимое, чтобы получить такой       массив, что каждый его элемент <span class="tex-font-style-bf">без         остатка делится на</span> $$$k$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
4 3
1 2 1 3
10 6
8 7 1 8 3 7 5 10 8 9
5 10
20 100 50 20 100500
10 25
24 24 24 24 24 24 24 24 24 24
8 8
1 2 3 4 5 6 7 8
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
6
18
0
227
8
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Рассмотрим первый набор тестовых данных примера:</p>          <ol> <li> $$$x=0$$$, $$$a = [1, 2, 1, 3]$$$. Надо просто увеличить         $$$x$$$; </li>       <li> $$$x=1$$$, $$$a = [1, 2, 1, 3]$$$. Надо добавить $$$x$$$ ко         второму элементу и увеличить $$$x$$$; </li>       <li> $$$x=2$$$, $$$a = [1, 3, 1, 3]$$$. Надо добавить $$$x$$$ к         третьему элементу и увеличить $$$x$$$; </li>       <li> $$$x=3$$$, $$$a = [1, 3, 3, 3]$$$. Надо добавить $$$x$$$ к         четвертому элементу и увеличить $$$x$$$; </li>       <li> $$$x=4$$$, $$$a = [1, 3, 3, 6]$$$. Надо просто увеличить         $$$x$$$; </li>       <li> $$$x=5$$$, $$$a = [1, 3, 3, 6]$$$. Надо добавить $$$x$$$ к         первому элементу и увеличить $$$x$$$; </li>       <li> $$$x=6$$$, $$$a = [6, 3, 3, 6]$$$. Мы получили необходимый         массив. </li></ol>          <p>       <span class="tex-font-style-bf">Заметьте, что вы не можете         добавить $$$x$$$ к одному и тому же элементу больше, чем один раз</span>.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1374/problem/D' title='Codeforces Round 653 (Div. 3)'>1374D - Zero Remainder Array</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Firstly, we can understand that during each full cycle of $$$x$$$       from $$$0$$$ to $$$k-1$$$ we can fix each remainder only once.       Notice that when we add some $$$x$$$ then we fix the remainder       $$$k-x$$$ (and we don't need to fix elements which are already       divisible by $$$k$$$). So, let $$$cnt_i$$$ be the number of such       elements for which the condition $$$k - a_i \bmod k = i$$$ holds       (i.e. the number of such elements that we can fix if we add the       value $$$i \bmod k$$$ to them). We can count this using some       logarithmic data structure (like <span class="tex-font-style-tt">std::map</span> in C++).</p>     <p>So, what's the number of full cycles? It equals to the amount of       most frequent element in $$$cnt$$$ minus one. So, the answer is at       least $$$k \cdot (max(cnt) - 1)$$$. And there can be one last       cycle which will be incomplete. So what is the remanining number       of moves? It equals to the maximum possible $$$i$$$ among all       $$$cnt_i = max(cnt)$$$. So if $$$key$$$ is the maximum such       $$$i$$$ that $$$cnt_{key} = max(cnt)$$$ then the answer is $$$k       \cdot (cnt_{key} - 1) + key + 1$$$.</p>     <p>Time complexity: $$$O(n \log{n})$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif

	int t;
	cin &gt;&gt; t;
	while (t--) {
		int n, k;
		cin &gt;&gt; n &gt;&gt; k;
		vector&lt;int&gt; a(n);
		for (auto &amp;it : a) cin &gt;&gt; it;
		map&lt;int, int&gt; cnt;
		int mx = 0;
		for (auto &amp;it : a) {
			if (it % k == 0) continue;
			++cnt[k - it % k];
			mx = max(mx, cnt[k - it % k]);
		}
		long long ans = 0;
		for (auto [key, value] : cnt) {
			if (value == mx) {
				ans = k * 1ll * (value - 1) + key + 1;
			}
		}
		cout &lt;&lt; ans &lt;&lt; endl;
	}
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #653 (Div. 3)
    1374F
    Сортировка циклическими сдвигами </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Сортировка циклическими сдвигами</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам задан массив $$$a$$$, состоящий из $$$n$$$ целых чисел.</p>     <p>За один ход вы можете выбрать некоторый индекс $$$i$$$ ($$$1 \le       i \le n - 2$$$) и сдвинуть отрезок $$$[a_i, a_{i + 1}, a_{i +       2}]$$$ циклически вправо (т.е. заменить отрезок $$$[a_i, a_{i +       1}, a_{i + 2}]$$$ на $$$[a_{i + 2}, a_i, a_{i + 1}]$$$). </p>     <p>Ваша задача — отсортировать заданный массив за <span class="tex-font-style-bf">не более чем $$$n^2$$$ таких       операций</span> или сказать, что это невозможно.</p>     <p>Вам нужно ответить на $$$t$$$ независимых наборов тестовых данных.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка теста содержит одно целое число $$$t$$$ ($$$1 \le t       \le 100$$$) — количество наборов тестовых данных. Затем следуют       $$$t$$$ наборов тестовых данных.</p>     <p>Первая строка набора тестовых данных содержит одно целое число       $$$n$$$ ($$$3 \le n \le 500$$$) — длину массива $$$a$$$. Вторая       строка набора тестовых данных содержит $$$n$$$ целых чисел $$$a_1,       a_2, \dots, a_n$$$ ($$$1 \le a_i \le 500$$$), где $$$a_i$$$ —       $$$i$$$-й элемент $$$a$$$.</p>     <p>Гарантируется, что сумма всех $$$n$$$ не превосходит $$$500$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите ответ: <span class="tex-font-style-tt">-1</span> единственной строкой, если       невозможно отсортировать заданный массив, используя операции,       описанные в условии задачи, или количество операций $$$ans$$$       первой строкой и $$$ans$$$ целых чисел $$$idx_1, idx_2, \dots,       idx_{ans}$$$ ($$$1 \le idx_i \le n - 2$$$), где $$$idx_i$$$ —       индекс левой границы отрезка для $$$i$$$-й операции. Вы должны       вывести индексы <span class="tex-font-style-bf">в порядке         применения операций</span>.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
5
1 2 3 4 5
5
5 4 3 2 1
8
8 4 5 2 3 6 7 3
7
5 2 1 6 4 7 3
6
1 2 3 3 6 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0

6
3 1 3 2 2 3 
13
2 1 1 6 4 2 4 3 3 4 4 6 6 
-1
4
3 3 4 4 
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1374/problem/F' title='Codeforces Round 653 (Div. 3)'>1374F - Cyclic Shifts Sorting</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Firstly, let's solve the easier version of the problem. Assume we       are given a permutation, not an array. Notice that the given       operation applied to some segment of the permutation cannot change       the parity of number of inversions (the number of inversions is       the number of such pairs of indices $$$(i, j)$$$ that $$$j &gt;       i$$$ and $$$a_j &lt; a_i$$$). So if the number of inversions in       the given permutation is odd then we can't sort this permutation       (we can't obtain zero inversions).</p>     <p>But if the number of inversions is even then we can always sort       the permutation with the following greedy algorithm: let's find       the minimum element and move it to the first position. If its       position is $$$i$$$ then we can apply the operation to the segment       $$$[i-2; i]$$$ and our element will move by two positions to the       left. So, after all, our element is either at the first or at the       second position. If it's at the second position, let's just apply       two additional operations to the segment $$$[1; 3]$$$. Then let's       just cut off the first element and solve the problem without it.       At the end we have only two numbers that can be not sorted and we       can check all three possibilities and choose one which is suitable       for us (it's always exists because the number of inversions is even).</p>     <p>How do we solve the problem if we are given the array, not the       permutation? First of all, we can prove that if the array contains       at least two equal elements, we can always sort it (we will prove       it by construction). Let's just renumerate the elements of the       given array in a way to obtian the permutation with the even       number of inversions. Thus, if $$$a[i_1] \le a[i_2] \le \dots \le       a[i_n]$$$ then let's find such a permutation $$$p$$$ that       $$$p[i_1] &lt; p[i_2] &lt; \dots &lt; p[i_n]$$$. We can find this       permutation easily if we sort the array of pairs $$$(a_i, i)$$$ in       increasing order. But there can be one problem: this permutation       can have odd number of inversions. Then we need to find two       consecutive pairs with the same first values and swap these two       elements in the permutation. Because in fact these two numbers are       equal in the array and have consecutive values in the permutation,       we guaranteed change the parity of number of inversions. Then we       can apply our algorithm for permutations and solve the problem for       the array. If we failed then the answer is <span class="tex-font-style-tt">-1</span>. Otherwise the number of       operations always does not exceed $$$n^2$$$ (because this sort       works like a bubble sort) so our answer is suitable.</p>     <p>Time complexity: $$$O(n^2)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
#ifdef _DEBUG
	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);
#endif
	
	auto make = [](vector&lt;int&gt; &amp;a, int pos) {
		swap(a[pos + 1], a[pos + 2]);
		swap(a[pos], a[pos + 1]);
	};

	int t;
	cin &gt;&gt; t;
	while (t--) {
		int n;
		cin &gt;&gt; n;
		vector&lt;int&gt; a(n);
		vector&lt;pair&lt;int, int&gt;&gt; res(n);
		for (int i = 0; i &lt; n; ++i) {
			cin &gt;&gt; a[i];
			res[i] = { a[i], i };
		}
		sort(res.begin(), res.end());
		for (int i = 0; i &lt; n; ++i) {
			a[res[i].second] = i;
		}
		int cnt = 0;
		for (int i = 0; i &lt; n; ++i) {
			for (int j = i + 1; j &lt; n; ++j) {
				cnt += a[j] &lt; a[i];
			}
		}
		if (cnt &amp; 1) {
			for (int i = 0; i &lt; n - 1; ++i) {
				if (res[i].first == res[i + 1].first) {
					swap(a[res[i].second], a[res[i + 1].second]);
					break;
				}
			}
		}
		vector&lt;int&gt; ans;
		for (int i = 0; i &lt; n - 2; ++i) {
			int pos = min_element(a.begin() + i, a.end()) - a.begin();
			while (pos &gt; i + 1) {
				make(a, pos - 2);
				ans.push_back(pos - 2);
				pos -= 2;
			}
			if (pos != i) {
				make(a, i);
				make(a, i);
				ans.push_back(i);
				ans.push_back(i);
				pos = i;
			}
		}
		for (int i = 0; i &lt; 3; ++i) {
			if (is_sorted(a.begin(), a.end())) {
				break;
			}
			make(a, n - 3);
			ans.push_back(n - 3);
		}
		if (!is_sorted(a.begin(), a.end())) {
			cout &lt;&lt; -1 &lt;&lt; endl;
		} else {
			cout &lt;&lt; ans.size() &lt;&lt; endl;
			for (auto it : ans) cout &lt;&lt; it + 1 &lt;&lt; &#34; &#34;;
			cout &lt;&lt; endl;
		}
	}
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 91 (рейтинговый для Див. 2)
    1380A
    Три индекса </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Три индекса</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам задана перестановка $$$p_1, p_2, \dots, p_n$$$. Напомним, что       последовательность из $$$n$$$ целых чисел называется <span class="tex-font-style-it">перестановкой</span>, если она содержит       все целые числа от $$$1$$$ до $$$n$$$ ровно один раз.</p>     <p>Вам необходимо найти три индекса $$$i$$$, $$$j$$$ и $$$k$$$       такие, что:</p>          <ul> <li> $$$1 \le i &lt; j &lt; k \le n$$$; </li>       <li> $$$p_i &lt; p_j$$$ и $$$p_j &gt; p_k$$$. </li></ul>          <p>Или сообщить, что таких трех индексов нет.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит одно целое число $$$T$$$ ($$$1 \le T \le       200$$$) — количество наборов входных данных.</p>     <p>Следующие $$$2T$$$ содержат описание наборов входных данных  —       две строки на каждый набор. Первая строка каждого набора входных       данных содержит единственное целое число $$$n$$$ ($$$3 \le n \le       1000$$$) — длина перестановки $$$p$$$.</p>     <p>Вторая строка содержит $$$n$$$ целых чисел $$$p_1, p_2, \dots,       p_n$$$ ($$$1 \le p_i \le n$$$; $$$p_i \neq p_j$$$ если $$$i \neq       j$$$) — перестановка $$$p$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных: </p>     <ul> <li> если есть такие индексы $$$i$$$, $$$j$$$ и $$$k$$$,         выведите <span class="tex-font-style-tt">YES</span> (без учета         регистра) и сами индексы; </li>       <li> если таких трех индексов нет, выведите <span class="tex-font-style-tt">NO</span> (без учета регистра). </li></ul>          <p>Если допустимых наборов индексов несколько, выведите любой из них.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
4
2 1 4 3
6
4 6 1 2 5 3
5
5 3 1 2 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
YES
2 3 4
YES
3 5 6
NO
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1380/problem/A' title='Educational Codeforces Round 91 (Rated for Div. 2)'>1380A - Three Indices</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>A solution in $$$O(n^2)$$$: iterate on $$$j$$$, check that there       exists an element lower than $$$a_j$$$ to the left of it, and       check that there exists an element lower than $$$a_j$$$ to the       right of it. Can be optimized to $$$O(n)$$$ with prefix/suffix minima.</p>     <p>A solution in $$$O(n)$$$: note that if there is some answer, we       can find an index $$$j$$$ such that $$$a_{j - 1} &lt; a_j$$$ and       $$$a_j &gt; a_{j + 1}$$$ (if there is no such triple, the array       descends to some point and ascends after that, so there is no       answer). So we only have to check $$$n - 2$$$ consecutive triples.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

const int N = 1000;

int n;
int a[N];

void solve() {
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i)
		cin &gt;&gt; a[i];
	for (int i = 1; i &lt; n - 1; ++i) {
		if (a[i] &gt; a[i - 1] &amp;&amp; a[i] &gt; a[i + 1]) {
			cout &lt;&lt; &#34;YES&#34; &lt;&lt; endl;
			cout &lt;&lt; i &lt;&lt; &#39; &#39; &lt;&lt; i + 1 &lt;&lt; &#39; &#39; &lt;&lt; i + 2 &lt;&lt; endl;
			return;
		}
	}
	cout &lt;&lt; &#34;NO&#34; &lt;&lt; endl;
}

int main() {
	int T;
	cin &gt;&gt; T;
	while (T--)
		solve();
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 91 (рейтинговый для Див. 2)
    1380B
    Универсальное решение </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Универсальное решение</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Недавно, вы обнаружили бота, с которым можно сыграть в «Камень,       ножницы, бумага». К сожалению, бот использует довольно примитивный       алгоритм игры: у него есть строка $$$s = s_1 s_2 \dots s_{n}$$$       длины $$$n$$$, где каждый символ — это <span class="tex-font-style-tt">R</span>, <span class="tex-font-style-tt">S</span> или <span class="tex-font-style-tt">P</span>.</p>     <p>Во время инициализации, бот выбирает стартовую позицию $$$pos$$$       ($$$1 \le pos \le n$$$), и потом может сыграть любое количество       раундов. В первом раунде, он выбирает «Камень», «Ножницы» или       «Бумагу» на основании значения $$$s_{pos}$$$: </p>     <ul> <li> если $$$s_{pos}$$$ равняется <span class="tex-font-style-tt">R</span>, то бот выбирает «Камень»; </li>       <li> если $$$s_{pos}$$$ равняется <span class="tex-font-style-tt">S</span>, то бот выбирает «Ножницы»; </li>       <li> если $$$s_{pos}$$$ равняется <span class="tex-font-style-tt">P</span>, то бот выбирает «Бумагу»; </li></ul>          <p>Во втором раунде, выбор бота основан на значении $$$s_{pos +       1}$$$. В третьем раунде — на $$$s_{pos + 2}$$$ и так далее. После       $$$s_n$$$, бот возвращается к $$$s_1$$$ и продолжает игру.</p>     <p>Вы планируете сыграть $$$n$$$ раундов и уже определили строку       $$$s$$$, однако не знаете, чему равняется стартовая позиция       $$$pos$$$. Но так как тактика бота очень скучная, вы решили найти       такие $$$n$$$ ходов в раундах, чтобы максимизировать среднее       количество побед.</p>     <p>Другими словами, предположим, что ваши ходы — это $$$c_1 c_2       \dots c_n$$$ и если бот начнет с позиции $$$pos$$$, то вы       выиграете в $$$win(pos)$$$ раундах. Найдите $$$c_1 c_2 \dots       c_n$$$ такие, что $$$\frac{win(1) + win(2) + \dots +       win(n)}{n}$$$ — максимально возможное.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке задано единственное число $$$t$$$ ($$$1 \le t \le       1000$$$) — количество наборов входных данных.</p>     <p>В следующих $$$t$$$ строках заданы сами наборы — по одному в       строке. В единственной строке каждого набора задана строка $$$s =       s_1 s_2 \dots s_{n}$$$ ($$$1 \le n \le 2 \cdot 10^5$$$; $$$s_i \in       \{\text{R}, \text{S}, \text{P}\}$$$) — строка бота.</p>     <p>Гарантируется, что суммарная длина всех строк в одном тесте не       превосходит $$$2 \cdot 10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных, выведите $$$n$$$ ходов $$$c_1       c_2 \dots c_n$$$ таких, которые максимизируют среднее количество       побед. Выведите их в том же формате, в котором задана строка $$$s$$$.</p>     <p>Если существует несколько оптимальных ответов, выведите любой из них.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
RRRR
RSP
S
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
PPPP
RSP
R</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных, бот (с какой бы позиции не начал)       будет всегда выбирать «Камень», поэтому мы можем всегда выбирать       «Бумагу». То есть, в любом случае, мы выиграем все $$$n = 4$$$       раунда, и, соответственно, среднее количество побед также равно $$$4$$$.</p>     <p>Во втором наборе: </p>     <ul> <li> если бот начнет с позиции $$$pos = 1$$$, то $$$(s_1,         c_1)$$$ — ничья, $$$(s_2, c_2)$$$ — ничья и $$$(s_3, c_3)$$$ —         ничья, поэтому $$$win(1) = 0$$$; </li>       <li> если бот начнет с позиции $$$pos = 2$$$, то $$$(s_2,         c_1)$$$ — победа, $$$(s_3, c_2)$$$ — победа и $$$(s_1, c_3)$$$ —         победа, поэтому $$$win(2) = 3$$$; </li>       <li> если бот начнет с позиции $$$pos = 3$$$, то $$$(s_3,         c_1)$$$ — проигрыш, $$$(s_1, c_2)$$$ — проигрыш и $$$(s_2,         c_3)$$$ — проигрыш, поэтому $$$win(3) = 0$$$; </li></ul> Среднее     равно $$$\frac{0 + 3 + 0}{3} = 1$$$, и можно доказать, что это     максимально возможное среднее количество побед.     <p>Картинка из Википедии, описывающая игру «Камень, ножницы,       бумага»: </p>     <center> <img class="tex-graphics" src="https://espresso.codeforces.com/46da581691fc5fc89f034caf475c42a4026d6342.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1380/problem/B' title='Educational Codeforces Round 91 (Rated for Div. 2)'>1380B - Universal Solution</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's look at the contribution of each choice $$$c_i$$$ to the       total number of wins $$$win(1) + win(2) + \dots + win(n)$$$ (we       can look at &quot;total&quot; instead of &quot;average&quot;,       since &quot;average&quot; is equal to &quot;total&quot; divided by       $$$n$$$). For example, let's look at the first choice $$$c_1$$$:       in $$$win(1)$$$ we compare $$$c_1$$$ with $$$s_1$$$, in       $$$win(2)$$$ — $$$c_1$$$ with $$$s_2$$$, in $$$win(3)$$$ —       $$$c_1$$$ with $$$s_3$$$ and so on.</p>     <p>In the result, we compare $$$c_1$$$ with all $$$s_i$$$ once. So,       to maximize the total sum, we need to choose $$$c_1$$$ that beats       the maximum number of $$$s_i$$$ or, in other words, let's find the       most frequent character in $$$s$$$ and choose $$$c_1$$$ that beats it.</p>     <p>Okay, we found the optimal $$$c_1$$$. But if we look at the       contribution of any other $$$c_i$$$ we can note that we compare       any $$$c_i$$$ with all $$$s_i$$$ once. So we can choose all       $$$c_i$$$ equal to $$$c_1$$$ which is equal to the choice that       beats the most frequent choice in $$$s$$$.</p></div></div></div>

           
            <pre><code>fun main() {
    val winBy = mapOf(&#39;R&#39; to &#39;P&#39;, &#39;S&#39; to &#39;R&#39;, &#39;P&#39; to &#39;S&#39;)
    repeat(readLine()!!.toInt()) {
        val s = readLine()!!
        val maxCnt = s.groupingBy { it }.eachCount().maxBy { it.value }!!.key
        println(&#34;${winBy[maxCnt]}&#34;.repeat(s.length))
    }
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 91 (рейтинговый для Див. 2)
    1380C
    Собери команды </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Собери команды</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У вас есть $$$n$$$ программистов, которых вы хотите распределить       по командам. Навык $$$i$$$-го программиста равен $$$a_i$$$. Вы       хотите собрать из них максимальное количество команд. Для команд       есть одно ограничение: количество программистов в команде,       умноженное на минимальный навык среди всех программистов этой       команды, должно быть как минимум $$$x$$$.</p>     <p>Каждый программист может находиться максимум в одной команде.       Некоторые программисты могут остаться без команды.</p>     <p>Посчитайте максимальное количество команд, которое вы можете собрать.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит одно число $$$t$$$ ($$$1 \le t \le       1000$$$) — количество наборов входных данных.</p>     <p>Первая строка каждого набора входных данных содержит два числа       $$$n$$$ и $$$x$$$ ($$$1 \le n \le 10^5; 1 \le x \le 10^9$$$) —       количество программистов и ограничение на навык команды соответственно.</p>     <p>Вторая строка каждого набора входных данных содержит $$$n$$$       чисел $$$a_1, a_2, \dots , a_n$$$ ($$$1 \le a_i \le 10^9$$$), где       $$$a_i$$$ равно навыку $$$i$$$-го программиста.</p>     <p>Сумма $$$n$$$ по всем наборам не превосходит $$$10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>На каждый набор входных данных выведите одно число — максимальное       количество команд, которое вы можете собрать.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
5 10
7 11 2 9 5
4 8
2 4 2 3
4 11
1 3 3 7
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
1
0
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1380/problem/C' title='Educational Codeforces Round 91 (рейтинговый для Див. 2)'>1380C - Собери команды</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>At first, notice that if only $$$k &lt; n$$$ programmers are       taken, then the same or even better answer can be achieved if       $$$k$$$ strongest programmers are taken.</p>     <p>Now let's sort the programmers in non-decreasing order and choose       some assignment into the teams. For each team only the rightmost       taken programmer of that team matters (the sorted sequence implies       that the rightmost is the weakest).</p>     <p>Take a look at the team with the strongest weakest member. If the       number of programmers in it is less than the position of the       weakest member, then you can safely rearrange the programmers       before him in such a way that none of parameters of later teams       change and the weakest member in the first one only becomes       stronger. After that you can get rid of the first team (as it       takes exactly the prefix of all the programmers) and proceed to       fix the later teams.</p>     <p>Thus, we can see that there is an optimal solution such that each       team is a segment and all the teams together take some prefix of       the programmers. So we can finally run a greedy solution that       takes programmers from left to right and increases the answer if       the conditions for the latest team hold.</p>     <p>Overall complexity: $$$O(n \log n)$$$.</p></div></div></div>

           
            <pre><code>for _ in range(int(input())):
    n, x = map(int, input().split())
    a = sorted(list(map(int, input().split())), reverse=True)
    res, cur = 0, 1
    for s in a:
        if s * cur &gt;= x:
            res += 1
            cur = 0
        cur += 1
    print(res)
    
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 91 (рейтинговый для Див. 2)
    1380D
    Берсерк и Огненный Шар </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Берсерк и Огненный Шар</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>В ряд стоят $$$n$$$ воинов. Сила $$$i$$$-го воина равна       $$$a_i$$$. Все силы различны.</p>     <p>Вы можете использовать заклинания двух типов: </p>     <ol> <li> Огненный Шар: вы тратите $$$x$$$ маны и уничтожаете <span class="tex-font-style-bf">ровно</span> $$$k$$$ последовательных         воинов; </li>       <li> Берсерк: вы тратите $$$y$$$ маны, выбираете двух соседних         воинов, и воин с большей силой убивает воина с меньшей силой. </li></ol>          <p>Например, пусть силы воинов равны $$$[2, 3, 7, 8, 11, 5, 4]$$$, и       $$$k = 3$$$. Если использовать Берсерк на воинах с силой $$$8$$$ и       $$$11$$$, последовательность станет $$$[2, 3, 7, 11, 5, 4]$$$.       Если после этого использовать Огненный Шар на воинах с силами       $$$[7, 11, 5]$$$, последовательность станет $$$[2, 3, 4]$$$.</p>     <p>Вам необходимо превратить последовательность сил воинов $$$a_1,       a_2, \dots, a_n$$$ в $$$b_1, b_2, \dots, b_m$$$. Посчитайте       минимальное количество маны, которое вы должны затратить.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит два числа $$$n$$$ и $$$m$$$ ($$$1 \le n, m       \le 2 \cdot 10^5$$$) — длина последовательности $$$a$$$ и длина       последовательности $$$b$$$ соответственно.</p>     <p>Вторая строка содержит три числа $$$x, k, y$$$ ($$$1 \le x, y,       \le 10^9; 1 \le k \le n$$$) — стоимость Огненного Шара, длина       действия Огненного Шара и стоимость Берсерка соответсвенно.</p>     <p>Третья строка содержит $$$n$$$ чисел $$$a_1, a_2, \dots, a_n$$$       ($$$1 \le a_i \le n$$$). Гарантируется что числа $$$a_i$$$ попарно различны.</p>     <p>Четвертая строка содержит $$$m$$$ чисел $$$b_1, b_2, \dots,       b_m$$$ ($$$1 \le b_i \le n$$$). Гарантируется что числа $$$b_i$$$       попарно различны.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите минимальное количество маны для превращения       последовательности $$$a_1, a_2, \dots, a_n$$$ в $$$b_1, b_2,       \dots, b_m$$$ (или $$$-1$$$, если это невозможно).</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5 2
5 2 3
3 1 4 5 2
3 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
8
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
4 4
5 1 4
4 3 1 2
2 4 3 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
-1
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
4 4
2 1 11
1 3 2 4
1 3 2 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1380/problem/D' title='Educational Codeforces Round 91 (Rated for Div. 2)'>1380D - Berserk And Fireball</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>The first thing we need to do is to find the occurrences of       $$$b_i$$$ in the sequence $$$[a_1, a_2, \dots, a_n]$$$ — these are       the monsters that have to remain. Since both spells (Fireball and       Berserk) affect consecutive monsters, we should treat each       subsegment of monsters we have to delete separately.</p>     <p>Consider a segment with $$$x$$$ monsters we have to delete such       that the last monster before it has power $$$l$$$, the first       monster after the segment has power $$$r$$$, and the strongest       monster on the segment has power $$$p$$$.</p>     <p>If $$$x \bmod k \ne 0$$$, then we have to use Berserk at least       $$$x \bmod k$$$ times. Let's make the strongest monster on segment       kill some other monster. If $$$x &lt; k$$$, then the strongest       monster should also be killed by one of the monsters bounding the       segment, so if $$$l &lt; p$$$ and $$$r &lt; p$$$, there is no solution.</p>     <p>Okay, now the number of monsters is divisible by $$$k$$$. If it       is more profitable to use Fireball, we use the required number of       Fireballs to kill all of them. Otherwise, we have to kill the       maximum possible number of monsters with Berserk and finish the       remaining ones with Fireball. If $$$l &gt; p$$$ or $$$r &gt; p$$$,       then one of the monsters just outside the segment can kill all the       monsters inside the segment; otherwise, the strongest monster       should kill adjacent monsters until exactly $$$k$$$ remain, and       those $$$k$$$ monsters are finished with a single Fireball.</p>     <p>Now we know what we need to consider when processing a single       segment; all that's left is to sum the minimum required mana over       all such segments. Since the total length of these segments is at       most $$$n - 1$$$ and we can process each segment in linear time,       we have a solution with complexity $$$O(n)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

const int N = int(2e5) + 9;

int n, m;
long long x, k, y;
int a[N];
int b[N];

bool upd(int l, int r, long long &amp;res) {
    if (l &gt; r) return true;
    bool canDel = false;
    int mx = *max_element(a + l, a + r + 1);
    int len = r - l + 1;
    if (l - 1 &gt;= 0 &amp;&amp; a[l - 1] &gt; mx) canDel = true;
    if (r + 1 &lt; n &amp;&amp; a[r + 1] &gt; mx) canDel = true;
    if (len &lt; k &amp;&amp; !canDel) return false;
    
    int need = len % k;
    res += need * y;
    len -= need;
    
    if (y * k &gt;= x) {
        res += len / k * x;
    } else if(canDel) {
        res += len * y;
    } else {
        res += (len - k) * y + x;
    }
    
    return true;
}

int main(){
    scanf(&#34;%d %d&#34;, &amp;n, &amp;m);
    scanf(&#34;%lld %lld %lld&#34;, &amp;x, &amp;k, &amp;y);
    for (int i = 0; i &lt; n; ++i) scanf(&#34;%d&#34;, a + i);
    for (int i = 0; i &lt; m; ++i) scanf(&#34;%d&#34;, b + i);
    
    long long res = 0;
    int lst = -1, posa = 0, posb = 0;
    while (posb &lt; m) {
        while(posa &lt; n &amp;&amp; a[posa] != b[posb]) ++posa;
        if (posa == n) {
            puts(&#34;-1&#34;);
            return 0;
        }
        
        if (!upd(lst + 1, posa - 1, res)) {
            puts(&#34;-1&#34;);
            return 0;
        }
        
        lst = posa;
        ++posb;
    }
    
    if (!upd(lst + 1, n - 1, res)) {
        puts(&#34;-1&#34;);
        return 0;
    }
    
    printf(&#34;%lld\n&#34;, res);
    
    return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 91 (рейтинговый для Див. 2)
    1380E
    Слияние башен </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. Слияние башен</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У вас есть $$$n$$$ дисков, радиус $$$i$$$-го диска равен $$$i$$$.       Изначально эти диски распределены по $$$m$$$ башням из дисков:       каждая башня содержит хотя бы один диск, и диски в каждой башне       отсортированы от большего к меньшему снизу вверх.</p>     <p>Вы должны собрать все диски в одну башню. Чтобы сделать это, вы       можете выбрать две различных башни $$$i$$$ и $$$j$$$ (каждая из       которых содержит хотя бы один диск), взять несколько (возможно,       все) верхних дисков с башни $$$i$$$ и поместить их на вершину       башни $$$j$$$ в том же самом порядке — при условии, что верхний       диск башни $$$j$$$ больше каждого перемещаемого диска. Эту       операцию можно применять любое количество раз.</p>     <p>Например, если у вас есть две башни, содержащие диски $$$[6, 4,       2, 1]$$$ и $$$[8, 7, 5, 3]$$$ (в порядке снизу вверх), существуют       ровно две возможные операции:</p>          <ul> <li> переместить диск $$$1$$$ с первой башни на вторую, после         чего башни станут следующими: $$$[6, 4, 2]$$$ и $$$[8, 7, 5, 3,         1]$$$; </li>       <li> переместить диски $$$[2, 1]$$$ с первой башни на вторую,         после чего башни станут следующими: $$$[6, 4]$$$ и $$$[8, 7, 5,         3, 2, 1]$$$. </li></ul>          <p>Пусть <span class="tex-font-style-it">сложность</span> некоторого       набора башен — это минимальное количество операций, необходимых       для того, чтобы собрать все диски в одну башню. Например, <span class="tex-font-style-it">сложность</span> набора башен $$$[[3,       1], [2]]$$$ равна $$$2$$$: вы можете переместить диск $$$1$$$ на       вторую башню, а потом переместить оба диска со второй башни на       первую башню.</p>     <p>Вам заданы $$$m - 1$$$ запросов. Каждый запрос обозначается двумя       числами $$$a_i$$$ и $$$b_i$$$, обозначающими следующее: «слить       башни $$$a_i$$$ и $$$b_i$$$ в одну» (то есть взять все диски из       этих башен и составить из них одну башню, в которой диски       отсортированы по убыванию размера снизу вверх). Новая башня       (являющаяся результатом слияния) получает индекс $$$a_i$$$.</p>     <p>Для каждого $$$k \in [0, m - 1]$$$ посчитайте <span class="tex-font-style-it">сложность</span> набора башен после       выполнения первых $$$k$$$ запросов.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит два целых числа $$$n$$$ и $$$m$$$ ($$$2       \le m \le n \le 2 \cdot 10^5$$$) — количество дисков и башен, соответственно.</p>     <p>Вторая строка содержит $$$n$$$ целых чисел $$$t_1$$$, $$$t_2$$$,       ..., $$$t_n$$$ ($$$1 \le t_i \le m$$$), где $$$t_i$$$ — индекс       башни, к которой принадлежит диск $$$i$$$. Каждое значение от       $$$1$$$ до $$$m$$$ встречается в этой последовательности хотя бы       один раз.</p>     <p>Затем следуют $$$m - 1$$$ строк, обозначающих запросы. Каждый       запрос задается двумя целыми числами $$$a_i$$$ и $$$b_i$$$ ($$$1       \le a_i, b_i \le m$$$, $$$a_i \ne b_i$$$), обозначающими, что во       время $$$i$$$-го запроса башни $$$a_i$$$ и $$$b_i$$$ сливаются в       одну ($$$a_i$$$ и $$$b_i$$$ всегда выбраны таким образом, что       башни с этими номерами существуют до $$$i$$$-го запроса).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$m$$$ целых чисел. $$$k$$$-е число (в       $$$0$$$-индексации) должно быть равно сложности набора башен после       первых $$$k$$$ запросов.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
7 4
1 2 3 3 1 4 3
3 1
2 3
2 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
5
4
2
0
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Башни в примере из условия:</p>          <ul> <li> до запросов: $$$[[5, 1], [2], [7, 4, 3], [6]]$$$; </li>       <li> после первого запроса: $$$[[2], [7, 5, 4, 3, 1], [6]]$$$; </li>       <li> после второго запроса: $$$[[7, 5, 4, 3, 2, 1], [6]]$$$; </li>       <li> после третьего запроса остается только одна башня: $$$[7, 6,         5, 4, 3, 2, 1]$$$. </li></ul></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1380/problem/E' title='Educational Codeforces Round 91 (Rated for Div. 2)'>1380E - Merging Towers</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>First of all, let's try to find a simple way to evaluate the       difficulty of a given set of towers. I claim that the difficulty       is equal to the number of pairs of discs $$$(i, i + 1)$$$ that       belong to different towers.</p>     <p>       <span class="tex-font-style-bf">The beginning of the proof</span></p>          <ul>               <li> during each operation we can &quot;merge&quot; at most one         such pair: if we move discs to the tower with disk $$$i$$$ on         top of it, only the pair $$$(i - 1, i)$$$ can be affected; </li>       <li> we can always take the first several $$$k$$$ discs belonging         to the same tower and move them to the tower containing disc         $$$k + 1$$$, thus merging exactly one pair in exactly one operation.         </li></ul>          <p>       <span class="tex-font-style-bf">The end of the proof</span></p>     <p>After that, there are two main approaches: LCA and small-to-large       merging. The model solution uses LCA, so I'll describe it.</p>     <p>For each pair $$$(i, i + 1)$$$, we have to find the first moment       these discs belong to the same tower. To do so, let's build a       rooted tree on $$$2m - 1$$$ vertices. The vertices $$$1$$$ to       $$$m$$$ will be the leaves of the tree and will represent the       original towers. The vertex $$$m + i$$$ will represent the tower       created during the $$$i$$$-th query and will have two children —       the vertices representing the towers we merge during the       $$$i$$$-th query. The vertex $$$2m - 1$$$ is the root.</p>     <p>Now, if some vertex $$$x$$$ is an ancestor of vertex $$$y$$$, it       means that the tower represented by vertex $$$x$$$ contains all       the discs from the tower represented by vertex $$$y$$$. So, to       find the first tower containing two discs $$$i$$$ and $$$i + 1$$$,       we have to find the lowest common ancestor of the vertices       representing the towers $$$t_i$$$ and $$$t_{i + 1}$$$. The easiest       way to do it is to implement something like binary lifting, which       allows us to solve the problem in $$$O(n \log m)$$$.</p></div></div></div>

           
            <pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;

const int N = 200043;
const int L = 20;

vector&lt;int&gt; g[2 * N];
int p[2 * N];
int up[2 * N][L];
int idx[N];
int psum[N];
int cur[N];
int tin[2 * N];
int tout[2 * N];
int T = 0;

void dfs(int x, int y)
{
	tin[x] = T++;
	p[x] = y;
	up[x][0] = y;
	for(int i = 1; i &lt; L; i++)
		up[x][i] = up[up[x][i - 1]][i - 1];
	for(auto z : g[x])
		dfs(z, x);
	tout[x] = T++;
}

bool is_ancestor(int x, int y)
{
	return tin[x] &lt;= tin[y] &amp;&amp; tout[x] &gt;= tout[y];
}

int lca(int x, int y)
{
	if(is_ancestor(x, y))
		return x;
	for(int i = L - 1; i &gt;= 0; i--)
		if(!is_ancestor(up[x][i], y))
			x = up[x][i];
	return p[x];
}

int main()
{
	int n, m;
	scanf(&#34;%d %d&#34;, &amp;n, &amp;m);
	for(int i = 0; i &lt; n; i++)
	{
		scanf(&#34;%d&#34;, &amp;idx[i]);
		idx[i]--;
	}
	for(int i = 0; i &lt; m; i++)
		cur[i] = i;
	for(int i = 0; i &lt; m - 1; i++)
	{
		int x, y;
		scanf(&#34;%d %d&#34;, &amp;x, &amp;y);
		--x;
		--y;
		int nidx = m + i;
		g[nidx].push_back(cur[x]);
		g[nidx].push_back(cur[y]);
		cur[x] = nidx;
	}
	int root = m * 2 - 2;
	dfs(root, root);
	for(int i = 0; i &lt; n - 1; i++)
	{
		int t = lca(idx[i], idx[i + 1]);
		if(t &lt; m)
			psum[0]++;
		else
			psum[t - m + 1]++;
	}
	for(int i = 0; i &lt; m - 1; i++)
		psum[i + 1] += psum[i];
	for(int i = 0; i &lt; m; i++)
		printf(&#34;%d\n&#34;, n - 1 - psum[i]);
}
</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;

#define forn(i, n) for (int i = 0; i &lt; int(n); i++)

using namespace std;

int n, m;
vector&lt;int&gt; p;
vector&lt;vector&lt;int&gt;&gt; val;
vector&lt;int&gt; who;

int getp(int a){
	return a == p[a] ? a : p[a] = getp(p[a]);
}

int main(){
	scanf(&#34;%d%d&#34;, &amp;n, &amp;m);
	p.resize(m);
	val.resize(m);
	who.resize(n);
	int ans = n - 1;
	forn(i, m)
		p[i] = i;
	forn(i, n){
		int x;
		scanf(&#34;%d&#34;, &amp;x);
		--x;
		who[i] = x;
		ans -= (i &amp;&amp; who[i] == who[i - 1]);
		val[who[i]].push_back(i);
	}
	printf(&#34;%d\n&#34;, ans);
	forn(i, m - 1){
		int v, u;
		scanf(&#34;%d%d&#34;, &amp;v, &amp;u);
		v = getp(v - 1), u = getp(u - 1);
		if (val[v].size() &lt; val[u].size())
			swap(v, u);
		for (int x : val[u]){
			if (x) ans -= who[x - 1] == v;
			if (x &lt; n - 1) ans -= who[x + 1] == v;
		}
		for (int x : val[u]){
			val[v].push_back(x);
			who[x] = v;
		}
		p[u] = v;
		printf(&#34;%d\n&#34;, ans);
	}
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 91 (рейтинговый для Див. 2)
    1380F
    Странное сложение </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Странное сложение</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>5 секунд</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Пусть $$$a$$$ и $$$b$$$ будут некоторыми неотрицательными целыми       числами. Определим <span class="tex-font-style-it">странное       сложение</span> $$$a$$$ и $$$b$$$ следующим образом:</p>          <ol> <li> запишем числа одно под другим и выровняем их по младшему         разряду; </li>       <li> сложим числа поразрядно и запишем полученные суммы одну за         другой. </li></ol>          <p>Будем считать, что у обоих чисел бесконечное число лидирующих нулей.</p>     <p>Например, взглянем на <span class="tex-font-style-it">странное       сложение</span> чисел $$$3248$$$ и $$$908$$$:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/347654d27ffde9fca26cd3d1b164ce3730931fe0.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>Вам задана строка $$$c$$$, состоящая из $$$n$$$ цифр от $$$0$$$       до $$$9$$$. Также заданы $$$m$$$ запросов обновления следующего вида:</p>     <ul> <li> $$$x~d$$$ — заменить цифру на $$$x$$$-й позиции $$$c$$$ на         цифру $$$d$$$. </li></ul>          <p>Обратите внимание, что $$$c$$$ может иметь лидирующие нули в       любой момент времени.</p>     <p>После каждого обновления выведите количество пар чисел $$$(a,       b)$$$ таких, что $$$a$$$ и $$$b$$$ оба являются неотрицательными       целыми числами и результат <span class="tex-font-style-it">странного сложения</span> $$$a$$$ и       $$$b$$$ равен $$$c$$$.</p>     <p>Обратите внимание, что количество пар может быть довольно велико,       поэтому требуется вывести его по модулю $$$998244353$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано два целых числа $$$n$$$ и $$$m$$$ ($$$1       \le n, m \le 5 \cdot 10^5$$$) — длина числа $$$c$$$ и количество       запросов обновления.</p>     <p>Во второй строке задана строка $$$c$$$, состоящая из ровно       $$$n$$$ цифр от $$$0$$$ до $$$9$$$.</p>     <p>В каждой из следующих $$$m$$$ строк записаны по два целых числа       $$$x$$$ и $$$d$$$ ($$$1 \le x \le n$$$, $$$0 \le d \le 9$$$) —       описания запросов обновления.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$m$$$ целых чисел — $$$i$$$-е значение должно быть       равно количеству пар чисел $$$(a, b)$$$ таких, что $$$a$$$ и       $$$b$$$ оба являются неотрицательными целыми числами и результат         <span class="tex-font-style-it">странного сложения</span>       $$$a$$$ и $$$b$$$ равен $$$c$$$ после применения $$$i$$$ запросов обновления.</p>     <p>Обратите внимание, что количество пар может быть довольно велико,       поэтому требуется вывести его по модулю $$$998244353$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2 3
14
2 4
2 1
1 0
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
15
12
2
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>После первого запроса $$$c$$$ равно $$$14$$$. Пары, которые       складываются в $$$14$$$: $$$(0, 14)$$$, $$$(1, 13)$$$, $$$(2,       12)$$$, $$$(3, 11)$$$, $$$(4, 10)$$$, $$$(5, 9)$$$, $$$(6, 8)$$$,       $$$(7, 7)$$$, $$$(8, 6)$$$, $$$(9, 5)$$$, $$$(10, 4)$$$, $$$(11,       3)$$$, $$$(12, 2)$$$, $$$(13, 1)$$$, $$$(14, 0)$$$.</p>     <p>После второго запроса $$$c$$$ равно $$$11$$$.</p>     <p>После третьего запроса $$$c$$$ равно $$$01$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1380/problem/F' title='Educational Codeforces Round 91 (рейтинговый для Див. 2)'>1380F - Странное сложение</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's solve the task as if there are no updates. This can be done       with a pretty straightforward dp.</p>     <p>$$$dp_i$$$ is the number of pairs $$$(a, b)$$$ such that the       result of the strange addition of $$$a$$$ and $$$b$$$ is the       prefix of $$$c$$$ of length $$$i$$$. $$$dp_0 = 1$$$. From each       state you can add a single digit to $$$a$$$ and to $$$b$$$ at the       same time. You can either go to $$$dp_{i+1}$$$ and multiply the       answer by the number of pairs of digits than sum up to $$$c_i$$$.       Or go to $$$dp_{i+2}$$$ and multiply the answer by the number of       pairs of digits than sum up to $$$c_i c_{i+1}$$$. Note that no       pair of digits can sum up to a three-digit value, so it makes no       sense to go further.</p>     <p>Let's optimize this dp with some data structure. Segment tree       will work well. Let the node store the number of ways to split the       segment $$$[l; r)$$$ into blocks of size $$$1$$$ or $$$2$$$ so that:</p>          <ol> <li> both the leftmost character and the rightmost character         are not taken into any block; </li>       <li> the leftmost character is taken into some block and the         rightmost character is not taken into any block; </li>       <li> the leftmost character is not taken into any block and the         rightmost character is taken into some block; </li>       <li> both the leftmost and the rightmost characters are taken into         some blocks. </li></ol>          <p>This structure makes the merge pretty manageable. You should glue       up the segments in such a way that all the middle characters are       taken into some block: either in separate blocks in their own       segments or into the same block of length $$$2$$$.</p>     <p>The answer will be in the root of the tree in a value such that       both characters are taken.</p>     <p>The update in the segment tree will still work in $$$O(\log n)$$$.</p>     <p>Overall complexity: $$$O(n + m \log n)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

#define forn(i, n) for(int i = 0; i &lt; int(n); i++) 

const int MOD = 998244353;
const int N = 500 * 1000 + 13;

string s;

int add(int a, int b){
	a += b;
	if (a &gt;= MOD)
		a -= MOD;
	return a;
}

int mul(int a, int b){
	return a * 1ll * b % MOD;
}

struct node{
	int val[4], len;
};

node merge(const node &amp;a, const node &amp;b, int l, int r){
	node c;
	int na = a.len == 1 ? 0 : 1;
	int nb = b.len == 1 ? 0 : 2;
	c.len = a.len + b.len;
	c.val[0] = mul(a.val[na], b.val[nb]);
	c.val[1] = mul(a.val[na], b.val[3]);
	c.val[2] = mul(a.val[3], b.val[nb]);
	c.val[3] = mul(a.val[3], b.val[3]);
	if (l == 1){
		na = a.len == 1 ? 2 : 0;
		nb = b.len == 1 ? 1 : 0;
		c.val[na + nb] = add(c.val[na + nb], mul(mul(a.val[0], b.val[0]), 19 - (l * 10 + r)));
		c.val[1 + na] = add(c.val[1 + na], mul(mul(a.val[0], b.val[1]), 19 - (l * 10 + r)));
		c.val[2 + nb] = add(c.val[2 + nb], mul(mul(a.val[2], b.val[0]), 19 - (l * 10 + r)));
		c.val[3] = add(c.val[3], mul(mul(a.val[2], b.val[1]), 19 - (l * 10 + r)));
	}
	return c;
}

node t[4 * N];

void build(int v, int l, int r){
	t[v].len = r - l;
	if (l == r - 1){
		t[v].val[0] = 1;
		t[v].val[3] = s[l] + 1;
		return;
	}
	int m = (l + r) / 2;
	build(v * 2, l, m);
	build(v * 2 + 1, m, r);
	t[v] = merge(t[v * 2], t[v * 2 + 1], s[m - 1], s[m]);
}

void upd(int v, int l, int r, int x, int val){
	if (l == r - 1){
		s[l] = val;
		t[v].val[3] = s[l] + 1;
		return;
	}
	int m = (l + r) / 2;
	if (x &lt; m)
		upd(v * 2, l, m, x, val);
	else
		upd(v * 2 + 1, m, r, x, val);
	t[v] = merge(t[v * 2], t[v * 2 + 1], s[m - 1], s[m]);
}

int main(){
	int n, m;

	scanf(&#34;%d%d&#34;, &amp;n, &amp;m);
	static char buf[N];
	scanf(&#34;%s&#34;, buf);
	s = buf;
	forn(i, n) s[i] -= &#39;0&#39;;
	
	memset(t, 0, sizeof(t));
	build(1, 0, n);
	
	forn(i, m){
		int x, v;
		scanf(&#34;%d%d&#34;, &amp;x, &amp;v);
		--x;
		upd(1, 0, n, x, v);
		printf(&#34;%d\n&#34;, t[1].val[3]);
	}
}
</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

const int N = int(5e5) + 9;
const int MOD = 998244353;

int mul(int a, int b) {
    return (a * 1LL * b) % MOD;
}

void add(int &amp;a, int x) {
    a += x;
    a %= MOD;
}

int bp(int a, int n) {
    int res = 1;
    for (; n &gt; 0; n &gt;&gt;= 1) {
        if (n &amp; 1) res = mul(res, a);
        a = mul(a, a);
    }
    return res;
}

int inv(int a) {
    int ia = bp(a, MOD - 2);
    assert(mul(a, ia) == 1);
    return ia;
}

int n, m;
string s;
int dp[N][10];
int idp[N][10];
set &lt;pair&lt;int, int&gt; &gt; lr;
int res = 1;

void updRes(int l, int r, int c) {
    assert(l &lt;= r);
    if (c == 1) {
        assert(!lr.count(make_pair(l, r)));
        lr.insert(make_pair(l, r));
        res = mul(res, dp[r - l + (r + 1 != n)][r + 1 == n? 1 : s[r + 1] - &#39;0&#39;]);
    } else {
        assert(lr.count(make_pair(l, r)));
        lr.erase(make_pair(l, r));
        res = mul(res, inv(dp[r - l + (r + 1 != n)][r + 1 == n? 1 : s[r + 1] - &#39;0&#39;]));
    }
}

void getLR(int &amp;l, int &amp;r, int pos) {
    l = r = -1;
    auto it = lr.lower_bound(make_pair(pos, n));
    if(it == lr.begin()) return;
    --it;
    if(!(it-&gt;first &lt;= pos &amp;&amp; pos &lt;= it-&gt;second)) return;
    l = it-&gt;first, r = it-&gt;second;
}

char buf[N];
int main(){
    scanf(&#34;%d %d\n&#34;, &amp;n, &amp;m);
    scanf(&#34;%s&#34;, buf);
    s = string(buf);
    for (int i = 0; i &lt;= 9; ++i) {
        dp[0][i] = i + 1; //idp[0][i] = inv(dp[0][i]);
        dp[1][i] = 2 * (i + 1) + (9 - i); //idp[1][i] = inv(dp[1][i]);
    }
    for (int i = 2; i &lt; N; ++i)
        for (int j = 0; j &lt;= 9; ++j) {
            dp[i][j] = (2LL * dp[i - 1][j] + 8LL * dp[i - 2][j]) % MOD;
            //idp[i][j] = inv(dp[i][j]);
        }
    for (int i = 0; i &lt; N; ++i) for(int j = 0; j &lt; 10; ++j) assert(dp[i][j] != 0);
    for (int l = 0; l &lt; n; ) {
        int r = l;
        while(r &lt; n &amp;&amp; s[r] == &#39;1&#39;) ++r;
        res = mul(res, dp[r - l - (r == n)][r == n? 1 : s[r] - &#39;0&#39;]);
        if (l != r) lr.insert(make_pair(l, r - 1));
        l = r + 1;
    }
    
    for (int i = 0; i &lt; m; ++i) {
        int pos;
        char x;
        scanf(&#34;%d %c\n&#34;, &amp;pos, &amp;x);
        --pos;
        if (x == &#39;1&#39;) {
            if (s[pos] != &#39;1&#39;){ 
                int l1, r1, l2, r2;
                getLR(l1, r1, pos - 1);
                getLR(l2, r2, pos + 1);
                
                int l = pos, r = pos;
                if (l1 != -1) {
                    assert(r1 == pos - 1);
                    updRes(l1, r1, -1);
                    l = l1;
                } else {
                    res = mul(res, inv(dp[0][s[pos] - &#39;0&#39;]));
                }
                
                if (l2 != -1) {
                    assert(l2 == pos + 1);
                    updRes(l2, r2, -1);
                    r = r2;
                } else {
                    if (pos + 1 != n) res = mul(res, inv(dp[0][s[pos + 1] - &#39;0&#39;]));
                }
                
                s[pos] = x;
                updRes(l, r, 1);
            }
        } else {
            if (s[pos] != &#39;1&#39;) {
                if (pos - 1 &gt;= 0 &amp;&amp; s[pos - 1] == &#39;1&#39;) {
                    int l, r;
                    getLR(l, r, pos - 1);
                    updRes(l, r, -1);
                    s[pos] = x;
                    updRes(l, r, 1);
                } else {
                    res = mul(res, dp[0][x - &#39;0&#39;]);
                    res = mul(res, inv(dp[0][s[pos] - &#39;0&#39;]));
                    s[pos] = x;
                }
            } else {
                int l, r;
                getLR(l, r, pos);
                assert(l != -1 &amp;&amp; r != -1);
                
                updRes(l, r, -1);
                s[pos] = x;
                if (l == r) {
                    res = mul(res, dp[0][s[pos] - &#39;0&#39;]);
                    if (pos + 1 &lt; n) res = mul(res, dp[0][s[pos + 1] - &#39;0&#39;]);
                } else if (pos == l) {
                    res = mul(res, dp[0][s[pos] - &#39;0&#39;]);
                    updRes(l + 1, r, 1);
                } else if (pos == r) {
                    if (pos + 1 != n) res = mul(res, dp[0][s[pos + 1] - &#39;0&#39;]);
                    updRes(l, r - 1, 1);
                } else {
                    updRes(l, pos - 1, 1);
                    updRes(pos + 1, r, 1);
                }
            }
            
        }
        printf(&#34;%d\n&#34;, res);
    }
}
</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;

#define forn(i, n) for (int i = 0; i &lt; int(n); i++)

using namespace std;

const int MOD = 998244353;

int add(int a, int b){
	a += b;
	if (a &gt;= MOD)
		a -= MOD;
	if (a &lt; 0)
		a += MOD;
	return a;
}

int mul(int a, int b){
	return a * 1ll * b % MOD;
}

int binpow(int a, int b){
	int res = 1;
	while (b){
		if (b &amp; 1)
			res = mul(res, a);
		a = mul(a, a);
		b &gt;&gt;= 1;
	}
	return res;
}

vector&lt;int&gt; pr;

int main() {
	int n;
	scanf(&#34;%d&#34;, &amp;n);
	vector&lt;int&gt; c(n);
	forn(i, n)
		scanf(&#34;%d&#34;, &amp;c[i]);
	sort(c.begin(), c.end(), greater&lt;int&gt;());
	pr.push_back(0);
	forn(i, n)
		pr.push_back(add(pr.back(), c[i]));
	
	int invn = binpow(n, MOD - 2);
	for (int k = 1; k &lt;= n; ++k){
		int ans = 0;
		for (int i = 0, j = 0; i &lt; n; i += k, ++j)
			ans = add(ans, mul(j, add(pr[min(n, i + k)], -pr[i])));
		printf(&#34;%d &#34;, mul(ans, invn));
	}
	puts(&#34;&#34;);
	
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 91 (рейтинговый для Див. 2)
    1380G
    Круговое подземелье </h1>

    <div class="problemindexholder" problemindex="G">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">G. Круговое подземелье</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вы проектируете уровень для компьютерной игры. Этот уровень       состоит из $$$n$$$ комнат, расположенных по кругу. Комнаты       пронумерованы от $$$1$$$ до $$$n$$$. У каждой комнаты ровно один       выход: после завершения $$$j$$$-й комнаты вы отправляетесь в       $$$(j+1)$$$-ю комнату (а после завершения $$$n$$$-й комнаты вы       отправляетесь в $$$1$$$-ю комнату).</p>     <p>Вам задано описание мультимножества из $$$n$$$ сундуков: ценность       сокровища в $$$i$$$-м сундуке равна $$$c_i$$$.</p>     <p>Каждый сундук может быть одного из двух типов: </p>     <ul> <li> обычный сундук — когда игрок заходит в комнату с таким         сундуком, то он забирает сокровище и проходит в следующую         комнату; </li>       <li> сундук-мимик — когда игрок заходит в комнату с таким         сундуком, то сундук его съедает, и игрок проигрывает. </li></ul>          <p>Игрок начинает в случайной комнате, и у каждой комнаты равная       вероятность быть выбранной. Доход игрока равен сумме ценностей       сокровищ в тех сундуках, которые он собрал до своего поражения.</p>     <p>Вы можете выбрать порядок, в котором сундуки будут установлены в       комнатах. Для каждого $$$k$$$ от $$$1$$$ до $$$n$$$ расставьте       сундуки таким образом, что: </p>     <ul> <li> в каждой комнате находится <span class="tex-font-style-bf">ровно</span> один сундук; </li>       <li> <span class="tex-font-style-bf">ровно</span> $$$k$$$ сундуков         являются мимиками; </li>       <li> математическое ожидание дохода игрока <span class="tex-font-style-bf">минимально</span> возможно. </li></ul>          <p>Обратите внимание, что для каждого $$$k$$$ расстановка выбирается независимо.</p>     <p>Можно показать, что данное математическое ожидание можно       представить в виде $$$\frac{P}{Q}$$$, где $$$P$$$ и $$$Q$$$       являются неотрицательными целыми числами $$$Q \ne 0$$$. Выведите       значения $$$P \cdot Q^{-1} \pmod {998244353}$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$n$$$ ($$$2 \le n \le       3 \cdot 10^5$$$) — количество комнат и количество сундуков.</p>     <p>Во второй строке записаны $$$n$$$ целых чисел $$$c_1, c_2, \dots,       c_n$$$ ($$$1 \le c_i \le 10^6$$$) — ценности сокровищ в каждом сундуке.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$n$$$ целых чисел — $$$k$$$-е число должно быть равно       минимальному математическому ожиданию дохода игрока, если сундуки       расставлены по комнатам в каком-то порядке и ровно $$$k$$$ из       сундуков являются мимиками.</p>     <p>Можно показать, что данное математическое ожидание можно       представить в виде $$$\frac{P}{Q}$$$, где $$$P$$$ и $$$Q$$$       являются неотрицательными целыми числами $$$Q \ne 0$$$. Выведите       значения $$$P \cdot Q^{-1} \pmod {998244353}$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
1 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
499122177 0 
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
8
10 4 3 6 5 10 7 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
499122193 249561095 249561092 873463811 499122178 124780545 623902721 0 
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере точные значения минимального математического       ожидания равны: $$$\frac 1 2$$$, $$$\frac 0 2$$$.</p>     <p>Во втором примере точные значения минимального математического       ожидания равны: $$$\frac{132} 8$$$, $$$\frac{54} 8$$$,       $$$\frac{30} 8$$$, $$$\frac{17} 8$$$, $$$\frac{12} 8$$$, $$$\frac       7 8$$$, $$$\frac 3 8$$$, $$$\frac 0 8$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1380/problem/G' title='Educational Codeforces Round 91 (рейтинговый для Див. 2)'>1380G - Круговое подземелье</a></h3><div class="ttypography"><p>Unable to parse markup [type=CF_MATHJAX]</p></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #625 (Div. 1, based on Technocup 2020 Final Round)
    1320A
    Планирование путешествия </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Планирование путешествия</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Таня запланировала путешествие по городам Берляндии. Всего в       Берляндии $$$n$$$ городов, расположенных вдоль главного       железнодорожного пути. Города пронумерованы от $$$1$$$ до $$$n$$$. </p>     <p>План путешествия Тани выглядит следующим образом: для начала она       выбирает город $$$c_1$$$, с которого она начнет путешествие. Она       посещает его, а затем отправляется в другой город $$$c_2 &gt;       c_1$$$, затем в следующий город $$$c_3 &gt; c_2$$$, и так далее,       пока не решит закончить свое путешествие в некотором городе $$$c_k       &gt; c_{k - 1}$$$. Таким образом, последовательность посещенных       городов $$$[c_1, c_2, \dots, c_k]$$$ должна быть строго возрастающей.</p>     <p>На последовательность посещенных городов есть еще одно       ограничение. Город $$$i$$$ имеет красоту $$$b_i$$$. Если Таня       решит посетить только один город, красоты городов не накладывают       никаких дополнительных ограничений; однако если она решила       посетить несколько городов, то для каждой пары соседних городов       $$$c_i$$$ и $$$c_{i + 1}$$$ в плане должно выполняться условие       $$$c_{i + 1} - c_i = b_{c_{i + 1}} - b_{c_i}$$$.</p>     <p>Например, если $$$n = 8$$$ и $$$b = [3, 4, 4, 6, 6, 7, 8, 9]$$$,       следующие планы путешествия корректны:</p>          <ul> <li> $$$c = [1, 2, 4]$$$; </li>       <li> $$$c = [3, 5, 6, 8]$$$; </li>       <li> $$$c = [7]$$$ (путешествие, состоящее из одного города,         считается корректным). </li></ul>          <p>Также существуют другие планы посещения городов, не описанные выше.</p>     <p>Таня хочет, чтобы ее путешествие было максимально красивым.       Красота путешествия равна суммарной красоте всех посещенных       городов. Можете ли вы составить план путешествия, максимизирующий       суммарную красоту посещенных городов?</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит целое число $$$n$$$ ($$$1 \le n \le 2       \cdot 10^5$$$) — количество городов в Берляндии.</p>     <p>Вторая строка содержит $$$n$$$ целых чисел $$$b_1$$$, $$$b_2$$$,       ..., $$$b_n$$$ ($$$1 \le b_i \le 4 \cdot 10^5$$$), где $$$b_i$$$       равно красоте $$$i$$$-го города.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одно число — максимально возможную красоту путешествия Тани.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
10 7 1 9 10 15
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
26
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
1
400000
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
400000
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
7
8 9 26 11 12 29 14
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
55
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Оптимальный план путешествия в первом примере: $$$c = [2, 4, 5]$$$.</p>     <p>Оптимальный план путешествия во втором примере: $$$c = [1]$$$.</p>     <p>Оптимальный план путешествия в третьем примере: $$$c = [3, 6]$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #625 (Div. 1, based on Technocup 2020 Final Round)
    1320B
    Система навигации </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Система навигации</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>          <p>Карта Бертауна может быть представлена как набор из $$$n$$$       перекрестков, пронумерованных от $$$1$$$ до $$$n$$$ и соединенных       между собой $$$m$$$ односторонними дорогами. Гарантируется, что       возможно добраться от любого перекрестка до любого другого,       путешествуя по существующим дорогам. Длина какого-либо пути от       одного перекрестка до другого равна количеству переходов по       дорогам в этом пути. Кратчайшим путем от перекрестка $$$v$$$ до       другого перекрестка $$$u$$$ называется путь, который начинается в       $$$v$$$, заканчивается в $$$u$$$ и имеет минимальную длину среди       всех таких путей.</p>     <p>Поликарп живет около перекрестка $$$s$$$ и работает в здании       неподалеку от перекрестка $$$t$$$. Каждый день он ездит от $$$s$$$       до $$$t$$$ на машине. Сегодня он выбрал следующий путь до своей       работы: $$$p_1$$$, $$$p_2$$$, ..., $$$p_k$$$, где $$$p_1 = s$$$,       $$$p_k = t$$$, а все другие элементы этой последовательности       являются промежуточными перекрестками, перечисленными в том       порядке, в котором Поликарп их посещал. Поликарп никогда не       посещал один и тот же перекресток дважды, таким образом, все       элементы этой последовательности попарно различны. <span class="tex-font-style-bf">Заметьте, что вы знаете путь Поликарпа         заранее (он фиксирован), и он не обязательно является одним из         кратчайших путей от $$$s$$$ до $$$t$$$</span>.</p>     <p>Машина Поликарпа оснащена сложной навигационной системой. Опишем,       как она работает. Когда Поликарп начинает свою поездку с       перекрестка $$$s$$$, система выбирает какой-либо кратчайший путь       от $$$s$$$ до $$$t$$$ и показывает его Поликарпу. Пусть следующий       перекресток в выбранном пути равен $$$v$$$. Если Поликарп выбирает       ехать дорогой от $$$s$$$ до $$$v$$$, то навигатор показывает ему       тот же самый кратчайший путь (очевидно, он будет стартовать с       $$$v$$$ с того момента, как Поликарп доедет до этого перекрестка).       Однако если Поликарп выбирает доехать до другого перекрестка       $$$w$$$, навигатор <span class="tex-font-style-bf">перестраивает</span> путь: как только       Поликарп доезжает до $$$w$$$, навигационная система выбирает       какой-то кратчайший путь от $$$w$$$ до $$$t$$$ и показывает его       Поликарпу. Тот же самый процесс продолжается до тех пор, пока       Поликарп не доедет до $$$t$$$: если Поликарп едет по дороге,       рекомендованной системой, то она оставляет кратчайший путь,       который уже был построен; но если Поликарп выбирает какой-либо       другой путь, система <span class="tex-font-style-bf">перестраивает</span> путь по тем же       самым правилам.</p>     <p>Рассмотрим пример. Пусть карта Бертауна выглядит следующим       образом, а Поликарп едет путем $$$[1, 2, 3, 4]$$$ ($$$s = 1$$$,       $$$t = 4$$$): </p>     <center>              <p>Ознакомьтесь с картинкой по ссылке <a href="//tk.codeforces.com/a.png">http://tk.codeforces.com/a.png</a>     </p></center> <ol> <li> Когда Поликарп начинает свой путь у         перекрестка $$$1$$$, система выбирает какой-то кратчайший путь         от $$$1$$$ до $$$4$$$. Существует только один такой путь, он         равен $$$[1, 5, 4]$$$; </li>       <li> Поликарп выбирает поехать к перекрестку $$$2$$$, который не         лежит на кратчайшем пути, выбранным системой. Когда Поликарп         доезжает до $$$2$$$, навигатор <span class="tex-font-style-bf">перестраивает</span> путь, выбирая         какой-то кратчайший путь от $$$2$$$ до $$$4$$$, например, $$$[2,         6, 4]$$$ (заметьте, что он может выбрать $$$[2, 3, 4]$$$); </li>       <li> Поликарп выбирает поехать к перекрестку $$$3$$$, который не         лежит на кратчайшем пути, выбранным системой. Когда Поликарп         доезжает до $$$3$$$, навигатор <span class="tex-font-style-bf">перестраивает</span> путь, выбирая         единственный кратчайший путь от $$$3$$$ до $$$4$$$, который         равен $$$[3, 4]$$$; </li>       <li> Поликарп доезжает до $$$4$$$ по дороге, выбранной         навигатором, таким образом, система больше ничего не         перестраивает. </li></ol>          <p>В этом сценарии случилось $$$2$$$ перестроения маршрута.       Заметьте, что если система выберет $$$[2, 3, 4]$$$ вместо $$$[2,       6, 4]$$$ в течение второго шага, то будет только $$$1$$$       перестроение (так как Поликарп едет по этому же пути, система       сохранит путь $$$[3, 4]$$$ в течение третьего шага).</p>     <p>Пример показывает, что количество перестроений может различаться       даже несмотря на то, что карта Бертауна и путь, выбранный       Поликарпом, никогда не меняются. Имея эту информацию (карту и путь       Поликарпа), сможете ли вы определить минимальное и максимальное       количество перестроений маршрута, которые могли произойти в       течение поездки?</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит два целых числа $$$n$$$ и $$$m$$$ ($$$2       \le n \le m \le 2 \cdot 10^5$$$) — количество перекрестков и       односторонних дорог в Бертауне соответственно.</p>     <p>Далее следуют $$$m$$$ строк, каждая из которых описывает дорогу.       Каждая строка содержит два целых числа $$$u$$$ и $$$v$$$ ($$$1 \le       u, v \le n$$$, $$$u \ne v$$$), обозначающих дорогу от перекрестка       $$$u$$$ к перекрестку $$$v$$$. Все дороги в Бертауне попарно       различны, и это значит, что каждая упорядоченная пара $$$(u, v)$$$       встречается не более одного раза среди этих $$$m$$$ строк (но если       существует дорога $$$(u, v)$$$, то дорога $$$(v, u)$$$ также может существовать).</p>     <p>Следующая строка содержит одно целое число $$$k$$$ ($$$2 \le k       \le n$$$) — количество перекрестков в пути Поликарпа от его дома       до его работы.</p>     <p>Последняя строка содержит $$$k$$$ целых чисел $$$p_1$$$,       $$$p_2$$$, ..., $$$p_k$$$ ($$$1 \le p_i \le n$$$, все эти целые       числа попарно различны) — перекрестки в пути Поликарпа в том       порядке, в котором он их посещал. $$$p_1$$$ равно перекрестку,       около которого живет Поликарп ($$$s = p_1$$$), а $$$p_k$$$ равно       перекрестку, около которого Поликарп работает ($$$t = p_k$$$).       Гарантируется, что для каждого $$$i \in [1, k - 1]$$$ существует       дорога от $$$p_i$$$ до $$$p_{i + 1}$$$, таким образом, путь идет       по дорогам Бертауна.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите два числа: минимальное и максимальное количество <span class="tex-font-style-bf">перестроений маршрута</span>, которые       могут произойти в течение поездки.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6 9
1 5
5 4
1 2
2 3
3 4
4 1
2 6
6 4
4 2
4
1 2 3 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1 2
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
7 7
1 2
2 3
3 4
4 5
5 6
6 7
7 1
7
1 2 3 4 5 6 7
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0 0
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
8 13
8 7
8 6
7 5
7 4
6 5
6 4
5 3
5 2
4 3
4 2
3 1
2 1
1 8
5
8 7 5 2 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0 3
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #625 (Div. 1, based on Technocup 2020 Final Round)
    1320C
    World of Darkraft: Battle for Azathoth </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. World of Darkraft: Battle for Azathoth</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Рома играет в новое дополнение к его любимой игре — World of       Darkraft. Рома только что закончил создавать персонажа и готов       выйти на первую охоту на монстров.</p>     <p>Перед охотой Рома должен купить оружие и комплект брони. Он может       выбрать <span class="tex-font-style-bf">ровно одно</span> из       $$$n$$$ различных типов оружия и <span class="tex-font-style-bf">ровно один</span> из $$$m$$$ различных       комплектов брони. Оружие $$$i$$$ имеет модификатор атаки $$$a_i$$$       и стоит $$$ca_i$$$ монет, комплект брони $$$j$$$ имеет модификатор       защиты $$$b_j$$$ и стоит $$$cb_j$$$ монет.</p>     <p>После выбора экипировки Рома может начать охотиться на монстров.       Всего есть $$$p$$$ монстров, которых можно попытаться победить. У       каждого монстра $$$k$$$ есть три параметра: защита $$$x_k$$$,       атака $$$y_k$$$ и награда за его убийство $$$z_k$$$. Рома может       победить монстра только в том случае, если модификатор атаки его       оружия больше, чем защита монстра, а модификатор защиты его брони       больше, чем атака монстра. То есть монстра $$$k$$$ можно победить       с использованием оружия $$$i$$$ и комплекта брони $$$j$$$, если       $$$a_i &gt; x_k$$$ и $$$b_j &gt; y_k$$$. После победы над монстром       Рома получает награду за него. Во время охоты можно попробовать       победить любое количество монстров в любом порядке — но они не       появляются заново после смерти, поэтому каждого монстра можно       победить только один раз.</p>     <p>Благодаря внесенным в игру деньгам Рома может себе позволить       любое оружие и любой комплект брони. Несмотря на это, ему все       равно необходимо распланировать охоту так, чтобы получить       максимальную прибыль. Прибыль с охоты считается как разность между       количеством монет, полученных за убийство монстров, и ценой       выбранного оружия и брони. Обратите внимание, что Рома <span class="tex-font-style-bf">должен</span> купить оружие и броню,       даже если охота не покроет расходы на них.</p>     <p>Помогите Роме максимизировать прибыль с охоты на монстров.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке заданы три целых числа $$$n$$$, $$$m$$$ и $$$p$$$       ($$$1 \leq n, m, p \leq 2 \cdot 10^5$$$) — количество доступных       типов оружия, комплектов брони и монстров соответственно.</p>     <p>В следующих $$$n$$$ строках описаны доступные типы оружия. В       $$$i$$$-й из этих строк заданы два целых числа $$$a_i$$$ и       $$$ca_i$$$ ($$$1 \leq a_i \leq 10^6$$$, $$$1 \leq ca_i \leq       10^9$$$) — модификатор атаки и цена оружия $$$i$$$.</p>     <p>В следующих $$$m$$$ строках описаны доступные комплекты брони. В       $$$j$$$-й из этих строк заданы два целых числа $$$b_j$$$ и       $$$cb_j$$$ ($$$1 \leq b_j \leq 10^6$$$, $$$1 \leq cb_j \leq       10^9$$$) — модификатор защиты и цена комплекта брони $$$j$$$.</p>     <p>В следующих $$$p$$$ строках описываются монстры. В $$$k$$$-й из       этих строк заданы три целых числа $$$x_k, y_k, z_k$$$ ($$$1 \leq       x_k, y_k \leq 10^6$$$, $$$1 \leq z_k \leq 10^3$$$) — защита, атака       и награда за убийство монстра $$$k$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одно целое число — максимальную прибыль с охоты.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2 3 3
2 3
4 7
2 4
3 2
5 11
1 2 4
2 1 6
3 4 6
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #625 (Div. 1, based on Technocup 2020 Final Round)
    1320D
    Достижимые строки </h1>

    <div class="problemindexholder" problemindex="D">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">D. Достижимые строки</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>3 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>В этой задаче мы будем иметь дело с бинарными строками. Каждый       символ бинарной строки — это либо <span class="tex-font-style-tt">0</span>, либо <span class="tex-font-style-tt">1</span>. Мы также будем иметь дело с       подстроками; напомним, что подстрока — это непрерывная       подпоследовательность строки. Для удобства будем обозначать       подстроку строки $$$s$$$, начинающуюся в позиции $$$l$$$ и       заканчивающуюся в позиции $$$r$$$, как $$$s[l \dots r]$$$. Символы       в строках нумернуются с $$$1$$$.</p>     <p>Мы можем проводить операции над строками. Есть две различных       операции: заменить подстроку <span class="tex-font-style-tt">011</span> на <span class="tex-font-style-tt">110</span>, или заменить подстроку <span class="tex-font-style-tt">110</span> на <span class="tex-font-style-tt">011</span>. Например, если мы применим       ровно одну операцию к строке <span class="tex-font-style-tt">110011110</span>, она может превратиться       в <span class="tex-font-style-tt">011011110</span>, <span class="tex-font-style-tt">110110110</span>, или <span class="tex-font-style-tt">110011011</span>.</p>     <p>Бинарная строка $$$a$$$ считается <span class="tex-font-style-it">достижимой</span> из бинарной строки       $$$b$$$, если существует последовательность $$$s_1$$$, $$$s_2$$$,       ..., $$$s_k$$$, такая, что $$$s_1 = a$$$, $$$s_k = b$$$, и для       каждого $$$i \in [1, k - 1]$$$, $$$s_i$$$ можно превратить в       $$$s_{i + 1}$$$ ровно за одну операцию. Обратите внимание, что       $$$k$$$ может быть равно $$$1$$$, т. е., <span class="tex-font-style-bf">каждая строка достижима из самой себя</span>.</p>     <p>Вам дана строка $$$t$$$ и $$$q$$$ запросов к ней. Каждый запрос       состоит из трех целых чисел $$$l_1$$$, $$$l_2$$$ и $$$len$$$. Для       каждого запроса вы должны определить, является ли $$$t[l_1 \dots       l_1 + len - 1]$$$ достижимой из $$$t[l_2 \dots l_2 + len - 1]$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке содержится одно целое число $$$n$$$ ($$$1 \le n       \le 2 \cdot 10^5$$$) — длина строки $$$t$$$.</p>     <p>Во второй строке задана одна строка $$$t$$$ ($$$|t| = n$$$).       Каждый символ $$$t$$$ равен либо <span class="tex-font-style-tt">0</span>, либо <span class="tex-font-style-tt">1</span>.</p>     <p>В третьей строке задано одно целое число $$$q$$$ ($$$1 \le q \le       2 \cdot 10^5$$$) — количество запросов.</p>     <p>Затем следуют $$$q$$$ строк, в каждой из которых содержится       описание очередного запроса. В $$$i$$$-й строке заданы три целых       числа $$$l_1$$$, $$$l_2$$$ и $$$len$$$ ($$$1 \le l_1, l_2 \le       |t|$$$, $$$1 \le len \le |t| - \max(l_1, l_2) + 1$$$) для       $$$i$$$-го запроса.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого запроса выведите либо <span class="tex-font-style-tt">YES</span>, если $$$t[l_1 \dots l_1 +       len - 1]$$$ достижима из $$$t[l_2 \dots l_2 + len - 1]$$$, либо         <span class="tex-font-style-tt">NO</span> в противном случае. Вы       можете выводить каждую букву в любом регистре.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
11011
3
1 3 3
1 4 2
1 2 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
Yes
Yes
No
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #625 (Div. 1, based on Technocup 2020 Final Round)
    1320E
    Древляндия и вирусы </h1>

    <div class="problemindexholder" problemindex="E">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">E. Древляндия и вирусы</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>3 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>В Древляндии $$$n$$$ городов, соединенных $$$n - 1$$$       двунаправленными дорогами таким образом, что из любого города       можно добраться в любой другой (другими словами, граф городов и       дорог является деревом). Древлядния готовится к сезонной вирусной       эпидемии, и сейчас они пытаются оценить различные сценарии       распространения инфекции.</p>     <p>В каждом из сценариев некоторые города исходно заражены       различными видами вирусов. Пусть в $$$i$$$-м сценарии присутствует       $$$k_i$$$ типов вирусов. Обозначим за $$$v_j$$$ исходный город для       вируса $$$j$$$, и за $$$s_j$$$ скорость распространения вируса       $$$j$$$. Распространение вирусов происходит пошагово: сперва       распространяется вирус $$$1$$$, затем вирус $$$2$$$, и так далее.       После распространения вируса $$$k_i$$$ процесс начинается заново с       вируса $$$1$$$.</p>     <p>Шаг распространения вируса $$$j$$$ происходит следующим образом.       Для каждого города $$$x$$$, еще не зараженного никаким вирусом в       начале шага, заражение вирусом $$$j$$$ происходит тогда и только       тогда, когда найдется другой город $$$y$$$ со следующими свойствами:</p>          <ul>                     <li> город $$$y$$$ заражен вирусом $$$j$$$ в начале шага;         </li>       <li> путь между городами $$$x$$$ и $$$y$$$ содержит не более         $$$s_j$$$ рёбер;         </li>       <li> ни один город на пути между $$$x$$$ и $$$y$$$ (не считая         $$$y$$$) не был заражен никаким вирусом в начале шага.         </li></ul>          <p>Если город заражен вирусом, он всегда остается зараженным и       больше не может быть заражен никаким другим вирусом.       Распространение вирусов останавливается, когда все города заражены.</p>     <p>Вам требуется обработать $$$q$$$ независимых сценариев. Каждый       сценарий описывается $$$k_i$$$ типами вирусов и списком из       $$$m_i$$$ важных городов. Для каждого важного города определите       тип вируса, которым он будет заражен в конце сценария.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит одно целое число $$$n$$$ ($$$1 \leq n \leq       2 \cdot 10^5$$$) — количество городов в Древляндии.</p>     <p>Следующие $$$n - 1$$$ строк описывают дороги. $$$i$$$-я из этих       строк содержит два целых числа $$$x_i$$$ и $$$y_i$$$ ($$$1 \leq       x_i, y_i \leq n$$$) — номера городов, соединенных $$$i$$$-й       дорогой. Гарантируется, что данный граф городов и дорог является       деревом. </p>     <p>Следующая строка содержит одно целое число $$$q$$$ ($$$1 \leq q       \leq 2 \cdot 10^5$$$) — количество сценариев заражения. Далее       следуют $$$q$$$ описаний сценариев.</p>     <p>Описание $$$i$$$-го сценария начинается со строки, содержащей два       целых числа $$$k_i$$$ и $$$m_i$$$ ($$$1 \leq k_i, m_i \leq n$$$) —       количество типов вируса и количество важных городов в этом       сценарии соответственно. Гарантируется, что $$$\sum_{i = 1}^ q       k_i$$$ и $$$\sum_{i = 1}^ q m_i$$$ не превосходят $$$2 \cdot 10^5$$$.</p>     <p>Следующие $$$k_i$$$ строк описывают типы вирусов. $$$j$$$-я из       этих строк содержит два целых числа $$$v_j$$$ и $$$s_j$$$ ($$$1       \leq v_j \leq n$$$, $$$1 \leq s_j \leq 10^6$$$) – номер исходного       города и скорость распространения вируса $$$j$$$. Гарантируется,       что исходные города всех типов вирусов внутри одного сценария различны.</p>     <p>Следующая строка содержит $$$m_i$$$ различных чисел $$$u_1,       \ldots, u_{m_i}$$$ ($$$1 \leq u_j \leq n$$$) — номера важных       городов .</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$q$$$ строк. $$$i$$$-я строка должна содержать       $$$m_i$$$ целых чисел — номера типов вирусов, которыми будут       заражены города $$$u_1, \ldots, u_{m_i}$$$ соответственно в конце       $$$i$$$-го сценария.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
7
1 2
1 3
2 4
2 5
3 6
3 7
3
2 2
4 1
7 1
1 3
2 2
4 3
7 1
1 3
3 3
1 1
4 100
7 100
1 2 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1 2
1 1
1 1 1
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #625 (Div. 1, based on Technocup 2020 Final Round)
    1320F
    Блоки и сенсоры </h1>

    <div class="problemindexholder" problemindex="F">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">F. Блоки и сенсоры</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>3 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>512 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Поликарп играет в одну очень известную компьютерную игру (мы не       будем упоминать ее имя). Каждый объект в этой игре состоит из       трехмерных блоков — кубов $$$1 \times 1 \times 1$$$, ребра которых       параллельны осям координат. Эти блоки не подвержены гравитации,       поэтому могут находиться в воздухе без всякой опоры. Блоки       располагаются в ячейках $$$1 \times 1 \times 1$$$; каждая ячейка       либо пуста, либо содержит ровно один блок. Каждая ячейка       обозначается своими координатами $$$(x, y, z)$$$ (ячейка с такими       координатами — это куб с противоположными вершинами в $$$(x, y,       z)$$$ и $$$(x + 1, y + 1, z + 1)$$$) и значением $$$a_{x, y,       z}$$$; если ячейка пуста, $$$a_{x, y, z} = 0$$$, иначе $$$a_{x, y,       z}$$$ равно типу блока в ячейке (типы блоков — целые числа от       $$$1$$$ до $$$2 \cdot 10^5$$$).</p>     <p>Поликарп построил большую структуру из блоков. Эта структура       находится внутри прямоугольного параллелепипеда $$$n \times m       \times k$$$, содержащего все такие клетки $$$(x, y, z)$$$, что       $$$x \in [1, n]$$$, $$$y \in [1, m]$$$ и $$$z \in [1, k]$$$. После       построения структуры Поликарп окружил параллелепипед $$$2nm + 2nk       + 2mk$$$ сенсорами. Сенсор — специальный блок, который выпускает       луч в некотором направлении и показывает тип первого блока, до       которого дошел луч (за исключением других сенсоров). Сенсоры,       поставленные Поликарпом, расположены вплотную к границам       параллелепипеда; луч каждого сенсора параллелен одной из       координатных осей и направлен внутрь параллелепипеда. Более       формально, сенсоры можно разделить на $$$6$$$ типов:</p>          <ul> <li> есть $$$mk$$$ сенсоров первого типа; каждый такой сенсор         расположен в $$$(0, y, z)$$$, где $$$y \in [1, m]$$$ и $$$z \in         [1, k]$$$, и выпускает луч в положительном направлении оси         $$$Ox$$$; </li>       <li> есть $$$mk$$$ сенсоров второго типа; каждый такой сенсор         расположен в $$$(n + 1, y, z)$$$, где $$$y \in [1, m]$$$ и $$$z         \in [1, k]$$$, и выпускает луч в отрицательном направлении оси         $$$Ox$$$; </li>       <li> есть $$$nk$$$ сенсоров третьего типа; каждый такой сенсор         расположен в $$$(x, 0, z)$$$, где $$$x \in [1, n]$$$ и $$$z \in         [1, k]$$$, и выпускает луч в положительном направлении оси         $$$Oy$$$; </li>       <li> есть $$$nk$$$ сенсоров четвертого типа; каждый такой сенсор         расположен в $$$(x, m + 1, z)$$$, где $$$x \in [1, n]$$$ и $$$z         \in [1, k]$$$, и выпускает луч в отрицательном направлении оси         $$$Oy$$$; </li>       <li> есть $$$nm$$$ сенсоров пятого типа; каждый такой сенсор         расположен в $$$(x, y, 0)$$$, где $$$x \in [1, n]$$$ и $$$y \in         [1, m]$$$, и выпускает луч в положительном направлении оси         $$$Oz$$$; </li>       <li> наконец, есть $$$nm$$$ сенсоров шестого типа; каждый такой         сенсор расположен в $$$(x, y, k + 1)$$$, где $$$x \in [1, n]$$$         и $$$y \in [1, m]$$$, и выпускает луч в отрицательном         направлении оси $$$Oz$$$. </li></ul>          <p>Поликарп пригласил своего друга Монокарпа поиграть с ним.       Естественно, как только Монокарп увидел огромный параллелепипед,       окруженный сенсорами, ему стало интересно, что находится внутри.       Поликарп решил не сообщать Монокарпу точную форму структуры;       вместо этого он предложил Монокарпу догадаться, какая структура       построена внутри, по показаниям сенсоров.</p>     <p>После нескольких часов безуспешных попыток угадать, что же       находится внутри, Монокарп все еще не хочет сдаваться. Вместо       этого он решил попросить помощи. Можете ли вы написать программу,       которая проанализирует показания сенсоров и построит любую       структуру, которая не противоречит показаниям?</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке заданы три целых числа $$$n$$$, $$$m$$$ и $$$k$$$       ($$$1 \le n, m, k \le 2 \cdot 10^5$$$, $$$nmk \le 2 \cdot 10^5$$$)       — размеры параллелепипеда.</p>     <p>Затем следуют показания сенсоров. Показания каждого сенсора — это       либо $$$0$$$, если луч, выпущенный этим сенсором, достиг       противоположного сенсора (между ними нет блоков), либо целое число       от $$$1$$$ до $$$2 \cdot 10^5$$$, соответствующее типу первого       блока, которого достиг луч. Все показания разделены на $$$6$$$       секций (по одной на каждый тип сенсоров), каждая пара соседних       секций разделяется пустой строкой, а также первая секция       отделяется от размеров параллелепипеда пустой строкой.</p>     <p>Первая секция состоит из $$$m$$$ строк по $$$k$$$ целых чисел.       $$$j$$$-е число в $$$i$$$-й строке соответствует показаниям       сенсора, расположенного в $$$(0, i, j)$$$.</p>     <p>Вторая секция состоит из $$$m$$$ строк по $$$k$$$ целых чисел.       $$$j$$$-е число в $$$i$$$-й строке соответствует показаниям       сенсора, расположенного в $$$(n + 1, i, j)$$$.</p>     <p>Третья секция состоит из $$$n$$$ строк по $$$k$$$ целых чисел.       $$$j$$$-е число в $$$i$$$-й строке соответствует показаниям       сенсора, расположенного в $$$(i, 0, j)$$$.</p>     <p>Четвертая секция состоит из $$$n$$$ строк по $$$k$$$ целых чисел.       $$$j$$$-е число в $$$i$$$-й строке соответствует показаниям       сенсора, расположенного в $$$(i, m + 1, j)$$$.</p>     <p>Пятая секция состоит из $$$n$$$ строк по $$$m$$$ целых чисел.       $$$j$$$-е число в $$$i$$$-й строке соответствует показаниям       сенсора, расположенного в $$$(i, j, 0)$$$.</p>     <p>Наконец, шестая секция состоит из $$$n$$$ строк по $$$m$$$ целых       чисел. $$$j$$$-е число в $$$i$$$-й строке соответствует показаниям       сенсора, расположенного в $$$(i, j, k + 1)$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Если показания сенсоров противоречивы, выведите $$$-1$$$.</p>     <p>Иначе выведите описание структуры внутри параллелепипеда       следующим образом. Выходные данные должны содержать $$$nmk$$$       целых чисел: $$$a_{1, 1, 1}$$$, $$$a_{1, 1, 2}$$$, ..., $$$a_{1,       1, k}$$$, $$$a_{1, 2, 1}$$$, ..., $$$a_{1, 2, k}$$$, ..., $$$a_{1,       m, k}$$$, $$$a_{2, 1, 1}$$$, ..., $$$a_{n, m, k}$$$, где $$$a_{i,       j, k}$$$ — тип блока в $$$(i, j, k)$$$, или $$$0$$$, если эта       ячейка пуста. Если существует несколько структур, которым       соответствуют показания сенсоров, выведите любую из них.</p>     <p>Для вашего удобства выходные данные в примерах отформатированы:       они разделены на $$$n$$$ секций для блоков с $$$x = 1$$$, $$$x =       2$$$, ..., $$$x = n$$$; каждая секция состоит из $$$m$$$ строк по       $$$k$$$ чисел. <span class="tex-font-style-bf">Можно выводить         ответ в таком виде, но любой другой формат вывода тоже будет         принят; можно, например, вывести все числа на одной строке,         важен только их порядок.</span></p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4 3 2

1 4
3 2
6 5

1 4
3 2
6 7

1 4
1 4
0 0
0 7

6 5
6 5
0 0
0 7

1 3 6
1 3 6
0 0 0
0 0 7

4 3 5
4 2 5
0 0 0
0 0 7
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1 4
3 0
6 5

1 4
3 2
6 5

0 0
0 0
0 0

0 0
0 0
0 7
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
1 1 1

0

0

0

0

0

0
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
1 1 1

0

0

1337

0

0

0
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
-1
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
1 1 1

1337

1337

1337

1337

1337

1337
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1337
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        

        
    

    <div class="new-page"></div>



</body>

</html>