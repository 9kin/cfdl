<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {inlineMath: [['$$$','$$$']], displayMath: [['$$$$$$','$$$$$$']]}
        });
    </script>

    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


	<link rel="stylesheet" href="/home/lxc/modules/codeforces2html/codeforces2html/css.css"/>
    <link rel="stylesheet" href="/home/lxc/modules/codeforces2html/codeforces2html/github.css" /> 

	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/highlight.min.js"></script>
    
    <script>hljs.initHighlightingOnLoad();</script>

<style type="text/css">
* { font-family: Verdana; }
.new-page { page-break-after: always; }
</style>
</head>

<body>


    <h1> Codeforces Round #641 (Div. 2)
    1350A
    Орак и делители </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Орак и делители</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Орак изучает теорию чисел, и его очень заинтересовали свойства делимости.</p>     <p>Для двух натуральных чисел $$$a$$$ и $$$b$$$, $$$a$$$ является       делителем $$$b$$$ если и только если существует такое натуральное       число $$$c$$$, что $$$a\cdot c=b$$$.</p>     <p>Для $$$n \ge 2$$$, обозначим за $$$f(n)$$$ минимальный делитель       $$$n$$$, отличный от $$$1$$$.</p>     <p>Например, $$$f(7)=7,f(10)=2,f(35)=5$$$.</p>     <p>Для выбранного числа $$$n$$$ Орак решил прибавить $$$f(n)$$$ к       $$$n$$$. </p>     <p>Например, если у него было число $$$n=5$$$, новое значение       $$$n$$$ будет равно $$$10$$$. А если у него было число $$$n=6$$$,       $$$n$$$ станет равным $$$8$$$.</p>     <p>Ораку так это понравилось, что он решил проделать подобные       операции по несколько раз.</p>     <p>Для двух положительных чисел $$$n$$$ и $$$k$$$, Орак попросил вас       прибавить $$$f(n)$$$ к $$$n$$$ ровно $$$k$$$ раз (обратите       внимание, что $$$n$$$ изменяется после каждой операции,       соотвественно $$$f(n)$$$ тоже может измениться) и сказать ему       итоговое значение $$$n$$$.</p>     <p>Например, если Орак скажет вам, что $$$n=5$$$ и $$$k=2$$$,       сначала вы должны прибавить $$$f(5)=5$$$ к $$$n=5$$$, и новое       значение $$$n$$$ станет равным $$$n=10$$$, после этого вы должны       прибавить $$$f(10)=2$$$ к $$$10$$$, и новое (и итоговое!) значение       $$$n$$$ будет равно $$$12$$$.</p>     <p>Орак может задавать вам эти вопросы несколько раз.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$t\ (1\le t\le       100)$$$: количество запросов Орака.</p>     <p>В каждой из следующий $$$t$$$ строк записаны два целых числа       $$$n,k\ (2\le n\le 10^6, 1\le k\le 10^9)$$$, описывающие очередной запрос.</p>     <p>Гарантируется, что сумма всех $$$n$$$ не превосходит $$$10^6$$$. </p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$t$$$ строк, в $$$i$$$-й из которых должно быть       записано итоговое значение $$$n$$$ для $$$i$$$-го запроса Орака.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
5 1
8 2
3 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
10
12
12
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом запросе $$$n=5$$$ и $$$k=1$$$. Делители $$$5$$$ это       $$$1$$$ и $$$5$$$, и минимальный делитель, отличный от $$$1$$$ это       $$$5$$$. Соответственно, единственная операция это прибавление       $$$f(5)=5$$$ к $$$5$$$, поэтому результат равен $$$10$$$.</p>     <p>Во втором запросе $$$n=8$$$ и $$$k=2$$$. Делители $$$8$$$ это       $$$1,2,4,8$$$, и минимальный из них кроме $$$1$$$ равен $$$2$$$,       затем, после одной операции $$$8$$$ превратится в       $$$8+(f(8)=2)=10$$$. Делители $$$10$$$ это $$$1,2,5,10$$$,       минимальный делитель, отличный от $$$1$$$ это $$$2$$$, поэтому       ответ равен $$$10+(f(10)=2)=12$$$.</p>     <p>В третьем запросе $$$n$$$ изменялось следующим образом: $$$3 \to       6 \to 8 \to 10 \to 12$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1350/problem/A' title='Codeforces Round 641 (Div. 2)'>1350A - Orac and Factors</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p> If we simulate the whole process we will get TLE because $$$k$$$       is too large. So we need some trivial observations:</p>          <ul>                     <li> If $$$n$$$ is even, then for each operation $$$n$$$ will be         added by $$$2$$$ and keep being even.         </li>       <li> If $$$n$$$ is odd, then for the first time $$$n$$$ will be         added by an odd number and then become even.          </li></ul>          <p>So it's easy to see that the answer is $$$$$$ \left\{       \begin{array}{lcl} n+2k &amp; n\textrm{ is even}\\ n+2(k-1)+d(n)       &amp; n\textrm{ is odd}\\ \end{array} \right. $$$$$$ where       $$$d(n)$$$ is the smallest positive factor of $$$x$$$ except       $$$1$$$, which can be calculated in $$$O(n)$$$ time.</p>     <p>The overall complexity is $$$O(n)$$$ .</p></div></div></div>

           
            <pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;

using namespace std;

int main()
{
	int T;
	cin &gt;&gt; T;
	while(T--)
	{
		int n,k;
		cin &gt;&gt; n &gt;&gt; k;
		if(n%2==0)
		{
			cout &lt;&lt; n+2*k &lt;&lt; endl;
			continue;
		}
		int p = 0;
		for(int i = n; i&gt;=2; i--)
			if(n%i==0)
		    	p = i;
		cout &lt;&lt; n+p+2*(k-1) &lt;&lt; endl;
	}
	return 0;
}

</code></pre>
           
            <pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;

using namespace std;

int main()
{
	int T;
	cin &gt;&gt; T;
	while(T--)
	{
		int n,k;
		cin &gt;&gt; n &gt;&gt; k;
		if(n%2==0)
		{
			cout &lt;&lt; n+2*k &lt;&lt; endl;
			continue;
		}
		int p = 0;
		for(int i = n; i&gt;=2; i--)
			if(n%i==0)
		    	p = i;
		cout &lt;&lt; n+p+2*(k-1) &lt;&lt; endl;
	}
	return 0;
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #641 (Div. 2)
    1350B
    Орак и модели </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Орак и модели</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>3 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>В магазине есть $$$n$$$ моделей, пронумерованных от $$$1$$$ до       $$$n$$$, размеры которых равны $$$s_1, s_2, \ldots, s_n$$$.</p>     <p>Орак купит некоторые из этих моделей и упорядочит их по       возрастанию номеров (индексов, а не размеров).</p>     <p>Орак считает, что полученная расстановка <span class="tex-font-style-bf">красивая</span>, если для любых двух       соседних моделей с номерами $$$i_j$$$ и $$$i_{j+1}$$$ (обратите       внимание, что $$$i_j &lt; i_{j+1}$$$, так как Орак упорядочил их       правильно), $$$i_{j+1}$$$ делится на $$$i_j$$$ и $$$s_{i_j} &lt; s_{i_{j+1}}$$$.</p>     <p>Например, для $$$6$$$ моделей с размерами $$$\{3, 6, 7, 7, 7,       7\}$$$, он может купить модели с индексами $$$1$$$, $$$2$$$, и       $$$6$$$, и полученная расстановка будет красивой. Обратите       внимание, что расстановка из одной модели также считается красивой.</p>     <p>Орак хочет знать, какое наибольше число моделей он может купить,       и он может задавать вам эти вопросы по несколько раз.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$t\ (1 \le t\le       100)$$$: количество запросов.</p>     <p>Каждый запрос состоит из двух строк, в первой из которых записано       одно целое число $$$n\ (1\le n\le 100\,000)$$$: количество моделей       в магазине, а во второй записаны $$$n$$$ целых чисел       $$$s_1,\dots,s_n\ (1\le s_i\le 10^9)$$$: размеры моделей.</p>     <p>Гарантируется, что сумма величин $$$n$$$ не превосходит $$$100\,000$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$t$$$ строк, в $$$i$$$-й из которых должно быть       записано максимальное число моделей, которое Орак может купить для       $$$i$$$-го запроса.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
4
5 3 4 6
7
1 4 2 3 6 4 9
5
5 4 3 2 1
1
9
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
3
1
1
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Для первого запроса, например, Орак может купить модели с       индексами $$$2$$$ и $$$4$$$, расстановка которых будет красивой       так как $$$4$$$ делится на $$$2$$$ и $$$6$$$ больше, чем $$$3$$$.       Рассмотрев остальные варианты, можно легко убедиться, что нет       красивой расстановки с более, чем тремя моделями.</p>     <p>Во втором запросе Орак может купить модели с индексами $$$1$$$,       $$$3$$$, и $$$6$$$. Рассмотрев остальные варианты, можно легко       убедиться, что нет красивой расстановки с более, чем тремя моделями.</p>     <p>В третьем примере не существует красивой расстановки с более, чем       одной моделью.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1350/problem/B' title='Codeforces Round 641 (Div. 2)'>1350B - Orac and Models</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Considering DP, we can design DP statuses as follow: $$$f_i$$$       stands for the length of the longest beautiful sequence end up       with index $$$i$$$. </p>     <p>We can find the transformation easily: $$$$$$ f_i =       \max\limits_{j\mid i, s_j&lt;s_i} \{f_j + 1\} $$$$$$</p>     <p>Then, the length of answer sequence is the maximum value among $$$f_1,f_2,\cdots,f_n$$$.</p>     <p>About the complexity of DP: If you transform by iterating       multiples, it will be $$$O(n\log n)$$$ (According to properties of       Harmonic Series); if you iterate divisors, then it will be       $$$O(n\sqrt n)$$$. Fortunately, both of them are acceptable in       this problem.</p></div></div></div>

           
            <pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;
const int MAXN = 500005;
inline int readint()
{
	int res = 0;
	char c = 0;
	while(!isdigit(c))
		c = getchar();
	while(isdigit(c))
		res = res*10+c-&#39;0&#39;, c = getchar();
	return res;	
}
int n,a[MAXN],f[MAXN];

int main()
{
	int T = readint();
	while(T--)
	{
		n = readint();
		for(int i = 1; i&lt;=n; i++)
			a[i] = readint();
		for(int i = 1; i&lt;=n; i++)
			f[i] = 1;
		for(int i = 1; i&lt;=n; i++) 
			for(int j = i*2; j&lt;=n; j += i)
				if(a[i]&lt;a[j])
					f[j] = max(f[j],f[i]+1);
		int ans = 0;
		for(int i = 1; i&lt;=n; i++)
			ans = max(ans,f[i]);
		cout &lt;&lt; ans &lt;&lt; endl;
	}
	return 0;
}

</code></pre>
           
            <pre><code>#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;
const int MAXN = 500005;
inline int readint()
{
	int res = 0;
	char c = 0;
	while(!isdigit(c))
		c = getchar();
	while(isdigit(c))
		res = res*10+c-&#39;0&#39;, c = getchar();
	return res;	
}
int n,a[MAXN],f[MAXN];

int main()
{
	int T = readint();
	while(T--)
	{
		n = readint();
		for(int i = 1; i&lt;=n; i++)
			a[i] = readint();
		for(int i = 1; i&lt;=n; i++)
			f[i] = 1;
		for(int i = 1; i&lt;=n; i++) 
			for(int j = i*2; j&lt;=n; j += i)
				if(a[i]&lt;a[j])
					f[j] = max(f[j],f[i]+1);
		int ans = 0;
		for(int i = 1; i&lt;=n; i++)
			ans = max(ans,f[i]);
		cout &lt;&lt; ans &lt;&lt; endl;
	}
	return 0;
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 87 (рейтинговый для Див. 2)
    1354A
    Будильник </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Будильник</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Поликарп провел целый день за подготовкой задач для вас. Теперь       ему нужно поспать хотя бы $$$a$$$ минут, чтобы отдохнуть.</p>     <p>       <span class="tex-font-style-bf">Поликарп может проснуться только         от звука будильника.</span> Он только заснул, а его первый       будильник прозвонит ровно через $$$b$$$ минут.</p>     <p>Каждый раз когда Поликарп просыпается, он решает, заводить ли       будильник еще раз или нет. Если он проспал меньше $$$a$$$ минут       суммарно, то он заводит будильник так, чтобы тот прозвонил ровно       через $$$c$$$ минут, и тратит $$$d$$$ минут, чтобы снова заснуть.       Иначе же он встает с кровати, начиная новый день.</p>     <p>Если будильник звонит, пока Поликарп все еще засыпает, то он       снова его заводит на $$$c$$$ минут и опять тратит $$$d$$$ минут,       чтобы заснуть.</p>     <p>Вам же всего лишь предстоит выяснить, когда Поликарп встанет с       кровати или сообщить, что это не случится никогда.</p>     <p>       <span class="tex-font-style-bf">Пожалуйста, прочитайте пояснение,         чтобы получше понять пример.</span></p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$t$$$ ($$$1 \le t \le       1000$$$) — количество наборов входных данных.</p>     <p>В единственной строке каждого набора входных данных записаны       четыре целых числа $$$a, b, c, d$$$ ($$$1 \le a, b, c, d \le       10^9$$$) — время, которое необходимо Поликарпу, чтобы выспаться,       время до первого звонка будильника, время до каждого последующего       звонка будильника и время, необходимое Поликарпу, чтобы заснуть.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>На каждый набор входных данных выведите одно целое число. Если       Поликарп никогда не встанет с кровати, то выведите <span class="tex-font-style-tt">-1</span>. Иначе выведите время, которое       Поликарп потратит до того, как встать с кровати.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
7
10 3 6 4
11 3 6 4
5 9 4 10
6 5 2 3
1 1 1 1
3947465 47342 338129 123123
234123843 13 361451236 361451000
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
27
27
9
-1
1
6471793
358578060125049
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных Поликарп просыпается через $$$3$$$       минуты. Он отдохнул только $$$3$$$ минуты из необходимых $$$10$$$.       Поэтому он снова заводит будильник, чтобы тот прозвенел через       $$$6$$$ минут, и тратит $$$4$$$ минуты, чтобы уснуть. То есть он       отдыхает в течение еще $$$2$$$ минут, что суммируется в       $$$3+2=5$$$ минут сна. Он повторяет эту процедуру еще три раза, и       получается $$$11$$$ минут сна. Наконец, он встает с кровати. Он       потратил $$$3$$$ минуты до первого будильника, в потом заново       завел будильник четыре раза. Ответ равен $$$3+4 \cdot 6 = 27$$$.</p>     <p>Второй набор входных данных похож на первый, но Поликарпу надо       $$$11$$$ минут, чтобы выспаться, вместо $$$10$$$. Однако, это       ничего не меняет, потому что Поликарп получает $$$11$$$ минут сна       при таких настройках будильника так и так.</p>     <p>В третьем наборе входных данных Поликарп просыпается достаточно       отдохнувшим уже после первого будильника. Поэтому ответ равен $$$b=9$$$.</p>     <p>В четвертом наборе входных данных Поликарп просыпается через       $$$5$$$ минут. К сожалению, дальше он не может отдохнуть ни       минуты, заводя будильник все снова и снова бесконечно :(</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1354/problem/A' title='Educational Codeforces Round 87 (Rated for Div. 2)'>1354A - Alarm Clock</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's handle some cases. Firstly, if $$$b \ge a$$$ then Polycarp       wakes up rested enough immediately, so $$$b$$$ is the answer. </p>     <p>Otherwise, what does Polycarp do? He sets alarm to go off in       $$$c$$$ minutes and falls asleep in $$$d$$$ minutes. Thus, he       spends $$$c-d$$$ minutes sleeping. Notice that if $$$c-d$$$ is       non-positive, then Polycarp always resets his alarm without       sleeping. So for that case the answer is <span class="tex-font-style-tt">-1</span>.</p>     <p>Finally, if Polycarp resets his alarm $$$x$$$ times then he ends       up with $$$b + x \cdot (c - d)$$$ minutes of sleep in total and       ends up spending $$$b + x \cdot c$$$ minutes of time. We know that       $$$b + x \cdot (c - d)$$$ should be greater or equal to $$$a$$$       and $$$x$$$ should be the smallest possible. </p>     <p>$$$$$$b + x \cdot (c - d) \ge a \leftrightarrow x \cdot (c - d)       \ge a - b \leftrightarrow x \ge \frac{a - b}{c - d}$$$$$$ </p>     <p>Thus, the smallest possible integer $$$x$$$ is equal to $$$\lceil       \frac{a - b}{c - d} \rceil$$$. And the answer is $$$b + x \cdot c$$$.</p>     <p>Overall complexity: $$$O(1)$$$ per testcase.</p></div></div></div>

           
            <pre><code>t = int(input())
for _ in range(t):
	a, b, c, d = map(int, input().split())
	if b &gt;= a:
		print(b)
		continue
	if c &lt;= d:
		print(-1)
		continue
	a -= b
	dif = c - d
	print(b + (a + dif - 1) // dif * c)
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 87 (рейтинговый для Див. 2)
    1354B
    Троичная строка </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Троичная строка</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам дана строка $$$s$$$, каждый символ которой — <span class="tex-font-style-tt">1</span>, <span class="tex-font-style-tt">2</span> или <span class="tex-font-style-tt">3</span>. Вы должны выбрать кратчайшую       непрерывную подстроку $$$s$$$, в которой каждый из трех символов       встречается хотя бы один раз.</p>     <p>Непрерывная подстрока $$$s$$$ — строка, которую можно получить из       $$$s$$$ удалением какого-то количества (возможно, ни одного)       символов из начала строки $$$s$$$ и какого-то количества       (возможно, ни одного) символов из конца строки $$$s$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке задано одно целое число $$$t$$$ ($$$1 \le t \le       20000$$$) — количество наборов входных данных.</p>     <p>Каждый набор входных данных состоит из одной строки $$$s$$$ ($$$1       \le |s| \le 200000$$$). Гарантируется, что каждый символ $$$s$$$ —         <span class="tex-font-style-tt">1</span>, <span class="tex-font-style-tt">2</span> или <span class="tex-font-style-tt">3</span>.</p>     <p>Сумма длин всех строк не превосходит $$$200000$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора тестовых данных выведите одно число — длину       кратчайшей подстроки $$$s$$$, содержащей символы всех трех типов.       Если такой подстроки нет, выведите $$$0$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
7
123
12222133333332
112233
332211
12121212
333333
31121
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
3
4
4
0
0
4
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Рассмотрим пример из условия:</p>     <p>В первом наборе входных данных можно использовать подстроку <span class="tex-font-style-tt">123</span>.</p>     <p>Во втором наборе входных данных можно использовать подстроку         <span class="tex-font-style-tt">213</span>.</p>     <p>В третьем наборе входных данных можно использовать подстроку         <span class="tex-font-style-tt">1223</span>.</p>     <p>В четвертом наборе входных данных можно использовать подстроку         <span class="tex-font-style-tt">3221</span>.</p>     <p>В пятом наборе входных данных в $$$s$$$ нету символа <span class="tex-font-style-tt">3</span>.</p>     <p>В шестом наборе входных данных в $$$s$$$ нету символа <span class="tex-font-style-tt">1</span>.</p>     <p>В седьмом наборе входных данных можно использовать подстроку         <span class="tex-font-style-tt">3112</span>.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1354/problem/B' title='Educational Codeforces Round 87 (Rated for Div. 2)'>1354B - Ternary String</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>There are multiple solutions involving advanced methods such as       binary search or two pointers, but I'll try to describe a simpler one.</p>     <p>The main idea of my solution is that the answer should look like         <span class="tex-font-style-tt">abb...bbbbbc</span>: one       character of type $$$a$$$, a block of characters of type $$$b$$$,       and one character of type $$$c$$$. If we find all blocks of       consecutive equal characters in our string, each candidate for the       answer can be obtained by expanding a block to the left and to the       right by exactly one character. So the total length of all       candidates is $$$O(n)$$$, and we can check them all.</p>     <p>Why does the answer look like <span class="tex-font-style-tt">abb...bbbbbc</span>? If the first       character of the substring appears somewhere else in it, it can be       deleted. The same applies for the last character. So, the first       and the last characters should be different, and should not appear       anywhere else within the string. Since there are only three types       of characters, the answer always looks like <span class="tex-font-style-tt">abb...bbbbbc</span>.</p></div></div></div>

           
            <pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;

char buf[200043];

int main()
{
	int t;
	scanf(&#34;%d&#34;, &amp;t);
	for(int i = 0; i &lt; t; i++)
	{
		scanf(&#34;%s&#34;, buf);
		string s = buf;
		int ans = int(1e9);
		int n = s.size();
		vector&lt;pair&lt;char, int&gt; &gt; c;
		for(auto x : s)
		{
			if(c.empty() || c.back().first != x)
				c.push_back(make_pair(x, 1));
			else
				c.back().second++;
		}
		int m = c.size();
		for(int i = 1; i &lt; m - 1; i++)
			if(c[i - 1].first != c[i + 1].first)
				ans = min(ans, c[i].second + 2);
		if(ans &gt; n)
			ans = 0;
		printf(&#34;%d\n&#34;, ans);
	}
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #643 (Div. 2)
    1355A
    Последовательность с цифрами </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Последовательность с цифрами</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Определим рекуррентную последовательность следующим образом:       $$$$$$a_{n+1} = a_{n} + minDigit(a_{n}) \cdot maxDigit(a_{n}).$$$$$$</p>     <p>Здесь $$$minDigit(x)$$$ и $$$maxDigit(x)$$$ — минимальная и       максимальная цифры в десятичной записи числа $$$x$$$ без ведущих       нулей соответственно. Для примеров обратитесь к примечаниям.</p>     <p>Ваша задача — по заданным $$$a_{1}$$$ и $$$K$$$ вычислить $$$a_{K}$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано единственное число $$$t$$$ ($$$1 \le t       \le 1000$$$) — количество независимых наборов входных данных.</p>     <p>Каждый набор входных данных состоит из двух целых чисел       $$$a_{1}$$$ и $$$K$$$ ($$$1 \le a_{1} \le 10^{18}$$$, $$$1 \le K       \le 10^{16}$$$), записанных через пробел на отдельной строке.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите одно число $$$a_{K}$$$       на отдельной строке.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
8
1 4
487 1
487 2
487 3
487 4
487 5
487 6
487 7
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
42
487
519
528
544
564
588
628
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>$$$a_{1} = 487$$$ </p>     <p> $$$a_{2} = a_{1} + minDigit(a_{1}) \cdot maxDigit(a_{1}) = 487 +       \min (4, 8, 7) \cdot \max (4, 8, 7) = 487 + 4 \cdot 8 = 519$$$ </p>     <p> $$$a_{3} = a_{2} + minDigit(a_{2}) \cdot maxDigit(a_{2}) = 519 +       \min (5, 1, 9) \cdot \max (5, 1, 9) = 519 + 1 \cdot 9 = 528$$$ </p>     <p> $$$a_{4} = a_{3} + minDigit(a_{3}) \cdot maxDigit(a_{3}) = 528 +       \min (5, 2, 8) \cdot \max (5, 2, 8) = 528 + 2 \cdot 8 = 544$$$ </p>     <p> $$$a_{5} = a_{4} + minDigit(a_{4}) \cdot maxDigit(a_{4}) = 544 +       \min (5, 4, 4) \cdot \max (5, 4, 4) = 544 + 4 \cdot 5 = 564$$$ </p>     <p> $$$a_{6} = a_{5} + minDigit(a_{5}) \cdot maxDigit(a_{5}) = 564 +       \min (5, 6, 4) \cdot \max (5, 6, 4) = 564 + 4 \cdot 6 = 588$$$ </p>     <p> $$$a_{7} = a_{6} + minDigit(a_{6}) \cdot maxDigit(a_{6}) = 588 +       \min (5, 8, 8) \cdot \max (5, 8, 8) = 588 + 5 \cdot 8 = 628$$$</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1355/problem/A' title='Codeforces Round 643 (Div. 2)'>1355A - Sequence with Digits</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's calculate the sequence for fixed $$$a_{1} = 1$$$: $$$1, 2,       6, 42, 50, 50, 50, \ldots$$$</p>     <p>We got lucky and the minimal digit has become 0, after that the       element has stopped changing because we always add 0.</p>     <p>Actually it is not luck and that will always happen. Note that we       add no more than $$$9 \cdot 9 = 81$$$ every time, so the       difference between two consecutive elements of the sequence is       bounded by 81. Assume that we will never have minimal digit equal       to 0. Then the sequence will go to infinity. Let's take $$$X =       1000(\lfloor \frac{a_{1}}{1000} \rfloor + 1)$$$. All the numbers       on segment $$$[X;X+99]$$$ have 0 in hundreds digit, so none of       them can be element of our sequence. But our sequence should have       numbers greater than $$$X$$$. Let's take the smallest of them, it       should be at least $$$X + 100$$$. But then the previous number in       the sequence is at least $$$(X + 100) - 81 = X + 19$$$. It is       greater than $$$X$$$ but smaller than the minimal of such numbers. Contradiction.</p>     <p>In the previous paragraph we have actually shown that we have no       numbers greater than $$$X + 100$$$ in our sequence and we will see       the number with 0 among first 1001 elements.</p>     <p>That means that we can build the sequence till we find the first       number with 0 and then it will repeat forever.</p>     <p>In reality the maximal index of the first elements with 0 is 54       and minimal $$$a_{1}$$$ for that to happen is 28217.</p></div></div></div>

           
            <pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;unordered_set&gt;
#include &lt;unordered_map&gt;
#include &lt;queue&gt;
#include &lt;ctime&gt;
#include &lt;cassert&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;chrono&gt;
#include &lt;random&gt;
#include &lt;bitset&gt;
using namespace std;

#ifdef LOCAL
	#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);
#else
	#define eprintf(...) 42
#endif

using ll = long long;
using ld = long double;
using uint = unsigned int;
using ull = unsigned long long;
template&lt;typename T&gt;
using pair2 = pair&lt;T, T&gt;;
using pii = pair&lt;int, int&gt;;
using pli = pair&lt;ll, int&gt;;
using pll = pair&lt;ll, ll&gt;;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
 
#define pb push_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second

double startTime;
double getCurrentTime() {
	return ((double)clock() - startTime) / CLOCKS_PER_SEC;
}

ll getAdd(ll x) {
	ll m1 = 10, m2 = 0;
	while(x &gt; 0) {
		ll y = x % 10;
		x /= 10;
		m1 = min(m1, y);
		m2 = max(m2, y);
	}
	return m1 * m2;
}

int main()
{
	startTime = (double)clock();
//	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);

	int t;
	scanf(&#34;%d&#34;, &amp;t);
	while(t--) {
		ll x, k;
		scanf(&#34;%lld%lld&#34;, &amp;x, &amp;k);
		k--;
		while(k--) {
			ll y = getAdd(x);
			if (y == 0) break;
			x += y;
		}
		printf(&#34;%lld\n&#34;, x);
	}

	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #643 (Div. 2)
    1355B
    Юные следопыты </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Юные следопыты</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Отряд юных следопытов отправился в учебную экспедицию навстречу       своим первым приключениям. И возглавляет их старший следопыт       Рассел. Вот герои зашли в лес, разбили лагерь и дальше решили       разделиться на группы, чтобы исследовать как можно больше       интересных мест. Рассел должен был выбрать состав групп, но       столкнулся с одной проблемой...</p>     <p>Многие юные следопыты неопытны, и отправлять их маленькими       группами — не всегда хорошая идея. Даже сам Рассел недавно стал       старшим следопытом и нечасто бывал в экспедициях. Каждый следопыт       характеризуется своей неопытностью — целым положительным числом       $$$e_i$$$. Рассел решил, что юный следопыт с неопытностью $$$e$$$       может идти лишь в группе, количество следопытов в которой не       меньше $$$e$$$.</p>     <p>Теперь задача Рассела — определить, какое наибольшее число групп       следопытов он сможет организовать. При этом может получиться, что       некоторые следопыты не войдут в состав ни одной группы, это не       страшно, ведь и в лагере для них найдется работа. Рассел очень       переживает за успех экспедиции, и потому попросил вас помочь ему.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано число $$$T$$$ ($$$1 \leq T \leq 2 \cdot       10^5$$$) — количество независимых тестовых случаев. В следующих       $$$2T$$$ строках следует описание тестовых случаев.</p>     <p>В первой строке описания каждого теста задано целое число юных       следопытов $$$N$$$ ($$$1 \leq N \leq 2 \cdot 10^5$$$).</p>     <p>В следующей строке записаны $$$N$$$ целых чисел $$$e_1, e_2,       \ldots, e_N$$$ ($$$1 \leq e_i \leq N$$$), где $$$e_i$$$ —       неопытность $$$i$$$-го следопыта.</p>     <p>Гарантируется, что сумма $$$N$$$ по всем тестовым случаям не       превосходит $$$3 \cdot 10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$T$$$ чисел, каждое на отдельной строке.</p>     <p>В $$$i$$$-й строке выведите наибольшее число групп, которое можно       организовать в $$$i$$$-м тестовом случае.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
3
1 1 1
5
2 3 1 2 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
2
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере можно сформировать три группы, в каждой из       которых будет один следопыт. Это возможно, так как неопытность       всех трех следопытов равна $$$1$$$, что не меньше, чем размер их групп.</p>     <p>Во втором примере можно сформировать две группы. В первой группе       окажутся следопыты с неопытностью $$$1$$$, $$$2$$$ и $$$3$$$, а во       второй группе — два следопыта с неопытностью $$$2$$$.</p>     <p>Этот способ — не единственный возможный. Можно, например,       сформировать одну группу из трех следопытов с неопытностью       $$$2$$$, а также еще одну группу, в которой будет всего один       следопыт с неопытностью $$$1$$$. При таком разбиении на группы       следопыт с неопытностью $$$3$$$ не войдет в состав ни одной группы.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1355/problem/B' title='Codeforces Round 643 (Div. 2)'>1355B - Young Explorers</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's sort all the explorers by non-decreasing inexperience.       Suppose we have formed some group, how can we check is this group       is valid? Inexperience of all the explorers in the group should be       not greater than the group size. But we have sorted all the       explorers, so the last explorer from the group has the largest       inexperience. Therefore, to check the group for validity it is       necessary and sufficient to check that inexperience of the last       explorer is not greater than the group size.</p>     <p>We can notice that we don't even look at all the explorers except       the last one, the only important thing is their number. In fact,       we can organize the creation of groups in this way: first choose       the explorers that will be the last in their groups, then assign       sufficient number of other explorers to corresponding groups. It       is not profitable to assign more explorers than needed for this       particular last explorer, because we can always leave them at the camp.</p>     <p>So how should we choose the last explorers? We want to make more       groups, so the groups themselves should me smaller... It is       tempting to use the following greedy algorithm: let's greedily       pick the leftmost (which means with the smallest necessary group       size) explorer such that they have enough explorers to the left of       them to create a valid group. The idea is that we spend the       smallest number of explorers and leave the most potential last       explorers in the future. Let's strictly prove this greedy:</p>     <p>The solution is defined by positions of the last explorers in       their corresponding groups $$$1 \le p_{1} &lt; p_{2} &lt; \ldots       &lt; p_{k} \le n$$$. Notice that the solution is valid if and only       if $$$e_{p_{1}} + e_{p_{2}} + \ldots + e_{p_{i}} \le p_{i}$$$ for       all $$$1 \le i \le k$$$ (we always have enough explorers to form       first $$$i$$$ groups).</p>     <p>Let $$$1 \le p_{1} &lt; p_{2} &lt; \ldots &lt; p_{k} \le n$$$ be       the greedy solution and $$$1 \le q_{1} &lt; q_{2} &lt; \ldots &lt;       q_{m} \le n$$$ be the optimal solution such that it has the       largest common prefix with greedy one among all optimal solutions.       Let $$$t$$$ be the position of first difference in these       solutions. $$$t \le k$$$ since otherwise the greedy algorithm       couldn't add one more group but it was possible. $$$p_{t} &lt;       q_{t}$$$ since otherwise the greedy algorithm would take       $$$q_{t}$$$ instead of $$$p_{t}$$$. Since the explorers are sorted       we have $$$e_{p_{t}} \le e_{q_{t}}$$$. But then $$$1 \le q_{1}       &lt; q_{2} &lt; \ldots &lt; q_{t - 1} &lt; p_{t} &lt; q_{t + 1}       &lt; \ldots &lt; q_{m} \le n$$$ is a valid optimal solution and it       has strictly larger common prefix with the greedy one which       contradicts the choosing of our optimal solution.</p>     <p>To implement this solution it is enough to sort the explorers by       the non-decreasing inexperience, then go from left to right and       maintain the number of unused explorers. As soon as we encounter       the possibility to create a new group, we do it.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

int main() {
    int t;
    cin &gt;&gt; t;
    
    while (t--) {
        int n;
        cin &gt;&gt; n;
        vector &lt;int&gt; a(n);
        for (int i = 0; i &lt; n; i++) {
            cin &gt;&gt; a[i];
        }
        sort(a.begin(), a.end());
        int ans = 0, cur = 0;
        for (int i = 0; i &lt; n; i++) {
            if (++cur == a[i]) {
                ans++;
                cur = 0;
            }
        }
        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
    }
    return 0;
}</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #643 (Div. 2)
    1355C
    Сосчитайте треугольники </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Сосчитайте треугольники</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Как и у любого неизвестного математика, у Юрия есть любимые       числа: $$$A$$$, $$$B$$$, $$$C$$$ и $$$D$$$, причем $$$A \leq B       \leq C \leq D$$$. Также Юрий очень любит треугольники, поэтому в       один день он задумался: сколько существует невырожденных       треугольников с целочисленными длинами сторон $$$x$$$, $$$y$$$ и       $$$z$$$ таких, что $$$A \leq x \leq B \leq y \leq C \leq z \leq D$$$?</p>     <p>Сейчас Юрий очень занят подготовкой задач для очередной       олимпиады, поэтому он просит вас помочь посчитать количество       интересующих его треугольников. </p>     <p>Треугольник называется невырожденным тогда и только тогда, когда       его вершины не лежат на одной прямой.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В единственной строке через пробел записаны четыре целых числа       $$$A$$$, $$$B$$$, $$$C$$$ и $$$D$$$ ($$$1 \leq A \leq B \leq C       \leq D \leq 5 \cdot 10^5$$$) — любимые числа Юрия.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите одно число — количество невырожденных треугольников с       целочисленными длинами сторон $$$x$$$, $$$y$$$ и $$$z$$$, для       которых выполнено неравенство: $$$A \leq x \leq B \leq y \leq C       \leq z \leq D$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
1 2 3 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
4
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
1 2 2 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
500000 500000 500000 500000
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере можно составить треугольники со следующими       длинами сторон: $$$(1, 3, 3)$$$, $$$(2, 2, 3)$$$, $$$(2, 3, 3)$$$       и $$$(2, 3, 4)$$$.</p>     <p>Во втором примере можно составить треугольники: $$$(1, 2, 2)$$$,       $$$(2, 2, 2)$$$ и $$$(2, 2, 3)$$$.</p>     <p>В третьем примере можно составить лишь один равносторонний       треугольник. Длины всех сторон будут равны $$$5 \cdot 10^5$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1355/problem/C' title='Codeforces Round 643 (Div. 2)'>1355C - Count Triangles</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Since $$$x \le y \le z$$$ to be a non-degenerate triangle for       given triple it is necessary and sufficient to satisfy $$$z &lt; x       + y$$$. Let's calculate for all $$$s = x + y$$$ how many ways       there are to choose $$$(x, y)$$$. To do that we will try all       $$$x$$$ and add 1 on segment $$$[x + B; x + C]$$$ offline using       prefix sums. Let's calculate prefix sums once more, now we can       find in $$$O(1)$$$ how many ways there are to choose $$$(x, y)$$$       such that their sum if greater than $$$z$$$. Try all $$$z$$$,       calculate the answer. Total complexity — $$$O(C)$$$.</p></div></div></div>

           
            <pre><code>// #pragma comment(linker, &#34;/stack:200000000&#34;)
// #pragma GCC optimize(&#34;Ofast,no-stack-protector&#34;)
// #pragma GCC target(&#34;sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native&#34;)
// #pragma GCC optimize(&#34;unroll-loops&#34;)

#include &lt;bits/stdc++.h&gt;

#ifdef PERVEEVM_LOCAL
    #define debug(x) std::cerr &lt;&lt; (#x) &lt;&lt; &#34;:\t&#34; &lt;&lt; (x) &lt;&lt; std::endl
#else
    #define debug(x) 238;
#endif

#define fastIO std::ios_base::sync_with_stdio(false); std::cin.tie(0); std::cout.tie(0)
#define NAME &#34;File&#34;

using ll = long long;
using ld = long double;

#ifdef PERVEEVM_LOCAL
    std::mt19937 rnd(238);
#else
    std::mt19937 rnd(std::chrono::high_resolution_clock::now().time_since_epoch().count());
#endif

const double PI = atan2(0.0, -1.0);
const int INF = 0x3f3f3f3f;
const ll LINF = (ll)2e18;

ll calcProgression(ll a, ll d, ll n) {
    return (2 * a + d * (n - 1)) * n / 2;
}

void run() {
    int a, b, c, d;
    scanf(&#34;%d%d%d%d&#34;, &amp;a, &amp;b, &amp;c, &amp;d);

    ll ans = 0;
    for (int z = c; z &lt;= d; ++z) {
        int minX = std::max(a, z - c + 1);
        if (minX &gt; b) {
            continue;
        }

        int mid = z - b + 1;
        int start = c - std::max(b, z - minX + 1) + 1;

        if (mid &lt;= minX) {
            ans += 1ll * (c - b + 1) * (b - minX + 1);
        } else if (mid &gt; b) {
            // ans += 1ll * (b - minX + 1) * (b - minX + 2) / 2;
            ans += calcProgression(start, 1, b - minX + 1);
        } else {
            ans += calcProgression(start, 1, mid - minX + 1);
            ans += 1ll * (b - mid) * (c - b + 1);
            // ans += 1ll * (mid - minX + 1) * (mid - minX + 2) / 2 + 1ll * (b - mid) * (c - b + 1);
        }
    }    

    printf(&#34;%lld\n&#34;, ans);
}

int main(void) {
    // freopen(NAME&#34;.in&#34;, &#34;r&#34;, stdin);
    // freopen(NAME&#34;.out&#34;, &#34;w&#34;, stdout);

    auto start = std::chrono::high_resolution_clock::now();
    run();
    auto end = std::chrono::high_resolution_clock::now();

    #ifdef PERVEEVM_LOCAL
        std::cerr &lt;&lt; &#34;Execution time: &#34;
                  &lt;&lt; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start).count()
                  &lt;&lt; &#34; ms&#34; &lt;&lt; std::endl;
    #endif

    return 0;
}
</code></pre>
           
            <pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;vector&gt;
#include &lt;set&gt;
#include &lt;map&gt;
#include &lt;unordered_set&gt;
#include &lt;unordered_map&gt;
#include &lt;queue&gt;
#include &lt;ctime&gt;
#include &lt;cassert&gt;
#include &lt;complex&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;chrono&gt;
#include &lt;random&gt;
#include &lt;bitset&gt;
using namespace std;

#ifdef LOCAL
	#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);
#else
	#define eprintf(...) 42
#endif

using ll = long long;
using ld = long double;
using uint = unsigned int;
using ull = unsigned long long;
template&lt;typename T&gt;
using pair2 = pair&lt;T, T&gt;;
using pii = pair&lt;int, int&gt;;
using pli = pair&lt;ll, int&gt;;
using pll = pair&lt;ll, ll&gt;;
mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
 
#define pb push_back
#define mp make_pair
#define all(x) (x).begin(),(x).end()
#define fi first
#define se second

double startTime;
double getCurrentTime() {
	return ((double)clock() - startTime) / CLOCKS_PER_SEC;
}

const int N = (int)1e6 + 77;
int A, B, C, D;
ll a[N];

int main()
{
	startTime = (double)clock();
//	freopen(&#34;input.txt&#34;, &#34;r&#34;, stdin);
//	freopen(&#34;output.txt&#34;, &#34;w&#34;, stdout);

	scanf(&#34;%d%d%d%d&#34;, &amp;A, &amp;B, &amp;C, &amp;D);
	for (int i = A; i &lt;= B; i++) {
		a[i + B]++;
		a[i + C + 1]--;
	}
	for (int i = 1; i &lt; N; i++)
		a[i] += a[i - 1];
	for (int i = 1; i &lt; N; i++)
		a[i] += a[i - 1];
	ll ans = 0;
	for (int i = C; i &lt;= D; i++)
		ans += a[N - 1] - a[i];
	printf(&#34;%lld\n&#34;, ans);

	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #645 (Div. 2)
    1358A
    Освещение парка </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Освещение парка</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>В связи с эпидемией коронавируса власти города обязали жителей       соблюдать социальную дистанцию. Мэр города Семён Сергеевич хочет       осветить парк Глухарники, чтобы люди даже ночью могли видеть друг       друга и соблюдали дистанцию. </p>     <p>Парк представляет из себя прямоугольную таблицу состоящую из       $$$n$$$ строк и $$$m$$$ столбцов, где клетки таблицы — площади, а       границы между клетками — улицы. Также улицами являются внешние       границы. Каждая улица имеет длину $$$1$$$. Например, у парка       размера $$$n=m=2$$$ всего $$$12$$$ улиц.</p>     <p>Вам поручили разработать план освещения парка. Вы можете ставить       фонари в серединах улиц. Фонарь освещает две площади, между       которыми он стоит (или только одну площадь, если он стоит на       границе парка).</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/18aa1573b5d0c49e178a230e693800b5a0c2e6a8.png" style="max-width: 100.0%;max-height: 100.0%;"/>         <span class="tex-font-size-small">Пример парка размеров:         $$$n=4$$$, $$$m=5$$$. Освещенные площади отмечены жёлтым цветом.         Обратите внимание, что все улицы имеют длины $$$1$$$. Фонари         ставятся в середины улиц. На картинке <span class="tex-font-style-bf">не все</span> площади       освещены.</span> </center>          <p>Семён Сергеевич хочет потратить на освещение наименьшее возможное       количество денег, но также хочет чтобы люди по всему парку держали       социальную дистанцию. Поэтому он просит вас узнать, какое       минимальное количество фонарей понадобится, чтобы осветить все площади.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит одно целое число $$$t$$$ ($$$1 \le t \le       10^4$$$) — количество наборов входных данных. Далее следуют       $$$t$$$ наборов входных данных.</p>     <p>Каждый набор входных данных записывается одной строкой,       содержащей два натуральных числа $$$n$$$ и $$$m$$$ ($$$1 \le n, m       \le 10^4$$$) — размеры парка.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$t$$$ ответов на наборы тестовых данных. Каждый ответ       должен содержать одно целое число — минимальное количество фонарей       для того, чтобы осветить все площади.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
1 1
1 3
2 2
3 3
5 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
2
2
5
8
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Возможное оптимальное расположение фонарей для $$$2$$$-го набора       входных данных примера: <img class="tex-graphics" src="https://espresso.codeforces.com/9c98cd06c74ee783b366a57440a9ab57d0317193.png" style="max-width: 100.0%;max-height: 100.0%;"/></p>     <p>Возможное оптимальное расположение фонарей для $$$3$$$-го набора       входных данных примера: <img class="tex-graphics" src="https://espresso.codeforces.com/ea550342416cdfaeadf987bfcfdab6d169d5f8ad.png" style="max-width: 100.0%;max-height: 100.0%;"/> </p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1358/problem/A' title='Codeforces Round 645 (Div. 2)'>1358A - Park Lighting</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Note that if at least one of the sides is even, the square can be       divided into pairs of neighbors and the answer is       $$$\frac{nm}{2}$$$. </p>     <p>If both sides are odd, we can first light up a $$$(n - 1) \times       m$$$ part of the park. Then we'll still have the part $$$m \times       1$$$. We can light it up with $$$\frac{m + 1}{2}$$$ lanterns. Then       the total number of the lanterns is $$$\frac{(n-1) \cdot m}{2} +       \frac{m + 1}{2} = \frac{nm - m + m + 1}{2} = \frac{nm + 1}{2}$$$.</p>     <p>Note that both cases can be combined into one formula: $$$\lfloor       \frac{nm + 1}{2} \rfloor$$$.</p>     <p>The overall compexity is $$$\mathcal{O}(1)$$$ per test.</p></div></div></div>

           
            <pre><code>#include &lt;iostream&gt;

using namespace std;

int main() {
    int t, n, m;
    cin &gt;&gt; t;
    while (t--) {
        cin &gt;&gt; n &gt;&gt; m;
        cout &lt;&lt; (n * m + 1) / 2 &lt;&lt; &#39;\n&#39;;
    }
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #645 (Div. 2)
    1358B
    Марья Ивановна нарушает самоизоляцию </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Марья Ивановна нарушает самоизоляцию</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Марье Ивановне, самой активной бабушке двора, надоело сидеть       дома. Она решила организовать обряд против коронавируса.</p>     <p>У неё есть $$$n$$$ подруг-бабушек (сама Марья Ивановна в это       количество не входит). Бабушка с номером $$$i$$$ готова прийти на       обряд при условии, если в момент её появления во дворе кроме неё       там будет как минимум $$$a_i$$$ других бабушек. Обратите внимание,       что бабушки могут приходить во двор одновременно. Формально,       бабушка $$$i$$$ готова прийти, если количество бабушек пришедших       ранее или одновременно с ней больше или равно $$$a_i$$$.</p>     <p>Бабушки собираются во дворе так.</p>          <ul> <li> Изначально во дворе находится только Марья Ивановна (то         есть количество бабушек во дворе равно $$$1$$$). Все остальные         $$$n$$$ бабушек пока сидят по домам.         </li>       <li> На очередном шаге Марья Ивановна выбирает подмножество         бабушек, ни одна из которых ещё не вышла во двор. Каждой из них         она обещает, что когда бабушка выйдет, во дворе будет не менее         $$$a_i$$$ других бабушек (включая Марью Ивановну). Марья         Ивановна может звонить сразу нескольким соседкам. В таком случае         выбранные бабушки выйдут во двор <span class="tex-font-style-bf">одновременно</span>.          </li>       <li> Вы не можете обманывать бабушек, то есть ситуация, когда         $$$i$$$-я бабушка, после выхода во двор обнаружит, что сейчас во         дворе строго меньше $$$a_i$$$ других бабушек (кроме неё самой,         но включая Марью Ивановну), запрещена. Обратите внимание, что         если несколько бабушек появились во дворе одновременно, то они         каждая из них видит в том числе остальных в момент выхода. </li></ul>          <p>Ваша задача — найти, какое максимальное количество бабушек       (включая себя) Марья Ивановна может собрать во дворе для       проведения обряда «обкуривания от Короны-Вируса». Ведь чем больше       людей в одном месте во время карантина, тем эффективнее обряд!</p>     <p>Рассмотрим пример: если $$$n=6$$$ и $$$a=[1,5,4,5,1,9]$$$, то:</p>          <ul> <li> на первом шаге Марья Ивановна может позвать бабушек с         номерами $$$1$$$ и $$$5$$$, каждая из них будет видеть двух         бабушек в момент выхода во двор (заметим, что $$$a_1=1 \le 2$$$         и $$$a_5=1 \le 2$$$); </li>       <li> на втором шаге Марья Ивановна может позвать бабушек с         номерами $$$2$$$, $$$3$$$ и $$$4$$$, каждая из них будет видеть         пять бабушек в момент выхода во двор (заметим, что $$$a_2=5 \le         5$$$, $$$a_3=4 \le 5$$$ и $$$a_4=5 \le 5$$$); </li>       <li> бабушку номер $$$6$$$ позвать во двор не получится —         следовательно, ответ на для такого примера равен $$$6$$$ (сама         Марья Ивановна и еще $$$5$$$ суммарно вышедших бабушек). </li></ul></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке находится одно целое число $$$t$$$ ($$$1 \le t       \le 10^4$$$) — количество наборов входных данных в тесте. Далее       следуют описания наборов входных данных.</p>     <p>Первая строка описания набора содержит одно целое число $$$n$$$       ($$$1 \le n \le 10^5$$$) — количество бабушек (Марья Ивановна в       это количество не входит). </p>     <p>Вторая строка содержит $$$n$$$ целых чисел $$$a_1, a_2, \ldots,       a_n$$$ ($$$1 \le a_i \le 2\cdot10^5$$$).</p>     <p>Гарантируется, что сумма значений $$$n$$$ по всем наборам входных       данных не превосходит $$$10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите единственное целое       число $$$k$$$ ($$$1 \le k \le n + 1$$$) — максимальное возможное       количество бабушек во дворе.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
5
1 1 2 2 1
6
2 3 4 5 6 7
6
1 5 4 5 1 9
5
1 2 3 5 6
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
6
1
6
4
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных примера Марья Ивановна на первом       шаге может позвать всех бабушек. Тогда каждая из них увидит пять       бабушек, когда выйдет. Иными словами, ни одна не уйдёт домой.       Поэтому во дворе будет Марья Ивановна и пять других бабушек.</p>     <p>Во втором наборе входных данных примера никто не сможет       находиться во дворе, поэтому Марья Ивановна останется там одна.</p>     <p>Третий набор входных данных примера подробно разобран выше.</p>     <p>В четвёртом тестовом случае Марья Ивановна на первом шаге может       позвать бабушек с номерами $$$1$$$, $$$2$$$ и $$$3$$$. Если на       втором шаге Марья Ивановна позовёт только $$$4$$$-ю или только       $$$5$$$-ю, то когда эта бабушка выходила бы во двор, то она бы       увидела четверых бабушек, то есть Марья Ивановна по отдельности       позвать $$$4$$$-ю и $$$5$$$-ю не может. Если она позовёт сразу       обеих — $$$4$$$-ю и $$$5$$$-ю, то когда они будут выходить, то       увидят по $$$4+1=5$$$ бабушек. Несмотря на то, что $$$4$$$-ю       бабушку это устраивает, $$$5$$$-ю — этот вариант не устраивает.       Следовательно, позвать одновременно $$$4$$$-ю и $$$5$$$-ю Марья       Ивановна тоже не может. То есть во дворе будет только Марья       Ивановна и три бабушки из первого шага.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1358/problem/B' title='Codeforces Round 645 (Div. 2)'>1358B - Maria Breaks the Self-isolation</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let $$$x$$$ be the maximum number of grannies that can go out to       the yard. Then if Maria Ivanovna calls them all at the same time,       then everyone will see $$$x$$$ grannies. Since $$$x$$$ is the       maximum answer, then each granny of them satisfy $$$a_i \le x$$$       (otherwise there's no way for these grannies to gather in the       yard), that is, such call is correct. So it is always enough to       call once.</p>     <p>Note that if you order grannies by $$$a_i$$$, Maria Ivanovna will       have to call $$$x$$$ first grannies from this list. She can take       $$$x$$$ grannies if $$$a_x \le x$$$ (otherwise, after all $$$x$$$       grannies arrived, the last one will leave). To find $$$x$$$ we can       do a linear search.</p>     <p>The overall compexity is $$$\mathcal{O}(n\log{n})$$$ per test.</p></div></div></div>

           
            <pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

void solve() {
    int n;
    cin &gt;&gt; n;
    vector&lt;int&gt; arr(n);
    for (int &amp;el : arr)
        cin &gt;&gt; el;
    sort(arr.begin(), arr.end());
    for (int i = n - 1; i &gt;= 0; i--) {
        if (arr[i] &lt;= i + 1) {
            cout &lt;&lt; i + 2 &lt;&lt; &#39;\n&#39;;
            return;
        }
    }
    cout &lt;&lt; 1 &lt;&lt; &#39;\n&#39;;
}

int main() {
    int t;
    cin &gt;&gt; t;
    while (t--)
        solve();
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #645 (Div. 2)
    1358C
    Обновление Celex </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Обновление Celex</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>В связи с карантином, у Cайкромофта появилось больше свободного       времени для реализации новых функций в «<span class="tex-font-style-tt">Celex-2021</span>». Разработчики сделали       новую функцию <span class="tex-font-style-tt">GAZ-GIZ</span>,       которая от левого верхнего угла бесконечно заполняет бесконечную       вправо и вниз таблицу следующим образом:</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/ab3c49666e913d52a14ebf7f09d741f3f712bacb.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center>          <p>Клетка с координатами $$$(x, y)$$$ находится на пересечение       $$$x$$$-й строки и $$$y$$$-го столбца. Левая верхняя клетка       $$$(1,1)$$$ содержит число $$$1$$$.</p>     <p>Разработчики функции <span class="tex-font-style-tt">SUM</span>       тоже не спят. От скуки они сговорились с разработчиками функции         <span class="tex-font-style-tt">RAND</span>, поэтому они       добавили возможность посчитать сумму на произвольном пути от одной       клетки до другой, передвигаясь вниз или вправо. Формально, из       клетки $$$(x,y)$$$ за один шаг можно переместиться в клетку       $$$(x+1, y)$$$ или $$$(x, y+1)$$$.</p>     <p>После очередного обновления Dinwows, Левиан решил изучать «<span class="tex-font-style-tt">Celex-2021</span>» (ведь он хочет стать       бухгалтером!). После заполнения таблицы функцией <span class="tex-font-style-tt">GAZ-GIZ</span> он попросил вас посчитать       количество возможных различных сумм на пути от заданной клетки       $$$(x_1, y_1)$$$ до другой заданной клетки $$$(x_2, y_2$$$), если       за один ход вы можете ходить только на одну ячейку вниз или вправо.</p>     <p>Формально, рассмотрим все пути из клетки $$$(x_1, y_1)$$$ в       клетку $$$(x_2, y_2)$$$ такие, что каждая следующая клетка в пути       располагается либо справа, либо снизу от предыдущей. Посчитайте       количество различных сумм значений элементов для всех таких путей.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит одно целое число $$$t$$$ ($$$1 \le t \le       57179$$$) — количество наборов входных данных.</p>     <p>Каждая из следующих $$$t$$$ строк содержит четыре целых       положительных числа $$$x_1$$$, $$$y_1$$$, $$$x_2$$$, $$$y_2$$$       ($$$1 \le x_1 \le x_2 \le 10^9$$$, $$$1 \le y_1 \le y_2 \le       10^9$$$) — координаты стартовой и конечной клеток. </p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>На каждый набор входных данных в отдельной строке выведите ответ       — количество возможных различных сумм на пути от одной клетки до другой.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
1 1 2 2
1 2 2 4
179 1 179 100000
5 7 5 7
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
3
1
1
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных есть две возможных суммы:       $$$1+2+5=8$$$ и $$$1+3+5=9$$$. <img class="tex-graphics" src="https://espresso.codeforces.com/f80a32136dea106987ece7d1135079a5c040c792.png" style="max-width: 100.0%;max-height: 100.0%;"/></p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1358/problem/C' title='Codeforces Round 645 (Div. 2)'>1358C - Celex Update</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's look at the way with the minimum sum (first we go       $$$y_2-y_1$$$ steps right, and then $$$x_2-x_1$$$ steps down).       Let's look at such a change in the &quot;bends&quot; of the way:         <img class="tex-graphics" src="https://espresso.codeforces.com/62fb82fe60fcd4070ba7340fdbdee393ba3c352d.png" style="max-width: 100.0%;max-height: 100.0%;" />       After each step, the sum on the way will increase by $$$1$$$.</p>     <p>We're going to bend like this until we get to the maximum sum.       We're not going to miss any possible sum, because we're       incrementing the sum by 1. We started with the minimum sum and       finished with the maximum sum, so we can use these changes to get       all possible sums.</p>     <p>In order for us to come from the minimum to the maximum way, we       must bend the way exactly 1 time per each cell of table (except       for the cells of the minimum way). That is, the number of changes       equals the number of cells not belonging to the minimum way —       $$$(x_2-x_1)\cdot(y_2-y_1)$$$. Then the number of different sums       will be $$$(x_2-x_1)\cdot(y_2-y_1) + 1$$$.</p>     <p>The overall compexity is $$$\mathcal{O}(1)$$$ per test.</p></div></div></div>

           
            <pre><code>#include &lt;iostream&gt;

using namespace std;

int main() {
    int t;
    cin &gt;&gt; t;
    while (q--) {
        long long a, b, c, d;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;
        cout &lt;&lt; (c - a) * (d - b) + 1 &lt;&lt; &#39;\n&#39;;
    }
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 88 (рейтинговый для Див. 2)
    1359A
    Берляндский покер </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Берляндский покер</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>В берляндский покер играют с колодой из $$$n$$$ карт, $$$m$$$ из       которых являются джокерами. В игре участвует $$$k$$$ игроков       ($$$n$$$ делится на $$$k$$$).</p>     <p>В начале игры каждый игрок берет $$$\frac{n}{k}$$$ карт из колоды       (таким образом, каждая карта берется ровно одним игроком). Игрок,       у которого максимальное количество джокеров в руке, является       победителем, и он получает количество очков, равное $$$x - y$$$,       где $$$x$$$ — количество джокеров в руке победителя, а $$$y$$$ —       максимальное количество джокеров среди всех других игроков. Если       есть два или более игроков с максимальным количеством джокеров,       все они являются победителями, и они получают $$$0$$$ очков.</p>     <p>Вот несколько примеров:</p>          <ul> <li> $$$n = 8$$$, $$$m = 3$$$, $$$k = 2$$$. Если один игрок         получает $$$3$$$ джокера и $$$1$$$ простую карту, а другой игрок         получает $$$0$$$ джокеров и $$$4$$$ простые карты, то первый         игрок является победителем и получает $$$3 - 0 = 3$$$ очка; </li>       <li> $$$n = 4$$$, $$$m = 2$$$, $$$k = 4$$$. Два игрока получают         простые карты, а два других игрока получают джокеры, так что оба         они являются победителями и получают $$$0$$$ очков; </li>       <li> $$$n = 9$$$, $$$m = 6$$$, $$$k = 3$$$. Если первый игрок         получает $$$3$$$ джокера, второй игрок получает $$$1$$$ джокера         и $$$2$$$ простые карты, а третий игрок получает $$$2$$$ джокера         и $$$1$$$ простую карту, то первый игрок является победителем, и         он получает $$$3 - 2 = 1$$$ очко; </li>       <li> $$$n = 42$$$, $$$m = 0$$$, $$$k = 7$$$. Поскольку джокеров         нет, каждый получает $$$0$$$ джокеров, каждый является         победителем, и каждый получает $$$0$$$ очков. </li></ul>          <p>Для заданных $$$n$$$, $$$m$$$ и $$$k$$$ вычислите максимальное       количество очков, которое игрок может получить за победу в игре.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка входных данных содержит одно целое число $$$t$$$       ($$$1 \le t \le 500$$$) — количество наборов входных данных.</p>     <p>Каждый набор входных данных содержит три целых числа $$$n$$$,       $$$m$$$ и $$$k$$$ ($$$2 \le n \le 50$$$, $$$0 \le m \le n$$$, $$$2       \le k \le n$$$, $$$k$$$ делит $$$n$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите одно целое число —       максимальное количество очков, которое игрок может получить за       победу в игре.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
8 3 2
4 2 4
9 6 3
42 0 7
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3
0
1
0
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Тесты из примера разобраны в условии.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1359/problem/A' title='Educational Codeforces Round 88 (Rated for Div. 2)'>1359A - Berland Poker</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>There are many different ways to solve this problem. The easiest       one, in my opinion, is to iterate on the number of jokers the       winner has (let it be $$$a_1$$$) and the number of jokers the       runner-up has (let it be $$$a_2$$$). Then the following conditions       should be met:</p>          <ul> <li> $$$a_1 \ge a_2$$$ (the winner doesn't have less jokers         than the runner-up); </li>       <li> $$$a_1 \le \frac{n}{k}$$$ (the number of jokers in the         winner's hand does not exceed the number of cards in his hand); </li>       <li> $$$a_1 + a_2 \le m$$$ (the number of jokers for these two         players does not exceed the total number of jokers); </li>       <li> $$$a_1 + (k - 1)a_2 \ge m$$$ (it is possible to redistribute         remaining jokers among other players so that they have at most         $$$a_2$$$ jokers). </li></ul>          <p>Iterating on $$$a_1$$$ and $$$a_2$$$, then checking these       constraints gives us a $$$O(n^2)$$$ solution. It is possible to       get a constant-time solution using some greedy assumptions and       math (the first player should get as many jokers as possible,       while the remaining jokers should be evenly distributed among       other players).</p></div></div></div>

           
            <pre><code>t = int(input())

for i in range(t):
    n, m, k = map(int, input().split())
    d = n // k
    a1 = min(m, d)
    a2 = (m - a1 + k - 2) // (k - 1)
    print(a1 - a2)
</code></pre>
           
            <pre><code>t = int(input())

for i in range(t):
    n, m, k = map(int, input().split())
    ans = 0
    d = n // k
    for a1 in range(m + 1):
        for a2 in range(a1 + 1):
            if(a1 &gt; d):
                continue
            if(a1 + a2 &gt; m):
                continue
            if(a1 + (k - 1) * a2 &lt; m):
                continue
            ans = max(ans, a1 - a2)
    print(ans)
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 88 (рейтинговый для Див. 2)
    1359B
    Новая Театральная площадь </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Новая Театральная площадь</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Возможно, вы помните Театральную площадь из <a href="https://codeforces.com/problemset/problem/1/A">задачи       1A</a>. Сегодня ее покрытие наконец-то заменят.</p>     <p>Площадь все еще является прямоугольником $$$n \times m$$$ метров.       Однако, рисунок на ней будет более сложным в этот раз. Пусть       $$$a_{i,j}$$$ будет $$$j$$$-й ячейкой в $$$i$$$-м ряду покрытия плитками.</p>     <p>Вам задан рисунок покрытия:</p>          <ul> <li> если $$$a_{i,j} = $$$ «<span class="tex-font-style-tt">*</span>», то $$$j$$$-я ячейка в         $$$i$$$-м ряду должна быть <span class="tex-font-style-bf">черной</span>; </li>       <li> если $$$a_{i,j} = $$$ «<span class="tex-font-style-tt">.</span>», то $$$j$$$-я ячейка в         $$$i$$$-м ряду должна быть <span class="tex-font-style-bf">белой</span>. </li></ul>          <p>Черные ячейки уже покрыты. Вам же необходимо покрыть белые       ячейки. Существует две опции плиток:</p>          <ul> <li> $$$1 \times 1$$$ плитки — каждая плитка стоит $$$x$$$         бурлей и покрывает ровно $$$1$$$ ячейку; </li>       <li> $$$1 \times 2$$$ плитки — каждая плитка стоит $$$y$$$ бурлей         и покрывает ровно $$$2$$$ соседние ячейки в <span class="tex-font-style-bf">одном ряду</span>. <span class="tex-font-style-bf">Обратите внимание, что нельзя           вращать эти плитки или резать их на плитки $$$1 \times         1$$$.</span> </li></ul>          <p>       <span class="tex-font-style-bf">Вам необходимо покрыть все белые         ячейки, никакие две плитки не должны накладываться друг на друга         и никакие черные ячейки не должны быть накрыты плитками</span>.</p>     <p>Чему равна наименьшая суммарная цена плиток, которые могут       покрыть все белые клетки?</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$t$$$ ($$$1 \le t \le       500$$$) — количество наборов входных данных. Затем следует       описание $$$t$$$ наборов.</p>     <p>В первой строке каждого набора входных данных записаны четыре       целых числа $$$n$$$, $$$m$$$, $$$x$$$ и $$$y$$$ ($$$1 \le n \le       100$$$; $$$1 \le m \le 1000$$$; $$$1 \le x, y \le 1000$$$) —       размеры Театральной площади, цена плитки $$$1 \times 1$$$ и цена       плитки $$$1 \times 2$$$.</p>     <p>В каждой из следующих $$$n$$$ строк записаны по $$$m$$$ символов.       $$$j$$$-й символ в $$$i$$$-й строке — это $$$a_{i,j}$$$. Если       $$$a_{i,j} = $$$ «<span class="tex-font-style-tt">*</span>», то       $$$j$$$-я ячейка в $$$i$$$-м ряду должна быть <span class="tex-font-style-bf">черной</span>, а если $$$a_{i,j} = $$$         «<span class="tex-font-style-tt">.</span>», то $$$j$$$-я ячейка       в $$$i$$$-м ряду должна быть <span class="tex-font-style-bf">белой</span>.</p>     <p>       <span class="tex-font-style-bf">Гарантируется, что сумма $$$n         \times m$$$ по всем наборам входных данных не превышает $$$10^5$$$</span>.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите одно целое число —       наименьшая суммарная цена плиток, которые могут покрыть все белые       клетки, в бурлях.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
1 1 10 1
.
1 2 10 1
..
2 1 10 1
.
.
3 3 3 7
..*
*..
.*.
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
10
1
20
18
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных необходимо использовать одну       плитку $$$1 \times 1$$$, несмотря на то, что плитка $$$1 \times       2$$$ дешевле. Поэтому суммарная цена равна $$$10$$$ бурлей.</p>     <p>Во втором наборе можно использовать либо две плитки $$$1 \times       1$$$ и потратить $$$20$$$ бурлей, либо одну плитку $$$1 \times       2$$$ плитку и потратить $$$1$$$ бурль. Второй вариант дешевле,       поэтому ответ равен $$$1$$$.</p>     <p>Третий набор показывает, что нельзя поворачивать плитки $$$1       \times 2$$$. Приходится использовать две плитки $$$1 \times 1$$$ с       суммарной ценой $$$20$$$.</p>     <p>В четвертом наборе самый дешевый способ — это использовать $$$1       \times 1$$$ плитки повсюду. Итоговая цена — $$$6 \cdot 3 = 18$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1359/problem/B' title='Educational Codeforces Round 88 (Rated for Div. 2)'>1359B - New Theatre Square</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Notice that rows can be solved completely separately of each       other. Each tile takes either one or two squares but it's always       in the same row.</p>     <p>So let's take a look at a single row. There are sequences of dot       characters separated by some asterisks. Once again each of these       sequences can be solved independently of the others.</p>     <p>Thus, we have these empty strips of empty squares $$$1 \times       k$$$ which, when solved, can be summed up into the whole answer.</p>     <p>There are two cases, depending on if a $$$1 \times 2$$$ is       cheaper than two $$$1 \times 1$$$ tiles. </p>     <p>If it is then we want to use of many $$$1 \times 2$$$ tiles as       possible. So given $$$k$$$, we can place $$$\lfloor \frac k 2       \rfloor$$$ $$$1 \times 2$$$ tiles and cover the rest $$$k - 2       \cdot \lfloor \frac k 2 \rfloor = k~mod~2$$$ squares with $$$1       \times 1$$$ tiles.</p>     <p>If it isn't cheaper then we want to cover everything with $$$1       \times 1$$$ tiles and never use $$$1 \times 2$$$ ones. So all       $$$k$$$ should be $$$1 \times 1$$$.</p>     <p>The easier way to implement this might be the following. Let's       update the price of the $$$1 \times 2$$$ tile with the minimum of       $$$y$$$ and $$$2 \cdot x$$$. This way the first algorithm will       produce exactly the same result of the second one in the case when       a $$$1 \times 2$$$ tile isn't cheaper than two $$$1 \times 1$$$ ones.</p>     <p>Overall complexity: $$$O(nm)$$$ per testcase.</p></div></div></div>

           
            <pre><code>t = int(input())
for _ in range(t):
	n, m, x, y = map(int, input().split())
	ans = 0
	y = min(y, 2 * x)
	for __ in range(n):
		s = input()
		i = 0
		while i &lt; m:
			if s[i] == &#39;*&#39;:
				i += 1
				continue
			j = i
			while j + 1 &lt; m and s[j + 1] == &#39;.&#39;:
				j += 1
			l = j - i + 1
			ans += l % 2 * x + l // 2 * y
			i = j + 1
	print(ans)
</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;

#define forn(i, n) for (int i = 0; i &lt; int(n); i++)

using namespace std;


int main() {
	int tc;
	scanf(&#34;%d&#34;, &amp;tc);
	forn(_, tc){
		int h, c, t;
		scanf(&#34;%d%d%d&#34;, &amp;h, &amp;c, &amp;t);
		if (h + c - 2 * t &gt;= 0)
			puts(&#34;2&#34;);
		else{
			int a = h - t;
			int b = 2 * t - c - h;
			int k = 2 * (a / b) + 1;
			long long val1 = abs(k / 2 * 1ll * c + (k + 1) / 2 * 1ll * h - t * 1ll * k);
			long long val2 = abs((k + 2) / 2 * 1ll * c + (k + 3) / 2 * 1ll * h - t * 1ll * (k + 2));
			printf(&#34;%d\n&#34;, val1 * (k + 2) &lt;= val2 * k ? k : k + 2);
		}
	}
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 88 (рейтинговый для Див. 2)
    1359C
    Смешиваем воду </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Смешиваем воду</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Есть два бесконечных источника воды:</p>          <ul> <li> горячая вода температуры $$$h$$$; </li>       <li> холодная вода температуры $$$c$$$ ($$$c &lt; h$$$). </li></ul>          <p>Вы совершаете следующую чередующуюся последовательность действий:</p>          <ol> <li> набрать <span class="tex-font-style-bf">одну</span> кружку           <span class="tex-font-style-bf">горячей</span> воды и вылить         ее в бесконечно глубокую бочку; </li>       <li> набрать <span class="tex-font-style-bf">одну</span> кружку           <span class="tex-font-style-bf">холодной</span> воды и вылить         ее в бесконечно глубокую бочку; </li>       <li> набрать <span class="tex-font-style-bf">одну</span> кружку           <span class="tex-font-style-bf">горячей</span> воды         $$$\dots$$$ </li>       <li> и так далее $$$\dots$$$ </li></ol>          <p>       <span class="tex-font-style-bf">Обратите внимание, что вы всегда         начинаете с кружки горячей воды</span>.</p>     <p>Бочка изначально пустая. Необходимо налить <span class="tex-font-style-bf">хотя бы одну кружку</span> в бочку.       Температура воды в бочке равна средней температуре вылитых кружек.</p>     <p>Вы хотите получить воду температуры как можно ближе к $$$t$$$. То       есть если температура воды в бочке равна $$$t_b$$$, то <span class="tex-font-style-bf">абсолютная разность</span> $$$t_b$$$ и       $$$t$$$ ($$$|t_b - t|$$$) должна быть минимально возможна.</p>     <p>Сколько кружек необходимо налить в бочку, чтобы температура стала       как можно ближе к $$$t$$$? Если существует несколько ответов с       минимальной абсолютной разностью, то выведите наименьший из них.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$T$$$ ($$$1 \le T \le       3 \cdot 10^4$$$) — количество наборов входных данных.</p>     <p>В каждой из следующих $$$T$$$ строк записаны по три целых числа       $$$h$$$, $$$c$$$ и $$$t$$$ ($$$1 \le c &lt; h \le 10^6$$$; $$$c       \le t \le h$$$) — температура горячей воды, температура холодной       воды и желаемая температура в бочке.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>На каждый набор входных данных выведите одно положительное целое       число — минимальной количество кружек, которое необходимо вылить в       бочку, чтобы получить температуру, как можно более близкую к $$$t$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
30 10 20
41 15 30
18 13 18
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
7
1
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных температура после $$$2$$$ налитых       кружек: $$$1$$$ горячей и $$$1$$$ холодной — равна $$$20$$$. И это       самое близкое возможное значение.</p>     <p>Во втором наборе температура после $$$7$$$ налитых кружек:       $$$4$$$ горячих и $$$3$$$ холодных — примерно $$$29.857$$$. Если       наливать больше воды, то температура не станет ближе к $$$t$$$.</p>     <p>В третьем наборе температура после $$$1$$$ налитой кружки:       $$$1$$$ горячей — равна $$$18$$$. Это совпадает с $$$t$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1359/problem/C' title='Educational Codeforces Round 88 (Rated for Div. 2)'>1359C - Mixing Water</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>So there are two kinds of stops to consider: $$$k$$$ hot and       $$$k$$$ cold cup and $$$(k + 1)$$$ hot and $$$k$$$ cold cups.</p>     <p>The first case is trivial: the temperature is always $$$\frac{h +       c}{2}$$$. In the second case the temperature is always strictly       greater than $$$\frac{h + c}{2}$$$. Thus, if $$$t \le \frac{h +       c}{2}$$$, then the answer is $$$2$$$.</p>     <p>Let's show that otherwise the answer is always achieved through       the second case.</p>     <p>The temperature after $$$(k + 1)$$$ hot cups and $$$k$$$ cold       cups is $$$t_k = \frac{(k + 1) \cdot h + k \cdot c}{2k + 1}$$$.       The claim is that $$$t_0 &gt; t_1 &gt; \dots$$$. Let's prove that       by induction.</p>     <p>$$$t_0 = h, t_1 = \frac{2 \cdot h + c}{3}$$$. $$$c &lt; h$$$,       thus $$$t_0 &gt; t_1$$$.</p>     <p>Now compare $$$t_k$$$ and $$$t_{k+1}$$$.</p>     <p>$$$$$$t_k &gt; t_{k+1}$$$$$$</p>     <p>$$$$$$\frac{(k + 1) \cdot h + k \cdot c}{2k + 1} &gt; \frac{(k +       2) \cdot h + (k + 1) \cdot c}{2k + 3}$$$$$$</p>     <p>$$$$$$\frac{k \cdot (h + c) + h}{2k + 1} &gt; \frac{(k + 1) \cdot       (h + c) + h}{2k + 3}$$$$$$</p>     <p>$$$$$$2k \cdot (k \cdot (h + c) + h) + 3k \cdot (h + c) + 3h &gt;       2k \cdot ((k + 1) \cdot (h + c) + h) + (k + 1) \cdot (h + c) + h$$$$$$</p>     <p>$$$$$$2k \cdot (k \cdot (h + c) + h - (k + 1) \cdot (h + c) - h)       &gt; (k + 1) \cdot (h + c) + h - 3k \cdot (h + c) - 3h$$$$$$</p>     <p>$$$$$$2k \cdot (-(h + c)) &gt; (-2k + 1) \cdot (h + c) - 2h$$$$$$</p>     <p>$$$$$$2h &gt; (h + c)$$$$$$</p>     <p>$$$$$$h &gt; c$$$$$$</p>     <p>We can also show that this series converges to $$$\frac{h + c}{2}$$$:</p>     <p>I'm sorry that I'm not proficient with any calculus but my       intuition says that it's enough to show that $$$\forall k~t_k &gt;       \frac{h + c}{2}$$$ and $$$\forall \varepsilon \exists k~t_k &lt;       \frac{h + c}{2}$$$ with $$$k \ge 0$$$.</p>     <p>So the first part is:</p>     <p>$$$$$$\frac{(k + 1) \cdot h + k \cdot c}{2k + 1} &gt; \frac{h + c}{2}$$$$$$</p>     <p>$$$$$$\frac{k \cdot (h + c) + h}{2k + 1} &gt; \frac{h + c}{2}$$$$$$</p>     <p>$$$$$$2k \cdot (h + c) + 2h &gt; (2k + 1) \cdot (h + c)$$$$$$</p>     <p>$$$$$$2h &gt; h + c$$$$$$</p>     <p>$$$$$$h &gt; c$$$$$$</p>     <p>And the second part is:</p>     <p>$$$$$$\frac{(k + 1) \cdot h + k \cdot c}{2k + 1} &lt; \frac{h +       c}{2} + \varepsilon$$$$$$</p>     <p>$$$$$$\frac{k \cdot (h + c) + h}{2k + 1} &lt; \frac{h + c}{2} + \varepsilon$$$$$$</p>     <p>$$$$$$2k \cdot (h + c) + 2h &lt; (2k + 1) \cdot (h + c) + (2k +       1) \cdot \varepsilon$$$$$$</p>     <p>$$$$$$2h &lt; (h + c) + (2k + 1) \cdot \varepsilon$$$$$$</p>     <p>$$$$$$h &lt; c + (2k + 1) \cdot \varepsilon$$$$$$</p>     <p>$$$$$$\frac{h - c}{\varepsilon} &lt; 2k + 1$$$$$$</p>     <p>So that claim makes us see that for any $$$t$$$ greater than       $$$\frac{h + c}{2}$$$ the answer is always achieved from the       second case.</p>     <p>That allows us to find such $$$k$$$, that the value of $$$t_k$$$       is exactly $$$t$$$. However, such $$$k$$$ might not be integer.       $$$\frac{(k + 1) \cdot h + c}{2k + 1} = t \leftrightarrow$$$       $$$\frac{k \cdot (h + c) + h}{2k + 1} = t \leftrightarrow$$$ $$$k       \cdot (h + c) + h = 2kt + t \leftrightarrow$$$ $$$k \cdot (h + c -       2t) = t - h \leftrightarrow$$$ $$$k = \frac{t - h}{h + c - 2t}$$$.</p>     <p>The only thing left is to compare which side is better to round       $$$k$$$ to. It seems some implementations with float numbers might       fail due to precision errors. However, it's possible to do these       calculations completely in integers.</p>     <p>Let's actually rewrite that so that the denominator is always       positive $$$k = \frac{h - t}{2t - h - c}$$$. Now we can round this       value down and compare $$$k$$$ and $$$k + 1$$$.</p>     <p>So the optimal value is $$$k$$$ if $$$|\frac{k \cdot (h + c) +       h}{2k + 1} - t| \le |\frac{(k + 1) \cdot (h + c) + h}{2k + 3}| -       t$$$. So $$$|(k \cdot (h + c) + h) - t \cdot (2k + 1)| \cdot (2k +       3) \le |((k + 1) \cdot (h + c) + h) - t \cdot (2k + 3)| \cdot (2k       + 1)$$$. Otherwise, the answer is $$$k + 1$$$.</p>     <p>You can also find the optimal $$$k$$$ with binary search but the       formulas are exactly the same and you have to rely on monotonosity       as well. Also, these formulas can get you the better understanding       for the upper bound of the answer.</p>     <p>Overall complexity: $$$O(1)$$$ or $$$O(\log h)$$$ per testcase.</p></div></div></div>

        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #647 (Div. 2) - Thanks, Algo Muse!
    1362A
    Джонни и древний компьютер </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Джонни и древний компьютер</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Недавно Джонни обнаружил древний сломанный компьютер. У него есть       только один регистр, в который можно записать некоторое значение.       После чего, за одну операцию вы можете применить к значению       битовый сдвиг влево или вправо на не более чем три позиции. Сдвиг       вправо запрещен, если в результате <span class="tex-font-style-bf">будут потеряны единичные биты</span>.       Так что, на самом деле, за одну операцию вы можете умножить или       разделить значение на $$$2$$$, $$$4$$$ или $$$8$$$, и деление       разрешено только если значение делится нацело на выбранный делитель.</p>     <p>Формально, если регистр содержит целое положительное число       $$$x$$$, за одну операцию оно может быть заменено одним из       следующих: </p>     <ul> <li> $$$x \cdot 2$$$ </li>       <li> $$$x \cdot 4$$$ </li>       <li> $$$x \cdot 8$$$ </li>       <li> $$$x / 2$$$, если $$$x$$$ делится на $$$2$$$ </li>       <li> $$$x / 4$$$, если $$$x$$$ делится на $$$4$$$ </li>       <li> $$$x / 8$$$, если $$$x$$$ делится на $$$8$$$ </li></ul>          <p>Например, если $$$x = 6$$$, за одну операцию оно может быть       заменено на $$$12$$$, $$$24$$$, $$$48$$$ или $$$3$$$. Значение       $$$6$$$ не делится на $$$4$$$ или $$$8$$$, поэтому существуют       только четыре варианта замены.</p>     <p>Теперь Джонни интересуется, какое минимальное количество операций       необходимо, если он запишет в регистр значение $$$a$$$ и в конце       хочет получить там значение $$$b$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Входные данные состоят из нескольких наборов входных данных.       Первая строка содержит целое число $$$t$$$ ($$$1 \leq t \leq       1000$$$) — количество наборов входных данных. Следующие $$$t$$$       строк содержат описание наборов входных данных.</p>     <p>Первая и единственная строка каждого набора входных данных       содержит целые числа $$$a$$$ и $$$b$$$ ($$$1 \leq a, b \leq       10^{18}$$$) — исходное значение и желаемое итоговое значение, соответственно.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$t$$$ строк, каждая строка должна содержать одно целое       число, обозначающее минимальное количество операций, которое       Джонни должен выполнить. Если Джонни не сможет получить значение       $$$b$$$ в конце, выведите $$$-1$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
10
10 5
11 44
17 21
1 1
96 3
2 128
1001 1100611139403776
1000000000000000000 1000000000000000000
7 1
10 8
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
1
-1
0
2
2
14
0
-1
-1
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных, Джонни может получить $$$5$$$ из       $$$10$$$ сделав один сдвиг вправо на один (т.е. поделив на $$$2$$$).</p>     <p>Во втором наборе входных данных, Джонни может получить $$$44$$$       из $$$11$$$ сделав один сдвиг влево на два (т.е. умножив на $$$4$$$).</p>     <p>В третьем наборе входных данных, Джонни не может получить       значение $$$21$$$ из значения $$$17$$$.</p>     <p>В четвертом наборе входных данных, исходное и желаемое значения       совпадают, поэтому Джонни придется сделать $$$0$$$ операций.</p>     <p>В пятом наборе входных данных, Джонни может получить $$$3$$$ из       $$$96$$$ сделав два сдвига вправо: один на $$$2$$$, и другой на       $$$3$$$ (т.е. поделив на $$$4$$$ и $$$8$$$).</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1362/problem/A' title='Codeforces Round 647 (Div. 2) - Thanks, Algo Muse!'>1362A - Johnny and Ancient Computer</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let us write $$$a$$$ as $$$r_a \cdot 2^x$$$ and $$$b$$$ as $$$r_b       \cdot 2^y$$$, where $$$r_a$$$ and $$$r_b$$$ are odd. The only       operation we have changes $$$x$$$ by $$$\{-3, -2, -1, 1, 2, 3\}$$$       so $$$r_a$$$ must be equal to $$$r_b$$$, otherwise the answer is       $$$-1$$$. It is easy to notice that we can greedily move $$$x$$$       toward $$$y$$$ so the answer is equal to $$$\lceil \frac{|x -       y|}{3} \rceil$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long LL;

LL getR(LL a){
	while(a % 2 == 0)
		a /= 2;
	return a;
}

void solve(){
	LL a, b;
	scanf(&#34;%lld %lld&#34;, &amp;a, &amp;b);
	if(a &gt; b)	swap(a, b);
	
	LL r = getR(a);
	if(getR(b) != r){
		puts(&#34;-1&#34;);
		return;
	}
	
	int ans = 0;
	b /= a;
	
	while(b &gt;= 8)
		b /= 8, ++ans;
	if(b &gt; 1)	++ans;
	printf(&#34;%d\n&#34;, ans);
}

int main(){
	int quest;
	scanf(&#34;%d&#34;, &amp;quest);
	
	while(quest--)
		solve();
	return 0;
}

</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long LL;

LL getR(LL a){
	while(a % 2 == 0)
		a /= 2;
	return a;
}

void solve(){
	LL a, b;
	scanf(&#34;%lld %lld&#34;, &amp;a, &amp;b);
	if(a &gt; b)	swap(a, b);
	
	LL r = getR(a);
	if(getR(b) != r){
		puts(&#34;-1&#34;);
		return;
	}
	
	int ans = 0;
	b /= a;
	
	while(b &gt;= 8)
		b /= 8, ++ans;
	if(b &gt; 1)	++ans;
	printf(&#34;%d\n&#34;, ans);
}

int main(){
	int quest;
	scanf(&#34;%d&#34;, &amp;quest);
	
	while(quest--)
		solve();
	return 0;
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #647 (Div. 2) - Thanks, Algo Muse!
    1362B
    Джонни и его хобби </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Джонни и его хобби</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Среди многочисленных хобби Джонни, есть два, казалось бы,       безвредных: применение побитовых операций и прокрадывание в офис       его отца. Как это обычно и бывает у маленьких детей, Джонни не       подозревает, что комбинирование этих двух занятий может доставить       ему много неприятностей.</p>     <p>На столе его отца хранится множество $$$S$$$, содержащее очень       важные числа. В момент, когда Джонни узнал об этом, он решил, что       это хорошая идея выбрать <span class="tex-font-style-bf">положительное</span> целое число $$$k$$$       и заменить все элементы $$$s$$$ из множества $$$S$$$ на $$$s       \oplus k$$$ ($$$\oplus$$$ обозначает операцию <a href="https://en.wikipedia.org/wiki/Exclusive_or#Computer_science">исключающего или</a>).</p>     <p>Помогите Джонни выбрать такое $$$k$$$, что его отец не заметит       никакой разницы после того, как Джонни закончит играть (т.е.       Джонни должен получить такое же множество, какое было изначально).       Возможно, что ни одного такого числа не существует. Также,       возможно, что существует несколько подходящих чисел. В таком       случае, выведите минимальное из них. Обратите внимание, что       порядок элементов в множестве не имеет значения, т.е. множество       $$$\{1, 2, 3\}$$$ равно множеству $$$\{2, 1, 3\}$$$.</p>     <p>Формально, требуется найти минимальное положительное целое число       $$$k$$$, такое что $$$\{s \oplus k | s \in S\} = S$$$ или       сообщить, что ни одного подходящего числа не существует.</p>     <p>Например, если $$$S = \{1, 3, 4\}$$$ и $$$k = 2$$$, новое       множество будет равно $$$\{3, 1, 6\}$$$. Если $$$S = \{0, 1, 2,       3\}$$$ и $$$k = 1$$$, после игры множество останется таким же.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке дано одно целое число $$$t$$$ ($$$1 \leq t \leq       1024$$$) — количество наборов входных данных. В следующих строках       даны $$$t$$$ наборов входных данных, каждый из них занимает две строки.</p>     <p>В первой строке набора входных данных дано одно целое число       $$$n$$$ ($$$1 \leq n \leq 1024$$$), обозначающее количество       элементов в множестве $$$S$$$. Вторая строка содержит $$$n$$$         <span class="tex-font-style-bf">различных</span> целых чисел       $$$s_i$$$ ($$$0 \leq s_i &lt; 1024$$$) — элементы $$$S$$$.</p>     <p>Гарантируется, что сумма $$$n$$$ по всем наборам входных данных       не превышает $$$1024$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$t$$$ строк, $$$i$$$-я из них должна содержать ответ       на $$$i$$$-й набор входных данных — минимальное положительное       целое число $$$k$$$, удовлетворяющее условиям, или $$$-1$$$, если       ни одного подходящего $$$k$$$ не существует.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
4
1 0 2 3
6
10 7 14 8 3 12
2
0 2
3
1 2 3
6
1 4 6 10 11 12
2
0 1023
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
4
2
-1
-1
1023
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных, ответ $$$1$$$, потому что это       минимальное положительное целое число и оно удовлетворяет всем условиям.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1362/problem/B' title='Codeforces Round 647 (Div. 2) - Thanks, Algo Muse!'>1362B - Johnny and His Hobbies</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Consider $$$i$$$-th least significant bit ($$$0$$$ indexed). If       it is set in $$$k$$$, but not in $$$s$$$, it will be set in $$$k       \oplus s$$$. Hence $$$k \oplus s \geq 2^i$$$.</p>     <p>Consider such minimal positive integer $$$m$$$, that $$$2^m &gt;       s$$$ holds for all $$$s \in S$$$. $$$k$$$ cannot have the       $$$i$$$-th bit set for any $$$i \geq m$$$. From this follows that       $$$k &lt; 2^m$$$. So there are only $$$2^m$$$ feasible choices of       $$$k$$$. We can verify if a number satisfies the condition from       the statement in $$$ \mathcal{O} \left(n \right) $$$ operations.       This gives us a solution with complexity $$$\mathcal{O} \left(n       \cdot 2^m \right)$$$. Note that in all tests $$$m$$$ is at most $$$10$$$.</p>     <p>There is also another solution possible. It uses the observation       that if $$$k$$$ satisfies the required conditions, then for every       $$$s \in S$$$ there exists such $$$t \in S$$$ ($$$t \neq s$$$) ,       that $$$t \oplus s = k$$$. This gives us $$$n-1$$$ feasible       choices of $$$k$$$ and thus the complexity of this solution is       $$$\mathcal{O} \left( n^2 \right)$$$.</p></div></div></div>

           
            <pre><code>//O(n * maxA) solution

#include &lt;bits/stdc++.h&gt;

using namespace std;

const int N = 1025;

int n;
int in[N];
bool is[N];

bool check(int k){
	for(int i = 1; i &lt;= n; ++i)
		if(!is[in[i] ^ k])
			return false;
	return true;
}

void solve(){
	for(int i = 0; i &lt; N; ++i)
		is[i] = false;
	
	scanf(&#34;%d&#34;, &amp;n);
	for(int i = 1; i &lt;= n; ++i){
		scanf(&#34;%d&#34;, &amp;in[i]);
		is[in[i]] = true;
	}
	
	for(int k = 1; k &lt; 1024; ++k)
		if(check(k)){
			printf(&#34;%d\n&#34;, k);
			return;
		}
	
	puts(&#34;-1&#34;);
}

int main(){
	int cases;
	scanf(&#34;%d&#34;, &amp;cases);
	
	while(cases--)
		solve();
	return 0;
}

</code></pre>
           
            <pre><code>//O(n * maxA) solution

#include &lt;bits/stdc++.h&gt;

using namespace std;

const int N = 1025;

int n;
int in[N];
bool is[N];

bool check(int k){
	for(int i = 1; i &lt;= n; ++i)
		if(!is[in[i] ^ k])
			return false;
	return true;
}

void solve(){
	for(int i = 0; i &lt; N; ++i)
		is[i] = false;
	
	scanf(&#34;%d&#34;, &amp;n);
	for(int i = 1; i &lt;= n; ++i){
		scanf(&#34;%d&#34;, &amp;in[i]);
		is[in[i]] = true;
	}
	
	for(int k = 1; k &lt; 1024; ++k)
		if(check(k)){
			printf(&#34;%d\n&#34;, k);
			return;
		}
	
	puts(&#34;-1&#34;);
}

int main(){
	int cases;
	scanf(&#34;%d&#34;, &amp;cases);
	
	while(cases--)
		solve();
	return 0;
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #647 (Div. 2) - Thanks, Algo Muse!
    1362C
    Джонни и ещё одно падение рейтинга </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Джонни и ещё одно падение рейтинга</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Последний контест, проведённый на любимой Джонни платформе по       спортивному программированию, был встречен довольно позитивно.       Однако, рейтинг Джонни снова упал! Он думает, что хотя задачи были       неплохие, они не показывают истинный уровень участников.</p>     <p>Теперь мальчик смотрит на рейтинги соседних участников,       записанные в двоичной системе счисления. Он считает, что чем       больше эти рейтинги различаются, тем более нечестно, что эти       участники расположены на соседних позициях. Он определяет различие       между двумя числами как количество позиций битов, на которых одно       из чисел содержит ноль, а другое — единицу (мы считаем, что числа       дополнены ведущими нулями до одинаковой длины). Например, различие       между числами $$$5 = 101_2$$$ и $$$14 = 1110_2$$$ равно $$$3$$$,       так как $$$0101$$$ и $$$1110$$$ отличаются в $$$3$$$ позициях.       Джонни определяет нечестность контеста как сумму таких различий       для всех пар соседних участников.</p>     <p>Джонни только что прислал вам последовательность рейтингов и       хочет, чтобы вы вычислили нечестность контеста. Вы заметили, что       вы получили последовательные целые числа от $$$0$$$ до $$$n$$$.       Это странно, но мальчик упорно твердит, что все правильно.       Поэтому, помогите ему и вычислите желаемую нечестность для       полученной последовательности чисел.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Входные данные состоят из нескольких наборов входных данных.       Первая строка содержит одно целое число $$$t$$$ ($$$1 \leq t \leq       10\,000$$$) — количество наборов входных данных. Следующие $$$t$$$       строк содержат описание наборов входных данных.</p>     <p>Первая и единственная строка каждого набора входных данных       содержит одно целое число $$$n$$$ ($$$1 \leq n \leq 10^{18})$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$t$$$ строк. Для каждого набора входных данных, вы       должны вывести одну строку, содержащую одно целое число —       нечестность контеста, если последовательность рейтингов равна       $$$0$$$, $$$1$$$, ..., $$$n - 1$$$, $$$n$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
5
7
11
1
2000000000000
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
8
11
19
1
3999999999987
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Для $$$n = 5$$$, мы вычисляем нечестность следующей       последовательности (числа от $$$0$$$ до $$$5$$$, записанные в       двоичной системе счисления и дополненные ведущими нулями до       одинаковой длины): </p>     <ul> <li> $$$000$$$ </li>       <li> $$$001$$$ </li>       <li> $$$010$$$ </li>       <li> $$$011$$$ </li>       <li> $$$100$$$ </li>       <li> $$$101$$$ </li></ul>          <p>Различия равны $$$1$$$, $$$2$$$, $$$1$$$, $$$3$$$, $$$1$$$,       соответственно. Поэтому, нечестность равна $$$1 + 2 + 1 + 3 + 1 = 8$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1362/problem/C' title='Codeforces Round 647 (Div. 2) - Thanks, Algo Muse!'>1362C - Johnny and Another Rating Drop</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let us start by calculating the result for $$$n = 2^k$$$. It can       be quickly done by calculating the results for each bit separately       and summing these up. For $$$i$$$-th bit, the result is equal to       $$$\frac{2^k}{2^{i}}$$$ as this bit is different in $$$d-1$$$ and       $$$d$$$ iff $$$d$$$ is a multiple of $$$2^i$$$. Summing these up       we get that the result for $$$n = 2^k$$$ is equal to $$$2^{k + 1}       - 1 = 2n - 1$$$.</p>     <p>How to compute the answer for arbitrary $$$n$$$? Let us denote       $$$b_1 &gt; b_2 &gt; \ldots &gt; b_k$$$ as set bits in the binary       representation of $$$n$$$. I claim that the answer is equal to the       sum of answers for $$$2^{b_1}, 2^{b_2}, \ldots, 2^{b_k}$$$. Why?</p>     <p>We can compute results for intervals $$$[0, 2^{b_1}], [2^{b_1},       2^{b_1} + 2^{b_2}], \ldots, [n - 2^{b_k}, n]$$$. We can notice       that the result for interval $$$[s, s + 2^i]$$$, where $$$s$$$ is       a multiple of $$$2^i$$$, is equal to the answer for $$$[0, 2^i]$$$       so we can just compute the results for intervals $$$[0, 2^{b_1}],       [0, 2^{b_2}], \ldots, [0, 2^{b_k}]$$$!</p>     <p>This allows us to compute the answer for arbitrary $$$n$$$ in       $$$\mathcal{O}(\log n)$$$ – just iterate over all bits $$$b$$$ and       add $$$2^{b + 1} - 1$$$ if $$$b$$$ is set. Equivalently we can       just write down $$$2n - \texttt{#bits set}$$$ as the answer.</p>     <p>Final complexity is $$$\mathcal{O}(t \log n)$$$.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long LL;

void solve(){
	LL a;
	scanf(&#34;%lld&#34;, &amp;a);
	
	LL ans = 0;
	for(int i = 0; i &lt; 60; ++i)
		if(a &amp; (1LL &lt;&lt; i))
			ans += (1LL &lt;&lt; (i + 1)) - 1;
	printf(&#34;%lld\n&#34;, ans);
}

int main(){
	int quest;
	scanf(&#34;%d&#34;, &amp;quest);
	
	while(quest--)
		solve();
	return 0;
}

</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

typedef long long LL;

void solve(){
	LL a;
	scanf(&#34;%lld&#34;, &amp;a);
	
	LL ans = 0;
	for(int i = 0; i &lt; 60; ++i)
		if(a &amp; (1LL &lt;&lt; i))
			ans += (1LL &lt;&lt; (i + 1)) - 1;
	printf(&#34;%lld\n&#34;, ans);
}

int main(){
	int quest;
	scanf(&#34;%d&#34;, &amp;quest);
	
	while(quest--)
		solve();
	return 0;
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #646 (Div. 2)
    1363A
    Выбор нечетных </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Выбор нечетных</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У Shubham есть массив $$$a$$$ размера $$$n$$$, и он хочет выбрать       из него ровно $$$x$$$ элементов так, чтобы их сумма была нечетной.       Эти элементы не обязаны быть последовательными. Элементы массива       не обязательно различны.</p>     <p>Скажите ему, может ли он сделать это.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке входных данных содержится одно целое число       $$$t$$$ $$$(1\le t \le 100)$$$ — количество наборов входных       данных. Далее следуют описания наборов входных данных.</p>     <p>Первая строка каждого набора входных данных содержит два целых       числа $$$n$$$ и $$$x$$$ $$$(1 \le x \le n \le 1000)$$$ — длину       массива и количество элементов, которые нужно выбрать соответственно.</p>     <p>Следующая строка каждого набора входных данных содержит $$$n$$$       целых чисел $$$a_1, a_2, \dots, a_n$$$ $$$(1 \le a_i \le       1000)$$$ — элементы массива.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите «<span class="tex-font-style-tt">Yes</span>» или «<span class="tex-font-style-tt">No</span>» в зависимости от того, можно       ли выбрать ровно $$$x$$$ элементов, чтобы их сумма была нечетной.</p>     <p>Вы можете выводить буквы в любом регистре.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
1 1
999
1 1
1000
2 1
51 50
2 2
51 50
3 3
101 102 103
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
Yes
No
Yes
Yes
No
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В $$$1$$$-м наборе входных данных: мы должны выбрать элемент       $$$999$$$, и сумма будет нечетной.</p>     <p>В $$$2$$$-м наборе входных данных: мы должны выбрать элемент       $$$1000$$$, поэтому сумма не будет нечетной.</p>     <p>В $$$3$$$-м наборе входных данных: мы можем выбрать элемент $$$51$$$.</p>     <p>В $$$4$$$-м наборе входных данных: мы должны выбрать оба элемента       $$$50$$$ и $$$51$$$ — так что общая сумма нечетна.</p>     <p>В $$$5$$$-м наборе входных данных: мы должны выбрать все       элементы — но общая сумма не является нечетной.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1363/problem/A' title='Codeforces Round 646 (Div. 2)'>1363A - Odd Selection</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>       <span class="tex-font-style-bf">Key Idea</span>: The sum of       $$$x$$$ numbers can only be odd if we have an odd number of       numbers which are odd. (An odd statement, indeed).</p>     <p>       <span class="tex-font-style-bf">Detailed Explanation</span>: We       first maintain two variables, <span class="tex-font-style-tt">num_odd</span> and <span class="tex-font-style-tt">num_even</span>, representing the number       of odd and even numbers in the array, respectively. We then       iterate over the number of odd numbers we can choose; which are       $$$1,3,5,...$$$ upto <span class="tex-font-style-tt">min(num_odd,x)</span>, and see if <span class="tex-font-style-tt">num_even</span> $$$\geq x - i$$$ where       $$$i$$$ is the number of odd numbers we have chosen. </p>     <p>       <span class="tex-font-style-bf">Time complexity</span>: $$$O(N)$$$</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define endl &#34;\n&#34;
#define int long long
 
const int N = 2e5 + 5;
 
int n, x;
int a[N], f[2];
 
int32_t main()
{
	IOS;
	int t;
	cin &gt;&gt; t;
	while(t--)
	{
	    f[0] = f[1] = 0;
    	cin &gt;&gt; n &gt;&gt; x;
    	for(int i = 1; i &lt;= n; i++)
    	{
    		cin &gt;&gt; a[i];
    		f[a[i] % 2]++;
    	}
    	bool flag = 0;
    	for(int i = 1; i &lt;= f[1] &amp;&amp; i &lt;= x; i += 2) //Fix no of odd
    	{
    		int have = f[0], need = x - i;
    		if(need &lt;= f[0])
    	        flag = 1;
    	}
    	if(flag)
    	    cout &lt;&lt; &#34;Yes&#34; &lt;&lt; endl;
    	else
    	    cout &lt;&lt; &#34;No&#34; &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #646 (Div. 2)
    1363B
    Ненависть к подпоследовальностям </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Ненависть к подпоследовальностям</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У Shubham есть бинарная строка $$$s$$$. Бинарная строка  — это       строка, содержащая только символы «<span class="tex-font-style-tt">0</span>» и «<span class="tex-font-style-tt">1</span>».</p>     <p>Он может выполнить следующую операцию над строкой любое       количество раз: </p>     <ul> <li> Выбрать индекс строки, и поменять символ с этим индексом.         Это означает, что если символ был «<span class="tex-font-style-tt">0</span>», он становится «<span class="tex-font-style-tt">1</span>», и наоборот. </li></ul>          <p>Строка называется хорошей, если она не содержит строк «<span class="tex-font-style-tt">010</span>» или «<span class="tex-font-style-tt">101</span>» в качестве       подпоследовательностей  — например, «<span class="tex-font-style-tt">1001</span>» содержит «<span class="tex-font-style-tt">101</span>» как подпоследовательность,       следовательно, это не хорошая строка, а «<span class="tex-font-style-tt">1000</span>» не содержит ни «<span class="tex-font-style-tt">010</span>» ни «<span class="tex-font-style-tt">101</span>» как подпоследовательностей,       поэтому это хорошая строка.</p>     <p>Какое минимальное количество операций ему придется выполнить,       чтобы строка стала хорошей? Можно показать, что с помощью данных       операций можно сделать любую строку хорошей.</p>     <p>Строка $$$a$$$ является подпоследовательностью строки $$$b$$$,       если $$$a$$$ может быть получена из $$$b$$$ удалением нескольких       (возможно, ни одного или всех) символов.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке входных данных содержится одно целое число       $$$t$$$ $$$(1\le t \le 100)$$$ — количество наборов входных данных.</p>     <p>Каждая из следующих $$$t$$$ строк содержит бинарную строку       $$$s$$$ $$$(1 \le |s| \le 1000)$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждой строки выведите минимальное количество операций       необходимых для того, чтобы сделать ее хорошей.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
7
001
100
101
010
0
1
001100
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
0
1
1
0
0
2
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В наборах входных данных $$$1$$$, $$$2$$$, $$$5$$$, $$$6$$$       строки уже являются хорошими  — поэтому никаких операций не требуется.</p>     <p>Для набора $$$3$$$: «<span class="tex-font-style-tt">001</span>»       можно получить, поменяв первый символ, и это один из возможных       способов получить хорошую строку.</p>     <p>Для набора $$$4$$$: «<span class="tex-font-style-tt">000</span>»       можно получить, поменяв второй символ, и это один из возможных       способов получить хорошую строку.</p>     <p>Для набора $$$7$$$: «<span class="tex-font-style-tt">000000</span>» можно получить, поменяв       третий и четвертый символы, и это один из возможных способов       получить хорошую строку.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1363/problem/B' title='Codeforces Round 646 (Div. 2)'>1363B - Subsequence Hate</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>       <span class="tex-font-style-bf">Key Idea</span>: There are two       types of good strings: Those which start with a series of       $$$1$$$'s followed by $$$0$$$'s (such as $$$1111100$$$) and those       which start with a series of $$$0$$$'s followed by $$$1$$$'s (such       as $$$00111$$$). Note that there are strings which do belong to       both categories (such as $$$000$$$). </p>     <p>       <span class="tex-font-style-bf">Detailed Explanation</span>: We       will use the key idea to compute the minimum change required to       achieve every possible string of each of the two types, and then       take the minimum across them.</p>     <p>First, let us compute the total number of $$$1$$$'s and $$$0$$$'s       in the string, denoted by <span class="tex-font-style-tt">num_ones</span> and <span class="tex-font-style-tt">num_zeros</span>. Now, as we iterate       through the string, let us also maintain <span class="tex-font-style-tt">done_ones</span> and <span class="tex-font-style-tt">done_zeros</span>, which denote the       number of $$$1$$$'s and $$$0$$$'s encountered so far.</p>     <p>Let us iterate through the string. When we are at position       $$$i$$$ (indexed from $$$1$$$), we want to answer two questions:       what is the cost for changing the string into $$$11..000$$$ (where       number of $$$1$$$'s = $$$i$$$) and what is the cost for changing       the string into $$$00..111$$$ (where number of $$$0$$$'s =       $$$i$$$). </p>     <p>Assuming that <span class="tex-font-style-tt">done_zeros</span>       and <span class="tex-font-style-tt">done_ones</span> also consider       the current index, the answer to the first question is <span class="tex-font-style-tt">done_zeros + num_ones -       done_ones</span>. This is because <span class="tex-font-style-tt">done_zeros</span> $$$0$$$'s must be       converted to $$$1$$$'s, and <span class="tex-font-style-tt">num_ones - done_ones</span> $$$1$$$'s       must be converted to $$$0$$$'s. Similarly, the answer for the       second question is <span class="tex-font-style-tt">done_ones +         num_zeros - done_zeros</span>.</p>     <p>The answer is the minimum over all such changes possible. Please       do not forget to consider the all $$$1$$$'s and all $$$0$$$'s       string in the above solution.</p>     <p>       <span class="tex-font-style-bf">Time Complexity</span>: $$$O(N)$$$</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define endl &#34;\n&#34;
#define int long long
 
const int N = 1e5 + 5;
 
int32_t main()
{
	IOS;
	int t;
	cin &gt;&gt; t;
	while(t--)
	{
		string s;
		cin &gt;&gt; s;
		int suf0 = 0, suf1 = 0;
		for(auto &amp;it:s)
		{
			suf0 += (it == &#39;0&#39;);
			suf1 += (it == &#39;1&#39;);
		}
		int ans = min(suf0, suf1); //Make whole string 0/1
		int pref0 = 0, pref1 = 0;
		for(auto &amp;it:s)
		{
			pref0 += (it == &#39;0&#39;), suf0 -= (it == &#39;0&#39;);
			pref1 += (it == &#39;1&#39;), suf1 -= (it == &#39;1&#39;);
			//Cost of making string 0*1*
			ans = min(ans, pref1 + suf0);
			//Cost of making string 1*0*
			ans = min(ans, pref0 + suf1);
		}
		cout &lt;&lt; ans &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #646 (Div. 2)
    1363C
    Игра на листьях </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Игра на листьях</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Ayush и Ashish играют в игру на некорневом дереве, состоящем из       $$$n$$$ вершин, пронумерованных от $$$1$$$ до $$$n$$$. Игроки       делают следующий ход по очереди: </p>     <ul>     <li> Выберите любой лист в дереве и удалите его вместе со         всеми ребрами, для которых этот лист является одним из концов.         Лист  — это вершина со степенью, не превосходящей $$$1$$$. </li></ul>          <p>Дерево  — это связный неориентированный граф без циклов.</p>     <p>Дана специальная вершина с номером $$$x$$$. Игрок, который       удаляет эту вершину, выигрывает игру.</p>     <p>Ayush ходит первым. Определите победителя игры, если каждый игрок       играет оптимально.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке входных данных содержится одно целое число       $$$t$$$ $$$(1 \leq t \leq 10)$$$ — количество наборов входных       данных. Далее следуют описания наборов входных данных.</p>     <p>Первая строка каждого набора входных данных содержит два целых       числа $$$n$$$ и $$$x$$$ $$$(1\leq n \leq 1000, 1 \leq x \leq       n)$$$ — количество вершин в дереве и специальную вершину, соответственно.</p>     <p>Каждая из следующих $$$n-1$$$ строк содержит два целых числа       $$$u$$$, $$$v$$$ $$$(1 \leq u, v \leq n, \text{ } u \ne v)$$$, что       означает, что между вершинами $$$u$$$ и $$$v$$$ есть ребро.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных, если побеждает Ayush, выведите         "<span class="tex-font-style-tt">Ayush</span>", иначе       выведите "<span class="tex-font-style-tt">Ashish</span>"       (без кавычек).</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
1
3 1
2 1
3 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
Ashish
</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
1
3 2
1 2
1 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
Ayush
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных Ayush может удалить только вершину       $$$2$$$ или $$$3$$$, после чего вершина $$$1$$$ становится листом,       и Ashish может удалить ее в свою очередь.</p>     <p>Во втором наборе входных данных Ayush может удалить вершину       $$$2$$$ на самом первом шаге.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1363/problem/C' title='Codeforces Round 646 (Div. 2)'>1363C - Game On Leaves</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>       <span class="tex-font-style-bf">Key Idea</span>: The main idea of       this problem is to think backwards. Instead of thinking about how       the game will proceed, we think about how the penultimate state of       the game will look like, etc. Also, we take care of the cases       where the game will end immediately (i.e, when the special node is       a leaf node).</p>     <p>       <span class="tex-font-style-bf">Detailed Explanation</span>:       First, let us take care of the cases where the game ends       immediately. This only occurs when the special node $$$x$$$ is a       leaf node, so all we must do is check that <span class="tex-font-style-tt">deg[$$$x$$$] = 1</span>. Please note       that $$$n = 1$$$ must be handled seperately here (just output         <span class="tex-font-style-tt">Ayush</span>).</p>     <p>Now, in the case where $$$x$$$ is not a leaf node, the answer is       as follows: <span class="tex-font-style-tt">Ashish</span> wins if       $$$n$$$ is odd, and <span class="tex-font-style-tt">Ayush</span>       wins if $$$n$$$ is even. I will provide a short sketch of the       proof below.</p>     <p>With the hint from the key idea, let us analyze this game       backwards. (I will assume that $$$n&gt;10$$$ for the sake of a       clear explanation). When $$$x$$$ is removed from the game, it       cannot be the only node remaining (because then the previous       player could have also removed $$$x$$$, and thus he did not play       optimally). Assume the structure of the game is something like the       following WLOG at the last step (The tree attached to $$$x$$$       could be any tree):</p>          <center>       <img class="tex-graphics" src="https://espresso.codeforces.com/ee24a7b52cd2e7d642669bd398cfc2174a6a4a4b.png" style="max-width: 100.0%;max-height: 100.0%;" /></center>          <p>Consider also that <span class="tex-font-style-tt">Ayush</span>       won, and the last move was to remove $$$x$$$. Now, what could have       been the state before this move? If <span class="tex-font-style-tt">Ashish</span> had removed a node from       the tree, then he did not play optimally - since he could have       removed $$$x$$$! Thus, he must have removed something from       $$$x$$$, which looks like the following:</p>          <center>       <img class="tex-graphics" src="https://espresso.codeforces.com/94369c5be8cccf829c64c629e7240848a55418c2.png" style="max-width: 100.0%;max-height: 100.0%;" /></center>          <p>Considering this state, <span class="tex-font-style-tt">Ashish</span> should not infact remove       $$$6$$$, and instead remove something from the tree! Hence, the       state that we assumed the game should look like at the end is       impossible - and indeed, the tree attached to $$$x$$$ should only       consist of only one node (we already proved that $$$x$$$ cannot be       the only node remaining). </p>     <p>Thus, all we have to do is find who's turn it will be when the       structure of the tree is as follows:</p>          <center>       <img class="tex-graphics" src="https://espresso.codeforces.com/94d24c3811eea80c425fc0e608ce0b1ee9aaeb1f.png" style="max-width: 100.0%;max-height: 100.0%;" /></center>          <p>It is <span class="tex-font-style-tt">Ashish</span>'s turn if       $$$n$$$ is odd, and <span class="tex-font-style-tt">Ayush</span>'s       turn if $$$n$$$ is even. QED!</p>     <p>       <span class="tex-font-style-bf">Time complexity</span>: $$$O(N)$$$</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
 
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define endl &#34;\n&#34;
#define int long long
 
const int N = 2e5 + 5;
 
int n, x;
int deg[N];
vector&lt;int&gt; g[N];
 
int32_t main()
{
	IOS;
	int t;
	cin &gt;&gt; t;
	while(t--)
	{
		memset(deg, 0, sizeof(deg));
		cin &gt;&gt; n &gt;&gt; x;
		for(int i = 1; i &lt;= n - 1; i++)
		{
			int u, v;
			cin &gt;&gt; u &gt;&gt; v;
			deg[u]++, deg[v]++;
		}
		if(deg[x] &lt;= 1)
			cout &lt;&lt; &#34;Ayush&#34; &lt;&lt; endl;
		else
		{
			if(n % 2)
				cout &lt;&lt; &#34;Ashish&#34; &lt;&lt; endl;
			else
				cout &lt;&lt; &#34;Ayush&#34; &lt;&lt; endl;
		}
	}
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #648 (Div. 2)
    1365A
    Игра с таблицей </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Игра с таблицей</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Ashish и Vivek играют в игру на таблице с $$$n$$$ строками и       $$$m$$$ столбцами, захватывая клетки. Незахваченные клетки       обозначены $$$0$$$, а захваченные клетки обозначены $$$1$$$. Вам       дано исходное состояние таблицы.</p>     <p>На каждом ходу, игрок должен захватить одну клетку. Клетку можно       захватить, если она еще не захвачена, и она не находится в одной       строке или столбце с другой захваченной клеткой. Игра кончается,       когда игрок не может сделать ход, в таком случае, он проигрывает.</p>     <p>Если Ashish и Vivek ходят по очереди и Ashish ходит первым,       найдите победителя игры если они оба играют оптимально.</p>     <p>Оптимальная игра между двумя игроками означает, что оба игрока       выбирают лучшую возможную стратегию, чтобы получить наиболее       благоприятный для себя результат игры.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$t$$$ $$$(1 \le t \le       50)$$$ — количество наборов входных данных. Далее следуют описания       наборов входных данных.</p>     <p>В первой строке каждого набора входных данных записаны два целых       числа $$$n$$$, $$$m$$$ $$$(1 \le n, m \le 50)$$$ — количество       строк и столбцов в таблице.</p>     <p>В каждой из следующих $$$n$$$ строк записаны $$$m$$$ целых чисел,       $$$j$$$-е число на $$$i$$$-й строке описывает $$$a_{i,j}$$$       $$$(a_{i,j} \in \{0, 1\})$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных, если Ashish выиграет при       правильной игре, выведите «<span class="tex-font-style-tt">Ashish</span>», иначе выведите «<span class="tex-font-style-tt">Vivek</span>» (без кавычек).</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
2 2
0 0
0 0
2 2
0 0
0 1
2 3
1 0 1
1 1 0
3 3
1 0 0
0 0 0
1 0 0
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
Vivek
Ashish
Vivek
Ashish
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных: Один из возможных исходов игры       следующий: Ashish захватывает клетку $$$(1, 1)$$$, затем Vivek       захватывает клетку $$$(2, 2)$$$. Ashish не может захватить ни       клетку $$$(1, 2)$$$, ни клетку $$$(2, 1)$$$, так как клетки $$$(1,       1)$$$ и $$$(2, 2)$$$ уже захвачены. Таким образом, Ashish       проигрывает. Можно показать, что вне зависимости от ходов Ashish,       Vivek выиграет. Во втором наборе входных данных: Ashish       захватывает клетку $$$(1, 1)$$$, единственная клетка, которую       можно захватить. После этого у Vivek не будет возможных ходов.</p>     <p>В третьем наборе входных данных: Ashish не может сделать ход,       поэтому Vivek выиграет.</p>     <p>В четвертом наборе входных данных: Ashish захватывает клетку       $$$(2, 3)$$$, у Vivek не останется возможных ходов.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1365/problem/A' title='Codeforces Round 648 (Div. 2)'>1365A - Matrix Game</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>       <span class="tex-font-style-bf">Key Idea:</span></p>     <p>Vivek and Ashish can never claim cells in rows and columns which       already have at least one cell claimed. So we need to look at the       parity of minimum of the number of rows and columns which have no       cells claimed initially.</p>     <p>       <span class="tex-font-style-bf">Solution:</span></p>     <p>Let $$$a$$$ be the number of rows which do not have any cell       claimed in them initially and similarly $$$b$$$ be the number of       columns which do not have any cell claimed initially. Each time a       player makes a move both $$$a$$$ and $$$b$$$ decrease by $$$1$$$,       since they only claim cells in rows and columns with no claimed       cells. </p>     <p>If either one of $$$a$$$ or $$$b$$$ becomes $$$0$$$, the player       whose turn comes next loses the game. Since both $$$a$$$ and       $$$b$$$ decrease by $$$1$$$ after each move, $$$\min(a, b)$$$       becomes $$$0$$$ first. So, if $$$\min(a, b)$$$ is odd, Ashish wins       the game otherwise Vivek wins.</p>     <p>Time complexity: $$$O(n \cdot m)$$$</p></div></div></div>

           
            <pre><code>
#include 
using namespace std;
 
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define endl &#34;\n&#34;
#define int long long

const int N = 51;

int n, m;
int a[N][N];

int32_t main()
{
	IOS;
	int t;
	cin &gt;&gt; t;
	while(t--)
	{
		cin &gt;&gt; n &gt;&gt; m;
		set&lt; int &gt; r, c;
		for(int i = 1; i &lt;= n; i++)
		{
			for(int j = 1; j &lt;= m; j++)
			{
				cin &gt;&gt; a[i][j];
				if(a[i][j] == 1)
					r.insert(i), c.insert(j);
			}
		}
		int mn = min(n — r.size(), m — c.size());
		if(mn % 2)
			cout &lt;&lt; &#34;Ashish&#34; &lt;&lt; endl;
		else
			cout &lt;&lt; &#34;Vivek&#34; &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #648 (Div. 2)
    1365B
    Проблематичная сортировка </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Проблематичная сортировка</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У Ashish есть $$$n$$$ элементов, расположенных по порядку. </p>     <p>Каждый элемент задается двумя целыми числами $$$a_i$$$ — значение       элемента и $$$b_i$$$ — тип элемента (есть только два возможных       типа: $$$0$$$ и $$$1$$$). Он хочет отсортировать элементы в       порядке неубывания $$$a_i$$$.</p>     <p>Он может совершать следующую операцию произвольное число раз: </p>     <ul>                     <li> Выбрать любые два таких элемента $$$i$$$ и $$$j$$$, что         $$$b_i \ne b_j$$$ и поменять их местами. Таким образом, он может         за ход поменять местами два элемента разных типов.          </li></ul>          <p>Скажите ему, может ли он отсортировать массив в порядке       неубывания $$$a_i$$$, используя описанные операции.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$t$$$ $$$(1 \le t \le       100)$$$ — количество наборов входных данных.</p>     <p>В первой строке каждого набора входных данных записано одно целое       число $$$n$$$ $$$(1 \le n \le 500)$$$ — размеры массивов.</p>     <p>Во второй строке записаны $$$n$$$ целых чисел $$$a_i$$$ $$$(1 \le       a_i \le 10^5)$$$  — значение $$$i$$$-го элемента.</p>     <p>В третьей строке записаны $$$n$$$ целых чисел $$$b_i$$$ $$$(b_i       \in \{0, 1\})$$$  — тип $$$i$$$-го элемента.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных, выведите «<span class="tex-font-style-tt">Yes</span>» или «<span class="tex-font-style-tt">No</span>» (без кавычек) в зависимости       от того, возможно ли отсортировать массив в порядке неубывания       значений используя описанные операции.</p>     <p>Вы можете выводить каждый символ в любом регистре (верхнем или нижнем).</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
4
10 20 20 30
0 1 0 1
3
3 1 2
0 1 1
4
2 2 4 8
1 1 1 1
3
5 15 4
0 0 0
4
20 10 100 50
1 0 0 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
Yes
Yes
Yes
No
Yes
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных: элементы уже находятся в       отсортированном порядке.</p>     <p>Во втором наборе входных данных: Ashish сначала может поменять       местами элементы на позициях $$$1$$$ и $$$2$$$, затем поменять       местами элементы на позициях $$$2$$$ и $$$3$$$.</p>     <p>В четвертом наборе входных данных: Нельзя поменять местами       никакие два элемента, так как нет пары $$$i$$$ и $$$j$$$, что       $$$b_i \ne b_j$$$. Таким образом, элементы не могут быть отсортированы.</p>     <p>В пятом наборе входных данных: Ashish может поменять местами       элементы на позициях $$$3$$$ и $$$4$$$, а затем элементы на       позициях $$$1$$$ и $$$2$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1365/problem/B' title='Codeforces Round 648 (Div. 2)'>1365B - Trouble Sort</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>       <span class="tex-font-style-bf">Key Idea:</span></p>     <p>If there is at least one element of type $$$0$$$ and at least one       element of type $$$1$$$, we can always sort the array.</p>     <p>       <span class="tex-font-style-bf">Solution:</span></p>     <p>If all the elements are of the same type, we cannot swap any two       elements. So, in this case, we just need to check if given       elements are already in sorted order.</p>     <p>Otherwise, there is at least one element of type $$$0$$$ and at       least one element of type $$$1$$$. In this case, it is possible to       swap any two elements! We can swap elements of different types       using only one operation. Suppose we want to swap two elements       $$$a$$$ and $$$b$$$ of the same type. We can do it in $$$3$$$       operations. Let $$$c$$$ be an element of the type different from       $$$a$$$ and $$$b$$$. We can first swap $$$a$$$ and $$$c$$$, then       swap $$$b$$$ and $$$c$$$ and then swap $$$a$$$ and $$$c$$$ again.       In doing so, $$$c$$$ remains at its initial position and $$$a$$$,       $$$b$$$ are swapped. This is exactly how we swap two integers       using a temporary variable. Since we can swap any two elements, it       is always possible to sort the array in this case.</p>     <p>Time complexity: $$$O(n)$$$</p></div></div></div>

           
            <pre><code>
#include 
using namespace std;
 
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define endl &#34;\n&#34;
#define int long long

const int N = 1e3 + 5;

int n;
int a[N], b[N];

int32_t main()
{
	IOS;
	int t;
	cin &gt;&gt; t;
	while(t--)
	{
		cin &gt;&gt; n;
		bool sorted = 1, have0 = 0, have1 = 0;
		for(int i = 1; i &lt;= n; i++)
		{
			cin &gt;&gt; a[i];
			if(i &gt;= 2 &amp;&amp; a[i] &lt; a[i - 1])
				sorted = 0;
		}
		for(int i = 1; i &lt;= n; i++)
		{
			cin &gt;&gt; b[i];
			if(!b[i])
				have0 = 1;
			else
				have1 = 1;
		}
		if(have0 &amp;&amp; have1)
			cout &lt;&lt; &#34;Yes&#34; &lt;&lt; endl;
		else if(sorted)
			cout &lt;&lt; &#34;Yes&#34; &lt;&lt; endl;
		else
			cout &lt;&lt; &#34;No&#34; &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #648 (Div. 2)
    1365C
    Соответствия поворотом </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Соответствия поворотом</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>После мистического исчезнования Ashish, каждый из его любимых       учеников Ishika и Hriday, получил одну половину секретного       сообщения. Эти сообщения могут быть описаны перестановками размера       $$$n$$$. Назовем их $$$a$$$ и $$$b$$$.</p>     <p>Напомним, что перестановка из $$$n$$$ элементов это       последовательность чисел $$$a_1, a_2, \ldots, a_n$$$, в которой       каждое число от $$$1$$$ до $$$n$$$ встречается ровно один раз. </p>     <p>Сообщение может быть расшифровано из конфигурации перестановок       $$$a$$$ и $$$b$$$, в котором количество совпадающих пар элементов       максимально. Пара элементов $$$a_i$$$ и $$$b_j$$$ называется       совпадающей, если: </p>     <ul> <li> $$$i = j$$$, таким образом, у них один и тот же индекс. </li>       <li> $$$a_i = b_j$$$ </li></ul>          <p>Его ученикам разрешается совершать следующую операцию       произвольное число раз: </p>     <ul> <li> выбрать число $$$k$$$ и циклически сдвинуть одну из         перестановок влево или вправо $$$k$$$ раз. </li></ul>          <p>Циклический сдвиг перестановки $$$c$$$ влево это операция,       которая присваивает $$$c_1:=c_2, c_2:=c_3, \ldots, c_n:=c_1$$$       одновременно. Аналогично, циклический сдвиг перестановки $$$c$$$       вправо это операция, которая присваивает $$$c_1:=c_n, c_2:=c_1,       \ldots, c_n:=c_{n-1}$$$ одновременно.</p>     <p>Помогите Ishika и Hriday найти наибольшее возможное число       совпадающих пар в данных перестановках после применения описанных       операций несколько (возможно, ноль) раз.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое число $$$n$$$ $$$(1 \le n \le       2 \cdot 10^5)$$$ — размеры массивов.</p>     <p>Во второй строке записаны $$$n$$$ целых чисел $$$a_1$$$,       $$$a_2$$$, ..., $$$a_n$$$ $$$(1 \le a_i \le n)$$$ — элементы       первой перестановки.</p>     <p>В третьей строке записаны $$$n$$$ целых чисел $$$b_1$$$,       $$$b_2$$$, ..., $$$b_n$$$ $$$(1 \le b_i \le n)$$$ — элементы       второй перестановки.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите наибольшее возможное число совпадающих пар в данных       перестановках после применения описанных операций несколько       (возможно, ноль) раз.</p></div>         <div class="sample-tests">     <div class="section-title">Примеры</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
1 2 3 4 5
2 3 4 5 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
5</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
5 4 3 2 1
1 2 3 4 5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1</pre></div>       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
1 3 2 4
4 2 3 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом примере можно сдвинуть $$$b$$$ направо на $$$k = 1$$$.       Получившиеся перестановки будут $$$\{1, 2, 3, 4, 5\}$$$ и $$$\{1,       2, 3, 4, 5\}$$$.</p>     <p>Во втором примере не требуется совершать никаких операций. По       всем возможным сдвигам $$$a$$$ и $$$b$$$, число совпадающих пар не       будет превышать $$$1$$$.</p>     <p>В третьем примере можно сдвинуть $$$b$$$ влево на $$$k = 1$$$.       Получившиеся перестановки будут $$$\{1, 3, 2, 4\}$$$ и $$$\{2, 3,       1, 4\}$$$. Позиции $$$2$$$ и $$$4$$$ будут являться совпадающей       парой. По всем возможным циклическим сдвигам $$$a$$$ и $$$b$$$,       количество совпадающих пар не будет превышать $$$2$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1365/problem/C' title='Codeforces Round 648 (Div. 2)'>1365C - Rotation Matching</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>       <span class="tex-font-style-bf">Key Idea:</span></p>     <p>We only need to perform shifts on one of the arrays. Moreover,       all the shifts can be of the same type (right or left)!</p>     <p>       <span class="tex-font-style-bf">Solution:</span></p>     <p>First of all, a left cyclic shift is the same as $$$n - 1$$$       right cyclic shifts and vice versa. So we only need to perform       shifts of one type, say right.</p>     <p>Moreover, a right cyclic shift of $$$b$$$ is the same as       performing a left cyclic shift on $$$a$$$ and vice versa. So we       don't need to perform any shifts on $$$b$$$.</p>     <p>Now the problem reduces to finding the maximum number of matching       pairs over all right cyclic shifts of $$$a$$$. Since $$$n$$$ right       cyclic shifts on $$$a$$$ results in $$$a$$$ again, there are only       $$$n - 1$$$ right cyclic shifts possible. </p>     <p>Since both arrays are a permutation, each element in $$$a$$$       would match with its corresponding equal element in $$$b$$$ only       for one of the shifts. For example, if $$$a$$$ is $$$\{{2, 3,       1\}}$$$ and $$$b$$$ is $$$\{{3, 1, 2\}}$$$, the number $$$3$$$ in       $$$a$$$ would match with the number $$$3$$$ in $$$b$$$ only if one       right cyclic shift is performed. So for each element in $$$a$$$ we       can find the number of right cyclic shifts after which it would       match with its corresponding equal element in $$$b$$$. If       $$$a_i$$$ = $$$b_j$$$, then $$$a_i$$$ would match with $$$b_j$$$       after $$$k = j - i$$$ right cyclic shifts. If $$$j - i \lt 0$$$,       then $$$a_i$$$ would with $$$b_j$$$ after $$$n - j + i$$$ shifts.</p>     <p>Now for each shift, we can find the number of matching pairs and       take the maximum.</p>     <p>Time complexity: $$$O(n)$$$ or $$$O(n \cdot log(n))$$$ if you use       a map.</p></div></div></div>

           
            <pre><code>
#include 
using namespace std;
 
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define endl &#34;\n&#34;
#define int long long

const int N = 2e5 + 5;

int n;
int a[N], b[N], pos[N];
map&lt; int, int &gt; offset;

int32_t main()
{
	IOS;
	cin &gt;&gt; n;
	for(int i = 1; i &lt;= n; i++)
	{
		cin &gt;&gt; a[i];
		pos[a[i]] = i;
	}
	for(int i = 1; i &lt;= n; i++)
		cin &gt;&gt; b[i];
	for(int i = 1; i &lt;= n; i++)
	{
		int cur = pos[b[i]] - i;
		if(cur &lt; 0)
			cur += n;
		offset[cur]++;
	}
	int ans = 0;
	for(auto &amp;it:offset)
		ans = max(ans, it.second);
	cout &lt;&lt; ans;
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 89 (рейтинговый для Див. 2)
    1366A
    Лопаты и мечи </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Лопаты и мечи</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Поликарп играет в известную компьютерную игру (мы не хотим       упоминать ее название). В этой игре он может создавать инструменты       двух видов — лопаты и мечи. На создание лопаты Поликарп тратит две       палки и один алмаз; на создание меча Поликарп тратит два алмаза и       одну палку.</p>     <p>Каждый инструмент может быть продан за один изумруд. Как много       изумрудов может заработать Поликарп, если у него есть $$$a$$$       палок и $$$b$$$ алмазов?</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит число $$$t$$$ ($$$1 \le t \le 1000$$$) —       количество наборов входных данных.</p>     <p>Единственная строка каждого набора входных данных содержит два       числа $$$a$$$ и $$$b$$$ ($$$0 \le a, b \le 10^9$$$) — количество       палок и алмазов соответственно.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>На каждый набор входных данных выведите число — максимальное       количество изумрудов, которое может заработать Поликарп.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
4 4
1000000000 0
7 15
8 7
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
0
7
5
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных Поликарп может заработать два       изумруда следующим образом: создать один меч и одну лопату.</p>     <p>Во втором наборе входных данных у Поликарпа нет алмазов, а       значит, он не сможет ничего создать.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1366/problem/A' title='Educational Codeforces Round 89 (Rated for Div. 2)'>1366A - Shovels and Swords</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>There are three constraints on the number of emeralds:</p>          <ol> <li> the number of emeralds can't be greater than $$$a$$$; </li>       <li> the number of emeralds can't be greater than $$$b$$$; </li>       <li> the number of emeralds can't be greater than         $$$\frac{a+b}{3}$$$. </li></ol>          <p>So the answer is $$$\min(a, b, \frac{a+b}{3})$$$.</p></div></div></div>

           
            <pre><code>for _ in range(int(input())):
    l, r = map(int, input().split())
    print(min(l, r, (l + r) // 3))
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 89 (рейтинговый для Див. 2)
    1366B
    Перемешивание </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Перемешивание</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам задан массив, состоящий из $$$n$$$ чисел $$$a_1$$$,       $$$a_2$$$, ..., $$$a_n$$$. Изначально $$$a_x = 1$$$, а остальные       элементы равны $$$0$$$.</p>     <p>Вы выполняете $$$m$$$ операций. Во время $$$i$$$-й операции вы       выбираете два индекса $$$c$$$ и $$$d$$$ таких, что $$$l_i \le c, d       \le r_i$$$, и меняете местами $$$a_c$$$ и $$$a_d$$$.</p>     <p>Посчитайте количество индексов $$$k$$$ таких, что существуют       возможность выбрать операции так, что в конце $$$a_k = 1$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит число $$$t$$$ ($$$1 \le t \le 100$$$) —       количество наборов входных данных. Затем следует описание каждого       из $$$t$$$ наборов входных данных.</p>     <p>Первая строка каждого набора входных данных содержит три целых       числа $$$n$$$, $$$x$$$ и $$$m$$$ ($$$1 \le n \le 10^9$$$; $$$1 \le       m \le 100$$$; $$$1 \le x \le n$$$).</p>     <p>Каждая из следующих $$$m$$$ строк содержит описание операций; а       именно — в $$$i$$$-й строке содержится два целых числа $$$l_i$$$ и       $$$r_i$$$ ($$$1 \le l_i \le r_i \le n$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>На каждый набор входных данных выведите одно число — количество       индексов $$$k$$$ таких, что существуют возможность выбрать       операции так, что в конце $$$a_k = 1$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
6 4 3
1 6
2 3
5 5
4 1 2
2 4
1 2
3 3 2
2 3
1 2
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
6
2
3
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных условие $$$a_k = 1$$$ выполняется       для любого $$$k$$$. Для этого, можно выполнить следующие операции:</p>          <ol> <li> поменять местами $$$a_k$$$ и $$$a_4$$$; </li>       <li> поменять местами $$$a_2$$$ и $$$a_2$$$; </li>       <li> поменять местами $$$a_5$$$ и $$$a_5$$$. </li></ol>          <p>Во втором наборе входных данных подходят только индексы $$$k =       1$$$ и $$$k = 2$$$. Для выполнения $$$a_1 = 1$$$, нужно поменять       местами $$$a_1$$$ и $$$a_1$$$ во второй операции. Для выполнения       $$$a_2 = 1$$$, нужно поменять местами $$$a_1$$$ и $$$a_2$$$ во       второй операции.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1366/problem/B' title='Educational Codeforces Round 89 (Rated for Div. 2)'>1366B - Shuffle</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's consider how the set of possible indices where the $$$1$$$       can be changes. Initially, only one index is correct — $$$x$$$.       After performing an operation $$$l, r$$$ such that $$$x &lt; l$$$       or $$$x &gt; r$$$ this set does not change. But after performing       an operation $$$l, r$$$ such that $$$l \le x \le r$$$ we should       insert the elements $$$\{l, l+1, l+2, \dots, r-1, r\}$$$ into this       set, if they are not present. </p>     <p>Now consider how the set $$$\{L, L+1, L+2, \dots, R-1, R\}$$$       changes. If segments $$$[l, r]$$$ and $$$[L, R]$$$ do not share       any indices, there are no changes — but if they do, the set turns       into $$$\{ \min(l, L), \min(l, L)+1, \min(l, L)+2, \dots, \max(r,       R)-1, \max(r, R) \}$$$.</p>     <p>So the set of reachable indices is always a segment of numbers,       and to process an operation, we should check whether the segment       from operation intersects with the segment of indices we have —       and if it is true, unite them.</p></div></div></div>

           
            <pre><code>for _ in range(int(input())):
    n, x, m = map(int, input().split())
    l, r = x, x
    for _ in range(m):
        L, R = map(int, input().split())
        if max(l, L) &lt;= min(r, R):
            l = min(l, L)
            r = max(r, R)
            
    print(r - l + 1)
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 89 (рейтинговый для Див. 2)
    1366C
    Палиндромные пути </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Палиндромные пути</div>     <div class="time-limit"><div class="property-title">ограничение по времени на       тест</div>1.5 секунд</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам задана матрица из $$$n$$$ строк (пронумерованных от $$$1$$$       до $$$n$$$) и $$$m$$$ столбцов (пронумерованных от $$$1$$$ до       $$$m$$$). Обозначим за $$$a_{i, j}$$$ число в клетке на       пересечении $$$i$$$-й строки и $$$j$$$-го столбца, каждое число       либо $$$0$$$, либо $$$1$$$.</p>     <p>Изначально в ячейке $$$(1, 1)$$$ находится фишка, которая будет       перемещена в ячейку $$$(n, m)$$$ при помощи последовательности       шагов. На каждом шаге фишка перемещается либо в ячейку справа от       текущей, либо в ячейку снизу (если фишка сейчас в ячейке $$$(x,       y)$$$, ее можно переместить либо в $$$(x + 1, y)$$$, либо в $$$(x,       y + 1)$$$). Фишка не может покидать матрицу.</p>     <p>Рассмотрим все пути фишки из ячейки $$$(1, 1)$$$ в ячейку $$$(n,       m)$$$. Назовем путь <span class="tex-font-style-it">палиндромным</span>, если число в первой       ячейке пути равно числу в последней ячейке пути, число во второй       ячейке равно числу в предпоследней ячейке, и так далее.</p>     <p>Ваша цель — заменить минимальное количество элементов матрицы       так, чтобы <span class="tex-font-style-bf">все</span> пути стали         <span class="tex-font-style-it">палиндромными</span>.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке задано одно целое число $$$t$$$ ($$$1 \le t \le       200$$$) — количество наборов входных данных.</p>     <p>В первой строке каждого набора заданы два целых числа $$$n$$$ и       $$$m$$$ ($$$2 \le n, m \le 30$$$) — размеры матрицы.</p>     <p>Затем следуют $$$n$$$ строк, $$$i$$$-я из которых содержит       $$$m$$$ целых чисел $$$a_{i, 1}$$$, $$$a_{i, 2}$$$, ..., $$$a_{i,       m}$$$ ($$$0 \le a_{i, j} \le 1$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите одно целое число —       минимальное количество элементов, которое надо заменить.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
2 2
1 1
0 1
2 3
1 1 0
1 0 0
3 7
1 0 1 1 1 1 1
0 0 0 0 0 0 0
1 1 1 1 1 0 1
3 5
1 0 1 0 0
1 1 1 1 0
0 0 1 0 0
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
3
4
4
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Итоговые матрицы в первых трех примерах:</p>          <center> $$$\begin{pmatrix} 1 &amp; 1\\ 0 &amp; 1 \end{pmatrix}$$$ </center>               <center> $$$\begin{pmatrix} 0 &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0       \end{pmatrix}$$$ </center>               <center> $$$\begin{pmatrix} 1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp;       1 &amp; 1\\ 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0\\ 1       &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 \end{pmatrix}$$$ </center></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1366/problem/C' title='Educational Codeforces Round 89 (Rated for Div. 2)'>1366C - Palindromic Paths</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's group the cells by their distance from the starting point:       the group $$$0$$$ consists of a single cell $$$(1, 1)$$$; the       group $$$1$$$ consists of the cells $$$(1, 2)$$$ and $$$(2, 1)$$$,       and so on. In total, there are $$$n + m - 1$$$ groups.</p>     <p>Let's analyze the groups $$$k$$$ and $$$n + m - 2 - k$$$. There       are two cases:</p>          <ul> <li> if $$$k = 0$$$ or $$$n + m - 2 - k = 0$$$, then we are         looking at the starting cell and the ending cell, and their         contents should be equal; </li>       <li> otherwise, suppose two cells $$$(x, y)$$$ and $$$(x + 1, y -         1)$$$ belong to the same group. We can easily prove that the         contents of these two cells should be equal (for example, by         analyzing two paths that go through cell $$$(x + 1, y)$$$ and         coincide after this cell, but one goes to $$$(x + 1, y)$$$ from         $$$(x, y)$$$, and another — from $$$(x + 1, y - 1)$$$) — and,         using induction, we can prove that the contents of all cells in         a group should be equal. And since the paths should be         palindromic, the contents of the group $$$k$$$ should be equal         to the contents of the group $$$n + m - 2 - k$$$. </li></ul>          <p>So, in each pair of groups, we should calculate the number of       $$$1$$$'s and $$$0$$$'s, and choose which of them to change. Note       that if $$$n + m$$$ is even, the central group has no pair, so it       should not be modified.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

void solve()
{
	int n, m;
	cin &gt;&gt; n &gt;&gt; m;
	vector&lt;vector&lt;int&gt; &gt; a(n, vector&lt;int&gt;(m));
	for(int i = 0; i &lt; n; i++)
		for(int j = 0; j &lt; m; j++)
			cin &gt;&gt; a[i][j];
	vector&lt;vector&lt;int&gt; &gt; cnt(n + m - 1, vector&lt;int&gt;(2));
	for(int i = 0; i &lt; n; i++)
		for(int j = 0; j &lt; m; j++)
			cnt[i + j][a[i][j]]++;
	int ans = 0;
	for(int i = 0; i &lt;= n + m - 2; i++)
	{
		int j = n + m - 2 - i;
		if(i &lt;= j) continue;
		ans += min(cnt[i][0] + cnt[j][0], cnt[i][1] + cnt[j][1]);
	}
	cout &lt;&lt; ans &lt;&lt; endl;
}

int main() {
	int t;
	cin &gt;&gt; t;
	for(int i = 0; i &lt; t; i++)
		solve();
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #652 (Div. 2)
    1369A
    ПокупатеЛи </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. ПокупатеЛи</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>       <span class="tex-font-style-it">Ли собирается украсить свой дом к         вечеринке с помощью нескольких правильных многоугольников...</span></p>     <p>Ли считает правильный (выпуклый) $$$n$$$-угольник <span class="tex-font-style-it">красивым</span> тогда и только тогда,       когда он может повернуть многоугольник таким образом, чтобы хотя       бы одна из его сторон стала параллельна оси $$$OX$$$ и хотя бы       одна из его сторон стала параллельна оси $$$OY$$$ одновременно.</p>     <p>Напомним, что правильный $$$n$$$-угольник — это выпуклый       многоугольник из $$$n$$$ вершин такой, что все его стороны и углы равны.</p>     <p>Ли пришел в магазин: в магазине продаются $$$t$$$ правильных       многоугольников. Для каждого из них выведите <span class="tex-font-style-tt">YES</span>, если многоугольник красивый,       или <span class="tex-font-style-tt">NO</span> в противном случае.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке задано одно целое число $$$t$$$ ($$$1 \le t \le       10^4$$$) — количество многоугольников в магазине. </p>     <p>В каждой из следующих $$$t$$$ строк задано по одному целому числу       $$$n_i$$$ ($$$3 \le n_i \le 10^9$$$): то есть $$$i$$$-й       многоугольник является правильным $$$n_i$$$-угольником. </p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого многоугольника в магазине, выведите <span class="tex-font-style-tt">YES</span>, если он красивый, или <span class="tex-font-style-tt">NO</span> в противном случае (регистр       букв не важен).</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
3
4
12
1000000000
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
NO
YES
YES
YES
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В примере, в магазине продаются $$$4$$$ многоугольника. Несложно       определить, что равносторонний треугольник (правильный       $$$3$$$-угольник) не является красивым, квадрат (правильный       $$$4$$$-угольник) является красивым, и правильный       $$$12$$$-угольник (изображен ниже) также является красивым.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/1fb7c77820d27b1f996dbe8b237957113d122864.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1369/problem/A' title='Codeforces Round 652 (Div. 2)'>1369A - FashionabLee</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>$$$\mathcal Complete\;\mathcal Proof :$$$</p>     <p>Proof by contradiction :</p>     <p>One can prove that if two edges in a regular polygon make a $$$x       &lt; 180$$$ degrees angle, then for each edge $$$a$$$ there exist       two another edges $$$b$$$ and $$$c$$$ such that $$$a$$$ and       $$$b$$$ make a $$$x$$$ degrees angle as well as $$$a$$$ and       $$$c$$$. (proof is left as an exercise for the reader)</p>     <p>Consider a rotation such that an edge $$$a$$$ is parallel to       $$$OX$$$-axis and an edge $$$b$$$ is parallel to $$$OY$$$-axis,       then $$$a \perp b$$$ ($$$a$$$ and $$$b$$$ are perpendicular, i. e.       the angle between them is $$$90$$$ degrees), we can see that there       exist a third edge $$$c$$$ such that it's also parallel to       $$$OX$$$-axis and a forth edge $$$d$$$ such that it's also       parallel to $$$OY$$$-axis, so $$$a \perp d$$$ and $$$b \perp c$$$       and $$$c \perp d$$$. </p>     <p>Our polygon is regular so all the angles are equal, so that the       number of angles between $$$a$$$ and $$$b$$$ is equal to the       number of angles between $$$b$$$ and $$$c$$$ and so on, also we       know that a regular $$$n$$$-sided convex polygon has $$$n$$$       angles, so $$$n$$$ is divisible by $$$4$$$, contradiction!</p></div></div></div>

           
            <pre><code>t = int(input())
for testcase in range(t):
    n = int(input())
    if(n%4 == 0) :
        print(&#34;Yes&#34;)
    else :
        print(&#34;No&#34;)

</code></pre>
           
            <pre><code>#include &lt;iostream&gt;
 
using namespace std;
 
int main(){
    int t;
    cin &gt;&gt; t;
    while(t--){
        int n;
        cin &gt;&gt; n;
        if(n % 4 == 0){
            cout &lt;&lt; &#34;YES\n&#34;;
        }
        else cout &lt;&lt; &#34;NO\n&#34;;
    }
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #652 (Div. 2)
    1369B
    ОчиститеЛи </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. ОчиститеЛи</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>       <span class="tex-font-style-it">Ли убирался у себя в дома перед         вечеринкой, когда нашел под ковром «грязную» строку. Теперь он         хочет очистить строку, но сделать это стильно...</span></p>     <p>Строка $$$s$$$, которую нашел Ли, является двоичной строкой длины       $$$n$$$ (т. е. строка состоит только из символов <span class="tex-font-style-tt">0</span> и <span class="tex-font-style-tt">1</span>).</p>     <p>За один шаг, он может выбрать два последовательных символа       $$$s_i$$$ и $$$s_{i+1}$$$ и, если символ $$$s_i$$$ равен <span class="tex-font-style-tt">1</span> и $$$s_{i + 1}$$$ равен <span class="tex-font-style-tt">0</span>, он может удалить <span class="tex-font-style-bf">ровно один из символов</span> (Ли       может выбрать какой удалить, но не может удалить оба символа       одновременно). После удаления строка сжимается.</p>     <p>Ли может сделать произвольное количество шагов (возможно, ни       одного шага) и он хочет сделать строку $$$s$$$ как можно более         <span class="tex-font-style-it">чистой</span>. Он считает, что       из двух различных строк $$$x$$$ и $$$y$$$ <span class="tex-font-style-bf">более короткая</span> строка чище, а       если они равны по длине, то чище та, что <span class="tex-font-style-it">лексикографически меньше</span>.</p>     <p>Сейчас же вам необходимо ответить на $$$t$$$ наборов входных       данных: для $$$i$$$-го набора, выведите самую чистую строку,       которую может получить Ли за произвольное количество шагов.</p>     <p>Небольшое напоминание: если у нас есть две строки $$$x$$$ и       $$$y$$$ равной длины, то $$$x$$$ лексикографически меньше чем       $$$y$$$, если существует такая позиция $$$i$$$, что $$$x_1 =       y_1$$$, $$$x_2 = y_2$$$,..., $$$x_{i - 1} = y_{i - 1}$$$ и $$$x_i       &lt; y_i$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке задано одно целое число $$$t$$$ ($$$1 \le t \le       10^4$$$) — количество наборов входных данных.</p>     <p>В следующих $$$2t$$$ строках заданы сами наборы входных данных —       по одному на две строки.</p>     <p>В первой строке каждого набора задано одно целое число $$$n$$$       ($$$1 \le n \le 10^5$$$) — длина строки $$$s$$$.</p>     <p>Во второй строке задана сама бинарная строка $$$s$$$. Строка       $$$s$$$ — это строка длины $$$n$$$, состоящая только из нулей и единиц.</p>     <p>Гарантируется, что сумма $$$n$$$ по всем наборам не превосходит $$$10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Выведите $$$t$$$ ответов — по одному на набор входных данных.</p>     <p>Ответом на $$$i$$$-й набор является самая чистая строка, которую       может получить Ли за произвольное (возможно, нулевое) количество шагов.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
10
0001111111
4
0101
8
11001101
10
1110000000
1
1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0001111111
001
01
0
1
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных, Ли не может сделать ни одного шага.</p>     <p>Во втором наборе, Ли должен удалить $$$s_2$$$.</p>     <p>В третьем наборе, Ли может, например, выполнить следующие шаги:         11001<span class="tex-font-style-underline">10</span>1 $$$\rightarrow$$$         1<span class="tex-font-style-underline">10</span>0101 $$$\rightarrow$$$         1<span class="tex-font-style-underline">10</span>101 $$$\rightarrow$$$         <span class="tex-font-style-underline">10</span>101 $$$\rightarrow$$$         1<span class="tex-font-style-underline">10</span>1 $$$\rightarrow$$$         <span class="tex-font-style-underline">10</span>1 $$$\rightarrow$$$ 01.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1369/problem/B' title='Codeforces Round 652 (Div. 2)'>1369B - AccurateLee</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>$$$\mathcal Complete\; \mathcal Proof$$$ :</p>     <p>Realize that the answer is always non-descending, and we can't       perform any operations on non-descending strings.</p>     <p>First we know that we can't perform any operations on       non-descending strings, so the answer to a non-descending string       is itself. From now we consider our string $$$s$$$ to not to be       non-descending. (i.e. there exist index $$$i$$$ such that $$$1 \le       i \le n-1$$$ and $$$s_i &gt; s_{i+1}$$$)</p>     <p>Also realize that the remaining string wont be empty, so       &quot;0&quot; is the cleanest possible answer, but we can't reach       it probable.</p>     <p>Now realize that leading zeroes and trailing ones can't be       present in any operation. So they have to be in the answer, erase       them from $$$s$$$, and add them to the answer for the modified       $$$s$$$. From now we know that the string $$$s$$$ has no leading       zeroes and/or trailing ones, and is not non-descending, so it       starts with $$$1$$$ and ends with $$$0$$$. (why?)</p>     <p>With some small paperwork, we will realize that the answer to a       string that starts with $$$1$$$ and ends with $$$0$$$ is a single       $$$0$$$(proof is bellow). So if the string $$$s$$$ is       non-descending and it has $$$x$$$ leading zeroes and $$$y$$$       trailing ones($$$x$$$ and $$$y$$$ can be equal to zero), then the       answer is       $$$\underbrace{0\,0\dots0}_{x}\,0\,\underbrace{1\,1\dots1}_{y}$$$       (its $$$x+1$$$ zeroes and $$$y$$$ ones in order)</p>     <p>$$$\mathcal The\;\mathcal Small\;\mathcal Paperwork:$$$</p>     <p>We will randomly perform operations until we can't do any more or       the string's length is equal to $$$2$$$, but we wont erase the       first $$$1$$$ and the last $$$0$$$, we want to prove that the       remaining string's length is exactly $$$2$$$ after the process       ends, proof by contradiction :</p>     <p>So it's length is at least $$$3$$$, so we have at least two       $$$1$$$ or at least two $$$0$$$. If we had two or more $$$0$$$       then the string $$$[s_1\,s_2\dots s_{n-1}]$$$ will not be       non-descending(so we can perform more operations as we proved in         <span class="tex-font-style-tt">STAR</span>, but the process       have ended, contradiction!) and if we had two or more $$$1$$$ then       the string $$$[s_2\,s_3\dots s_n]$$$ will not be non-descending.       So the length of the remaining string is exactly $$$2$$$, and we       haven't erased first '1' and last '0', so the string is equal to       &quot;10&quot;, now erase '1' to get the cleanest string.</p>     <p>Sorry if the proof seems too long and hard, i wanted to explain       it accurately. ^-^</p></div></div></div>

           
            <pre><code>t = int(input())
for testcase in range(t):
    n = int(input())
    s = input()
    lef, rig, sw = 1, 1, 0
    for i in range(n-1):
        if(s[i] &gt; s[i+1]):
            sw = 1
            break
    if(sw == 0):
        print(s)
        continue
    for i in range(n):
        if (s[i] == &#39;1&#39;):
            lef = i
            break
    for i in range(n-1, 0, -1):
        if (s[i] == &#39;0&#39;):
            rig = i
            break
    st = s[:lef] + &#39;0&#39; + s[rig+1:]
    print(st)

</code></pre>
           
            <pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
 
using namespace std;
 
int main(){
    
    int t;
    cin &gt;&gt; t;
    while(t--){
        int n;
        cin &gt;&gt; n;
        string s;
        cin &gt;&gt; s;
        int sw = 1;
        for(int i = 1; i &lt; s.size(); i++){
            if(s[i] &lt; s[i-1])sw = 0;
        }
        if(sw){
            cout &lt;&lt; s &lt;&lt; &#39;\n&#39;;
            continue;
        }
        string ans;
        for(int i = 0; i &lt; s.size(); i++){
            if(s[i] == &#39;1&#39;)break;
            ans.push_back(&#39;0&#39;);
        }
        ans.push_back(&#39;0&#39;);
        for(int i = s.size()-1; i &gt;= 0; i--){
            if(s[i] == &#39;0&#39;)break;
            ans.push_back(&#39;1&#39;);
        }
        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
    }
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #652 (Div. 2)
    1369C
    ПриятеЛи </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. ПриятеЛи</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>       <span class="tex-font-style-it">Ли наконец стал мастером на         Codeforces, и потому решил сходить за подарками своим друзьям.         Он приобрел $$$n$$$ целых чисел, и теперь настало время         распределить их между друзьями...</span></p>     <p>У Ли есть $$$n$$$ целых чисел $$$a_1, a_2, \ldots, a_n$$$ в своем       рюкзаке, а также у него $$$k$$$ друзей. Ли хочет распределить         <span class="tex-font-style-bf">все</span> целые числа из       рюкзака между друзьями так, чтобы $$$i$$$-му другу досталось ровно       $$$w_i$$$ чисел и каждое число досталось ровно одному другу.</p>     <p>Назовем <span class="tex-font-style-it">уровнем счастья</span>       друга сумму максимального и минимального числа, которое он получит.</p>     <p>Ли хочет сделать друзей как можно более счастливыми, другими       словами, он хочет максимизировать суммарный уровень счастья       друзей. Конечно же, Ли просит вас помочь ему посчитать этот       максимальный суммарный уровень счастья.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке задано единственное число $$$t$$$ ($$$1 \le t \le       10^4$$$) — количество наборов входных данных.</p>     <p>В следующих $$$3t$$$ строках заданы сами наборы — по одному на       три строки.</p>     <p>В первой строке каждого набора входных данных заданы два целых       числа $$$n$$$ и $$$k$$$ ($$$1 \le n \le 2 \cdot 10^5$$$; $$$1 \le       k \le n$$$) — количество целых чисел в рюкзаке Ли и количество его друзей.</p>     <p>Во второй строке каждого набора заданы $$$n$$$ целых чисел       $$$a_1, a_2, \ldots, a_n$$$ ($$$-10^9 \le a_i \le 10^9$$$) — сами       числа в рюкзаке.</p>     <p>В третьей строке заданы $$$k$$$ целых чисел $$$w_1, w_2, \ldots,       w_k$$$ ($$$1 \le w_i \le n$$$; $$$w_1 + w_2 + \ldots + w_k =       n$$$) — количество чисел, которое Ли собирается дать каждому       другу. </p>     <p>Гарантируется, что сумма $$$n$$$ по всем наборам не превосходит       $$$2 \cdot 10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите по одному числу —       максимальный суммарный уровень счастья, который сможет достигнуть Ли.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
4 2
1 13 7 17
1 3
6 2
10 10 10 10 11 11
3 3
4 4
1000000000 1000000000 1000000000 1000000000
1 1 1 1
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
48
42
8000000000
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных, Ли нужно отдать наибольшее число       первому другу (его уровень счастья будет равен $$$17 + 17$$$) и       остальные числа — второму (его уровень счастья будет равен $$$13 + 1$$$).</p>     <p>В втором наборе, Ли нужно отдать $$$\{10, 10, 11\}$$$ и первому и       второму другу, тогда суммарный уровень счастья будет равен $$$(11       + 10) + (11 + 10)$$$</p>     <p>В третьем наборе, у Ли четыре друга и четыре числа. Не важно, как       он распределит числа между ними.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1369/problem/C' title='Codeforces Round 652 (Div. 2)'>1369C - RationalLee</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>$$$\mathcal Complete\; \mathcal Proof$$$ :</p>     <p>First if $$$w_i = 1$$$ for some $$$i$$$, then assign the greatest       element to $$$i$$$-th friends, it's always better obviously.</p>     <p>Sort the elements in non-descending order and sort the friends in       non-ascending order of $$$w_i$$$. Define $$$v_i$$$ the set of       indices of elements to give to $$$i$$$-th friend. Also define       $$$l_i$$$ the minimum element to give to $$$i$$$-th friend and       $$$r_i$$$ the maximum element to give to $$$i$$$-th friend, and       define $$$m = \max\limits_{1\,\le\,i\,\le\,k} w_i$$$.</p>     <p>Now it's easy to see that the first element of $$$a$$$(the       smallest element) is always equal to $$$l_i$$$ for some $$$i$$$,       Indeed it's better to have the rest of $$$v_i$$$ equal to a small       number except one of them, which should be equal to a very large       number. So we can greedily assign $$$a_1$$$, $$$a_2$$$ ...       $$$a_{{w_i}-1}$$$ to $$$v_i$$$, and then assign $$$a_n$$$ to it,       also it's better to have $$$w_i = m$$$. One can prove that there       exist an optimal distributing such that the set($$$\{a_1, a_2       \ldots a_{m-1}, a_n\}$$$) is equal to one of $$$v_i$$$-s(proof is       blow). So add $$$a_1 + a_n$$$ to the answer for remaining elements       of $$$a$$$(excluding the set) and remaining friends(excluding one       of the friends with maximum $$$w_i$$$) and so, it will be optimal.</p>     <p>Look at an optimal distributing (which maximizes sum of       happiness), first element of $$$a$$$ is in $$$v_i$$$ for example,       we want to prove that in at least one of the optimal distributings       $$$w_i-1$$$ smallest elements of $$$a$$$ are in $$$v_i$$$       (including the first element), proof by contradiction:</p>     <p>If at least one of the smallest $$$w_i-1$$$ elements is not in       $$$v_i$$$, then call the smallest of them $$$x$$$, lets say it's       in $$$v_j$$$, now add $$$x$$$ to $$$v_i$$$(and erase it from       $$$v_j$$$), instead add a greater number than $$$x$$$ in $$$v_i$$$       to $$$v_j$$$ (it's at least two of them, and one of them is       $$$r_i$$$, so there exist another one, erase it from $$$v_i$$$ and       add it to $$$v_j$$$), it's easy to see that sum of happiness won't       decrease that way, continue the process until all $$$w_i-1$$$       smallest elements are in $$$v_i$$$, so we have an optimal answer       which has all $$$w_i-1$$$ smallest elements in $$$v_i$$$, contradiction!</p>     <p>As we proved above, we have an optimal distributing such that all       $$$w_i-1$$$ smallest elements are in $$$v_i$$$(for some $$$i$$$),       now we want to prove that the greatest element is in $$$v_i$$$ in       at least one of the optimal distributings, again proof by contradiction.</p>     <p>Lets say it's not that way, so look at an optimal distributing       such that first $$$w_i-1$$$ elements are in $$$v_i$$$ and       $$$r_i$$$ is not equal to the greatest element(for some $$$i$$$),       if there exist such $$$j$$$ that $$$r_i &lt; l_j$$$, then swap       $$$r_i$$$ and $$$l_j$$$, the resulting distributing has the same       happiness, continue it until no such $$$j$$$ exist, now lets say       the greatest element of $$$a$$$ is in $$$v_j$$$ for some $$$j$$$,       also we know that $$$r_j$$$ is equal to the greatest element of       $$$a$$$ and $$$l_j \le r_i$$$(if $$$r_i &lt; l_j$$$ then the       process of swapping is not finished, which is contradiction). So       now we can swap $$$r_i$$$ and $$$r_j$$$, again the resulting       distributing has happiness greater than or equal to the happiness       of the optimal distributing(the one we chose in the beginning),       and so, its also an optimal distributing, and $$$r_i$$$ is equal       to the greatest element, we have found an optimal distributing       such that first $$$w_i-1$$$ elements of $$$a$$$ and $$$a_n$$$ are       in $$$v_i$$$(for some $$$i$$$), contradiction!</p>     <p>Now we have proved that there exist an optimal distributing such       that first $$$w_i-1$$$ elements of $$$a$$$ and $$$a_n$$$ are in       $$$v_i$$$(for some $$$i$$$), call such optimal distributing <span class="tex-font-style-tt">STAR</span>, and now the only remaining       part is to prove that there exist an optimal distributing such       that first $$$m-1$$$ elements of $$$a$$$ and $$$a_n$$$ are in       $$$v_i$$$(for some $$$i$$$). See the whole algorithm, its like       &quot;we choose a permutation of friends then we do that greedy       assignment to them one by one from left to right&quot;, now we       want to prove that there exist an optimal distributing such that       it's <span class="tex-font-style-tt">STAR</span> and it's       permutation is sorted in non-descending order of $$$w$$$, call       them <span class="tex-font-style-tt">GOOD</span> distributings.       Again, proof by contradiction :</p>     <p>Choose a distributing such that it's a <span class="tex-font-style-tt">STAR</span>, it's permutation(called       $$$p$$$) is not sorted in non-descending order of       $$$w$$$(otherwise it's a <span class="tex-font-style-tt">GOOD</span> distributing,       contradiction!), so there exist an $$$i$$$ such that $$$w_{p_i}       &gt; w_{p_{i+1}}$$$, now swap them(i. e. swap $$$p_i$$$ and       $$$p_{i+1}$$$ and then do the same greedy assignment using the       modified permutation of friends), it's easy to see that happiness       of friends after $$$i+1$$$ in permutation $$$p$$$ wont change,       also happiness of friends before $$$i$$$ in the permutation wont       change as well.</p>     <p>Now look at the happiness of $$$p_i$$$ and $$$p_{i+1}$$$, you can       realize that sum of happiness will increase.</p>     <p>You really don't need to prove it like that, it's not time       friendly at all. ^-^</p></div></div></div>

           
            <pre><code>t = int(input())
for tc in range(t):
    n, k = map(int, input().split())
    a = list(map(int, input().split()))
    w = list(map(int, input().split()))
    a.sort(reverse = True)
    w.sort()
    ii, l, r = k, 0, n-1
    ans = 0
    for i in range(k):
        if(w[i] &gt; 1):
            ii = i
            break
        ans = ans+a[l]*2
        l = l+1
    for u in range(k-1, ii-1, -1):
        i = w[u]
        ans = ans + a[l] + a[r]
        r = r-i+1
        l = l+1
    print(ans)

</code></pre>
           
            <pre><code>#include &lt;bits/stdc++.h&gt;
#define ll long long
#define fr first
#define sc second
#define int ll

using namespace std;
const int MN = 2e5+7;

vector&lt;int&gt; v[MN];

signed main(){
    ios::sync_with_stdio(false);
    cin.tie();
    cout.tie();

    int t;
    cin &gt;&gt; t;
    while(t--){
        int n, k;
        cin &gt;&gt; n &gt;&gt; k;
        for(int i = 0; i &lt;= n; i++)v[i].clear();
        ll a[n], w[k];
        for(int i = 0; i &lt; n; i++){
            cin &gt;&gt; a[i];
        }
        for(int i = 0; i &lt; k; i++){
            cin &gt;&gt; w[i];
        }
        sort(w, w+k);
        sort(a, a+n);
        for(int i = 0; i &lt; k/2; i++)swap(w[i], w[k-i-1]);
        int po = 0;
        for(int i = 0; i &lt; n-k; i++){
            while(w[po] == v[po].size()+1)po++;
            v[po].push_back(a[i]);
        }
        ll ans = 0;
        int qf = 1;
        for(int i = 0; i &lt; k; i++){
            ans += a[n-i-1];
            if(v[i].size())ans += v[i][0];
            else ans += a[n-qf], qf++;
        }
        
        cout &lt;&lt; ans &lt;&lt; &#39;\n&#39;;
    }
}

</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #651 (Div. 2)
    1370A
    Максимальный НОД </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Максимальный НОД</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Рассмотрим все целые числа в промежутке от $$$1$$$ до $$$n$$$ (включительно).</p>     <p>По всем парам <span class="tex-font-style-bf">различных</span>       целых чисел из этого промежутка, найдите максимальное возможное       значение наибольшего общего делителя чисел в паре. Более       формально, найдите максимальное значение $$$\mathrm{gcd}(a, b)$$$       по всем $$$1 \leq a &lt; b \leq n$$$.</p>     <p>Наибольшим общим делителем $$$\mathrm{gcd}(a, b)$$$ пары       положительных целых чисел $$$a$$$ и $$$b$$$ называется наибольшее       целое число, являющееся делителем числа $$$a$$$ и делителем числа $$$b$$$.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке находится единственное целое число $$$t$$$ ($$$1       \leq t \leq 100$$$)  — количество наборов входных данных. Описание       наборов входных данных следует.</p>     <p>В единственной строке описания каждого набора входных данных       находится единственное целое число $$$n$$$ ($$$2 \leq n \leq 10^6$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных, выведите максимальное значение       $$$\mathrm{gcd}(a, b)$$$ по всем $$$1 \leq a &lt; b \leq n$$$.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
3
5
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
2
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных $$$\mathrm{gcd}(1, 2) =       \mathrm{gcd}(2, 3) = \mathrm{gcd}(1, 3) = 1$$$.</p>     <p>Во втором наборе входных данных $$$2$$$ является максимальным       возможным значением, соответствующим $$$\mathrm{gcd}(2, 4)$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1370/problem/A' title='Codeforces Round 651 (Div. 2)'>1370A - Maximum GCD</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>       <span class="tex-font-style-bf">Key Idea</span>:</p>     <p>Answer for any $$$n \ge 2$$$ is equal to       $$$\lfloor{\frac{n}{2}}\rfloor$$$ .</p>     <p>       <span class="tex-font-style-bf">Solution</span>:</p>     <p>Let the maximum gcd be equal to $$$g$$$. Since the two numbers in       a pair are distinct, one of them must be $$$\gt g$$$ and both of       them must be divisible by $$$g$$$. The smallest multiple of       $$$g$$$, greater than $$$g$$$, is $$$2 \cdot g$$$. Since each       number in the pair must be $$$\le n$$$, we must have $$$2 \cdot g       \le n$$$, or $$$g \le \lfloor{\frac{n}{2}}\rfloor$$$. We can       achieve $$$g = \lfloor{\frac{n}{2}}\rfloor$$$, by choosing $$$       \lfloor{\frac{n}{2}}\rfloor$$$ and $$$2 \cdot \lfloor{\frac{n}{2}}\rfloor$$$.</p>     <p>Time Complexity: $$$O(1)$$$</p></div></div></div>

           
            <pre><code>
#include &lt; bits/stdc++.h &gt;
using namespace std;
 
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define endl &#34;\n&#34;
#define int long long

const int N = 1e5 + 5;

int32_t main()
{
	IOS;
	int t;
	cin &gt;&gt; t;
	while(t--)
	{
		int n;
		cin &gt;&gt; n;
		cout &lt;&lt; n / 2 &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #651 (Div. 2)
    1370B
    Сжатие массива и НОД </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Сжатие массива и НОД</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У Ashish есть массив $$$a$$$, состоящий из $$$2n$$$ положительных       целых чисел. Он хочет сжать массив $$$a$$$ в массив $$$b$$$       размера $$$n-1$$$. Чтобы это сделать, он сначала выбирает ровно       $$$2$$$ (любые два) элемента массива $$$a$$$ и удаляет их из       массива. После этого он выполняет следующую операцию, пока массив       $$$a$$$ не пустой:</p>          <ul> <li> удалить любые два элемента из массива $$$a$$$ и добавить         их сумму в массив $$$b$$$. </li></ul>          <p>Получившийся массив $$$b$$$ должен удовлетворять одному условию.       Наибольший общий делитель ($$$\mathrm{gcd}$$$) всех элементов       массива должен быть больше $$$1$$$.</p>     <p>Напомним, что наибольший общий делитель ($$$\mathrm{gcd}$$$)       массива положительных целых чисел равен наибольшему целому числу,       которое является делителем всех элементов массива.</p>     <p>Можно доказать, что всегда можно таким образом сжать массив       $$$a$$$ в массив $$$b$$$ размера $$$n-1$$$, так что $$$gcd(b_1,       b_2..., b_{n-1}) &gt; 1$$$.</p>     <p>Помогите Ashish найти способ это сделать.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке находится единственное целое число $$$t$$$ ($$$1       \leq t \leq 10$$$)  — количество наборов входных данных. Описание       наборов входных данных следует.</p>     <p>В первой строке описания каждого набора входных данных находится       единственное целое число $$$n$$$ ($$$2 \leq n \leq 1000$$$).</p>     <p>Во второй строке описания каждого набора входных данных находится       $$$2n$$$ целых чисел $$$a_1, a_2, \ldots, a_{2n}$$$ ($$$1 \leq a_i       \leq 1000$$$)  — элементы массива $$$a$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных, выведите $$$n-1$$$ строку  —       выполненные операции, чтобы сжать массив $$$a$$$ в массив $$$b$$$.         <span class="tex-font-style-bf">Изначальное удаление двух         элементов не является операцией и про это действие не нужно         ничего выводить.</span></p>     <p>В $$$i$$$-й из этих строк должно находиться два целых числа,       индексы (нумерация с $$$1$$$) двух элементов массива $$$a$$$,       которые используются в $$$i$$$-й операции. Все $$$2n-2$$$       выведенных индекса должны быть различными целыми числами от       $$$1$$$ до $$$2n$$$.</p>     <p>Вам не нужно выводить индексы двух изначально удаленных элементов       из массива $$$a$$$.</p>     <p>Если есть несколько возможных ответов, вы можете найти любой.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
3
1 2 3 4 5 6
2
5 7 9 10
5
1 3 3 4 5 90 100 101 2 3
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
3 6
4 5
3 4
1 9
2 3
4 5
6 10
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных $$$b = \{3+6, 4+5\} = \{9, 9\}$$$       и $$$\mathrm{gcd}(9, 9) = 9$$$.</p>     <p>Во втором наборе входных данных $$$b = \{9+10\} = \{19\}$$$ и       $$$\mathrm{gcd}(19) = 19$$$.</p>     <p>В третьем наборе входных данных $$$b = \{1+2, 3+3, 4+5, 90+3\} =       \{3, 6, 9, 93\}$$$ и $$$\mathrm{gcd}(3, 6, 9, 93) = 3$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1370/problem/B' title='Codeforces Round 651 (Div. 2)'>1370B - GCD Compression</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>       <span class="tex-font-style-bf">Key Idea</span>:</p>     <p>It is always possible to form $$$n-1$$$ pairs of elements such       that their gcd is divisible by $$$2$$$.</p>     <p>       <span class="tex-font-style-bf">Solution</span>:</p>     <p>We can pair up the odd numbers and even numbers separately so       that the sum of numbers in each pair is divisible by $$$2$$$. Note       that we can always form $$$n - 1$$$ pairs in the above manner       because in the worst case, we would discard one odd number and one       even number from $$$a$$$. If we discarded more than one even or       odd numbers, we could instead form another pair with even sum.</p>     <p>Time Complexity: $$$O(n)$$$</p></div></div></div>

           
            <pre><code>
#include &lt; bits/stdc++.h &gt;
using namespace std;
 
#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
#define endl &#34;\n&#34;
#define int long long

const int N = 2e5 + 5;

int n;
int a[N];

int32_t main()
{
	IOS;
	int t;
	cin &gt;&gt; t;
	while(t--)
	{
		cin &gt;&gt; n;
		vector&lt; int &gt; even, odd;
		for(int i = 1; i &lt;= 2 * n; i++)
		{
			cin &gt;&gt; a[i];
			if(a[i] % 2)
				odd.push_back(i);
			else
				even.push_back(i);
		}
		vector&lt; pair&lt; int, int &gt; &gt; ans;
		for(int i = 0; i + 1 &lt; odd.size(); i += 2)
			ans.push_back({odd[i], odd[i + 1]});
		for(int i = 0; i + 1 &lt; even.size(); i += 2)
			ans.push_back({even[i], even[i + 1]});
		for(int i = 0; i &lt; n - 1; i++)
			cout &lt;&lt; ans[i].first &lt;&lt; &#34; &#34; &lt;&lt; ans[i].second &lt;&lt; endl;
	}
	return 0;
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #651 (Div. 2)
    1370C
    Игра с числом </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Игра с числом</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Ashishgup и FastestFinger играют в игру. </p>     <p>Они начинают с целого числа $$$n$$$ и начинают делать ходы по       очереди. На каждом ходу игрок может сделать <span class="tex-font-style-bf">любой из</span> следующих двух ходов:</p>          <ul> <li> Разделить $$$n$$$ на один из его нечетных делителей,         который больше чем $$$1$$$. </li>       <li> Вычесть $$$1$$$ из $$$n$$$, если $$$n$$$ больше чем $$$1$$$. </li></ul>          <p>Обратите внимание, что множество делителей числа включает само число.</p>     <p>Если игрок <span class="tex-font-style-bf">не может сделать       ход</span> он проигрывает игру.</p>     <p>Ashishgup ходит первым. Определите победителя игры, если оба       игрока играют оптимально.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке находится единственное целое число $$$t$$$ ($$$1       \leq t \leq 100$$$)  — количество наборов входных данных. Описание       наборов входных данных следует.</p>     <p>В единственной строке описания каждого набора входных данных       находится единственное целое число $$$n$$$ ($$$1 \leq n \leq 10^9$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных, выведите «<span class="tex-font-style-tt">Ashishgup</span>», если он побеждает в       игре и «<span class="tex-font-style-tt">FastestFinger</span>»       иначе (без кавычек).</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
7
1
2
3
4
5
6
12
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
FastestFinger
Ashishgup
Ashishgup
FastestFinger
Ashishgup
FastestFinger
Ashishgup
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных $$$n = 1$$$ и Ashishgup не может       сделать ход. Он проигрывает.</p>     <p>Во втором наборе входных данных $$$n = 2$$$ и Ashishgup вычитает       $$$1$$$ на первом ходу. Теперь $$$n = 1$$$ и FastestFinger не       может сделать ход, поэтому он проигрывает.</p>     <p>В третьем наборе входных данных $$$n = 3$$$ и Ashishgup делит на       $$$3$$$ на первом ходу. Теперь $$$n = 1$$$ и FastestFinger не       может сделать ход, поэтому он проигрывает.</p>     <p>В последнем наборе входных данных $$$n = 12$$$ и Ashishgup делит       на $$$3$$$ на первом ходу. Теперь $$$n = 4$$$, FastestFinger может       только вычесть $$$1$$$ и Ashishgup получает число $$$3$$$.       Наконец, он побеждает после деления этого числа на $$$3$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1370/problem/C' title='Codeforces Round 651 (Div. 2)'>1370C - Number Game</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>       <span class="tex-font-style-bf">Key Idea</span>:</p>     <p>       <span class="tex-font-style-tt">FastestFinger</span> wins for       $$$n=1$$$ , $$$n=2^x$$$ where ($$$x&gt;1$$$) and $$$n= 2 \cdot       p$$$ where $$$p$$$ is a prime $$$\ge 3$$$ else <span class="tex-font-style-tt">Ashishgup</span> wins.</p>     <p>       <span class="tex-font-style-bf">Solution</span>:</p>     <p>Let's analyse the problem for the following $$$3$$$ cases: </p>     <ul>                     <li> Case $$$1$$$: n is odd         <p>Here <span class="tex-font-style-tt">Ashishgup</span> can           divide $$$n$$$ by itself, since it is odd and hence           $$$\frac{n}{n} = 1$$$, and <span class="tex-font-style-tt">FastestFinger</span> loses. Here           $$$n = 1$$$ is an exception.</p>         </li>       <li> Case $$$2$$$: $$$n$$$ is even and has no odd divisors greater         than $$$1$$$         <p>Here $$$n$$$ is of the form $$$2^x$$$. As $$$n$$$ has no odd           divisors greater than $$$1$$$, <span class="tex-font-style-tt">Ashishgup</span> is forced to           subtract it by $$$1$$$ making $$$n$$$ odd. So if $$$x &gt;           1$$$, <span class="tex-font-style-tt">FastestFinger</span>           wins. For $$$x = 1$$$, $$$n - 1$$$ is equal to $$$1$$$, so             <span class="tex-font-style-tt">Ashishgup</span> wins. </p>         </li>       <li> Case $$$3$$$: $$$n$$$ is even and has odd divisors         <p>If $$$n$$$ is divisible by $$$4$$$ then <span class="tex-font-style-tt">Ashishgup</span> can divide $$$n$$$           by its largest odd factor after which $$$n$$$ becomes of the           form $$$2^x$$$ where $$$x \gt 1$$$, so <span class="tex-font-style-tt">Ashishgup</span> wins. </p>         <p>Otherwise $$$n$$$ must be of the form $$$2 \cdot p$$$, where           $$$p$$$ is odd. If $$$p$$$ is prime, <span class="tex-font-style-tt">Ashishgup</span> loses since he can           either reduce $$$n$$$ by $$$1$$$ or divide it by $$$p$$$ both           of which would be losing for him. If $$$p$$$ is not prime then           $$$p$$$ must be of the form $$$p_1 \cdot p_2$$$ where           $$$p_1$$$ is prime and $$$p_2$$$ is any odd number $$$\gt           1$$$. <span class="tex-font-style-tt">Ashishgup</span> can win           by dividing $$$n$$$ by $$$p_2$$$. </p></li></ul></div></div></div>

           
            <pre><code>
#include&lt; bits/stdc++.h &gt;
using namespace std;

const int N = 50000;

void player_1(){
	cout &lt;&lt; &#34;Ashishgup&#34; &lt;&lt; endl;
}

void player_2(){
	cout &lt;&lt; &#34;FastestFinger&#34; &lt;&lt; endl;
}

bool check_prime(int n){
	for(int i = 2; i &lt; min(N, n); i++)
		if(n % i == 0)
			return 0;
	return 1;
}

int main(){
	int tc;
	cin &gt;&gt; tc;
	while(tc--){
		int n;
		cin &gt;&gt; n;
		bool lose = (n == 1);
		if(n &gt; 2 &amp;&amp; n % 2 == 0){
			if((n &amp; (n — 1)) == 0)
				lose = 1;
			else if(n % 4 != 0 &amp;&amp; check_prime(n / 2))
				lose = 1;
		}
		if(lose)
			player_2();
		else player_1();
	}
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #654 (Div. 2)
    1371A
    Волшебные палочки </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Волшебные палочки</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У пингвина Rocher есть $$$n$$$ палочек — у него ровно одна       палочка длины $$$i$$$ для всех $$$1 \le i \le n$$$.</p>     <p>Он может соединять некоторые палочки. Если он соединяет две       палочки, которые имеют длины $$$a$$$ и $$$b$$$, он получает одну       палочку длины $$$a + b$$$. Две палочки, которые были использованы       в этой операции, пропадают из его множества. Новая соединенная       палочка появляется в его множестве и может быть использована в       следующих соединениях.</p>     <p>Он хочет создать максимальное количество палочек, имеющих       одинаковую длину. Не обязательно при этом, чтобы в итоге все       палочки имели одинаковую длину — некоторые палочки могут иметь       другие длины. Какое максимальное количество палочек одинаковой       длины он может получить в итоге?</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Каждый тест состоит из нескольких наборов входных данных. В       первой строке находится единственное целое число $$$t$$$ ($$$1 \le       t \le 1000$$$) — количество наборов входных данных. Следующие       $$$t$$$ строк содержат описания наборов входных данных.</p>     <p>Для каждого набора входных данных в единственной строке находится       единственное целое число $$$n$$$ ($$$1 \le n \le 10^{9}$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите единственное целое       число  — ответ на задачу.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
1
2
3
4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1
1
2
2
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В третьем наборе входных данных он может соединить две палочки       длины $$$1$$$ и $$$2$$$ и он получит одну палочку длины $$$3$$$.       Так он получит две палочки одинаковой длины $$$3$$$.</p>     <p>В четвертом наборе входных данных он может соединить две палочки       длины $$$1$$$ и $$$3$$$ и он получит одну палочку длины $$$4$$$.       После этого у него будет три палочки, имеющие длины $$$\{2, 4,       4\}$$$. Две палочки имеют одинаковую длину и она палочка будет       иметь другую длину.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1371/problem/A' title='Codeforces Round 654 (Div. 2)'>1371A - Magical Sticks</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Output $$$\lceil \frac{n}{2} \rceil$$$.</p>          <ul> <li> When $$$n$$$ is even, we can create $$$1+n = 2+(n-1) =         3+(n-2) = ...$$$ </li>       <li> When $$$n$$$ is odd, we can create $$$n = 1+(n-1) = 2+(n-2) =         ...$$$ </li></ul>          <p>Initially, there are only $$$1$$$ stick which has length $$$i (1       \le i \le n)$$$. If we connect $$$2$$$ sticks $$$s_1$$$ and       $$$s_2$$$, after that, there is a stick which has a different       length from $$$s_1$$$ and $$$s_2$$$. Then, we can create at most       $$$1 + \lfloor \frac{n-1}{2} \rfloor$$$ sticks that have the same       length. The value is equal to $$$\lceil \frac{n}{2} \rceil$$$.</p>     <p>Total complexity: $$$O(1)$$$</p></div></div></div>

           
            <pre><code>#include&lt;stdio.h&gt;

int main(){
  long long n,t;
  scanf(&#34;%lld&#34;,&amp;t);
  while(t&gt;0){
    t--;
    scanf(&#34;%lld&#34;,&amp;n);
    if(n%2){printf(&#34;%lld\n&#34;,(n/2)+1);}
    else{printf(&#34;%lld\n&#34;,n/2);}
  }
  return 0;
}</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #654 (Div. 2)
    1371B
    Магический календарь </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Магический календарь</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Профессиональный едок Алиса ставит в расписание в своем       магическом календаре тренировки для подготовки к очередному       контесту по поеданию. Календарь необычен тем, что неделя не       обязательно может состоять из $$$7$$$ дней!</p>     <p>Более точно, она может выбрать целое число $$$k$$$, которое       удовлетворяет $$$1 \leq k \leq r$$$ и выставить, что неделя       состоит из $$$k$$$ дней.</p>     <p>Алиса собирается закрасить некоторые $$$n$$$ последовательных       дней в календаре. В этом календаре недели соответсвуют строкам и       идут подряд слева направо. Для последнего дня недели первая клетка       следующей (снизу) строки соотвествует следующему дню.</p>     <p>Она хочет, чтобы <span class="tex-font-style-bf">все закрашенные         клетки были связны по сторонам</span>. Это означает, что для       любых двух закрашенных клеток, должна существовать как минимум       одна последовательность закрашенных клеток, начинающаяся в одной       из этих клеток и заканчивающаяся в другой, что любые две соседние       клетки в этой последовательности имеют общую сторону.</p>     <p>Алиса рассматривает форму закрашенных клеток. Две формы являются       одинаковыми, если можно совместить их <span class="tex-font-style-bf">только с помощью параллельных         переносов, паралельных сторонам календаря (то есть перемещая         вверх-вниз и вправо-влево)</span>.</p>     <p>Например, на картинке неделя состоит из $$$4$$$ дней и Алиса       закрашивает $$$5$$$ последовательных дней. [1] и [2] имеют       различную форму, но [1] и [3] имеют одинаковую форму.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/b8aba909c2b00c956b657be3cd83668d52b3cc9e.png" style="max-width: 100.0%;max-height: 100.0%;"/>   </center>          <p>Алисе интересно узнать <span class="tex-font-style-bf">какое         количество различных форм</span> существует <span class="tex-font-style-bf">если она установит из скольки дней         состоит неделя и выберет последовательные $$$n$$$ дней и         закрасит их в календаре, начиная в какой-то день недели</span>.       Как уже было сказано до этого, она рассматривает только формы, где       все закрашенные клетки связны по сторонам.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Каждый тест состоит из нескольких наборов входных данных. В       первой строке находится единственное целое число $$$t$$$ ($$$1 \le       t \le 1000$$$) — количество наборов входных данных. Следующие       $$$t$$$ строк содержат описания набов входных данных.</p>     <p>Для каждого набора входных данных в единственной строке находится       два целых числа $$$n$$$, $$$r$$$ ($$$1 \le n \le 10^9, 1 \le r \le 10^9$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите единственное целое       число  — ответ на задачу.</p>     <p>Обратите внимание, что ответ на некоторые наборы входных данных       не влезает в $$$32$$$-битный целочисленный тип, поэтому вы должны       использовать как минимум $$$64$$$-битный целочисленный тип вашего       языка программирования.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
5
3 4
3 2
3 1
13 7
1010000 9999999
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
4
3
1
28
510049495001
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных Алиса может выбрать $$$1,2,3$$$       или $$$4$$$ дня, как количество дней, которое будет в неделе.</p>     <p>Всего есть $$$6$$$ возможных раскрасок, которые изображены на       рисунке, но среди них есть только $$$4$$$ различные формы.       Поэтому, ответ равен $$$4$$$. Обратите внимание, что <span class="tex-font-style-bf">последний пример на картинке это         некорректная раскраска</span>, потому что не все клетки связны       по сторонам.</p>          <center> <img class="tex-graphics" src="https://espresso.codeforces.com/400bb1c5b641e72da448c36d8c87308dfe29233c.png" style="max-width: 100.0%;max-height: 100.0%;"/>   </center>          <p>В последнем наборе входных данных будьте аккуратны с возможным       переполнением, описанном в формате выходных данных.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1371/problem/B' title='Codeforces Round 654 (Div. 2)'>1371B - Magical Calendar</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>First, let's consider in case of a week has exactly $$$w$$$ days.</p>          <ul> <li> If $$$w&lt;n$$$ , the length of painted cells is strictly         more than one week. So there are $$$w$$$ valid shapes. (The         first week contains $$$1,2,...,w$$$ days) The shapes have         $$$w$$$-day width, then if the value of $$$w$$$ are different,         the shapes are also different. </li>       <li> Otherwise $$$(n \le w)$$$ , there is only one valid liner         pattern. The shape is insensitive to the chosen value of         $$$w$$$. </li></ul>          <p>We can sum up this for $$$1 \le w \le r$$$, by using following       well-known formula: $$$a+(a+1)+(a+2)+...+b = \frac{(a+b)*(b-a+1)}{2}$$$</p>     <p>Total complexity : $$$O(1)$$$</p></div></div></div>

           
            <pre><code>#include&lt;stdio.h&gt;

int main(){
  long long n,l=1,r,t,res;
  scanf(&#34;%lld&#34;,&amp;t);
  while(t&gt;0){
    t--;
    res=0;
    scanf(&#34;%lld%lld&#34;,&amp;n,&amp;r);
    if(n&lt;=l){printf(&#34;1\n&#34;);continue;}
    if(n&lt;=r){r=n-1;res=1;}
    printf(&#34;%lld\n&#34;,res+((l+r)*(r-l+1))/2);
  }
  return 0;
}</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #654 (Div. 2)
    1371C
    Печенье для тебя </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Печенье для тебя</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Анна очень смелая девочка, ее любят все в городе. Также все       горожане обожают ее печенье. Она планирует провести вечеринку с       печеньем. Сейчас у нее есть $$$a$$$ единиц ванильного печенья и       $$$b$$$ единиц шоколадного печенья для вечеринки.</p>     <p>Она пригласит $$$n$$$ гостей первого типа и $$$m$$$ гостей       второго типа на вечеринку. Они придут на вечеринку в некотором       порядке. После того, как они придут на вечеринку, каждый гость       выберет один из двух типов печенья (ванильное или шоколадное),       чтобы съесть. Есть различие в том, как гости выбирают тип печенья:</p>     <p>Если всего $$$v$$$ единиц ванильного печенья и $$$c$$$ единиц       шоколадного печенья в момент, когда гость приходит, тогда</p>          <ul> <li> если гость первого типа: если $$$v&gt;c$$$ гость выбирает           <span class="tex-font-style-bf">ванильное</span> печенье.         Иначе, гость выбирает <span class="tex-font-style-bf">шоколадное</span> печенье. </li>       <li> если гость второго типа: если $$$v&gt;c$$$ гость выбирает           <span class="tex-font-style-bf">шоколадное</span> печенье.         Иначе, гость выбирает <span class="tex-font-style-bf">ванильное</span> печенье. </li></ul>          <p>После этого:</p>          <ul> <li> Если есть хотя бы одна единица выбранного типа печенья,         гость съедает одну. </li>       <li> Иначе (если не осталось печенья выбранного типа), гость         остается голодным и уходит домой. </li></ul>          <p>Анна хочет узнать, существует ли какой-то порядок гостей, такой       что <span class="tex-font-style-bf">ни один гость не останется       голодным</span>. Ваша задача состоит в том, чтобы ответить на ее вопрос.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Каждый тест состоит из нескольких наборов входных данных. В       первой строке находится единственное целое число $$$t$$$ ($$$1 \le       t \le 1000$$$) — количество наборов входных данных. Следующие       $$$t$$$ строк содержат описания набов входных данных.</p>     <p>Для каждого набора входных данных в единственной строке находится       четыре целых числа $$$a$$$, $$$b$$$, $$$n$$$, $$$m$$$ ($$$0 \le       a,b,n,m \le 10^{18}, n+m \neq 0$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных, выведите ответ в одной строке.       Если есть хотя бы один подходящий порядок гостей, выведите «<span class="tex-font-style-tt">Yes</span>». Иначе, выведите «<span class="tex-font-style-tt">No</span>».</p>     <p>Вы можете выводить каждый символ в любом регистре (верхнем или нижнем).</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
6
2 2 1 2
0 100 0 1
12 13 25 1
27 83 14 25
0 0 1 0
1000000000000000000 1000000000000000000 1000000000000000000 1000000000000000000
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
Yes
No
No
Yes
No
Yes
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных рассмотрим порядок $$$\{1, 2,       2\}$$$ типов гостей. Тогда:</p>          <ul> <li> Первый гость съедает шоколадное печенье. После этого         остается $$$2$$$ единицы ванильного печенья и $$$1$$$ единица         шоколадного печенья. </li>       <li> Второй гость съедает шоколадное печенье. После этого остается         $$$2$$$ единицы ванильного печенья и $$$0$$$ единиц шоколадного         печенья. </li>       <li> Последний гость выбирает шоколадное печенье, чтобы съесть, но         больше не осталось шоколадного печенья. Поэтому гость остается         голодным. </li></ul>          <p>Поэтому такой порядок гостей Анна выбрать не может.</p>     <p>Рассмотрим порядок $$$\{2, 2, 1\}$$$ типов гостей. Тогда:</p>          <ul> <li> Первый гость съедает ванильное печенье. После этого         остается $$$1$$$ единица ванильного печенья и $$$2$$$ единицы         шоколадного печенья. </li>       <li> Второй гость съедает ванильное печенье. После этого остается         $$$0$$$ единиц ванильного печенья и $$$2$$$ единицы шоколадного         печенья. </li>       <li> Последний гость съедает шоколадное печенье. После этого         остается $$$0$$$ единиц ванильного печенья и $$$1$$$ единица         шоколадного печенья. </li></ul>          <p>Поэтому ответ для этого набора входных данных «<span class="tex-font-style-tt">Yes</span>».</p>     <p>В пятом наборе входных данных можно увидеть, что количество       единиц печенья ($$$a + b$$$) может быть равно нулю, но количество       гостей ($$$n + m$$$) никогда не равно нулю.</p>     <p>В шестом наборе входных данных будьте осторожны с переполнением       $$$32$$$-битного целочисленного типа.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1371/problem/C' title='Codeforces Round 654 (Div. 2)'>1371C - A Cookie for You</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>If $$$m &lt; \min (a,b) , n+m \le a+b$$$ are satisfied, the       answer is &quot;<span class="tex-font-style-tt">Yes</span>&quot;.       Otherwise, the answer is &quot;<span class="tex-font-style-tt">No</span>&quot;. Let's proof it.</p>     <p>Of course, $$$n+m \le a+b$$$ must be satisfied, because violating       this inequality means lack of cookies.</p>     <p>When a type $$$2$$$ guest comes, or when $$$a=b$$$, the value of       $$$\min(a,b)$$$ is decremented by $$$1$$$. </p>     <p>You need to consider only about the case that all type $$$2$$$       guests come first and after that all type $$$1$$$ guests come,       because if there is a type $$$1$$$ guest before a type $$$2$$$       guest, swapping them is better to make no one angry. (Because if       there is a type $$$1$$$ guest before a type $$$2$$$ guest, the       type $$$1$$$ guest have a possibility to decrease the value of       $$$min(a,b)$$$ unnecessarily.)</p>     <p>At last, all of type $$$1$$$ guests eat one cookie when there is       at least one cookie(both types are ok).</p>     <p>Total complexity: $$$O(1)$$$</p></div></div></div>

           
            <pre><code>#include&lt;stdio.h&gt;

int main(){
  long long t,a,b,n,m,k;
  scanf(&#34;%lld&#34;,&amp;t);
  while(t&gt;0){
    t--;
    scanf(&#34;%lld%lld%lld%lld&#34;,&amp;a,&amp;b,&amp;n,&amp;m);
    if(a&gt;b){k=a;a=b;b=k;}
    if(a&lt;m){printf(&#34;No\n&#34;);continue;}
    if(a+b&lt;n+m){printf(&#34;No\n&#34;);continue;}
    printf(&#34;Yes\n&#34;);
  }
}</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #655 (Div. 2)
    1372A
    Омкар и полнота </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Омкар и полнота</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вы были благословлены как дитя Омкара. Чтобы выразить свою       благодарность, пожалуйста, решите для Омкара эту задачу!</p>     <p>Массив $$$a$$$ длины $$$n$$$ называется <span class="tex-font-style-bf">полным</span>, если все его элементы       положительны, не превышают $$$1000$$$, и для любых трех индексов       $$$x$$$, $$$y$$$, $$$z$$$ ($$$1 \leq x,y,z \leq n$$$),       $$$a_{x}+a_{y} \neq a_{z}$$$ (не обязательно различных).</p>     <p>Вам дано одно целое число $$$n$$$. Найдите <span class="tex-font-style-bf">полный</span> массив длины $$$n$$$.       Гарантируется, что при данных ограничениях решение существует.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Каждый тест содержит несколько наборов входных данных. Первая       строка содержит $$$t$$$ ($$$1 \le t \le 1000$$$)  — количество       наборов входных данных. Описание наборов входных данных приведено ниже.</p>     <p>Единственная строка каждого набора входных данных содержит одно       целое число $$$n$$$ ($$$1 \leq n \leq 1000$$$).</p>     <p>Гарантируется, что сумма $$$n$$$ по всем наборам входных данных       не превышает $$$1000$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите <span class="tex-font-style-bf">полный</span> массив в отдельной строке.       Все элементы должны быть целыми числами между $$$1$$$ и $$$1000$$$       и для любых трех индексов $$$x$$$, $$$y$$$, $$$z$$$ ($$$1 \leq       x,y,z \leq n$$$) (не обязательно различных), должно выполняться       $$$a_{x}+a_{y} \neq a_{z}$$$. </p>     <p>Если существует несколько решений, вы можете вывести любое.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
5
4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
1 5 3 77 12
384 384 44 44
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Можно показать, что массивы с примера являются <span class="tex-font-style-bf">полными</span> массивами. Например,       $$$44+44 \neq 384$$$.</p>     <p>Ниже приведены некоторые примеры массивов, которые НЕ <span class="tex-font-style-bf">полные</span> для 1-го теста:</p>     <p>$$$[1,2,3,4,5]$$$ </p>     <p>Обратите внимание, что $$$a_{1}+a_{2} = a_{3}$$$.</p>     <p>$$$[1,3000,1,300,1]$$$ </p>     <p>Обратите внимание, что $$$a_{2} = 3000 &gt; 1000$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1372/problem/A' title='Codeforces Round 655 (Div. 2)'>1372A - Omkar and Completion</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Notice that since all elements must be positive, $$$k \neq 2k$$$.       The most simple construction of this problem is to simply make all       elements equal to $$$1$$$.</p></div></div></div>

           
            <pre><code>import java.util.*

fun main() {
    val jin = Scanner(System.`in`)
    for (c in 1..jin.nextInt()) {
        val n = jin.nextInt()
        for (j in 1..n) {
            print(&#34;1 &#34;)
        }
        println()
    }
}</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #655 (Div. 2)
    1372B
    Омкар и последний урок математики </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Омкар и последний урок математики</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>На последнем уроке математики Омкар он узнал о наименьшем общем       кратном, или $$$HOK$$$. $$$HOK(a, b)$$$  — это наименьшее       положительное целое число $$$x$$$, которое делится и на $$$a$$$ и       на $$$b$$$.</p>     <p>Омкар, обладающий похвально любопытным умом, сразу же подумал о       задаче, связанной с операцией $$$HOK$$$: по целому числу $$$n$$$       найдите положительные целые числа $$$a$$$ и $$$b$$$ такие, что       $$$a + b = n$$$ и $$$HOK(a, b)$$$ принимает минимально возможное значение.</p>     <p>Можете ли вы помочь Омкару решить его смешную математическую задачу?</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Каждый тест содержит несколько наборов входных данных. Первая       строка содержит количество наборов входных данных $$$t$$$ ($$$1       \leq t \leq 10$$$). Описание наборов входных данных приведено ниже.</p>     <p>Каждый набор входных данных состоит из одного целого числа       $$$n$$$ ($$$2 \leq n \leq 10^{9}$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите два положительных       целых числа $$$a$$$ и $$$b$$$ такие, что $$$a + b = n$$$ и       $$$HOK(a, b)$$$ минимально возможный.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
4
6
9
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2 2
3 3
3 6
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Для первого набора входных данных мы можем выбрать числа $$$1,       3$$$ или $$$2, 2$$$. $$$HOK(1, 3) = 3$$$ и $$$HOK(2, 2) = 2$$$,       поэтому мы выводим $$$2 \ 2$$$.</p>     <p>Для второго набора входных данных мы можем выбрать числа $$$1,       5$$$, $$$2, 4$$$ или $$$3, 3$$$. $$$HOK(1, 5) = 5$$$, $$$HOK(2, 4)       = 4$$$ и $$$HOK(3, 3) = 3$$$, поэтому мы выводим $$$3 \ 3$$$.</p>     <p>Для третьего набора входных данных $$$HOK(3, 6) = 6$$$. Можно       показать, что нет других пар чисел с суммой $$$9$$$, имеющих       меньший $$$HOK$$$.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1372/problem/B' title='Codeforces Round 655 (Div. 2)'>1372B - Omkar and Last Class of Math</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Short Solution: The two integers are $$$k$$$ and $$$n-k$$$, where       $$$k$$$ is the largest proper factor of $$$n$$$.</p>     <p>Proof: Let the two integers be $$$k$$$ and $$$n-k$$$. Assume WLOG       that $$$k \leq n-k$$$. Notice that this implies that $$$n - k \geq       \frac n 2$$$.</p>     <p>We first claim that $$$LCM(k, n-k) = n-k &lt; n$$$ if $$$k \mid       n$$$, and we prove this as follows: if $$$k \mid n$$$, then there       exists some integer $$$m$$$ such that $$$m \cdot k = n$$$. The       integer $$$n-k$$$ can then be written as $$$(m-1) \cdot k$$$,       which is a multiple of $$$k$$$. Thus, $$$LCM(k, n-k) = n-k $$$ if       $$$k \mid n$$$.</p>     <p>We now show that $$$LCM(k, n-k) \geq n$$$ if $$$k \nmid n$$$. We       show this by using the fact that $$$LCM(a, b) = b$$$ iff $$$a \mid       b$$$, so if $$$k \nmid n$$$, $$$k \nmid n - k$$$, and so $$$LCM(k,       n-k) \neq n-k$$$. And since $$$LCM(k, n - k)$$$ must be a multiple       of both $$$k$$$ and $$$n - k$$$, it follows that $$$LCM(k, n-k)       \geq 2 \cdot (n-k) \geq 2 \cdot \frac n 2 = n$$$.</p>     <p>We have now established that to minimize $$$LCM(k, n-k)$$$,       $$$k$$$ must be a factor of $$$n$$$. And, since $$$LCM(k, n-k) =       n-k$$$ when $$$k$$$ is a factor of $$$n$$$, we need to minimize       $$$n-k$$$, so we must maximize $$$k$$$ by choosing it to be the       largest proper factor of $$$n$$$ (i. e. the largest factor of       $$$n$$$ other than $$$n$$$).</p>     <p>We then simply need to find $$$k$$$, the largest proper factor of       $$$n$$$. If $$$p$$$ is the smallest prime dividing $$$n$$$, then       $$$k = \frac n p$$$, so it suffices to find the smallest prime       factor of $$$n$$$. We can do this by simply checking all values of       $$$p$$$ such that $$$2 \leq p \leq \sqrt n$$$. If $$$n$$$ is not       prime, then it must have a prime factor not exceeding       $$$\sqrt{n}$$$. Furthermore, if we do not find a factor of $$$n$$$       between $$$2$$$ and $$$\sqrt n$$$, then $$$n$$$ must be prime so       we simply get $$$p = n$$$ and $$$k = \frac n p = 1$$$.</p>     <p>We're given that $$$n \leq 10^9$$$, so $$$\sqrt n \leq 10^{\frac       9 2} &lt; 10^5$$$. $$$t \leq 10$$$, meaning that we will check       less than $$$10^6$$$ numbers, which runs well under the time limit.</p></div></div></div>

           
            <pre><code>fun main() {
    for (c in 1..readLine()!!.toInt()) {
        val n = readLine()!!.toInt()
        var p = 0
        for (m in 2..100000) {
            if (n % m == 0) {
                p = m
                break
            }
        }
        if (p == 0) {
            p = n
        }
        println(&#34;${n / p} ${n - (n / p)}&#34;)
    }
}</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Codeforces Round #655 (Div. 2)
    1372C
    Омкар и бейсбол </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Омкар и бейсбол</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Патрик любит играть в бейсбол, но иногда он тратит так много       часов на пробежки, что его разум начинает затуманиваться! Патрик       уверен, что его набранные очки за $$$n$$$ игр соответствуют       тождественной перестановке (т.е. в первой игре он набирает       $$$1$$$, во второй игре он набирает $$$2$$$ и так далее). Однако,       когда он посмотрел на свои записи, он увидел, что все значения перепутаны!</p>     <p>Определим специальный обмен следующим образом: выберите любой       подмассив очков и переставьте местами его элементы так, чтобы ни       один элемент не оказался в той же позиции, где он был до обмена.       Например, выполнение специального обмена на $$$[1,2,3]$$$ может       дать $$$[3,1,2]$$$, но не может дать $$$[3,2,1]$$$, так как       $$$2$$$ находится в той же позиции.</p>     <p>Вам дана перестановка из $$$n$$$ целых чисел. Пожалуйста,       помогите Патрику найти минимальное количество специальных обменов,       необходимых для того, чтобы сделать ее отсортированной! Можно       доказать, что при данных ограничениях это число не превышает $$$10^{18}$$$.</p>     <p>Массив $$$a$$$ является подмассивом массива $$$b$$$, если $$$a$$$       можно получить из $$$b$$$, удалив несколько (возможно, ноль или       все) элементов из начала и несколько (возможно, ноль или все)       элементов с конца.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Каждый тест содержит несколько наборов входных данных. Первая       строка содержит количество наборов входных данных $$$t$$$ ($$$1       \le t \le 100$$$). Описание наборов входных данных приведено ниже.</p>     <p>Первая строка каждого набора входных данных содержит целое число       $$$n$$$ ($$$1 \leq n \leq 2 \cdot 10^5$$$)  — длину данной перестановки.</p>     <p>Вторая строка каждого набора входных данных содержит $$$n$$$       целых чисел $$$a_{1},a_{2},...,a_{n}$$$ ($$$1 \leq a_{i} \leq       n$$$)  — начальную перестановку.</p>     <p>Гарантируется, что сумма $$$n$$$ по всем наборам входных данных       не превышает $$$2 \cdot 10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных выведите одно целое число:       минимальное количество специальных обменов, необходимых для       сортировки перестановки.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
2
5
1 2 3 4 5
7
3 2 4 5 1 6 7
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
0
2
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>Первая перестановка она уже отсортирована, поэтому обмены не нужны.</p>     <p>Можно показать, что для сортировки второй перестановки нужно как       минимум $$$2$$$ обмена.</p>     <p>$$$[3, 2, 4, 5, 1, 6, 7]$$$</p>     <p>Сделаем специальный обмен для диапазона ($$$1, 5$$$)</p>     <p>$$$[4, 1, 2, 3, 5, 6, 7]$$$</p>     <p>Сделаем специальный обмен для диапазона ($$$1, 4$$$)</p>     <p>$$$[1, 2, 3, 4, 5, 6, 7]$$$</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1372/problem/C' title='Codeforces Round 655 (Div. 2)'>1372C - Omkar and Baseball</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>You need at most $$$2$$$ special exchanges to sort the       permutation. Obviously, $$$0$$$ special exchanges are needed if       the array is already sorted. Let's look into cases in which you       need $$$1$$$ special exchange to sort the array.</p>     <p>Refer to i as a matching index if $$$a_i = i$$$. If there are no       matching indices, then you can just use one special exchange to       sort the entire thing. Otherwise, you can use the location of       matching indices to determine whether you need more than $$$1$$$       special exchange. If all matching indices are located in some       prefix of the permutation, you can sort the permutation with one       special exchange. The same is true for a suffix. In other words,       if you can choose a subarray in the permutation such that all       elements contained in the subarray are NOT matching and the       elements outside of this subarray are matching, then one special       exchange is needed to sort the array.</p>     <p>Otherwise, you need $$$2$$$ special exchanges to sort the       permutation. Let's prove why you do not need more than $$$2$$$       special exchanges. You can quickly check that you need at most       $$$2$$$ special exchanges for all permutations of length $$$\leq       3$$$. For permutations of length $$$\geq 4$$$, I claim that we can       perform $$$2$$$ special exchanges on the whole array; to show this       it suffices to construct a permutation $$$p$$$ that has no       matching indices with either the given permutation or the identity       permutation $$$1, 2, \ldots, n$$$. We can do this as follows:</p>     <p>For simplicity, assume that $$$n$$$ is even. We will assign the       numbers $$$\frac n 2 + 1, \frac n 2 + 2, \ldots, n$$$ to the first       $$$\frac n 2$$$ positions of our permutation $$$p$$$ and the       numbers $$$1, 2, \ldots, \frac n 2$$$ to the last $$$\frac n 2$$$       positions of $$$p$$$. This ensures that $$$p$$$ has no matching       indices with the identity permutation. Then, for all integers       $$$b$$$ such that their position $$$i$$$ in $$$a$$$ (i. e. the       $$$j$$$ such that $$$a_j = b$$$) is in the appropriate half of       $$$p$$$, assign $$$p_i = b$$$; assign other $$$b$$$ to arbitrary       positions in the appropriate half of $$$p$$$. Finally, cyclically       rotate each half of $$$p$$$ – this ensures that $$$p$$$ has no       matching indices with $$$a$$$.</p>     <p>As an example, let's take $$$a = [3, 6, 2, 4, 5, 1]$$$. You can       quickly check that this cannot be done in less than $$$2$$$       special exchanges. The construction of $$$p$$$ goes as follows:</p>     <p>First, we move all numbers to the proper half of $$$p$$$, so that       $$$p = [4, 5, 6, 1, 2, 3]$$$.</p>     <p>Observing that $$$a_2 = 6$$$ and $$$a_6 = 1$$$, we set $$$p_2 =       6$$$ and $$$p_6 = 1$$$ then replace the remaining elements       arbitrarily into the correct half, so we can get, for example,       $$$p = [4, 6, 5, 2, 3, 1]$$$.</p>     <p>Finally, we cyclically rotate each half of $$$p$$$, obtaining       $$$p = [5, 4, 6, 1, 2, 3]$$$, which has no matching indexes with       either $$$a = [3, 6, 2, 4, 5, 1]$$$ or $$$[1, 2, 3, 4, 5, 6]$$$.</p>     <p>This can be extended to odd $$$n$$$ by first choosing some       element other than $$$1$$$ and $$$a_1$$$ to be $$$p_1$$$ (this       works for $$$n \geq 3$$$ and we must have $$$n \geq 5$$$ anyway in       this case), and then running the same algorithm on the rest of $$$p$$$.</p></div></div></div>

           
            <pre><code>import java.io.BufferedReader
import java.io.InputStreamReader

fun main() {
    val jin = BufferedReader(InputStreamReader(System.`in`))
    for (c in 1..jin.readLine().toInt()) {
        val n = jin.readLine().toInt()
        val scores = jin.readLine().split(&#34; &#34;).map { it.toInt() - 1 }
        if ((1 until n).all { scores[it - 1] &lt; scores[it] }) {
            println(0)
        } else {
            var stage = 0
            var answer = 1
            for (j in 0 until n) {
                if (scores[j] == j) {
                    if (stage == 1) {
                        stage = 2
                    }
                } else {
                    if (stage == 0) {
                        stage = 1
                    } else if (stage == 2) {
                        answer = 2
                        break
                    }
                }
            }
            println(answer)
        }
    }
}</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 90 (рейтинговый для Див. 2)
    1373A
    Магазины пончиков </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Магазины пончиков</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Существует два конкурирующих магазина пончиков.</p>     <p>Первый магазин продает пончики в розницу: каждый пончик стоит       $$$a$$$ долларов.</p>     <p>Второй магазин продает пончики оптом: коробка из $$$b$$$ пончиков       стоит $$$c$$$ долларов. То есть если вы хотите купить $$$x$$$       пончиков в этом магазине, то вам придется купить минимальное       количество коробок такое, что суммарное количество пончиков больше       или равно $$$x$$$.</p>     <p>Вы хотите определить два <span class="tex-font-style-bf">положительных целых</span> значения: </p>     <ol> <li> сколько пончиков можно купить, чтобы они стоили дешевле в         первом магазине, чем во втором? </li>       <li> сколько пончиков можно купить, чтобы они стоили дешевле во         втором магазине, чем в первом? </li></ol>          <p>Если какое-то из значений не существует, то оно должно быть равно       $$$-1$$$. Если существует несколько решений, выведите любое из них.</p>     <p>       <span class="tex-font-style-bf">Выведенные значения должны быть         меньше или равны $$$10^9$$$. Можно показать, что в данных         ограничениях такие значения всегда существуют, если значения         существуют вообще.</span></p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке записано одно целое $$$t$$$ ($$$1 \le t \le       1000$$$) — количество наборов входных данных.</p>     <p>В каждой из следующих $$$t$$$ строк записаны по три целых числа       $$$a$$$, $$$b$$$ и $$$c$$$ ($$$1 \le a \le 10^9$$$, $$$2 \le b \le       10^9$$$, $$$1 \le c \le 10^9$$$).</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>На каждый набор входных данных выведите два <span class="tex-font-style-bf">положительных</span> целых числа. Для       обоих магазинов выведите такой $$$x$$$, что купить $$$x$$$       пончиков в этом магазине строго дешевле, чем купить $$$x$$$       пончиков в другом магазине. $$$x$$$ должно быть больше $$$0$$$ и       меньше или равно, чем $$$10^9$$$.</p>     <p>Если такого $$$x$$$ не существует, то выведите $$$-1$$$. Если       существует несколько решений, выведите любое из них.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
4
5 10 4
4 5 20
2 2 3
1000000000 1000000000 1000000000
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
-1 20
8 -1
1 2
-1 1000000000
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных любое количество пончиков будет       дешевле во втором магазине. Например, для $$$3$$$ или $$$5$$$       пончиков придется купить коробку из $$$10$$$ пончиков за $$$4$$$       доллара. Однако $$$3$$$ или $$$5$$$ пончиков будут стоить $$$15$$$       или $$$25$$$ долларов, соответственно. Для $$$20$$$ пончиков       придется купить две коробки за $$$8$$$ долларов суммарно. Обратите       внимание, что $$$3$$$ и $$$5$$$ также являются правильными       ответами для второго магазина вместе со многими другими ответами.</p>     <p>Во втором наборе входных данных любое количество пончиков будет       либо дешевле в первом магазине, либо по одинаковой цене. $$$8$$$       пончиков стоят $$$32$$$ доллара в первом магазине и $$$40$$$       долларов во втором магазине (потому что придется купить две       коробки). $$$10$$$ пончиков будут стоить $$$40$$$ долларов в обоих       магазинах, поэтому $$$10$$$ не будет правильным ответом ни для       одного из магазинов.</p>     <p>В третьем наборе входных данных $$$1$$$ пончик стоит $$$2$$$ и       $$$3$$$ доллара, соответственно. $$$2$$$ пончика стоят $$$4$$$ и       $$$3$$$ доллара. Поэтому $$$1$$$ является правильным ответом для       первого магазина, а $$$2$$$ является правильным ответом для       второго магазина.</p>     <p>В четвертом наборе входных данных $$$10^9$$$ пончиков стоят       $$$10^{18}$$$ долларов в первом магазине и $$$10^9$$$ долларов во       втором магазине.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1373/problem/A' title='Educational Codeforces Round 90 (Rated for Div. 2)'>1373A - Donut Shops</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>At first notice that if there exists a value for the second shop,       then the value divisible by $$$b$$$ also exists. For any $$$x$$$       you can round it up to the nearest multiple of $$$b$$$. That won't       change the price for the second shop and only increase the price       for the first shop.</p>     <p>You can also guess that if there exists a value for the first       shop, then the value with $$$1$$$ modulo $$$b$$$ also exists       (exactly $$$1$$$ donut on top of some number of full boxes).       Following the same logic — the second shop needs an entire new box       and the first shop needs only an extra donut.</p>     <p>So let's take a look at the smallest values of two kinds: </p>     <ul> <li> $$$x = b$$$: this value is valid for the second shop if         one box is cheaper than $$$b$$$ donuts in the first shop.         Otherwise, no matter how many boxes will you take, they will         never be cheaper than the corresponding number of donuts. </li>       <li> $$$x = 1$$$: this value is valid for the first shop if one         donut is cheaper than one box in the second shop. Apply the same         idea — otherwise no value for the first shop is valid. </li></ul>          <p>Overall complexity: $$$O(1)$$$ per testcase.</p></div></div></div>

           
            <pre><code>for tc in range(int(input())):
	a, b, c = map(int, input().split())
	print(1 if a &lt; c else -1, end=&#34; &#34;)
	print(b if c &lt; a * b else -1)
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 90 (рейтинговый для Див. 2)
    1373B
    01-игра </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. 01-игра</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>1 секунда</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Алиса и Боб играют в игру.</p>     <p>Изначально у них есть строка $$$s$$$, состоящая только из       символов <span class="tex-font-style-tt">0</span> и <span class="tex-font-style-tt">1</span>.</p>     <p>Алиса и Боб ходят по очереди: Алиса делает первый ход, второй       делает Боб, третий ход делает Алиса, и так далее. Во время своего       хода игрок должен выбрать два <span class="tex-font-style-bf">соседних различных</span> символа       строки $$$s$$$ и удалить их. Например, если $$$s = 1011001$$$,       тогда возможны следующие ходы: </p>     <ol> <li> удалить $$$s_1$$$ и $$$s_2$$$: $$$\textbf{10}11001         \rightarrow 11001$$$; </li>       <li> удалить $$$s_2$$$ и $$$s_3$$$: $$$1\textbf{01}1001         \rightarrow 11001$$$; </li>       <li> удалить $$$s_4$$$ и $$$s_5$$$: $$$101\textbf{10}01         \rightarrow 10101$$$; </li>       <li> удалить $$$s_6$$$ и $$$s_7$$$: $$$10110\textbf{01}         \rightarrow 10110$$$. </li></ol>          <p>Если игрок не может сделать ход — он проигрывает. Оба игрока       играют оптимально. Вам нужно определить, сможет ли Алиса выиграть.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит число $$$t$$$ ($$$1 \le t \le 1000$$$) —       количество наборов входных данных.</p>     <p>Единственная строка каждого набора входных данных содержит строку       $$$s$$$ ($$$1 \le |s| \le 100$$$), состоящую только из символов         <span class="tex-font-style-tt">0</span> и <span class="tex-font-style-tt">1</span>.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>На каждый набор входных данных выведите ответ в отдельной строке.</p>     <p>Если Алиса может выиграть, выведите <span class="tex-font-style-tt">DA</span> в любом регистре. Иначе       выведите <span class="tex-font-style-tt">NET</span> в любом регистре.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
01
1111
0011
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
DA
NET
NET
</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных после хода Алисы строка $$$s$$$       станет пустой и Боб не сможет сделать ход.</p>     <p>Во втором наборе входных данных Алиса не может сделать ход изначально.</p>     <p>В третьем наборе входных данных после хода Алисы строка $$$s$$$       превратится в $$$01$$$. А после хода Боба строка $$$s$$$ станет       пустой и Алиса не сможет сделать ход.</p></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1373/problem/B' title='Educational Codeforces Round 90 (Rated for Div. 2)'>1373B - 01 Game</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>If there is at least one character <span class="tex-font-style-tt">0</span> and at least one character         <span class="tex-font-style-tt">1</span>, then current player       can always make a move. After the move the number of character         <span class="tex-font-style-tt">0</span> decreases by one, and       the number of character <span class="tex-font-style-tt">1</span>       decreases by one too. So the number of moves is always $$$min(c0,       c1)$$$, where $$$c0$$$ is the number of characters <span class="tex-font-style-tt">0</span> in string $$$s$$$, and $$$c1$$$       is the number of characters <span class="tex-font-style-tt">1</span> in string $$$s$$$.</p>     <p>So if $$$min(c0, c1)$$$ is odd then Alice wins, otherwise Bob       wins. </p></div></div></div>

           
            <pre><code>for _ in range(int(input())):
    s = input()
    print(&#39;DA&#39; if min(s.count(&#39;0&#39;), s.count(&#39;1&#39;)) % 2 == 1 else &#39;NET&#39;)
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 90 (рейтинговый для Див. 2)
    1373C
    Плюсы и минусы </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Плюсы и минусы</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам задана строка $$$s$$$ состоящая только из символов <span class="tex-font-style-tt">+</span> и <span class="tex-font-style-tt">-</span>. Вы выполняете некоторый       процесс с этой строкой. Этот процесс можно описать следующим       псевдокодом: </p>     <pre class="lstlisting"><code class="prettyprint">res = 0<br/>for init = 0 to inf<br/>    cur = init<br/>    ok = true<br/>    for i = 1 to |s|<br/>        res = res + 1<br/>        if s[i] == '+'<br/>            cur = cur + 1<br/>        else<br/>            cur = cur - 1<br/>        if cur &lt; 0<br/>            ok = false<br/>            break<br/>    if ok<br/>        break<br/></code></pre>          <p>Обратите внимание, что $$$inf$$$ обозначает бесконечность, а       символы строки пронумерованы от $$$1$$$ до $$$|s|$$$.</p>     <p>Вам нужно определить значение переменной $$$res$$$ после       выполнения процесса.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит целое число $$$t$$$ ($$$1 \le t \le       1000$$$) — количество наборов входных данных.</p>     <p>Единственная строка каждого набора входных данных содержит строку       $$$s$$$ ($$$1 \le |s| \le 10^6$$$), состоящую только из символов         <span class="tex-font-style-tt">+</span> и <span class="tex-font-style-tt">-</span>.</p>     <p>Гарантируется, что сумма $$$|s|$$$ по всем наборам входных данных       не превосходит $$$10^6$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>На каждый набор входных данных выведите ответ — значение       переменной $$$res$$$ после завершения процесса.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
--+-
---
++--+-
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
7
9
6
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1373/problem/C' title='Educational Codeforces Round 90 (Rated for Div. 2)'>1373C - Pluses and Minuses</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's replace all <span class="tex-font-style-tt">+</span> with         <span class="tex-font-style-tt">1</span>, and all <span class="tex-font-style-tt">-</span> with <span class="tex-font-style-tt">-1</span>. After that let's create a       preffix-sum array $$$p$$$ ($$$p_i = \sum\limits_{j=1}^{i} s_j$$$).       Also lets create array $$$f$$$ such that $$$f_i$$$ is equal       minimum index $$$j$$$ such that $$$p_j = -i$$$ (if there is no       such index $$$p_i = -1$$$).</p>     <p>Let's consider the first iteration of loop $$$for ~ init ~ = ~ 0       ~ to ~ inf$$$. If $$$f_1 = -1$$$ then process ends and $$$res =       |s|$$$. Otherwise the condition $$$if ~ cur ~ &lt; ~ 0$$$       fulfilled then the value of $$$i$$$ will be equal to $$$f_1$$$.       So, the value of $$$res$$$ is equal to $$$f_1$$$ after first iteration.</p>     <p>Now, let's consider the second iteration of loop $$$for ~ init ~       = ~ 0 ~ to ~ inf$$$. If $$$f_2 = -1$$$ then process ends and       $$$res = f_1 + |s|$$$. Otherwise the condition $$$if ~ cur ~ &lt;       ~ 0$$$ fulfilled then the value of $$$i$$$ will be equal to       $$$f_2$$$. So, the value of $$$res$$$ is equal to $$$f_1 + f_2$$$       after second iteration.</p>     <p>In this way we can calculate the value of $$$res$$$ after the       process ends.</p></div></div></div>

           
            <pre><code>for _ in range(int(input())):
    s = input()
    cur, mn, res = 0, 0, len(s)
    for i in range(len(s)):
        cur += 1 if s[i] == &#39;+&#39; else -1
        if cur &lt; mn:
            mn = cur
            res += i + 1
        
    print(res)
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 91 (рейтинговый для Див. 2)
    1380A
    Три индекса </h1>

    <div class="problemindexholder" problemindex="A">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">A. Три индекса</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Вам задана перестановка $$$p_1, p_2, \dots, p_n$$$. Напомним, что       последовательность из $$$n$$$ целых чисел называется <span class="tex-font-style-it">перестановкой</span>, если она содержит       все целые числа от $$$1$$$ до $$$n$$$ ровно один раз.</p>     <p>Вам необходимо найти три индекса $$$i$$$, $$$j$$$ и $$$k$$$       такие, что:</p>          <ul> <li> $$$1 \le i &lt; j &lt; k \le n$$$; </li>       <li> $$$p_i &lt; p_j$$$ и $$$p_j &gt; p_k$$$. </li></ul>          <p>Или сообщить, что таких трех индексов нет.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит одно целое число $$$T$$$ ($$$1 \le T \le       200$$$) — количество наборов входных данных.</p>     <p>Следующие $$$2T$$$ содержат описание наборов входных данных  —       две строки на каждый набор. Первая строка каждого набора входных       данных содержит единственное целое число $$$n$$$ ($$$3 \le n \le       1000$$$) — длина перестановки $$$p$$$.</p>     <p>Вторая строка содержит $$$n$$$ целых чисел $$$p_1, p_2, \dots,       p_n$$$ ($$$1 \le p_i \le n$$$; $$$p_i \neq p_j$$$ если $$$i \neq       j$$$) — перестановка $$$p$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных: </p>     <ul> <li> если есть такие индексы $$$i$$$, $$$j$$$ и $$$k$$$,         выведите <span class="tex-font-style-tt">YES</span> (без учета         регистра) и сами индексы; </li>       <li> если таких трех индексов нет, выведите <span class="tex-font-style-tt">NO</span> (без учета регистра). </li></ul>          <p>Если допустимых наборов индексов несколько, выведите любой из них.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
4
2 1 4 3
6
4 6 1 2 5 3
5
5 3 1 2 4
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
YES
2 3 4
YES
3 5 6
NO
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1380/problem/A' title='Educational Codeforces Round 91 (Rated for Div. 2)'>1380A - Three Indices</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>A solution in $$$O(n^2)$$$: iterate on $$$j$$$, check that there       exists an element lower than $$$a_j$$$ to the left of it, and       check that there exists an element lower than $$$a_j$$$ to the       right of it. Can be optimized to $$$O(n)$$$ with prefix/suffix minima.</p>     <p>A solution in $$$O(n)$$$: note that if there is some answer, we       can find an index $$$j$$$ such that $$$a_{j - 1} &lt; a_j$$$ and       $$$a_j &gt; a_{j + 1}$$$ (if there is no such triple, the array       descends to some point and ascends after that, so there is no       answer). So we only have to check $$$n - 2$$$ consecutive triples.</p></div></div></div>

           
            <pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;

const int N = 1000;

int n;
int a[N];

void solve() {
	cin &gt;&gt; n;
	for (int i = 0; i &lt; n; ++i)
		cin &gt;&gt; a[i];
	for (int i = 1; i &lt; n - 1; ++i) {
		if (a[i] &gt; a[i - 1] &amp;&amp; a[i] &gt; a[i + 1]) {
			cout &lt;&lt; &#34;YES&#34; &lt;&lt; endl;
			cout &lt;&lt; i &lt;&lt; &#39; &#39; &lt;&lt; i + 1 &lt;&lt; &#39; &#39; &lt;&lt; i + 2 &lt;&lt; endl;
			return;
		}
	}
	cout &lt;&lt; &#34;NO&#34; &lt;&lt; endl;
}

int main() {
	int T;
	cin &gt;&gt; T;
	while (T--)
		solve();
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 91 (рейтинговый для Див. 2)
    1380B
    Универсальное решение </h1>

    <div class="problemindexholder" problemindex="B">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">B. Универсальное решение</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>Недавно, вы обнаружили бота, с которым можно сыграть в «Камень,       ножницы, бумага». К сожалению, бот использует довольно примитивный       алгоритм игры: у него есть строка $$$s = s_1 s_2 \dots s_{n}$$$       длины $$$n$$$, где каждый символ — это <span class="tex-font-style-tt">R</span>, <span class="tex-font-style-tt">S</span> или <span class="tex-font-style-tt">P</span>.</p>     <p>Во время инициализации, бот выбирает стартовую позицию $$$pos$$$       ($$$1 \le pos \le n$$$), и потом может сыграть любое количество       раундов. В первом раунде, он выбирает «Камень», «Ножницы» или       «Бумагу» на основании значения $$$s_{pos}$$$: </p>     <ul> <li> если $$$s_{pos}$$$ равняется <span class="tex-font-style-tt">R</span>, то бот выбирает «Камень»; </li>       <li> если $$$s_{pos}$$$ равняется <span class="tex-font-style-tt">S</span>, то бот выбирает «Ножницы»; </li>       <li> если $$$s_{pos}$$$ равняется <span class="tex-font-style-tt">P</span>, то бот выбирает «Бумагу»; </li></ul>          <p>Во втором раунде, выбор бота основан на значении $$$s_{pos +       1}$$$. В третьем раунде — на $$$s_{pos + 2}$$$ и так далее. После       $$$s_n$$$, бот возвращается к $$$s_1$$$ и продолжает игру.</p>     <p>Вы планируете сыграть $$$n$$$ раундов и уже определили строку       $$$s$$$, однако не знаете, чему равняется стартовая позиция       $$$pos$$$. Но так как тактика бота очень скучная, вы решили найти       такие $$$n$$$ ходов в раундах, чтобы максимизировать среднее       количество побед.</p>     <p>Другими словами, предположим, что ваши ходы — это $$$c_1 c_2       \dots c_n$$$ и если бот начнет с позиции $$$pos$$$, то вы       выиграете в $$$win(pos)$$$ раундах. Найдите $$$c_1 c_2 \dots       c_n$$$ такие, что $$$\frac{win(1) + win(2) + \dots +       win(n)}{n}$$$ — максимально возможное.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>В первой строке задано единственное число $$$t$$$ ($$$1 \le t \le       1000$$$) — количество наборов входных данных.</p>     <p>В следующих $$$t$$$ строках заданы сами наборы — по одному в       строке. В единственной строке каждого набора задана строка $$$s =       s_1 s_2 \dots s_{n}$$$ ($$$1 \le n \le 2 \cdot 10^5$$$; $$$s_i \in       \{\text{R}, \text{S}, \text{P}\}$$$) — строка бота.</p>     <p>Гарантируется, что суммарная длина всех строк в одном тесте не       превосходит $$$2 \cdot 10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>Для каждого набора входных данных, выведите $$$n$$$ ходов $$$c_1       c_2 \dots c_n$$$ таких, которые максимизируют среднее количество       побед. Выведите их в том же формате, в котором задана строка $$$s$$$.</p>     <p>Если существует несколько оптимальных ответов, выведите любой из них.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
RRRR
RSP
S
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
PPPP
RSP
R</pre></div></div></div>         <div class="note">     <div class="section-title">Примечание</div>          <p>В первом наборе входных данных, бот (с какой бы позиции не начал)       будет всегда выбирать «Камень», поэтому мы можем всегда выбирать       «Бумагу». То есть, в любом случае, мы выиграем все $$$n = 4$$$       раунда, и, соответственно, среднее количество побед также равно $$$4$$$.</p>     <p>Во втором наборе: </p>     <ul> <li> если бот начнет с позиции $$$pos = 1$$$, то $$$(s_1,         c_1)$$$ — ничья, $$$(s_2, c_2)$$$ — ничья и $$$(s_3, c_3)$$$ —         ничья, поэтому $$$win(1) = 0$$$; </li>       <li> если бот начнет с позиции $$$pos = 2$$$, то $$$(s_2,         c_1)$$$ — победа, $$$(s_3, c_2)$$$ — победа и $$$(s_1, c_3)$$$ —         победа, поэтому $$$win(2) = 3$$$; </li>       <li> если бот начнет с позиции $$$pos = 3$$$, то $$$(s_3,         c_1)$$$ — проигрыш, $$$(s_1, c_2)$$$ — проигрыш и $$$(s_2,         c_3)$$$ — проигрыш, поэтому $$$win(3) = 0$$$; </li></ul> Среднее     равно $$$\frac{0 + 3 + 0}{3} = 1$$$, и можно доказать, что это     максимально возможное среднее количество побед.     <p>Картинка из Википедии, описывающая игру «Камень, ножницы,       бумага»: </p>     <center> <img class="tex-graphics" src="https://espresso.codeforces.com/46da581691fc5fc89f034caf475c42a4026d6342.png" style="max-width: 100.0%;max-height: 100.0%;"/> </center></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1380/problem/B' title='Educational Codeforces Round 91 (Rated for Div. 2)'>1380B - Universal Solution</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>Let's look at the contribution of each choice $$$c_i$$$ to the       total number of wins $$$win(1) + win(2) + \dots + win(n)$$$ (we       can look at &quot;total&quot; instead of &quot;average&quot;,       since &quot;average&quot; is equal to &quot;total&quot; divided by       $$$n$$$). For example, let's look at the first choice $$$c_1$$$:       in $$$win(1)$$$ we compare $$$c_1$$$ with $$$s_1$$$, in       $$$win(2)$$$ — $$$c_1$$$ with $$$s_2$$$, in $$$win(3)$$$ —       $$$c_1$$$ with $$$s_3$$$ and so on.</p>     <p>In the result, we compare $$$c_1$$$ with all $$$s_i$$$ once. So,       to maximize the total sum, we need to choose $$$c_1$$$ that beats       the maximum number of $$$s_i$$$ or, in other words, let's find the       most frequent character in $$$s$$$ and choose $$$c_1$$$ that beats it.</p>     <p>Okay, we found the optimal $$$c_1$$$. But if we look at the       contribution of any other $$$c_i$$$ we can note that we compare       any $$$c_i$$$ with all $$$s_i$$$ once. So we can choose all       $$$c_i$$$ equal to $$$c_1$$$ which is equal to the choice that       beats the most frequent choice in $$$s$$$.</p></div></div></div>

           
            <pre><code>fun main() {
    val winBy = mapOf(&#39;R&#39; to &#39;P&#39;, &#39;S&#39; to &#39;R&#39;, &#39;P&#39; to &#39;S&#39;)
    repeat(readLine()!!.toInt()) {
        val s = readLine()!!
        val maxCnt = s.groupingBy { it }.eachCount().maxBy { it.value }!!.key
        println(&#34;${winBy[maxCnt]}&#34;.repeat(s.length))
    }
}
</code></pre>
        
    

    <div class="new-page"></div>


    <h1> Educational Codeforces Round 91 (рейтинговый для Див. 2)
    1380C
    Собери команды </h1>

    <div class="problemindexholder" problemindex="C">&#13;
        <div class="ttypography"><div class="problem-statement">   <div class="header">     <div class="title">C. Собери команды</div>     <div class="time-limit"><div class="property-title">ограничение по времени на тест</div>2 секунды</div>     <div class="memory-limit">       <div class="property-title">ограничение по памяти на тест</div>256 мегабайт</div>     <div class="input-file">       <div class="property-title">ввод</div>стандартный ввод</div>     <div class="output-file">       <div class="property-title">вывод</div>стандартный вывод</div></div>   <div>     <p>У вас есть $$$n$$$ программистов, которых вы хотите распределить       по командам. Навык $$$i$$$-го программиста равен $$$a_i$$$. Вы       хотите собрать из них максимальное количество команд. Для команд       есть одно ограничение: количество программистов в команде,       умноженное на минимальный навык среди всех программистов этой       команды, должно быть как минимум $$$x$$$.</p>     <p>Каждый программист может находиться максимум в одной команде.       Некоторые программисты могут остаться без команды.</p>     <p>Посчитайте максимальное количество команд, которое вы можете собрать.</p></div>         <div class="input-specification">     <div class="section-title">Входные данные</div>          <p>Первая строка содержит одно число $$$t$$$ ($$$1 \le t \le       1000$$$) — количество наборов входных данных.</p>     <p>Первая строка каждого набора входных данных содержит два числа       $$$n$$$ и $$$x$$$ ($$$1 \le n \le 10^5; 1 \le x \le 10^9$$$) —       количество программистов и ограничение на навык команды соответственно.</p>     <p>Вторая строка каждого набора входных данных содержит $$$n$$$       чисел $$$a_1, a_2, \dots , a_n$$$ ($$$1 \le a_i \le 10^9$$$), где       $$$a_i$$$ равно навыку $$$i$$$-го программиста.</p>     <p>Сумма $$$n$$$ по всем наборам не превосходит $$$10^5$$$.</p></div>         <div class="output-specification">     <div class="section-title">Выходные данные</div>          <p>На каждый набор входных данных выведите одно число — максимальное       количество команд, которое вы можете собрать.</p></div>         <div class="sample-tests">     <div class="section-title">Пример</div>               <div class="sample-test">       <div class="input">         <div class="title">Входные данные</div>         <pre>
3
5 10
7 11 2 9 5
4 8
2 4 2 3
4 11
1 3 3 7
</pre></div>       <div class="output">         <div class="title">Выходные данные</div>         <pre>
2
1
0
</pre></div></div></div></div>  <p>  </p></div>&#13;
</div>&#13;
&#13;
&#13;


    

        <h3><a href='/contest/1380/problem/C' title='Educational Codeforces Round 91 (рейтинговый для Див. 2)'>1380C - Собери команды</a></h3><div class="ttypography"><div class="problem-statement">      <div>     <p>At first, notice that if only $$$k &lt; n$$$ programmers are       taken, then the same or even better answer can be achieved if       $$$k$$$ strongest programmers are taken.</p>     <p>Now let's sort the programmers in non-decreasing order and choose       some assignment into the teams. For each team only the rightmost       taken programmer of that team matters (the sorted sequence implies       that the rightmost is the weakest).</p>     <p>Take a look at the team with the strongest weakest member. If the       number of programmers in it is less than the position of the       weakest member, then you can safely rearrange the programmers       before him in such a way that none of parameters of later teams       change and the weakest member in the first one only becomes       stronger. After that you can get rid of the first team (as it       takes exactly the prefix of all the programmers) and proceed to       fix the later teams.</p>     <p>Thus, we can see that there is an optimal solution such that each       team is a segment and all the teams together take some prefix of       the programmers. So we can finally run a greedy solution that       takes programmers from left to right and increases the answer if       the conditions for the latest team hold.</p>     <p>Overall complexity: $$$O(n \log n)$$$.</p></div></div></div>

           
            <pre><code>for _ in range(int(input())):
    n, x = map(int, input().split())
    a = sorted(list(map(int, input().split())), reverse=True)
    res, cur = 0, 1
    for s in a:
        if s * cur &gt;= x:
            res += 1
            cur = 0
        cur += 1
    print(res)
    
</code></pre>
        
    

    <div class="new-page"></div>



</body>

</html>